<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" revision="1.0.0" language="Java" filename="E:/01Courses@USASK/CMPT898-HumanDrivenSoftwareEngineeringForScientificResearch/ProjectProgress/data_files/final_dataset/gen_patch_codes/filtered/lucene/0810107d1f.java"><expr_stmt><expr><name>From</name> <literal type="number">0810107d1f75bf1bc6760853347da3981a566e41</literal> <name>Mon</name> <name>Sep</name> <literal type="number">17</literal> <literal type="number">00</literal><operator>:</operator><literal type="number">00</literal><operator>:</operator><literal type="number">00</literal> <literal type="number">2001</literal>
<name>From</name><operator>:</operator> <name>Michael</name> <name><name>McCandless</name> <argument_list type="generic">&lt;<argument><name>mikemccand</name><annotation>@<name><name>apache</name><operator>.</operator><name>org</name></name></annotation></argument>&gt;</argument_list></name>
<name>Date</name><operator>:</operator> <name>Sat</name></expr><operator>,</operator> <expr><literal type="number">2</literal> <name>Apr</name> <literal type="number">2011</literal> <literal type="number">15</literal><operator>:</operator><literal type="number">32</literal><operator>:</operator><literal type="number">31</literal> <operator>+</operator><literal type="number">0000</literal>
<name>Subject</name><operator>:</operator> <index>[<expr><name>PATCH</name></expr>]</index> <name>LUCENE</name><operator>-</operator><literal type="number">3003</literal><operator>:</operator> <name>refactor</name> <name>UnInvertedField</name> <name>into</name> <name>Lucene</name> <name>core</name>

<name>git</name><operator>-</operator><name>svn</name><operator>-</operator><name>id</name><operator>:</operator> <name>https</name><operator>:</operator><comment type="line">//svn.apache.org/repos/asf/lucene/dev/trunk@1088049 13f79535-47bb-0310-9956-ffa450edef68</comment>
<operator>--</operator>
 <name>lucene</name><operator>/</operator><name><name>CHANGES</name><operator>.</operator><name>txt</name></name>                            <operator>|</operator>   <literal type="number">7</literal> <operator>+</operator>
 <operator>...</operator><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>index</name><operator>/</operator><name><name>DocTermOrds</name><operator>.</operator><name>java</name></name>  <operator>|</operator> <literal type="number">799</literal> <operator>++</operator><operator>++</operator><operator>++</operator><operator>++</operator><operator>++</operator><operator>++</operator><operator>++</operator><operator>++</operator><operator>++</operator>
 <operator>...</operator><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>index</name><operator>/</operator><name><name>IndexReader</name><operator>.</operator><name>java</name></name>  <operator>|</operator>  <literal type="number">16</literal> <operator>+</operator>
 <operator>...</operator><operator>/</operator><name>lucene</name><operator>/</operator><name>index</name><operator>/</operator><name><name>RandomIndexWriter</name><operator>.</operator><name>java</name></name>       <operator>|</operator>   <literal type="number">2</literal> <operator>+</operator><operator>-</operator>
 <operator>...</operator><operator>/</operator><name>lucene</name><operator>/</operator><name>store</name><operator>/</operator><name><name>MockDirectoryWrapper</name><operator>.</operator><name>java</name></name>    <operator>|</operator>  <literal type="number">20</literal> <operator>+</operator><operator>-</operator>
 <operator>...</operator><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>util</name><operator>/</operator><name><name>_TestUtil</name><operator>.</operator><name>java</name></name>     <operator>|</operator>  <literal type="number">13</literal> <operator>+</operator>
 <operator>...</operator><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>index</name><operator>/</operator><name><name>TestDocTermOrds</name><operator>.</operator><name>java</name></name>  <operator>|</operator> <literal type="number">517</literal> <operator>++</operator><operator>++</operator><operator>++</operator><operator>++</operator><operator>++</operator><operator>++</operator>
 <operator>...</operator><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>request</name><operator>/</operator><name><name>UnInvertedField</name><operator>.</operator><name>java</name></name>  <operator>|</operator> <literal type="number">743</literal> <operator>++</operator><operator>+</operator><operator>--</operator><operator>--</operator><operator>--</operator><operator>--</operator><operator>--</operator><operator>--</operator><operator>-</operator>
 <operator>...</operator><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>request</name><operator>/</operator><name><name>TestFaceting</name><operator>.</operator><name>java</name></name> <operator>|</operator>  <literal type="number">59</literal> <operator>+</operator><operator>-</operator>
 <literal type="number">9</literal> <name>files</name> <name>changed</name></expr><operator>,</operator> <expr><literal type="number">1514</literal> <call><name>insertions</name><argument_list>(<argument><expr><operator>+</operator></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><literal type="number">662</literal> <call><name>deletions</name><argument_list>(<argument><expr><operator>-</operator></expr></argument>)</argument_list></call>
 <name>create</name> <name>mode</name> <literal type="number">100644</literal> <name>lucene</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>index</name><operator>/</operator><name><name>DocTermOrds</name><operator>.</operator><name>java</name></name>
 <name>create</name> <name>mode</name> <literal type="number">100644</literal> <name>lucene</name><operator>/</operator><name>src</name><operator>/</operator><name>test</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>index</name><operator>/</operator><name><name>TestDocTermOrds</name><operator>.</operator><name>java</name></name>

<name>diff</name> <operator>--</operator><name>git</name> <name>a</name><operator>/</operator><name>lucene</name><operator>/</operator><name><name>CHANGES</name><operator>.</operator><name>txt</name></name> <name>b</name><operator>/</operator><name>lucene</name><operator>/</operator><name><name>CHANGES</name><operator>.</operator><name>txt</name></name>
<name>index</name> <literal type="number">8ea03b6dcc2</literal><operator>..</operator><literal type="number">64a55afadfe</literal> <literal type="number">100644</literal>
<operator>--</operator> <name>a</name><operator>/</operator><name>lucene</name><operator>/</operator><name><name>CHANGES</name><operator>.</operator><name>txt</name></name>
<operator>++</operator> <name>b</name><operator>/</operator><name>lucene</name><operator>/</operator><name><name>CHANGES</name><operator>.</operator><name>txt</name></name>
@@ <operator>-</operator><literal type="number">337</literal></expr><operator>,</operator><expr><literal type="number">6</literal> <operator>+</operator><literal type="number">337</literal></expr><operator>,</operator><expr><literal type="number">13</literal> @@ <name>New</name> <name>features</name>
 <operator>*</operator> <name>LUCENE</name><operator>-</operator><literal type="number">3001</literal><operator>:</operator> <name>Added</name> <name>TrieFieldHelper</name> <name>to</name> <name>write</name> <name>solr</name> <name>compatible</name> <name>numeric</name>
   <name>fields</name> <name>without</name> <name>the</name> <name>solr</name> <name><name>dependency</name><operator>.</operator></name> (<name>ryan</name></expr></expr_stmt>)
   
<expr_stmt><expr><operator>*</operator> <name>LUCENE</name><operator>-</operator><literal type="number">3003</literal><operator>:</operator> <name>Added</name> <operator>new</operator> <name>expert</name> <name>class</name> <name><name>oal</name><operator>.</operator><name>index</name><operator>.</operator><name>DocTermsOrd</name></name></expr><operator>,</operator>
  <expr><name>refactored</name> <name>from</name> <name>Solr</name><literal type="char">'s UnInvertedField, for accessing term ords for
  multi-valued fields, per document.  This is similar to FieldCache in
  that it inverts the index to compute the ords, but differs in that
  it'</literal><name>s</name> <name>able</name> <name>to</name> <name>handle</name> <name>multi</name><operator>-</operator><name>valued</name> <name>fields</name> <name>and</name> <name>does</name> <name>not</name> <name>hold</name> <name>the</name> <name>term</name>
  <name>bytes</name> <name>in</name> <name><name>RAM</name><operator>.</operator></name> (<name>Mike</name> <name>McCandless</name></expr></expr_stmt>)

 <expr_stmt><expr><name>Optimizations</name>
 
 <operator>*</operator> <name>LUCENE</name><operator>-</operator><literal type="number">2588</literal><operator>:</operator> <name>Don</name><literal type="char">'t store unnecessary suffixes when writing the terms
diff --git a/lucene/src/java/org/apache/lucene/index/DocTermOrds.java b/lucene/src/java/org/apache/lucene/index/DocTermOrds.java
new file mode 100644
index 00000000000..9c5361f6dde
-- /dev/null
++ b/lucene/src/java/org/apache/lucene/index/DocTermOrds.java
@@ -0,0 +1,799 @@
/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.lucene.index;

import org.apache.lucene.util.PagedBytes;
import org.apache.lucene.util.BytesRef;
import org.apache.lucene.util.Bits;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Comparator;

/**
 * This class enables fast access to multiple term ords for
 * a specified field across all docIDs.
 *
 * Like FieldCache, it uninverts the index and holds a
 * packed data structure in RAM to enable fast access.
 * Unlike FieldCache, it can handle multi-valued fields,
 * and, it does not hold the term bytes in RAM.  Rather, you
 * must obtain a TermsEnum from the {@link #getOrdTermsEnum}
 * method, and then seek-by-ord to get the term'</literal><name>s</name> <name><name>bytes</name><operator>.</operator></name>
 *
 <operator>*</operator> <name>While</name> <name>normally</name> <name>term</name> <name>ords</name> <name>are</name> <name>type</name> <name>long</name></expr><operator>,</operator> <expr><name>in</name> <name>this</name> <name>API</name> <name>they</name> <name>are</name>
 <operator>*</operator> <name>int</name> <name>as</name> <name>the</name> <name>internal</name> <name>representation</name> <name>here</name> <name>cannot</name> <name>address</name>
 <operator>*</operator> <name>more</name> <name>than</name> <name>MAX_INT</name> <name>unique</name> <name><name>terms</name><operator>.</operator>  <name>Also</name></name></expr><operator>,</operator> <expr><name>typically</name> <name>this</name>
 <operator>*</operator> <name>class</name> <name>is</name> <name>used</name> <name>on</name> <name>fields</name> <name>with</name> <name>relatively</name> <name>few</name> <name>unique</name> <name>terms</name>
 <operator>*</operator> <name>vs</name> <name>the</name> <name>number</name> <name>of</name> <name><name>documents</name><operator>.</operator>  <name>In</name></name> <name>addition</name></expr><operator>,</operator> <expr><name>there</name> <name>is</name> <name>an</name>
 <operator>*</operator> <name>internal</name> <call><name>limit</name> <argument_list>(<argument><expr><literal type="number">16</literal> <name>MB</name></expr></argument>)</argument_list></call> <name>on</name> <name>how</name> <name>many</name> <name>bytes</name> <name>each</name> <name>chunk</name> <name>of</name>
 <operator>*</operator> <name>documents</name> <name>may</name> <name><name>consume</name><operator>.</operator>  <name>If</name></name> <name>you</name> <name>trip</name> <name>this</name> <name>limit</name> <name>you</name><literal type="char">'ll hit
 * an IllegalStateException.
 *
 * Deleted documents are skipped during uninversion, and if
 * you look them up you'</literal><name>ll</name> <name>get</name> <literal type="number">0</literal> <name><name>ords</name><operator>.</operator></name>
 *
 <operator>*</operator> <name>The</name> <name>returned</name> <name>per</name><operator>-</operator><name>document</name> <name>ords</name></expr></expr_stmt> <do>do<block type="pseudo"><block_content> <expr_stmt><expr><name>not</name> <name>retain</name> <name>their</name>
 <operator>*</operator> <name>original</name> <name>order</name> <name>in</name> <name>the</name> <name><name>document</name><operator>.</operator>  <name>Instead</name></name> <name>they</name> <name>are</name> <name>returned</name>
 <operator>*</operator> <name>in</name> <call><name>sorted</name> <argument_list>(<argument><expr><name>by</name> <name>ord</name></expr></argument>, <argument><expr><name>ie</name> <name>term</name><literal type="char">'s BytesRef comparator) order.  They
 * are also de-dup'</literal><call><name>d</name> <argument_list>(<argument><expr><name>ie</name></expr></argument> <if_stmt><if>if doc has same term more than once
 * in this field<operator>,</operator> <expr_stmt><expr><name>you</name><literal type="char">'ll only get that ord back once).
 *
 * This class tests whether the provided reader is able to
 * retrieve terms by ord (ie, it'</literal><name>s</name> <name>single</name> <name>segment</name></expr><operator>,</operator> <expr><name>and</name> <name>it</name>
 <operator>*</operator> <name>uses</name> <name>an</name> <name>ord</name><operator>-</operator><name>capable</name> <name>terms</name> <name>index</name></expr></expr_stmt></if></if_stmt>)</argument_list></call><operator>.</operator>  <name>If</name> <name>not</name></expr></argument>, <argument><expr><name>this</name> class
 <operator>*</operator> <name>will</name> <name>create</name> <name>its</name> <name>own</name> <name>term</name> <name>index</name> <name>internally</name></expr></argument>, <argument><expr><name>allowing</name> <name>to</name>
 <operator>*</operator> <name>create</name> <name>a</name> <name>wrapped</name> <name>TermsEnum</name> <name>that</name> <name>can</name> <name>handle</name> <name><name>ord</name><operator>.</operator>  <name>The</name></name>
 <operator>*</operator> <block>{@<expr><name>link</name> <operator>#</operator><name>getOrdTermsEnum</name></expr>}</block> <name>method</name> <name>then</name> <name>provides</name> <name>this</name>
 <operator>*</operator> <name>wrapped</name> enum</expr></argument>, if <argument><expr><name><name>necessary</name><operator>.</operator></name>
 *
 <operator>*</operator> <name>The</name> <name>RAM</name> <name>consumption</name> <name>of</name> <name>this</name> class <name>can</name> <name>be</name> <name>high</name><operator>!</operator>
 <operator>*</operator>
 <operator>*</operator> @<name><name>lucene</name><operator>.</operator><name>experimental</name></name>
 <operator>*</operator><operator>/</operator>

<comment type="block">/*
 * Final form of the un-inverted field:
 *   Each document points to a list of term numbers that are contained in that document.
 *
 *   Term numbers are in sorted order, and are encoded as variable-length deltas from the
 *   previous term number.  Real term numbers start at 2 since 0 and 1 are reserved.  A
 *   term number of 0 signals the end of the termNumber list.
 *
 *   There is a single int[maxDoc()] which either contains a pointer into a byte[] for
 *   the termNumber lists, or directly contains the termNumber list if it fits in the 4
 *   bytes of an integer.  If the first byte in the integer is 1, the next 3 bytes
 *   are a pointer into a byte[] where the termNumber list starts.
 *
 *   There are actually 256 byte arrays, to compensate for the fact that the pointers
 *   into the byte arrays are only 3 bytes long.  The correct byte array for a document
 *   is a function of it's id.
 *
 *   To save space and speed up faceting, any term that matches enough documents will
 *   not be un-inverted... it will be skipped while building the un-inverted field structure,
 *   and will use a set intersection method during faceting.
 *
 *   To further save memory, the terms (the actual string values) are not all stored in
 *   memory, but a TermIndex is used to convert term numbers to term values only
 *   for the terms needed after faceting has completed.  Only every 128th term value
 *   is stored, along with it's corresponding term number, and this is used as an
 *   index to find the closest term and iterate until the desired number is hit (very
 *   much like Lucene's own internal term index).
 *
 */</comment>

<specifier>public</specifier> class <name>DocTermOrds</name> <block>{

  <comment type="line">// Term ords are shifted by this, internally, to reseve</comment>
  <comment type="line">// values 0 (end term) and 1 (index is a pointer into byte array)</comment>
  <expr><specifier>private</specifier> <name>final</name> <specifier>static</specifier> <name>int</name> <name>TNUM_OFFSET</name> <operator>=</operator> <literal type="number">2</literal></expr>;

  <comment type="line">// Default: every 128th term is indexed</comment>
  <expr><specifier>public</specifier> <name>final</name> <specifier>static</specifier> <name>int</name> <name>DEFAULT_INDEX_INTERVAL_BITS</name> <operator>=</operator> <literal type="number">7</literal></expr>; <comment type="line">// decrease to a low number like 2 for testing</comment>

  <expr><specifier>private</specifier> <name>int</name> <name>indexIntervalBits</name></expr>;
  <expr><specifier>private</specifier> <name>int</name> <name>indexIntervalMask</name></expr>;
  <expr><specifier>private</specifier> <name>int</name> <name>indexInterval</name></expr>;

  <expr><specifier>protected</specifier> <name>final</name> <name>int</name> <name>maxTermDocFreq</name></expr>;

  <expr><specifier>protected</specifier> <name>final</name> <name>String</name> <name>field</name></expr>;

  <expr><specifier>protected</specifier> <name>int</name> <name>numTermsInField</name></expr>;
  <expr><specifier>protected</specifier> <name>long</name> <name>termInstances</name></expr>; <comment type="line">// total number of references to term numbers</comment>
  <expr><specifier>private</specifier> <name>long</name> <name>memsz</name></expr>;
  <expr><specifier>protected</specifier> <name>int</name> <name>total_time</name></expr>;  <comment type="line">// total time to uninvert the field</comment>
  <expr><specifier>protected</specifier> <name>int</name> <name>phase1_time</name></expr>;  <comment type="line">// time for phase1 of the uninvert process</comment>

  <expr><specifier>protected</specifier> <name><name>int</name><index>[]</index></name> <name>index</name></expr>;
  <expr><specifier>protected</specifier> <name><name>byte</name><index>[]</index><index>[]</index></name> <name>tnums</name> <operator>=</operator> <operator>new</operator> <name><name>byte</name><index>[<expr><literal type="number">256</literal></expr>]</index><index>[]</index></name></expr>;
  <expr><specifier>protected</specifier> <name>long</name> <name>sizeOfIndexedStrings</name></expr>;
  <expr><specifier>protected</specifier> <name><name>BytesRef</name><index>[]</index></name> <name>indexedTermsArray</name></expr>;
  <expr><specifier>protected</specifier> <name>BytesRef</name> <name>prefix</name></expr>;
  <expr><specifier>protected</specifier> <name>int</name> <name>ordBase</name></expr>;

  <expr><specifier>public</specifier> <name>long</name> <call><name>ramUsedInBytes</name><argument_list>()</argument_list></call> <block>{
    <comment type="line">// can cache the mem size since it shouldn't change</comment>
    <if_stmt><if>if <condition>(<expr><name>memsz</name><operator>!=</operator><literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>memsz</name></expr>;</return></block_content></block></if></if_stmt>
    <name>long</name> <name>sz</name> <operator>=</operator> <literal type="number">8</literal><operator>*</operator><literal type="number">8</literal> <operator>+</operator> <literal type="number">32</literal></block></expr>; <comment type="line">// local fields</comment>
    <if_stmt><if>if <condition>(<expr><name>index</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>sz</name> <operator>+=</operator> <name><name>index</name><operator>.</operator><name>length</name></name> <operator>*</operator> <literal type="number">4</literal></expr>;</expr_stmt></block_content></block></if></if_stmt></block></expr></argument>
    <if_stmt><if>if <condition>(<expr><name>tnums</name><operator>!=</operator><literal type="null">null</literal></expr>)</condition> <block>{<block_content>
      <for>for <control>(<init><decl><type><name><name>byte</name><index>[]</index></name></type> <name>arr</name> <range>: <expr><name>tnums</name></expr></range></decl></init>)</control><block type="pseudo"><block_content>
        <if_stmt><if>if <condition>(<expr><name>arr</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>sz</name> <operator>+=</operator> <name><name>arr</name><operator>.</operator><name>length</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>
    </block_content>}</block></if></if_stmt></argument_list></call></expr></expr_stmt></block_content></block>
    memsz = sz;
    return sz;
  }</do>

  <comment type="block" format="javadoc">/** Inverts all terms */</comment>
  <constructor><specifier>public</specifier> <name>DocTermOrds</name><parameter_list>(<parameter><decl><type><name>IndexReader</name></type> <name>reader</name></decl></parameter>, <parameter><decl><type><name>String</name></type> <name>field</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws> <block>{<block_content>
    <expr_stmt><expr><call><name>this</name><argument_list>(<argument><expr><name>reader</name></expr></argument>, <argument><expr><name>field</name></expr></argument>, <argument><expr><literal type="null">null</literal></expr></argument>, <argument><expr><name><name>Integer</name><operator>.</operator><name>MAX_VALUE</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></constructor>

  <comment type="block" format="javadoc">/** Inverts only terms starting w/ prefix */</comment>
  <constructor><specifier>public</specifier> <name>DocTermOrds</name><parameter_list>(<parameter><decl><type><name>IndexReader</name></type> <name>reader</name></decl></parameter>, <parameter><decl><type><name>String</name></type> <name>field</name></decl></parameter>, <parameter><decl><type><name>BytesRef</name></type> <name>termPrefix</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws> <block>{<block_content>
    <expr_stmt><expr><call><name>this</name><argument_list>(<argument><expr><name>reader</name></expr></argument>, <argument><expr><name>field</name></expr></argument>, <argument><expr><name>termPrefix</name></expr></argument>, <argument><expr><name><name>Integer</name><operator>.</operator><name>MAX_VALUE</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></constructor>

  <comment type="block" format="javadoc">/** Inverts only terms starting w/ prefix, and only terms
   *  whose docFreq (not taking deletions into account) is
   *  &lt;=  maxTermDocFreq */</comment>
  <constructor><specifier>public</specifier> <name>DocTermOrds</name><parameter_list>(<parameter><decl><type><name>IndexReader</name></type> <name>reader</name></decl></parameter>, <parameter><decl><type><name>String</name></type> <name>field</name></decl></parameter>, <parameter><decl><type><name>BytesRef</name></type> <name>termPrefix</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>maxTermDocFreq</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws> <block>{<block_content>
    <expr_stmt><expr><call><name>this</name><argument_list>(<argument><expr><name>reader</name></expr></argument>, <argument><expr><name>field</name></expr></argument>, <argument><expr><name>termPrefix</name></expr></argument>, <argument><expr><name>maxTermDocFreq</name></expr></argument>, <argument><expr><name>DEFAULT_INDEX_INTERVAL_BITS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>uninvert</name><argument_list>(<argument><expr><name>reader</name></expr></argument>, <argument><expr><name>termPrefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></constructor>

  <comment type="block" format="javadoc">/** Inverts only terms starting w/ prefix, and only terms
   *  whose docFreq (not taking deletions into account) is
   *  &lt;=  maxTermDocFreq, with a custom indexing interval
   *  (default is every 128nd term). */</comment>
  <constructor><specifier>public</specifier> <name>DocTermOrds</name><parameter_list>(<parameter><decl><type><name>IndexReader</name></type> <name>reader</name></decl></parameter>, <parameter><decl><type><name>String</name></type> <name>field</name></decl></parameter>, <parameter><decl><type><name>BytesRef</name></type> <name>termPrefix</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>maxTermDocFreq</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>indexIntervalBits</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws> <block>{<block_content>
    <expr_stmt><expr><call><name>this</name><argument_list>(<argument><expr><name>field</name></expr></argument>, <argument><expr><name>maxTermDocFreq</name></expr></argument>, <argument><expr><name>indexIntervalBits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>uninvert</name><argument_list>(<argument><expr><name>reader</name></expr></argument>, <argument><expr><name>termPrefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></constructor>

  <comment type="block" format="javadoc">/** Subclass inits w/ this, but be sure you then call
   *  uninvert, only once */</comment>
  <constructor><specifier>protected</specifier> <name>DocTermOrds</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>field</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>maxTermDocFreq</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>indexIntervalBits</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws> <block>{<block_content>
    <comment type="line">//System.out.println("DTO init field=" + field + " maxTDFreq=" + maxTermDocFreq);</comment>
    <expr_stmt><expr><name><name>this</name><operator>.</operator><name>field</name></name> <operator>=</operator> <name>field</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>this</name><operator>.</operator><name>maxTermDocFreq</name></name> <operator>=</operator> <name>maxTermDocFreq</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>this</name><operator>.</operator><name>indexIntervalBits</name></name> <operator>=</operator> <name>indexIntervalBits</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>indexIntervalMask</name> <operator>=</operator> <literal type="number">0xffffffff</literal> <operator>&gt;&gt;&gt;</operator> <operator>(</operator><literal type="number">32</literal><operator>-</operator><name>indexIntervalBits</name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>indexInterval</name> <operator>=</operator> <literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>indexIntervalBits</name></expr>;</expr_stmt>
  </block_content>}</block></constructor>

  <comment type="block" format="javadoc">/** Returns a TermsEnum that implements ord.  If the
   *  provided reader supports ord, we just return its
   *  TermsEnum; if it does not, we build a "private" terms
   *  index internally (WARNING: consumes RAM) and use that
   *  index to implement ord.  This also enables ord on top
   *  of a composite reader.  The returned TermsEnum is
   *  unpositioned.  This returns null if there are no terms.
   *
   *  &lt;p&gt;&lt;b&gt;NOTE&lt;/b&gt;: you must pass the same reader that was
   *  used when creating this class */</comment>
  <function><type><specifier>public</specifier> <name>TermsEnum</name></type> <name>getOrdTermsEnum</name><parameter_list>(<parameter><decl><type><name>IndexReader</name></type> <name>reader</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>termInstances</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <return>return <expr><literal type="null">null</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>indexedTermsArray</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
      <comment type="line">//System.out.println("GET normal enum");</comment>
      <decl_stmt><decl><type><specifier>final</specifier> <name>Terms</name></type> <name>terms</name> <init>= <expr><call><name><name>MultiFields</name><operator>.</operator><name>getTerms</name></name><argument_list>(<argument><expr><name>reader</name></expr></argument>, <argument><expr><name>field</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><name>terms</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
        <return>return <expr><call><name><name>terms</name><operator>.</operator><name>iterator</name></name><argument_list>()</argument_list></call></expr>;</return>
      </block_content>}</block></if> <else>else <block>{<block_content>
        <return>return <expr><literal type="null">null</literal></expr>;</return>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <comment type="line">//System.out.println("GET wrapped enum ordBase=" + ordBase);</comment>
      <return>return <expr><operator>new</operator> <call><name>OrdWrappedTermsEnum</name><argument_list>(<argument><expr><name>reader</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></function>

  <comment type="block" format="javadoc">/** Subclass can override this */</comment>
  <function><type><specifier>protected</specifier> <name>void</name></type> <name>visitTerm</name><parameter_list>(<parameter><decl><type><name>TermsEnum</name></type> <name>te</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>termNum</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws> <block>{<block_content>
  </block_content>}</block></function>

  <function><type><specifier>protected</specifier> <name>void</name></type> <name>setActualDocFreq</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>termNum</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>df</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws> <block>{<block_content>
  </block_content>}</block></function>

  <comment type="line">// Call this only once (if you subclass!)</comment>
  <function><type><specifier>protected</specifier> <name>void</name></type> <name>uninvert</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>IndexReader</name></type> <name>reader</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>BytesRef</name></type> <name>termPrefix</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws> <block>{<block_content>
    <comment type="line">//System.out.println("DTO uninvert field=" + field + " prefix=" + termPrefix);</comment>
    <decl_stmt><decl><type><specifier>final</specifier> <name>long</name></type> <name>startTime</name> <init>= <expr><call><name><name>System</name><operator>.</operator><name>currentTimeMillis</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>prefix</name> <operator>=</operator> <ternary><condition><expr><name>termPrefix</name> <operator>==</operator> <literal type="null">null</literal></expr> ?</condition><then> <expr><literal type="null">null</literal></expr> </then><else>: <expr><operator>new</operator> <call><name>BytesRef</name><argument_list>(<argument><expr><name>termPrefix</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>

    <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>maxDoc</name> <init>= <expr><call><name><name>reader</name><operator>.</operator><name>maxDoc</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>final</specifier> <name><name>int</name><index>[]</index></name></type> <name>index</name> <init>= <expr><operator>new</operator> <name><name>int</name><index>[<expr><name>maxDoc</name></expr>]</index></name></expr></init></decl>;</decl_stmt>       <comment type="line">// immediate term numbers, or the index into the byte[] representing the last number</comment>
    <decl_stmt><decl><type><specifier>final</specifier> <name><name>int</name><index>[]</index></name></type> <name>lastTerm</name> <init>= <expr><operator>new</operator> <name><name>int</name><index>[<expr><name>maxDoc</name></expr>]</index></name></expr></init></decl>;</decl_stmt>    <comment type="line">// last term we saw for this document</comment>
    <decl_stmt><decl><type><specifier>final</specifier> <name><name>byte</name><index>[]</index><index>[]</index></name></type> <name>bytes</name> <init>= <expr><operator>new</operator> <name><name>byte</name><index>[<expr><name>maxDoc</name></expr>]</index><index>[]</index></name></expr></init></decl>;</decl_stmt> <comment type="line">// list of term numbers for the doc (delta encoded vInts)</comment>

    <decl_stmt><decl><type><specifier>final</specifier> <name>Terms</name></type> <name>terms</name> <init>= <expr><call><name><name>MultiFields</name><operator>.</operator><name>getTerms</name></name><argument_list>(<argument><expr><name>reader</name></expr></argument>, <argument><expr><name>field</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>terms</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
      <comment type="line">// No terms</comment>
      <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <decl_stmt><decl><type><specifier>final</specifier> <name>TermsEnum</name></type> <name>te</name> <init>= <expr><call><name><name>terms</name><operator>.</operator><name>iterator</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>final</specifier> <name>BytesRef</name></type> <name>seekStart</name> <init>= <expr><ternary><condition><expr><name>termPrefix</name> <operator>!=</operator> <literal type="null">null</literal></expr> ?</condition><then> <expr><name>termPrefix</name></expr> </then><else>: <expr><operator>new</operator> <call><name>BytesRef</name><argument_list>()</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <comment type="line">//System.out.println("seekStart=" + seekStart.utf8ToString());</comment>
    <if_stmt><if>if <condition>(<expr><call><name><name>te</name><operator>.</operator><name>seek</name></name><argument_list>(<argument><expr><name>seekStart</name></expr></argument>)</argument_list></call> <operator>==</operator> <name><name>TermsEnum</name><operator>.</operator><name>SeekStatus</name><operator>.</operator><name>END</name></name></expr>)</condition> <block>{<block_content>
      <comment type="line">// No terms match</comment>
      <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// If we need our "term index wrapper", these will be</comment>
    <comment type="line">// init'd below:</comment>
    <decl_stmt><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name>BytesRef</name></argument>&gt;</argument_list></name></type> <name>indexedTerms</name> <init>= <expr><literal type="null">null</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PagedBytes</name></type> <name>indexedTermsBytes</name> <init>= <expr><literal type="null">null</literal></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>boolean</name></type> <name>testedOrd</name> <init>= <expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>final</specifier> <name>Bits</name></type> <name>delDocs</name> <init>= <expr><call><name><name>MultiFields</name><operator>.</operator><name>getDeletedDocs</name></name><argument_list>(<argument><expr><name>reader</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="line">// we need a minimum of 9 bytes, but round up to 12 since the space would</comment>
    <comment type="line">// be wasted with most allocators anyway.</comment>
    <decl_stmt><decl><type><name><name>byte</name><index>[]</index></name></type> <name>tempArr</name> <init>= <expr><operator>new</operator> <name><name>byte</name><index>[<expr><literal type="number">12</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

    <comment type="line">//</comment>
    <comment type="line">// enumerate all terms, and build an intermediate form of the un-inverted field.</comment>
    <comment type="line">//</comment>
    <comment type="line">// During this intermediate form, every document has a (potential) byte[]</comment>
    <comment type="line">// and the int[maxDoc()] array either contains the termNumber list directly</comment>
    <comment type="line">// or the *end* offset of the termNumber list in it's byte array (for faster</comment>
    <comment type="line">// appending and faster creation of the final form).</comment>
    <comment type="line">//</comment>
    <comment type="line">// idea... if things are too large while building, we could do a range of docs</comment>
    <comment type="line">// at a time (but it would be a fair amount slower to build)</comment>
    <comment type="line">// could also do ranges in parallel to take advantage of multiple CPUs</comment>

    <comment type="line">// OPTIONAL: remap the largest df terms to the lowest 128 (single byte)</comment>
    <comment type="line">// values.  This requires going over the field first to find the most</comment>
    <comment type="line">// frequent terms ahead of time.</comment>

    <decl_stmt><decl><type><name>int</name></type> <name>termNum</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>DocsEnum</name></type> <name>docsEnum</name> <init>= <expr><literal type="null">null</literal></expr></init></decl>;</decl_stmt>

    <comment type="line">// Loop begins with te positioned to first term (we call</comment>
    <comment type="line">// seek above):</comment>
    <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
      <decl_stmt><decl><type><specifier>final</specifier> <name>BytesRef</name></type> <name>t</name> <init>= <expr><call><name><name>te</name><operator>.</operator><name>term</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><name>t</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <operator>(</operator><name>termPrefix</name> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name><name>t</name><operator>.</operator><name>startsWith</name></name><argument_list>(<argument><expr><name>termPrefix</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
        <break>break;</break>
      </block_content>}</block></if></if_stmt>
      <comment type="line">//System.out.println("visit term=" + t.utf8ToString() + " " + t + " termNum=" + termNum);</comment>

      <if_stmt><if>if <condition>(<expr><operator>!</operator><name>testedOrd</name></expr>)</condition> <block>{<block_content>
        <try>try <block>{<block_content>
          <expr_stmt><expr><name>ordBase</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <call><name><name>te</name><operator>.</operator><name>ord</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
          <comment type="line">//System.out.println("got ordBase=" + ordBase);</comment>
        </block_content>}</block> <catch>catch <parameter_list>(<parameter><decl><type><name>UnsupportedOperationException</name></type> <name>uoe</name></decl></parameter>)</parameter_list> <block>{<block_content>
          <comment type="line">// Reader cannot provide ord support, so we wrap</comment>
          <comment type="line">// our own support by creating our own terms index:</comment>
          <expr_stmt><expr><name>indexedTerms</name> <operator>=</operator> <operator>new</operator> <call><name><name>ArrayList</name><argument_list type="generic">&lt;<argument><name>BytesRef</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>indexedTermsBytes</name> <operator>=</operator> <operator>new</operator> <call><name>PagedBytes</name><argument_list>(<argument><expr><literal type="number">15</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <comment type="line">//System.out.println("NO ORDS");</comment>
        </block_content>}</block></catch></try>
        <expr_stmt><expr><name>testedOrd</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>

      <expr_stmt><expr><call><name>visitTerm</name><argument_list>(<argument><expr><name>te</name></expr></argument>, <argument><expr><name>termNum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <if_stmt><if>if <condition>(<expr><name>indexedTerms</name> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>termNum</name> <operator>&amp;</operator> <name>indexIntervalMask</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <comment type="line">// Index this term</comment>
        <expr_stmt><expr><name>sizeOfIndexedStrings</name> <operator>+=</operator> <name><name>t</name><operator>.</operator><name>length</name></name></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>BytesRef</name></type> <name>indexedTerm</name> <init>= <expr><operator>new</operator> <call><name>BytesRef</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>indexedTermsBytes</name><operator>.</operator><name>copy</name></name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>indexedTerm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="line">// TODO: really should 1) strip off useless suffix,</comment>
        <comment type="line">// and 2) use FST not array/PagedBytes</comment>
        <expr_stmt><expr><call><name><name>indexedTerms</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name>indexedTerm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>

      <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>df</name> <init>= <expr><call><name><name>te</name><operator>.</operator><name>docFreq</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><name>df</name> <operator>&lt;=</operator> <name>maxTermDocFreq</name></expr>)</condition> <block>{<block_content>

        <expr_stmt><expr><name>docsEnum</name> <operator>=</operator> <call><name><name>te</name><operator>.</operator><name>docs</name></name><argument_list>(<argument><expr><name>delDocs</name></expr></argument>, <argument><expr><name>docsEnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <decl_stmt><decl><type><specifier>final</specifier> <name><name>DocsEnum</name><operator>.</operator><name>BulkReadResult</name></name></type> <name>bulkResult</name> <init>= <expr><call><name><name>docsEnum</name><operator>.</operator><name>getBulkResult</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// dF, but takes deletions into account</comment>
        <decl_stmt><decl><type><name>int</name></type> <name>actualDF</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

        <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
          <decl_stmt><decl><type><name>int</name></type> <name>chunk</name> <init>= <expr><call><name><name>docsEnum</name><operator>.</operator><name>read</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
          <if_stmt><if>if <condition>(<expr><name>chunk</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <break>break;</break>
          </block_content>}</block></if></if_stmt>
          <comment type="line">//System.out.println("  chunk=" + chunk + " docs");</comment>

          <expr_stmt><expr><name>actualDF</name> <operator>+=</operator> <name>chunk</name></expr>;</expr_stmt>

          <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name><init>=<expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>chunk</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <expr_stmt><expr><name>termInstances</name><operator>++</operator></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>doc</name> <init>= <expr><name><name>bulkResult</name><operator>.</operator><name>docs</name><operator>.</operator><name>ints</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <comment type="line">//System.out.println("    docID=" + doc);</comment>
            <comment type="line">// add TNUM_OFFSET to the term number to make room for special reserved values:</comment>
            <comment type="line">// 0 (end term) and 1 (index into byte array follows)</comment>
            <decl_stmt><decl><type><name>int</name></type> <name>delta</name> <init>= <expr><name>termNum</name> <operator>-</operator> <name><name>lastTerm</name><index>[<expr><name>doc</name></expr>]</index></name> <operator>+</operator> <name>TNUM_OFFSET</name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name><name>lastTerm</name><index>[<expr><name>doc</name></expr>]</index></name> <operator>=</operator> <name>termNum</name></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>val</name> <init>= <expr><name><name>index</name><index>[<expr><name>doc</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><operator>(</operator><name>val</name> <operator>&amp;</operator> <literal type="number">0xff</literal><operator>)</operator><operator>==</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
              <comment type="line">// index into byte array (actually the end of</comment>
              <comment type="line">// the doc-specific byte[] when building)</comment>
              <decl_stmt><decl><type><name>int</name></type> <name>pos</name> <init>= <expr><name>val</name> <operator>&gt;&gt;&gt;</operator> <literal type="number">8</literal></expr></init></decl>;</decl_stmt>
              <decl_stmt><decl><type><name>int</name></type> <name>ilen</name> <init>= <expr><call><name>vIntSize</name><argument_list>(<argument><expr><name>delta</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
              <decl_stmt><decl><type><name><name>byte</name><index>[]</index></name></type> <name>arr</name> <init>= <expr><name><name>bytes</name><index>[<expr><name>doc</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
              <decl_stmt><decl><type><name>int</name></type> <name>newend</name> <init>= <expr><name>pos</name><operator>+</operator><name>ilen</name></expr></init></decl>;</decl_stmt>
              <if_stmt><if>if <condition>(<expr><name>newend</name> <operator>&gt;</operator> <name><name>arr</name><operator>.</operator><name>length</name></name></expr>)</condition> <block>{<block_content>
                <comment type="line">// We avoid a doubling strategy to lower memory usage.</comment>
                <comment type="line">// this faceting method isn't for docs with many terms.</comment>
                <comment type="line">// In hotspot, objects have 2 words of overhead, then fields, rounded up to a 64-bit boundary.</comment>
                <comment type="line">// TODO: figure out what array lengths we can round up to w/o actually using more memory</comment>
                <comment type="line">// (how much space does a byte[] take up?  Is data preceded by a 32 bit length only?</comment>
                <comment type="line">// It should be safe to round up to the nearest 32 bits in any case.</comment>
                <decl_stmt><decl><type><name>int</name></type> <name>newLen</name> <init>= <expr><operator>(</operator><name>newend</name> <operator>+</operator> <literal type="number">3</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xfffffffc</literal></expr></init></decl>;</decl_stmt>  <comment type="line">// 4 byte alignment</comment>
                <decl_stmt><decl><type><name><name>byte</name><index>[]</index></name></type> <name>newarr</name> <init>= <expr><operator>new</operator> <name><name>byte</name><index>[<expr><name>newLen</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name><name>System</name><operator>.</operator><name>arraycopy</name></name><argument_list>(<argument><expr><name>arr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>newarr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>arr</name> <operator>=</operator> <name>newarr</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>bytes</name><index>[<expr><name>doc</name></expr>]</index></name> <operator>=</operator> <name>newarr</name></expr>;</expr_stmt>
              </block_content>}</block></if></if_stmt>
              <expr_stmt><expr><name>pos</name> <operator>=</operator> <call><name>writeInt</name><argument_list>(<argument><expr><name>delta</name></expr></argument>, <argument><expr><name>arr</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><name><name>index</name><index>[<expr><name>doc</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>pos</name><operator>&lt;&lt;</operator><literal type="number">8</literal><operator>)</operator> <operator>|</operator> <literal type="number">1</literal></expr>;</expr_stmt>  <comment type="line">// update pointer to end index in byte[]</comment>
            </block_content>}</block></if> <else>else <block>{<block_content>
              <comment type="line">// OK, this int has data in it... find the end (a zero starting byte - not</comment>
              <comment type="line">// part of another number, hence not following a byte with the high bit set).</comment>
              <decl_stmt><decl><type><name>int</name></type> <name>ipos</name></decl>;</decl_stmt>
              <if_stmt><if>if <condition>(<expr><name>val</name><operator>==</operator><literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>ipos</name><operator>=</operator><literal type="number">0</literal></expr>;</expr_stmt>
              </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>(</operator><name>val</name> <operator>&amp;</operator> <literal type="number">0x0000ff80</literal><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>ipos</name><operator>=</operator><literal type="number">1</literal></expr>;</expr_stmt>
              </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>(</operator><name>val</name> <operator>&amp;</operator> <literal type="number">0x00ff8000</literal><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>ipos</name><operator>=</operator><literal type="number">2</literal></expr>;</expr_stmt>
              </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>(</operator><name>val</name> <operator>&amp;</operator> <literal type="number">0xff800000</literal><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>ipos</name><operator>=</operator><literal type="number">3</literal></expr>;</expr_stmt>
              </block_content>}</block></if> <else>else <block>{<block_content>
                <expr_stmt><expr><name>ipos</name><operator>=</operator><literal type="number">4</literal></expr>;</expr_stmt>
              </block_content>}</block></else></if_stmt>

              <comment type="line">//System.out.println("      ipos=" + ipos);</comment>

              <decl_stmt><decl><type><name>int</name></type> <name>endPos</name> <init>= <expr><call><name>writeInt</name><argument_list>(<argument><expr><name>delta</name></expr></argument>, <argument><expr><name>tempArr</name></expr></argument>, <argument><expr><name>ipos</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
              <comment type="line">//System.out.println("      endpos=" + endPos);</comment>
              <if_stmt><if>if <condition>(<expr><name>endPos</name> <operator>&lt;=</operator> <literal type="number">4</literal></expr>)</condition> <block>{<block_content>
                <comment type="line">//System.out.println("      fits!");</comment>
                <comment type="line">// value will fit in the integer... move bytes back</comment>
                <for>for <control>(<init><decl><type><name>int</name></type> <name>j</name><init>=<expr><name>ipos</name></expr></init></decl>;</init> <condition><expr><name>j</name><operator>&lt;</operator><name>endPos</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
                  <expr_stmt><expr><name>val</name> <operator>|=</operator> <operator>(</operator><name><name>tempArr</name><index>[<expr><name>j</name></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0xff</literal><operator>)</operator> <operator>&lt;&lt;</operator> <operator>(</operator><name>j</name><operator>&lt;&lt;</operator><literal type="number">3</literal><operator>)</operator></expr>;</expr_stmt>
                </block_content>}</block></for>
                <expr_stmt><expr><name><name>index</name><index>[<expr><name>doc</name></expr>]</index></name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>
              </block_content>}</block></if> <else>else <block>{<block_content>
                <comment type="line">// value won't fit... move integer into byte[]</comment>
                <for>for <control>(<init><decl><type><name>int</name></type> <name>j</name><init>=<expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name><operator>&lt;</operator><name>ipos</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
                  <expr_stmt><expr><name><name>tempArr</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>byte</name><operator>)</operator><name>val</name></expr>;</expr_stmt>
                  <expr_stmt><expr><name>val</name> <operator>&gt;&gt;&gt;=</operator><literal type="number">8</literal></expr>;</expr_stmt>
                </block_content>}</block></for>
                <comment type="line">// point at the end index in the byte[]</comment>
                <expr_stmt><expr><name><name>index</name><index>[<expr><name>doc</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>endPos</name><operator>&lt;&lt;</operator><literal type="number">8</literal><operator>)</operator> <operator>|</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>bytes</name><index>[<expr><name>doc</name></expr>]</index></name> <operator>=</operator> <name>tempArr</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>tempArr</name> <operator>=</operator> <operator>new</operator> <name><name>byte</name><index>[<expr><literal type="number">12</literal></expr>]</index></name></expr>;</expr_stmt>
              </block_content>}</block></else></if_stmt>
            </block_content>}</block></else></if_stmt>
          </block_content>}</block></for>
        </block_content>}</block></for>
        <expr_stmt><expr><call><name>setActualDocFreq</name><argument_list>(<argument><expr><name>termNum</name></expr></argument>, <argument><expr><name>actualDF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>

      <expr_stmt><expr><name>termNum</name><operator>++</operator></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><call><name><name>te</name><operator>.</operator><name>next</name></name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
        <break>break;</break>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><name>numTermsInField</name> <operator>=</operator> <name>termNum</name></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>long</name></type> <name>midPoint</name> <init>= <expr><call><name><name>System</name><operator>.</operator><name>currentTimeMillis</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>termInstances</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <comment type="line">// we didn't invert anything</comment>
      <comment type="line">// lower memory consumption.</comment>
      <expr_stmt><expr><name>tnums</name> <operator>=</operator> <literal type="null">null</literal></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>

      <expr_stmt><expr><name><name>this</name><operator>.</operator><name>index</name></name> <operator>=</operator> <name>index</name></expr>;</expr_stmt>

      <comment type="line">//</comment>
      <comment type="line">// transform intermediate form into the final form, building a single byte[]</comment>
      <comment type="line">// at a time, and releasing the intermediate byte[]s as we go to avoid</comment>
      <comment type="line">// increasing the memory footprint.</comment>
      <comment type="line">//</comment>

      <for>for <control>(<init><decl><type><name>int</name></type> <name>pass</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>pass</name><operator>&lt;</operator><literal type="number">256</literal></expr>;</condition> <incr><expr><name>pass</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name><name>byte</name><index>[]</index></name></type> <name>target</name> <init>= <expr><name><name>tnums</name><index>[<expr><name>pass</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>pos</name><init>=<expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>  <comment type="line">// end in target;</comment>
        <if_stmt><if>if <condition>(<expr><name>target</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><name>pos</name> <operator>=</operator> <name><name>target</name><operator>.</operator><name>length</name></name></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
          <expr_stmt><expr><name>target</name> <operator>=</operator> <operator>new</operator> <name><name>byte</name><index>[<expr><literal type="number">4096</literal></expr>]</index></name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <comment type="line">// loop over documents, 0x00ppxxxx, 0x01ppxxxx, 0x02ppxxxx</comment>
        <comment type="line">// where pp is the pass (which array we are building), and xx is all values.</comment>
        <comment type="line">// each pass shares the same byte[] for termNumber lists.</comment>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>docbase</name> <init>= <expr><name>pass</name><operator>&lt;&lt;</operator><literal type="number">16</literal></expr></init></decl>;</init> <condition><expr><name>docbase</name><operator>&lt;</operator><name>maxDoc</name></expr>;</condition> <incr><expr><name>docbase</name><operator>+=</operator><operator>(</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><literal type="number">24</literal><operator>)</operator></expr></incr>)</control> <block>{<block_content>
          <decl_stmt><decl><type><name>int</name></type> <name>lim</name> <init>= <expr><call><name><name>Math</name><operator>.</operator><name>min</name></name><argument_list>(<argument><expr><name>docbase</name> <operator>+</operator> <operator>(</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><literal type="number">16</literal><operator>)</operator></expr></argument>, <argument><expr><name>maxDoc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <for>for <control>(<init><decl><type><name>int</name></type> <name>doc</name><init>=<expr><name>docbase</name></expr></init></decl>;</init> <condition><expr><name>doc</name><operator>&lt;</operator><name>lim</name></expr>;</condition> <incr><expr><name>doc</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <comment type="line">//System.out.println("  pass=" + pass + " process docID=" + doc);</comment>
            <decl_stmt><decl><type><name>int</name></type> <name>val</name> <init>= <expr><name><name>index</name><index>[<expr><name>doc</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><name>val</name><operator>&amp;</operator><literal type="number">0xff</literal><operator>)</operator> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
              <decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><name>val</name> <operator>&gt;&gt;&gt;</operator> <literal type="number">8</literal></expr></init></decl>;</decl_stmt>
              <comment type="line">//System.out.println("    ptr pos=" + pos);</comment>
              <expr_stmt><expr><name><name>index</name><index>[<expr><name>doc</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>pos</name><operator>&lt;&lt;</operator><literal type="number">8</literal><operator>)</operator><operator>|</operator><literal type="number">1</literal></expr>;</expr_stmt> <comment type="line">// change index to point to start of array</comment>
              <if_stmt><if>if <condition>(<expr><operator>(</operator><name>pos</name> <operator>&amp;</operator> <literal type="number">0xff000000</literal><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <comment type="line">// we only have 24 bits for the array index</comment>
                <throw>throw <expr><operator>new</operator> <call><name>IllegalStateException</name><argument_list>(<argument><expr><literal type="string">"Too many values for UnInvertedField faceting on field "</literal><operator>+</operator><name>field</name></expr></argument>)</argument_list></call></expr>;</throw>
              </block_content>}</block></if></if_stmt>
              <decl_stmt><decl><type><name><name>byte</name><index>[]</index></name></type> <name>arr</name> <init>= <expr><name><name>bytes</name><index>[<expr><name>doc</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
              <comment type="block">/*
              for(byte b : arr) {
                //System.out.println("      b=" + Integer.toHexString((int) b));
              }
              */</comment>
              <expr_stmt><expr><name><name>bytes</name><index>[<expr><name>doc</name></expr>]</index></name> <operator>=</operator> <literal type="null">null</literal></expr>;</expr_stmt>        <comment type="line">// IMPORTANT: allow GC to avoid OOM</comment>
              <if_stmt><if>if <condition>(<expr><name><name>target</name><operator>.</operator><name>length</name></name> <operator>&lt;=</operator> <name>pos</name> <operator>+</operator> <name>len</name></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name>int</name></type> <name>newlen</name> <init>= <expr><name><name>target</name><operator>.</operator><name>length</name></name></expr></init></decl>;</decl_stmt>
                <comment type="block" format="javadoc">/*** we don't have to worry about the array getting too large
                 * since the "pos" param will overflow first (only 24 bits available)
                if ((newlen&lt;&lt;1) &lt;= 0) {
                  // overflow...
                  newlen = Integer.MAX_VALUE;
                  if (newlen &lt;= pos + len) {
                    throw new SolrException(400,"Too many terms to uninvert field!");
                  }
                } else {
                  while (newlen &lt;= pos + len) newlen&lt;&lt;=1;  // doubling strategy
                }
                ****/</comment>
                <while>while <condition>(<expr><name>newlen</name> <operator>&lt;=</operator> <name>pos</name> <operator>+</operator> <name>len</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>newlen</name><operator>&lt;&lt;=</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></while>  <comment type="line">// doubling strategy                 </comment>
                <decl_stmt><decl><type><name><name>byte</name><index>[]</index></name></type> <name>newtarget</name> <init>= <expr><operator>new</operator> <name><name>byte</name><index>[<expr><name>newlen</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name><name>System</name><operator>.</operator><name>arraycopy</name></name><argument_list>(<argument><expr><name>target</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>newtarget</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>target</name> <operator>=</operator> <name>newtarget</name></expr>;</expr_stmt>
              </block_content>}</block></if></if_stmt>
              <expr_stmt><expr><call><name><name>System</name><operator>.</operator><name>arraycopy</name></name><argument_list>(<argument><expr><name>arr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>target</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><name>pos</name> <operator>+=</operator> <name>len</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>  <comment type="line">// skip single byte at end and leave it 0 for terminator</comment>
            </block_content>}</block></if></if_stmt>
          </block_content>}</block></for>
        </block_content>}</block></for>

        <comment type="line">// shrink array</comment>
        <if_stmt><if>if <condition>(<expr><name>pos</name> <operator>&lt;</operator> <name><name>target</name><operator>.</operator><name>length</name></name></expr>)</condition> <block>{<block_content>
          <decl_stmt><decl><type><name><name>byte</name><index>[]</index></name></type> <name>newtarget</name> <init>= <expr><operator>new</operator> <name><name>byte</name><index>[<expr><name>pos</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><call><name><name>System</name><operator>.</operator><name>arraycopy</name></name><argument_list>(<argument><expr><name>target</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>newtarget</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>target</name> <operator>=</operator> <name>newtarget</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        
        <expr_stmt><expr><name><name>tnums</name><index>[<expr><name>pass</name></expr>]</index></name> <operator>=</operator> <name>target</name></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>pass</name> <operator>&lt;&lt;</operator> <literal type="number">16</literal><operator>)</operator> <operator>&gt;</operator> <name>maxDoc</name></expr>)</condition><block type="pseudo"><block_content>
          <break>break;</break></block_content></block></if></if_stmt>
      </block_content>}</block></for>

      <if_stmt><if>if <condition>(<expr><name>indexedTerms</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>indexedTermsArray</name> <operator>=</operator> <call><name><name>indexedTerms</name><operator>.</operator><name>toArray</name></name><argument_list>(<argument><expr><operator>new</operator> <name><name>BytesRef</name><index>[<expr><call><name><name>indexedTerms</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>

    <decl_stmt><decl><type><name>long</name></type> <name>endTime</name> <init>= <expr><call><name><name>System</name><operator>.</operator><name>currentTimeMillis</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>total_time</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>endTime</name><operator>-</operator><name>startTime</name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>phase1_time</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>midPoint</name><operator>-</operator><name>startTime</name><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></function>

  <comment type="block" format="javadoc">/** Number of bytes to represent an unsigned int as a vint. */</comment>
  <function><type><specifier>private</specifier> <specifier>static</specifier> <name>int</name></type> <name>vIntSize</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>x</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>x</name> <operator>&amp;</operator> <operator>(</operator><literal type="number">0xffffffff</literal> <operator>&lt;&lt;</operator> <operator>(</operator><literal type="number">7</literal><operator>*</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr> )</condition> <block>{<block_content>
      <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>x</name> <operator>&amp;</operator> <operator>(</operator><literal type="number">0xffffffff</literal> <operator>&lt;&lt;</operator> <operator>(</operator><literal type="number">7</literal><operator>*</operator><literal type="number">2</literal><operator>)</operator><operator>)</operator><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr> )</condition> <block>{<block_content>
      <return>return <expr><literal type="number">2</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>x</name> <operator>&amp;</operator> <operator>(</operator><literal type="number">0xffffffff</literal> <operator>&lt;&lt;</operator> <operator>(</operator><literal type="number">7</literal><operator>*</operator><literal type="number">3</literal><operator>)</operator><operator>)</operator><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr> )</condition> <block>{<block_content>
      <return>return <expr><literal type="number">3</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>x</name> <operator>&amp;</operator> <operator>(</operator><literal type="number">0xffffffff</literal> <operator>&lt;&lt;</operator> <operator>(</operator><literal type="number">7</literal><operator>*</operator><literal type="number">4</literal><operator>)</operator><operator>)</operator><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr> )</condition> <block>{<block_content>
      <return>return <expr><literal type="number">4</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><literal type="number">5</literal></expr>;</return>
  </block_content>}</block></function>

  <comment type="line">// todo: if we know the size of the vInt already, we could do</comment>
  <comment type="line">// a single switch on the size</comment>
  <function><type><specifier>private</specifier> <specifier>static</specifier> <name>int</name></type> <name>writeInt</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name><name>byte</name><index>[]</index></name></type> <name>arr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pos</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>a</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>a</name> <operator>=</operator> <operator>(</operator><name>x</name> <operator>&gt;&gt;&gt;</operator> <operator>(</operator><literal type="number">7</literal><operator>*</operator><literal type="number">4</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>a</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name><name>arr</name><index>[<expr><name>pos</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>byte</name><operator>)</operator><operator>(</operator><name>a</name> <operator>|</operator> <literal type="number">0x80</literal><operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>a</name> <operator>=</operator> <operator>(</operator><name>x</name> <operator>&gt;&gt;&gt;</operator> <operator>(</operator><literal type="number">7</literal><operator>*</operator><literal type="number">3</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>a</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name><name>arr</name><index>[<expr><name>pos</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>byte</name><operator>)</operator><operator>(</operator><name>a</name> <operator>|</operator> <literal type="number">0x80</literal><operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>a</name> <operator>=</operator> <operator>(</operator><name>x</name> <operator>&gt;&gt;&gt;</operator> <operator>(</operator><literal type="number">7</literal><operator>*</operator><literal type="number">2</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>a</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name><name>arr</name><index>[<expr><name>pos</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>byte</name><operator>)</operator><operator>(</operator><name>a</name> <operator>|</operator> <literal type="number">0x80</literal><operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>a</name> <operator>=</operator> <operator>(</operator><name>x</name> <operator>&gt;&gt;&gt;</operator> <operator>(</operator><literal type="number">7</literal><operator>*</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>a</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name><name>arr</name><index>[<expr><name>pos</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>byte</name><operator>)</operator><operator>(</operator><name>a</name> <operator>|</operator> <literal type="number">0x80</literal><operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>arr</name><index>[<expr><name>pos</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>byte</name><operator>)</operator><operator>(</operator><name>x</name> <operator>&amp;</operator> <literal type="number">0x7f</literal><operator>)</operator></expr>;</expr_stmt>
    <return>return <expr><name>pos</name></expr>;</return>
  </block_content>}</block></function>

  <class><specifier>public</specifier> class <name>TermOrdsIterator</name> <block>{
    <decl_stmt><decl><type><specifier>private</specifier> <name>int</name></type> <name>tnum</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name>int</name></type> <name>upto</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name><name>byte</name><index>[]</index></name></type> <name>arr</name></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/** Buffer must be at least 5 ints long.  Returns number
     *  of term ords placed into buffer; if this count is
     *  less than buffer.length then that is the end. */</comment>
    <function><type><specifier>public</specifier> <name>int</name></type> <name>read</name><parameter_list>(<parameter><decl><type><name><name>int</name><index>[]</index></name></type> <name>buffer</name></decl></parameter>)</parameter_list> <block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>bufferUpto</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><name>arr</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
        <comment type="line">// code is inlined into upto</comment>
        <comment type="line">//System.out.println("inlined");</comment>
        <decl_stmt><decl><type><name>int</name></type> <name>code</name> <init>= <expr><name>upto</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>delta</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
          <expr_stmt><expr><name>delta</name> <operator>=</operator> <operator>(</operator><name>delta</name> <operator>&lt;&lt;</operator> <literal type="number">7</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><name>code</name> <operator>&amp;</operator> <literal type="number">0x7f</literal><operator>)</operator></expr>;</expr_stmt>
          <if_stmt><if>if <condition>(<expr><operator>(</operator><name>code</name> <operator>&amp;</operator> <literal type="number">0x80</literal><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>delta</name><operator>==</operator><literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>tnum</name> <operator>+=</operator> <name>delta</name> <operator>-</operator> <name>TNUM_OFFSET</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>buffer</name><index>[<expr><name>bufferUpto</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>ordBase</name><operator>+</operator><name>tnum</name></expr>;</expr_stmt>
            <comment type="line">//System.out.println("  tnum=" + tnum);</comment>
            <expr_stmt><expr><name>delta</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><name>code</name> <operator>&gt;&gt;&gt;=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
        </block_content>}</block></for>
      </block_content>}</block></if> <else>else <block>{<block_content>
        <comment type="line">// code is a pointer</comment>
        <for>for<control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
          <decl_stmt><decl><type><name>int</name></type> <name>delta</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
          <for>for<control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
            <decl_stmt><decl><type><name>byte</name></type> <name>b</name> <init>= <expr><name><name>arr</name><index>[<expr><name>upto</name><operator>++</operator></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>delta</name> <operator>=</operator> <operator>(</operator><name>delta</name> <operator>&lt;&lt;</operator> <literal type="number">7</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><name>b</name> <operator>&amp;</operator> <literal type="number">0x7f</literal><operator>)</operator></expr>;</expr_stmt>
            <comment type="line">//System.out.println("    cycle: upto=" + upto + " delta=" + delta + " b=" + b);</comment>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><name>b</name> <operator>&amp;</operator> <literal type="number">0x80</literal><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
          </block_content>}</block></for>
          <comment type="line">//System.out.println("  delta=" + delta);</comment>
          <if_stmt><if>if <condition>(<expr><name>delta</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
          <expr_stmt><expr><name>tnum</name> <operator>+=</operator> <name>delta</name> <operator>-</operator> <name>TNUM_OFFSET</name></expr>;</expr_stmt>
          <comment type="line">//System.out.println("  tnum=" + tnum);</comment>
          <expr_stmt><expr><name><name>buffer</name><index>[<expr><name>bufferUpto</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>ordBase</name><operator>+</operator><name>tnum</name></expr>;</expr_stmt>
          <if_stmt><if>if <condition>(<expr><name>bufferUpto</name> <operator>==</operator> <name><name>buffer</name><operator>.</operator><name>length</name></name></expr>)</condition> <block>{<block_content>
            <break>break;</break>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
      </block_content>}</block></else></if_stmt>

      <return>return <expr><name>bufferUpto</name></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <name>TermOrdsIterator</name></type> <name>reset</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>docID</name></decl></parameter>)</parameter_list> <block>{<block_content>
      <comment type="line">//System.out.println("  reset docID=" + docID);</comment>
      <expr_stmt><expr><name>tnum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>code</name> <init>= <expr><name><name>index</name><index>[<expr><name>docID</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><operator>(</operator><name>code</name> <operator>&amp;</operator> <literal type="number">0xff</literal><operator>)</operator><operator>==</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <comment type="line">// a pointer</comment>
        <expr_stmt><expr><name>upto</name> <operator>=</operator> <name>code</name><operator>&gt;&gt;&gt;</operator><literal type="number">8</literal></expr>;</expr_stmt>
        <comment type="line">//System.out.println("    pointer!  upto=" + upto);</comment>
        <decl_stmt><decl><type><name>int</name></type> <name>whichArray</name> <init>= <expr><operator>(</operator><name>docID</name> <operator>&gt;&gt;&gt;</operator> <literal type="number">16</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xff</literal></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>arr</name> <operator>=</operator> <name><name>tnums</name><index>[<expr><name>whichArray</name></expr>]</index></name></expr>;</expr_stmt>
      </block_content>}</block></if> <else>else <block>{<block_content>
        <comment type="line">//System.out.println("    inline!");</comment>
        <expr_stmt><expr><name>arr</name> <operator>=</operator> <literal type="null">null</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>upto</name> <operator>=</operator> <name>code</name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <return>return <expr><name>this</name></expr>;</return>
    </block_content>}</block></function>
  }</block></class>

  <comment type="block" format="javadoc">/** Returns an iterator to step through the term ords for
   *  this document.  It's also possible to subclass this
   *  class and directly access members. */</comment>
  <function><type><specifier>public</specifier> <name>TermOrdsIterator</name></type> <name>lookup</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>doc</name></decl></parameter>, <parameter><decl><type><name>TermOrdsIterator</name></type> <name>reuse</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><specifier>final</specifier> <name>TermOrdsIterator</name></type> <name>ret</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>reuse</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>ret</name> <operator>=</operator> <name>reuse</name></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><name>ret</name> <operator>=</operator> <operator>new</operator> <call><name>TermOrdsIterator</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <return>return <expr><call><name><name>ret</name><operator>.</operator><name>reset</name></name><argument_list>(<argument><expr><name>doc</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></function>

  <comment type="block">/* Only used if original IndexReader doesn't implement
   * ord; in this case we "wrap" our own terms index
   * around it. */</comment>
  <class><specifier>private</specifier> <specifier>final</specifier> class <name>OrdWrappedTermsEnum</name> <super_list><extends>extends <super><name>TermsEnum</name></super></extends></super_list> <block>{
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>IndexReader</name></type> <name>reader</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>TermsEnum</name></type> <name>termsEnum</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name>BytesRef</name></type> <name>term</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name>long</name></type> <name>ord</name> <init>= <expr><operator>-</operator><name>indexInterval</name><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>          <comment type="line">// force "real" seek</comment>
    
    <constructor><specifier>public</specifier> <name>OrdWrappedTermsEnum</name><parameter_list>(<parameter><decl><type><name>IndexReader</name></type> <name>reader</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws> <block>{<block_content>
      <expr_stmt><expr><name><name>this</name><operator>.</operator><name>reader</name></name> <operator>=</operator> <name>reader</name></expr>;</expr_stmt>
      <assert>assert <expr><name>indexedTermsArray</name> <operator>!=</operator> <literal type="null">null</literal></expr>;</assert>
      <expr_stmt><expr><name>termsEnum</name> <operator>=</operator> <call><name><name>MultiFields</name><operator>.</operator><name>getTerms</name></name><argument_list>(<argument><expr><name>reader</name></expr></argument>, <argument><expr><name>field</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>iterator</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></constructor>

    <function><annotation>@<name>Override</name></annotation>
    <type><specifier>public</specifier> <name><name>Comparator</name><argument_list type="generic">&lt;<argument><name>BytesRef</name></argument>&gt;</argument_list></name></type> <name>getComparator</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws> <block>{<block_content>
      <return>return <expr><call><name><name>termsEnum</name><operator>.</operator><name>getComparator</name></name><argument_list>()</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><annotation>@<name>Override</name></annotation>    
    <type><specifier>public</specifier> <name>DocsEnum</name></type> <name>docs</name><parameter_list>(<parameter><decl><type><name>Bits</name></type> <name>skipDocs</name></decl></parameter>, <parameter><decl><type><name>DocsEnum</name></type> <name>reuse</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws> <block>{<block_content>
      <return>return <expr><call><name><name>termsEnum</name><operator>.</operator><name>docs</name></name><argument_list>(<argument><expr><name>skipDocs</name></expr></argument>, <argument><expr><name>reuse</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><annotation>@<name>Override</name></annotation>    
    <type><specifier>public</specifier> <name>DocsAndPositionsEnum</name></type> <name>docsAndPositions</name><parameter_list>(<parameter><decl><type><name>Bits</name></type> <name>skipDocs</name></decl></parameter>, <parameter><decl><type><name>DocsAndPositionsEnum</name></type> <name>reuse</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws> <block>{<block_content>
      <return>return <expr><call><name><name>termsEnum</name><operator>.</operator><name>docsAndPositions</name></name><argument_list>(<argument><expr><name>skipDocs</name></expr></argument>, <argument><expr><name>reuse</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><annotation>@<name>Override</name></annotation>
    <type><specifier>public</specifier> <name>BytesRef</name></type> <name>term</name><parameter_list>()</parameter_list> <block>{<block_content>
      <return>return <expr><name>term</name></expr>;</return>
    </block_content>}</block></function>

    <function><annotation>@<name>Override</name></annotation>
    <type><specifier>public</specifier> <name>BytesRef</name></type> <name>next</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws> <block>{<block_content>
      <expr_stmt><expr><name>ord</name><operator>++</operator></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><call><name><name>termsEnum</name><operator>.</operator><name>next</name></name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>term</name> <operator>=</operator> <literal type="null">null</literal></expr>;</expr_stmt>
        <return>return <expr><literal type="null">null</literal></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <return>return <expr><call><name>setTerm</name><argument_list>()</argument_list></call></expr>;</return>  <comment type="line">// this is extra work if we know we are in bounds...</comment>
    </block_content>}</block></function>

    <function><annotation>@<name>Override</name></annotation>
    <type><specifier>public</specifier> <name>int</name></type> <name>docFreq</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws> <block>{<block_content>
      <return>return <expr><call><name><name>termsEnum</name><operator>.</operator><name>docFreq</name></name><argument_list>()</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><annotation>@<name>Override</name></annotation>
    <type><specifier>public</specifier> <name>long</name></type> <name>totalTermFreq</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws> <block>{<block_content>
      <return>return <expr><call><name><name>termsEnum</name><operator>.</operator><name>totalTermFreq</name></name><argument_list>()</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><annotation>@<name>Override</name></annotation>
    <type><specifier>public</specifier> <name>long</name></type> <name>ord</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws> <block>{<block_content>
      <return>return <expr><name>ordBase</name> <operator>+</operator> <name>ord</name></expr>;</return>
    </block_content>}</block></function>

    <function><annotation>@<name>Override</name></annotation>
    <type><specifier>public</specifier> <name>SeekStatus</name></type> <name>seek</name><parameter_list>(<parameter><decl><type><name>BytesRef</name></type> <name>target</name></decl></parameter>, <parameter><decl><type><name>boolean</name></type> <name>useCache</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws> <block>{<block_content>

      <comment type="line">// already here</comment>
      <if_stmt><if>if <condition>(<expr><name>term</name> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <call><name><name>term</name><operator>.</operator><name>equals</name></name><argument_list>(<argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <return>return <expr><name><name>SeekStatus</name><operator>.</operator><name>FOUND</name></name></expr>;</return>
      </block_content>}</block></if></if_stmt>

      <decl_stmt><decl><type><name>int</name></type> <name>startIdx</name> <init>= <expr><call><name><name>Arrays</name><operator>.</operator><name>binarySearch</name></name><argument_list>(<argument><expr><name>indexedTermsArray</name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

      <if_stmt><if>if <condition>(<expr><name>startIdx</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <comment type="line">// we hit the term exactly... lucky us!</comment>
        <decl_stmt><decl><type><name><name>TermsEnum</name><operator>.</operator><name>SeekStatus</name></name></type> <name>seekStatus</name> <init>= <expr><call><name><name>termsEnum</name><operator>.</operator><name>seek</name></name><argument_list>(<argument><expr><name>target</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <assert>assert <expr><name>seekStatus</name> <operator>==</operator> <name><name>TermsEnum</name><operator>.</operator><name>SeekStatus</name><operator>.</operator><name>FOUND</name></name></expr>;</assert>
        <expr_stmt><expr><name>ord</name> <operator>=</operator> <name>startIdx</name> <operator>&lt;&lt;</operator> <name>indexIntervalBits</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>setTerm</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <assert>assert <expr><name>term</name> <operator>!=</operator> <literal type="null">null</literal></expr>;</assert>
        <return>return <expr><name><name>SeekStatus</name><operator>.</operator><name>FOUND</name></name></expr>;</return>
      </block_content>}</block></if></if_stmt>

      <comment type="line">// we didn't hit the term exactly</comment>
      <expr_stmt><expr><name>startIdx</name> <operator>=</operator> <operator>-</operator><name>startIdx</name><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    
      <if_stmt><if>if <condition>(<expr><name>startIdx</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <comment type="line">// our target occurs *before* the first term</comment>
        <decl_stmt><decl><type><name><name>TermsEnum</name><operator>.</operator><name>SeekStatus</name></name></type> <name>seekStatus</name> <init>= <expr><call><name><name>termsEnum</name><operator>.</operator><name>seek</name></name><argument_list>(<argument><expr><name>target</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <assert>assert <expr><name>seekStatus</name> <operator>==</operator> <name><name>TermsEnum</name><operator>.</operator><name>SeekStatus</name><operator>.</operator><name>NOT_FOUND</name></name></expr>;</assert>
        <expr_stmt><expr><name>ord</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>setTerm</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <assert>assert <expr><name>term</name> <operator>!=</operator> <literal type="null">null</literal></expr>;</assert>
        <return>return <expr><name><name>SeekStatus</name><operator>.</operator><name>NOT_FOUND</name></name></expr>;</return>
      </block_content>}</block></if></if_stmt>

      <comment type="line">// back up to the start of the block</comment>
      <expr_stmt><expr><name>startIdx</name><operator>--</operator></expr>;</expr_stmt>

      <if_stmt><if>if <condition>(<expr><operator>(</operator><name>ord</name> <operator>&gt;&gt;</operator> <name>indexIntervalBits</name><operator>)</operator> <operator>==</operator> <name>startIdx</name> <operator>&amp;&amp;</operator> <name>term</name> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <call><name><name>term</name><operator>.</operator><name>compareTo</name></name><argument_list>(<argument><expr><name>target</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <comment type="line">// we are already in the right block and the current term is before the term we want,</comment>
        <comment type="line">// so we don't need to seek.</comment>
      </block_content>}</block></if> <else>else <block>{<block_content>
        <comment type="line">// seek to the right block</comment>
        <decl_stmt><decl><type><name><name>TermsEnum</name><operator>.</operator><name>SeekStatus</name></name></type> <name>seekStatus</name> <init>= <expr><call><name><name>termsEnum</name><operator>.</operator><name>seek</name></name><argument_list>(<argument><expr><name><name>indexedTermsArray</name><index>[<expr><name>startIdx</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <assert>assert <expr><name>seekStatus</name> <operator>==</operator> <name><name>TermsEnum</name><operator>.</operator><name>SeekStatus</name><operator>.</operator><name>FOUND</name></name></expr>;</assert>
        <expr_stmt><expr><name>ord</name> <operator>=</operator> <name>startIdx</name> <operator>&lt;&lt;</operator> <name>indexIntervalBits</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>setTerm</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <assert>assert <expr><name>term</name> <operator>!=</operator> <literal type="null">null</literal></expr>;</assert>  <comment type="line">// should be non-null since it's in the index</comment>
      </block_content>}</block></else></if_stmt>

      <while>while <condition>(<expr><name>term</name> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <call><name><name>term</name><operator>.</operator><name>compareTo</name></name><argument_list>(<argument><expr><name>target</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>next</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></while>

      <if_stmt><if>if <condition>(<expr><name>term</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
        <return>return <expr><name><name>SeekStatus</name><operator>.</operator><name>END</name></name></expr>;</return>
      </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name><name>term</name><operator>.</operator><name>compareTo</name></name><argument_list>(<argument><expr><name>target</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <return>return <expr><name><name>SeekStatus</name><operator>.</operator><name>FOUND</name></name></expr>;</return>
      </block_content>}</block></if> <else>else <block>{<block_content>
        <return>return <expr><name><name>SeekStatus</name><operator>.</operator><name>NOT_FOUND</name></name></expr>;</return>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></function>

    <function><annotation>@<name>Override</name></annotation>
    <type><specifier>public</specifier> <name>SeekStatus</name></type> <name>seek</name><parameter_list>(<parameter><decl><type><name>long</name></type> <name>targetOrd</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws> <block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>delta</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><name>targetOrd</name> <operator>-</operator> <name>ordBase</name> <operator>-</operator> <name>ord</name><operator>)</operator></expr></init></decl>;</decl_stmt>
      <comment type="line">//System.out.println("  seek(ord) targetOrd=" + targetOrd + " delta=" + delta + " ord=" + ord);</comment>
      <if_stmt><if>if <condition>(<expr><name>delta</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>delta</name> <operator>&gt;</operator> <name>indexInterval</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>idx</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><name>targetOrd</name> <operator>&gt;&gt;&gt;</operator> <name>indexIntervalBits</name><operator>)</operator></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>BytesRef</name></type> <name>base</name> <init>= <expr><name><name>indexedTermsArray</name><index>[<expr><name>idx</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <comment type="line">//System.out.println("  do seek term=" + base.utf8ToString());</comment>
        <expr_stmt><expr><name>ord</name> <operator>=</operator> <name>idx</name> <operator>&lt;&lt;</operator> <name>indexIntervalBits</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>delta</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><name>targetOrd</name> <operator>-</operator> <name>ord</name><operator>)</operator></expr>;</expr_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name><name>TermsEnum</name><operator>.</operator><name>SeekStatus</name></name></type> <name>seekStatus</name> <init>= <expr><call><name><name>termsEnum</name><operator>.</operator><name>seek</name></name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <assert>assert <expr><name>seekStatus</name> <operator>==</operator> <name><name>TermsEnum</name><operator>.</operator><name>SeekStatus</name><operator>.</operator><name>FOUND</name></name></expr>;</assert>
      </block_content>}</block></if> <else>else <block>{<block_content>
        <comment type="line">//System.out.println("seek w/in block");</comment>
      </block_content>}</block></else></if_stmt>

      <while>while <condition>(<expr><operator>--</operator><name>delta</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>BytesRef</name></type> <name>br</name> <init>= <expr><call><name><name>termsEnum</name><operator>.</operator><name>next</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>br</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><name>term</name> <operator>=</operator> <literal type="null">null</literal></expr>;</expr_stmt>
          <return>return <expr><literal type="null">null</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>ord</name><operator>++</operator></expr>;</expr_stmt>
      </block_content>}</block></while>

      <expr_stmt><expr><call><name>setTerm</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><ternary><condition><expr><name>term</name> <operator>==</operator> <literal type="null">null</literal></expr> ?</condition><then> <expr><name><name>SeekStatus</name><operator>.</operator><name>END</name></name></expr> </then><else>: <expr><name><name>SeekStatus</name><operator>.</operator><name>FOUND</name></name></expr></else></ternary></expr>;</return>
      <comment type="line">//System.out.println("  return term=" + term.utf8ToString());</comment>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>BytesRef</name></type> <name>setTerm</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws> <block>{<block_content>
      <expr_stmt><expr><name>term</name> <operator>=</operator> <call><name><name>termsEnum</name><operator>.</operator><name>term</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <comment type="line">//System.out.println("  setTerm() term=" + term.utf8ToString() + " vs prefix=" + (prefix == null ? "null" : prefix.utf8ToString()));</comment>
      <if_stmt><if>if <condition>(<expr><name>prefix</name> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name><name>term</name><operator>.</operator><name>startsWith</name></name><argument_list>(<argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>term</name> <operator>=</operator> <literal type="null">null</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <return>return <expr><name>term</name></expr>;</return>
    </block_content>}</block></function>
  }</block></class>

  <function><type><specifier>public</specifier> <name>BytesRef</name></type> <name>lookupTerm</name><parameter_list>(<parameter><decl><type><name>TermsEnum</name></type> <name>termsEnum</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ord</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws> <block>{<block_content>
    <decl_stmt><decl><type><name><name>TermsEnum</name><operator>.</operator><name>SeekStatus</name></name></type> <name>status</name> <init>= <expr><call><name><name>termsEnum</name><operator>.</operator><name>seek</name></name><argument_list>(<argument><expr><name>ord</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <assert>assert <expr><name>status</name> <operator>==</operator> <name><name>TermsEnum</name><operator>.</operator><name>SeekStatus</name><operator>.</operator><name>FOUND</name></name></expr>;</assert>
    <return>return <expr><call><name><name>termsEnum</name><operator>.</operator><name>term</name></name><argument_list>()</argument_list></call></expr>;</return>
  </block_content>}</block></function>
}
diff <expr_stmt><expr><operator>--</operator><name>git</name> <name>a</name><operator>/</operator><name>lucene</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>index</name><operator>/</operator><name><name>IndexReader</name><operator>.</operator><name>java</name></name> <name>b</name><operator>/</operator><name>lucene</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>index</name><operator>/</operator><name><name>IndexReader</name><operator>.</operator><name>java</name></name>
<name>index</name> <name>d1e37c576bd</name><operator>..</operator><literal type="number">9f3494c4654</literal> <literal type="number">100644</literal>
<operator>--</operator> <name>a</name><operator>/</operator><name>lucene</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>index</name><operator>/</operator><name><name>IndexReader</name><operator>.</operator><name>java</name></name>
<operator>++</operator> <name>b</name><operator>/</operator><name>lucene</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>index</name><operator>/</operator><name><name>IndexReader</name><operator>.</operator><name>java</name></name>
@@ <operator>-</operator><literal type="number">919</literal></expr><operator>,</operator><expr><literal type="number">6</literal> <operator>+</operator><literal type="number">919</literal></expr><operator>,</operator><expr><literal type="number">22</literal> @@ <specifier>public</specifier> <specifier>abstract</specifier> <name>class</name> <name>IndexReader</name> implements <name>Cloneable</name></expr><operator>,</operator><expr><name>Closeable</name> <block>{
     }</block></expr></expr_stmt>
   }
 
  <comment type="block" format="javadoc">/**
   * Returns &lt;code&gt;true&lt;/code&gt; if an index exists at the specified directory.
   * @param  directory the directory to check for an index
   * @param  codecProvider provides a CodecProvider in case the index uses non-core codecs
   * @return &lt;code&gt;true&lt;/code&gt; if an index exists; &lt;code&gt;false&lt;/code&gt; otherwise
   * @throws IOException if there is a problem with accessing the index
   */</comment>
  public <function><type><specifier>static</specifier> <name>boolean</name></type> <name>indexExists</name><parameter_list>(<parameter><decl><type><name>Directory</name></type> <name>directory</name></decl></parameter>, <parameter><decl><type><name>CodecProvider</name></type> <name>codecProvider</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws> <block>{<block_content>
    <try>try <block>{<block_content>
      <expr_stmt><expr><operator>new</operator> <call><name>SegmentInfos</name><argument_list>()</argument_list></call><operator>.</operator><call><name>read</name><argument_list>(<argument><expr><name>directory</name></expr></argument>, <argument><expr><name>codecProvider</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><literal type="boolean">true</literal></expr>;</return>
    </block_content>}</block> <catch>catch <parameter_list>(<parameter><decl><type><name>IOException</name></type> <name>ioe</name></decl></parameter>)</parameter_list> <block>{<block_content>
      <return>return <expr><literal type="boolean">false</literal></expr>;</return>
    </block_content>}</block></catch></try>
  </block_content>}</block></function>

   <comment type="block" format="javadoc">/** Returns the number of documents in this index. */</comment>
   <function_decl><type><specifier>public</specifier> <specifier>abstract</specifier> <name>int</name></type> <name>numDocs</name><parameter_list>()</parameter_list>;</function_decl>
 
<expr_stmt><expr><name>diff</name> <operator>--</operator><name>git</name> <name>a</name><operator>/</operator><name>lucene</name><operator>/</operator><name>src</name><operator>/</operator><name>test</name><operator>-</operator><name>framework</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>index</name><operator>/</operator><name><name>RandomIndexWriter</name><operator>.</operator><name>java</name></name> <name>b</name><operator>/</operator><name>lucene</name><operator>/</operator><name>src</name><operator>/</operator><name>test</name><operator>-</operator><name>framework</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>index</name><operator>/</operator><name><name>RandomIndexWriter</name><operator>.</operator><name>java</name></name>
<name>index</name> <literal type="number">27962632acc</literal><operator>..</operator><literal type="number">5c68a75951a</literal> <literal type="number">100644</literal>
<operator>--</operator> <name>a</name><operator>/</operator><name>lucene</name><operator>/</operator><name>src</name><operator>/</operator><name>test</name><operator>-</operator><name>framework</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>index</name><operator>/</operator><name><name>RandomIndexWriter</name><operator>.</operator><name>java</name></name>
<operator>++</operator> <name>b</name><operator>/</operator><name>lucene</name><operator>/</operator><name>src</name><operator>/</operator><name>test</name><operator>-</operator><name>framework</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>index</name><operator>/</operator><name><name>RandomIndexWriter</name><operator>.</operator><name>java</name></name>
@@ <operator>-</operator><literal type="number">181</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">181</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@ <specifier>public</specifier> <name>class</name> <name>RandomIndexWriter</name> implements <name>Closeable</name> <block>{
         <expr><call><name><name>System</name><operator>.</operator><name>out</name><operator>.</operator><name>println</name></name><argument_list>(<argument><expr><literal type="string">"RIW.getReader: open new reader"</literal></expr></argument>)</argument_list></call></expr>;
       }</block>
       <call><name><name>w</name><operator>.</operator><name>commit</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><call><name><name>IndexReader</name><operator>.</operator><name>open</name></name><argument_list>(<argument><expr><call><name><name>w</name><operator>.</operator><name>getDirectory</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><operator>new</operator> <call><name>KeepOnlyLastCommitDeletionPolicy</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>r</name><operator>.</operator><name>nextBoolean</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>_TestUtil</name><operator>.</operator><name>nextInt</name></name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
      <return>return <expr><call><name><name>IndexReader</name><operator>.</operator><name>open</name></name><argument_list>(<argument><expr><call><name><name>w</name><operator>.</operator><name>getDirectory</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><operator>new</operator> <call><name>KeepOnlyLastCommitDeletionPolicy</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>r</name><operator>.</operator><name>nextBoolean</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>_TestUtil</name><operator>.</operator><name>nextInt</name></name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>w</name><operator>.</operator><name>getConfig</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getCodecProvider</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
     }
   }
 
<expr_stmt><expr><name>diff</name> <operator>--</operator><name>git</name> <name>a</name><operator>/</operator><name>lucene</name><operator>/</operator><name>src</name><operator>/</operator><name>test</name><operator>-</operator><name>framework</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>store</name><operator>/</operator><name><name>MockDirectoryWrapper</name><operator>.</operator><name>java</name></name> <name>b</name><operator>/</operator><name>lucene</name><operator>/</operator><name>src</name><operator>/</operator><name>test</name><operator>-</operator><name>framework</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>store</name><operator>/</operator><name><name>MockDirectoryWrapper</name><operator>.</operator><name>java</name></name>
<name>index</name> <literal type="number">03c07f45db3</literal><operator>..</operator><name>c04871daf01</name> <literal type="number">100644</literal>
<operator>--</operator> <name>a</name><operator>/</operator><name>lucene</name><operator>/</operator><name>src</name><operator>/</operator><name>test</name><operator>-</operator><name>framework</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>store</name><operator>/</operator><name><name>MockDirectoryWrapper</name><operator>.</operator><name>java</name></name>
<operator>++</operator> <name>b</name><operator>/</operator><name>lucene</name><operator>/</operator><name>src</name><operator>/</operator><name>test</name><operator>-</operator><name>framework</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>store</name><operator>/</operator><name><name>MockDirectoryWrapper</name><operator>.</operator><name>java</name></name>
@@ <operator>-</operator><literal type="number">32</literal></expr><operator>,</operator><expr><literal type="number">6</literal> <operator>+</operator><literal type="number">32</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@</expr></expr_stmt> <import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>Random</name></name>;</import>
 <import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>Set</name></name>;</import>
 
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>index</name><operator>.</operator><name>IndexReader</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>index</name><operator>.</operator><name>codecs</name><operator>.</operator><name>CodecProvider</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>util</name><operator>.</operator><name>LuceneTestCase</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>util</name><operator>.</operator><name>_TestUtil</name></name>;</import>
 
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">419</literal></expr><operator>,</operator><expr><literal type="number">12</literal> <operator>+</operator><literal type="number">420</literal></expr><operator>,</operator><expr><literal type="number">27</literal> @@ <specifier>public</specifier> <name>class</name> <name>MockDirectoryWrapper</name> extends <name>Directory</name> <block>{
       <throw>throw <argument_list>new <argument><expr><call><name>RuntimeException</name><argument_list>(<argument><expr><literal type="string">"MockDirectoryWrapper: cannot close: there are still open files: "</literal> <operator>+</operator> <name>openFiles</name></expr></argument>, <argument><expr><name>cause</name></expr></argument>)</argument_list></call></expr></argument></argument_list></throw>;
     }</block>
     <name>open</name> <operator>=</operator> <literal type="boolean">false</literal></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>checkIndexOnClose</name> <operator>&amp;&amp;</operator> <call><name><name>IndexReader</name><operator>.</operator><name>indexExists</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name><name>_TestUtil</name><operator>.</operator><name>checkIndex</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>checkIndexOnClose</name></expr>)</condition> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>codecProvider</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name><name>IndexReader</name><operator>.</operator><name>indexExists</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>codecProvider</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><call><name><name>_TestUtil</name><operator>.</operator><name>checkIndex</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>codecProvider</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if> <else>else <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name><name>IndexReader</name><operator>.</operator><name>indexExists</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><call><name><name>_TestUtil</name><operator>.</operator><name>checkIndex</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></else></if_stmt>
     </block_content>}</block></if></if_stmt>
     <expr_stmt><expr><call><name><name>delegate</name><operator>.</operator><name>close</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
   </block_content>}</block></if></if_stmt>
 
  <decl_stmt><decl><type><specifier>private</specifier> <name>CodecProvider</name></type> <name>codecProvider</name></decl>;</decl_stmt>

  <comment type="line">// We pass this CodecProvider to checkIndex when dir is closed...</comment>
  <function><type><specifier>public</specifier> <name>void</name></type> <name>setCodecProvider</name><parameter_list>(<parameter><decl><type><name>CodecProvider</name></type> <name>cp</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><name>codecProvider</name> <operator>=</operator> <name>cp</name></expr>;</expr_stmt>
  </block_content>}</block></function>

   <decl_stmt><decl><type><name>boolean</name></type> <name>open</name> <init>= <expr><literal type="boolean">true</literal></expr></init></decl>;</decl_stmt>
   
   <function><type><specifier>public</specifier> <specifier>synchronized</specifier> <name>boolean</name></type> <name>isOpen</name><parameter_list>()</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>diff</name> <operator>--</operator><name>git</name> <name>a</name><operator>/</operator><name>lucene</name><operator>/</operator><name>src</name><operator>/</operator><name>test</name><operator>-</operator><name>framework</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>util</name><operator>/</operator><name><name>_TestUtil</name><operator>.</operator><name>java</name></name> <name>b</name><operator>/</operator><name>lucene</name><operator>/</operator><name>src</name><operator>/</operator><name>test</name><operator>-</operator><name>framework</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>util</name><operator>/</operator><name><name>_TestUtil</name><operator>.</operator><name>java</name></name>
<name>index</name> <name>ad3efa76a21</name><operator>..</operator><name>bd49677b755</name> <literal type="number">100644</literal>
<operator>--</operator> <name>a</name><operator>/</operator><name>lucene</name><operator>/</operator><name>src</name><operator>/</operator><name>test</name><operator>-</operator><name>framework</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>util</name><operator>/</operator><name><name>_TestUtil</name><operator>.</operator><name>java</name></name>
<operator>++</operator> <name>b</name><operator>/</operator><name>lucene</name><operator>/</operator><name>src</name><operator>/</operator><name>test</name><operator>-</operator><name>framework</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>util</name><operator>/</operator><name><name>_TestUtil</name><operator>.</operator><name>java</name></name>
@@ <operator>-</operator><literal type="number">157</literal></expr><operator>,</operator><expr><literal type="number">6</literal> <operator>+</operator><literal type="number">157</literal></expr><operator>,</operator><expr><literal type="number">19</literal> @@ <specifier>public</specifier> <name>class</name> <name>_TestUtil</name> <block>{
     <return>return <expr><name>start</name> <operator>+</operator> <call><name><name>r</name><operator>.</operator><name>nextInt</name></name><argument_list>(<argument><expr><name>end</name><operator>-</operator><name>start</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
   }</block></expr></expr_stmt>
 
  <function><type><specifier>public</specifier> <specifier>static</specifier> <name>String</name></type> <name>randomSimpleString</name><parameter_list>(<parameter><decl><type><name>Random</name></type> <name>r</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>end</name> <init>= <expr><call><name><name>r</name><operator>.</operator><name>nextInt</name></name><argument_list>(<argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>end</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <comment type="line">// allow 0 length</comment>
      <return>return <expr><literal type="string">""</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <decl_stmt><decl><type><specifier>final</specifier> <name><name>char</name><index>[]</index></name></type> <name>buffer</name> <init>= <expr><operator>new</operator> <name><name>char</name><index>[<expr><name>end</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>end</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
      <expr_stmt><expr><name><name>buffer</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator> <call><name><name>_TestUtil</name><operator>.</operator><name>nextInt</name></name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><literal type="number">97</literal></expr></argument>, <argument><expr><literal type="number">102</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <return>return <expr><operator>new</operator> <call><name>String</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></function>

   <comment type="block" format="javadoc">/** Returns random string, including full unicode range. */</comment>
   <function><type><specifier>public</specifier> <specifier>static</specifier> <name>String</name></type> <name>randomUnicodeString</name><parameter_list>(<parameter><decl><type><name>Random</name></type> <name>r</name></decl></parameter>)</parameter_list> <block>{<block_content>
     <return>return <expr><call><name>randomUnicodeString</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><literal type="number">20</literal></expr></argument>)</argument_list></call></expr>;</return>
<expr_stmt><expr><name>diff</name> <operator>--</operator><name>git</name> <name>a</name><operator>/</operator><name>lucene</name><operator>/</operator><name>src</name><operator>/</operator><name>test</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>index</name><operator>/</operator><name><name>TestDocTermOrds</name><operator>.</operator><name>java</name></name> <name>b</name><operator>/</operator><name>lucene</name><operator>/</operator><name>src</name><operator>/</operator><name>test</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>index</name><operator>/</operator><name><name>TestDocTermOrds</name><operator>.</operator><name>java</name></name>
<operator>new</operator> <name>file</name> <name>mode</name> <literal type="number">100644</literal>
<name>index</name> <literal type="number">00000000000..fc771770413</literal>
<operator>--</operator> <operator>/</operator><name>dev</name><operator>/</operator><literal type="null">null</literal>
<operator>++</operator> <name>b</name><operator>/</operator><name>lucene</name><operator>/</operator><name>src</name><operator>/</operator><name>test</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>index</name><operator>/</operator><name><name>TestDocTermOrds</name><operator>.</operator><name>java</name></name>
@@ <operator>-</operator><literal type="number">0</literal></expr><operator>,</operator><expr><literal type="number">0</literal> <operator>+</operator><literal type="number">1</literal></expr><operator>,</operator><expr><literal type="number">517</literal> @@</expr></expr_stmt>
<package>package <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>index</name></name>;</package>

<comment type="block" format="javadoc">/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</comment>

<import>import <name><name>java</name><operator>.</operator><name>io</name><operator>.</operator><name>IOException</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>Arrays</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>List</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>ArrayList</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>HashSet</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>Set</name></name>;</import>

<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>analysis</name><operator>.</operator><name>MockAnalyzer</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>document</name><operator>.</operator><name>Document</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>document</name><operator>.</operator><name>Field</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>document</name><operator>.</operator><name>NumericField</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>index</name><operator>.</operator><name>DocTermOrds</name><operator>.</operator><name>TermOrdsIterator</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>index</name><operator>.</operator><name>codecs</name><operator>.</operator><name>BlockTermsReader</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>index</name><operator>.</operator><name>codecs</name><operator>.</operator><name>BlockTermsWriter</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>index</name><operator>.</operator><name>codecs</name><operator>.</operator><name>Codec</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>index</name><operator>.</operator><name>codecs</name><operator>.</operator><name>CoreCodecProvider</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>index</name><operator>.</operator><name>codecs</name><operator>.</operator><name>FieldsConsumer</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>index</name><operator>.</operator><name>codecs</name><operator>.</operator><name>FieldsProducer</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>index</name><operator>.</operator><name>codecs</name><operator>.</operator><name>FixedGapTermsIndexReader</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>index</name><operator>.</operator><name>codecs</name><operator>.</operator><name>FixedGapTermsIndexWriter</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>index</name><operator>.</operator><name>codecs</name><operator>.</operator><name>PostingsReaderBase</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>index</name><operator>.</operator><name>codecs</name><operator>.</operator><name>PostingsWriterBase</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>index</name><operator>.</operator><name>codecs</name><operator>.</operator><name>TermsIndexReaderBase</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>index</name><operator>.</operator><name>codecs</name><operator>.</operator><name>TermsIndexWriterBase</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>index</name><operator>.</operator><name>codecs</name><operator>.</operator><name>standard</name><operator>.</operator><name>StandardPostingsReader</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>index</name><operator>.</operator><name>codecs</name><operator>.</operator><name>standard</name><operator>.</operator><name>StandardPostingsWriter</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>search</name><operator>.</operator><name>FieldCache</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>store</name><operator>.</operator><name>Directory</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>store</name><operator>.</operator><name>MockDirectoryWrapper</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>util</name><operator>.</operator><name>BytesRef</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>util</name><operator>.</operator><name>LuceneTestCase</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>util</name><operator>.</operator><name>_TestUtil</name></name>;</import>

<comment type="line">// TODO:</comment>
<comment type="line">//   - test w/ del docs</comment>
<comment type="line">//   - test prefix</comment>
<comment type="line">//   - test w/ cutoff</comment>
<comment type="line">//   - crank docs way up so we get some merging sometimes</comment>

<class><specifier>public</specifier> class <name>TestDocTermOrds</name> <super_list><extends>extends <super><name>LuceneTestCase</name></super></extends></super_list> <block>{

  <function><type><specifier>public</specifier> <name>void</name></type> <name>testSimple</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>Exception</name></expr></argument></throws> <block>{<block_content>
    <decl_stmt><decl><type><name>Directory</name></type> <name>dir</name> <init>= <expr><call><name>newDirectory</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>final</specifier> <name>RandomIndexWriter</name></type> <name>w</name> <init>= <expr><operator>new</operator> <call><name>RandomIndexWriter</name><argument_list>(<argument><expr><name>random</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>, <argument><expr><call><name>newIndexWriterConfig</name><argument_list>(<argument><expr><name>TEST_VERSION_CURRENT</name></expr></argument>, <argument><expr><operator>new</operator> <call><name>MockAnalyzer</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>.</operator><call><name>setMergePolicy</name><argument_list>(<argument><expr><call><name>newInOrderLogMergePolicy</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Document</name></type> <name>doc</name> <init>= <expr><operator>new</operator> <call><name>Document</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Field</name></type> <name>field</name> <init>= <expr><call><name>newField</name><argument_list>(<argument><expr><literal type="string">"field"</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><name><name>Field</name><operator>.</operator><name>Index</name><operator>.</operator><name>ANALYZED</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>doc</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name>field</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>field</name><operator>.</operator><name>setValue</name></name><argument_list>(<argument><expr><literal type="string">"a b c"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>w</name><operator>.</operator><name>addDocument</name></name><argument_list>(<argument><expr><name>doc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name><name>field</name><operator>.</operator><name>setValue</name></name><argument_list>(<argument><expr><literal type="string">"d e f"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>w</name><operator>.</operator><name>addDocument</name></name><argument_list>(<argument><expr><name>doc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name><name>field</name><operator>.</operator><name>setValue</name></name><argument_list>(<argument><expr><literal type="string">"a f"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>w</name><operator>.</operator><name>addDocument</name></name><argument_list>(<argument><expr><name>doc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <decl_stmt><decl><type><specifier>final</specifier> <name>IndexReader</name></type> <name>r</name> <init>= <expr><call><name><name>w</name><operator>.</operator><name>getReader</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>w</name><operator>.</operator><name>close</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><specifier>final</specifier> <name>DocTermOrds</name></type> <name>dto</name> <init>= <expr><operator>new</operator> <call><name>DocTermOrds</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><literal type="string">"field"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>TermOrdsIterator</name></type> <name>iter</name> <init>= <expr><call><name><name>dto</name><operator>.</operator><name>lookup</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="null">null</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>final</specifier> <name><name>int</name><index>[]</index></name></type> <name>buffer</name> <init>= <expr><operator>new</operator> <name><name>int</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><call><name><name>iter</name><operator>.</operator><name>read</name></name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>buffer</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>buffer</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name><name>buffer</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>iter</name> <operator>=</operator> <call><name><name>dto</name><operator>.</operator><name>lookup</name></name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>iter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><call><name><name>iter</name><operator>.</operator><name>read</name></name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name><name>buffer</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name><name>buffer</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><name><name>buffer</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>iter</name> <operator>=</operator> <call><name><name>dto</name><operator>.</operator><name>lookup</name></name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>iter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><call><name><name>iter</name><operator>.</operator><name>read</name></name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>buffer</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><name><name>buffer</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name><name>r</name><operator>.</operator><name>close</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>dir</name><operator>.</operator><name>close</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></function>

  <class><specifier>private</specifier> <specifier>static</specifier> class <name>StandardCodecWithOrds</name> <super_list><extends>extends <super><name>Codec</name></super></extends></super_list> <block>{
    <constructor><specifier>public</specifier> <name>StandardCodecWithOrds</name><parameter_list>()</parameter_list> <block>{<block_content>
      <expr_stmt><expr><name>name</name> <operator>=</operator> <literal type="string">"StandardOrds"</literal></expr>;</expr_stmt>
    </block_content>}</block></constructor>

    <function><annotation>@<name>Override</name></annotation>
    <type><specifier>public</specifier> <name>FieldsConsumer</name></type> <name>fieldsConsumer</name><parameter_list>(<parameter><decl><type><name>SegmentWriteState</name></type> <name>state</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws> <block>{<block_content>
      <decl_stmt><decl><type><name>PostingsWriterBase</name></type> <name>docs</name> <init>= <expr><operator>new</operator> <call><name>StandardPostingsWriter</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

      <comment type="line">// TODO: should we make the terms index more easily</comment>
      <comment type="line">// pluggable?  Ie so that this codec would record which</comment>
      <comment type="line">// index impl was used, and switch on loading?</comment>
      <comment type="line">// Or... you must make a new Codec for this?</comment>
      <decl_stmt><decl><type><name>TermsIndexWriterBase</name></type> <name>indexWriter</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>boolean</name></type> <name>success</name> <init>= <expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt>
      <try>try <block>{<block_content>
        <expr_stmt><expr><name>indexWriter</name> <operator>=</operator> <operator>new</operator> <call><name>FixedGapTermsIndexWriter</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>success</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
      </block_content>}</block> <finally>finally <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>success</name></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><call><name><name>docs</name><operator>.</operator><name>close</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></finally></try>

      <expr_stmt><expr><name>success</name> <operator>=</operator> <literal type="boolean">false</literal></expr>;</expr_stmt>
      <try>try <block>{<block_content>
        <decl_stmt><decl><type><name>FieldsConsumer</name></type> <name>ret</name> <init>= <expr><operator>new</operator> <call><name>BlockTermsWriter</name><argument_list>(<argument><expr><name>indexWriter</name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><name>docs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>success</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
        <return>return <expr><name>ret</name></expr>;</return>
      </block_content>}</block> <finally>finally <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>success</name></expr>)</condition> <block>{<block_content>
          <try>try <block>{<block_content>
            <expr_stmt><expr><call><name><name>docs</name><operator>.</operator><name>close</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block> <finally>finally <block>{<block_content>
            <expr_stmt><expr><call><name><name>indexWriter</name><operator>.</operator><name>close</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></finally></try>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></finally></try>
    </block_content>}</block></function>

    <decl_stmt><decl><type><specifier>public</specifier> <specifier>final</specifier> <specifier>static</specifier> <name>int</name></type> <name>TERMS_CACHE_SIZE</name> <init>= <expr><literal type="number">1024</literal></expr></init></decl>;</decl_stmt>

    <function><annotation>@<name>Override</name></annotation>
    <type><specifier>public</specifier> <name>FieldsProducer</name></type> <name>fieldsProducer</name><parameter_list>(<parameter><decl><type><name>SegmentReadState</name></type> <name>state</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws> <block>{<block_content>
      <decl_stmt><decl><type><name>PostingsReaderBase</name></type> <name>postings</name> <init>= <expr><operator>new</operator> <call><name>StandardPostingsReader</name><argument_list>(<argument><expr><name><name>state</name><operator>.</operator><name>dir</name></name></expr></argument>, <argument><expr><name><name>state</name><operator>.</operator><name>segmentInfo</name></name></expr></argument>, <argument><expr><name><name>state</name><operator>.</operator><name>readBufferSize</name></name></expr></argument>, <argument><expr><name><name>state</name><operator>.</operator><name>codecId</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>TermsIndexReaderBase</name></type> <name>indexReader</name></decl>;</decl_stmt>

      <decl_stmt><decl><type><name>boolean</name></type> <name>success</name> <init>= <expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt>
      <try>try <block>{<block_content>
        <expr_stmt><expr><name>indexReader</name> <operator>=</operator> <operator>new</operator> <call><name>FixedGapTermsIndexReader</name><argument_list>(<argument><expr><name><name>state</name><operator>.</operator><name>dir</name></name></expr></argument>,
                                                   <argument><expr><name><name>state</name><operator>.</operator><name>fieldInfos</name></name></expr></argument>,
                                                   <argument><expr><name><name>state</name><operator>.</operator><name>segmentInfo</name><operator>.</operator><name>name</name></name></expr></argument>,
                                                   <argument><expr><name><name>state</name><operator>.</operator><name>termsIndexDivisor</name></name></expr></argument>,
                                                   <argument><expr><call><name><name>BytesRef</name><operator>.</operator><name>getUTF8SortedAsUnicodeComparator</name></name><argument_list>()</argument_list></call></expr></argument>,
                                                   <argument><expr><name><name>state</name><operator>.</operator><name>codecId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>success</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
      </block_content>}</block> <finally>finally <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>success</name></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><call><name><name>postings</name><operator>.</operator><name>close</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></finally></try>

      <expr_stmt><expr><name>success</name> <operator>=</operator> <literal type="boolean">false</literal></expr>;</expr_stmt>
      <try>try <block>{<block_content>
        <decl_stmt><decl><type><name>FieldsProducer</name></type> <name>ret</name> <init>= <expr><operator>new</operator> <call><name>BlockTermsReader</name><argument_list>(<argument><expr><name>indexReader</name></expr></argument>,
                                                  <argument><expr><name><name>state</name><operator>.</operator><name>dir</name></name></expr></argument>,
                                                  <argument><expr><name><name>state</name><operator>.</operator><name>fieldInfos</name></name></expr></argument>,
                                                  <argument><expr><name><name>state</name><operator>.</operator><name>segmentInfo</name><operator>.</operator><name>name</name></name></expr></argument>,
                                                  <argument><expr><name>postings</name></expr></argument>,
                                                  <argument><expr><name><name>state</name><operator>.</operator><name>readBufferSize</name></name></expr></argument>,
                                                  <argument><expr><name>TERMS_CACHE_SIZE</name></expr></argument>,
                                                  <argument><expr><name><name>state</name><operator>.</operator><name>codecId</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>success</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
        <return>return <expr><name>ret</name></expr>;</return>
      </block_content>}</block> <finally>finally <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>success</name></expr>)</condition> <block>{<block_content>
          <try>try <block>{<block_content>
            <expr_stmt><expr><call><name><name>postings</name><operator>.</operator><name>close</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block> <finally>finally <block>{<block_content>
            <expr_stmt><expr><call><name><name>indexReader</name><operator>.</operator><name>close</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></finally></try>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></finally></try>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/** Extension of freq postings file */</comment>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>final</specifier> <name>String</name></type> <name>FREQ_EXTENSION</name> <init>= <expr><literal type="string">"frq"</literal></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/** Extension of prox postings file */</comment>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>final</specifier> <name>String</name></type> <name>PROX_EXTENSION</name> <init>= <expr><literal type="string">"prx"</literal></expr></init></decl>;</decl_stmt>

    <function><annotation>@<name>Override</name></annotation>
    <type><specifier>public</specifier> <name>void</name></type> <name>files</name><parameter_list>(<parameter><decl><type><name>Directory</name></type> <name>dir</name></decl></parameter>, <parameter><decl><type><name>SegmentInfo</name></type> <name>segmentInfo</name></decl></parameter>, <parameter><decl><type><name>String</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><name><name>Set</name><argument_list type="generic">&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>files</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws> <block>{<block_content>
      <expr_stmt><expr><call><name><name>StandardPostingsReader</name><operator>.</operator><name>files</name></name><argument_list>(<argument><expr><name>dir</name></expr></argument>, <argument><expr><name>segmentInfo</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>files</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>BlockTermsReader</name><operator>.</operator><name>files</name></name><argument_list>(<argument><expr><name>dir</name></expr></argument>, <argument><expr><name>segmentInfo</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>files</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>FixedGapTermsIndexReader</name><operator>.</operator><name>files</name></name><argument_list>(<argument><expr><name>dir</name></expr></argument>, <argument><expr><name>segmentInfo</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>files</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><annotation>@<name>Override</name></annotation>
    <type><specifier>public</specifier> <name>void</name></type> <name>getExtensions</name><parameter_list>(<parameter><decl><type><name><name>Set</name><argument_list type="generic">&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>extensions</name></decl></parameter>)</parameter_list> <block>{<block_content>
      <expr_stmt><expr><call><name>getStandardExtensions</name><argument_list>(<argument><expr><name>extensions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>void</name></type> <name>getStandardExtensions</name><parameter_list>(<parameter><decl><type><name><name>Set</name><argument_list type="generic">&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>extensions</name></decl></parameter>)</parameter_list> <block>{<block_content>
      <expr_stmt><expr><call><name><name>extensions</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name>FREQ_EXTENSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>extensions</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name>PROX_EXTENSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>BlockTermsReader</name><operator>.</operator><name>getExtensions</name></name><argument_list>(<argument><expr><name>extensions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>FixedGapTermsIndexReader</name><operator>.</operator><name>getIndexExtensions</name></name><argument_list>(<argument><expr><name>extensions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>
  }</block></class>

  <function><type><specifier>public</specifier> <name>void</name></type> <name>testRandom</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>Exception</name></expr></argument></throws> <block>{<block_content>
    <decl_stmt><decl><type><name>MockDirectoryWrapper</name></type> <name>dir</name> <init>= <expr><call><name>newDirectory</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>NUM_TERMS</name> <init>= <expr><literal type="number">100</literal> <operator>*</operator> <name>RANDOM_MULTIPLIER</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>final</specifier> <name><name>Set</name><argument_list type="generic">&lt;<argument><name>BytesRef</name></argument>&gt;</argument_list></name></type> <name>terms</name> <init>= <expr><operator>new</operator> <call><name><name>HashSet</name><argument_list type="generic">&lt;<argument><name>BytesRef</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <while>while<condition>(<expr><call><name><name>terms</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&lt;</operator> <name>NUM_TERMS</name></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><specifier>final</specifier> <name>String</name></type> <name>s</name> <init>= <expr><call><name><name>_TestUtil</name><operator>.</operator><name>randomRealisticUnicodeString</name></name><argument_list>(<argument><expr><name>random</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <comment type="line">//final String s = _TestUtil.randomSimpleString(random);</comment>
      <if_stmt><if>if <condition>(<expr><call><name><name>s</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name><name>terms</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><operator>new</operator> <call><name>BytesRef</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>
    <decl_stmt><decl><type><specifier>final</specifier> <name><name>BytesRef</name><index>[]</index></name></type> <name>termsArray</name> <init>= <expr><call><name><name>terms</name><operator>.</operator><name>toArray</name></name><argument_list>(<argument><expr><operator>new</operator> <name><name>BytesRef</name><index>[<expr><call><name><name>terms</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>Arrays</name><operator>.</operator><name>sort</name></name><argument_list>(<argument><expr><name>termsArray</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>NUM_DOCS</name> <init>= <expr><literal type="number">1000</literal> <operator>*</operator> <name>RANDOM_MULTIPLIER</name></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>IndexWriterConfig</name></type> <name>conf</name> <init>= <expr><call><name>newIndexWriterConfig</name><argument_list>(<argument><expr><name>TEST_VERSION_CURRENT</name></expr></argument>, <argument><expr><operator>new</operator> <call><name>MockAnalyzer</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="line">// Sometimes swap in codec that impls ord():</comment>
    <if_stmt><if>if <condition>(<expr><call><name><name>random</name><operator>.</operator><name>nextInt</name></name><argument_list>(<argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">7</literal></expr>)</condition> <block>{<block_content>
      <comment type="line">// Make sure terms index has ords:</comment>
      <decl_stmt><decl><type><name>CoreCodecProvider</name></type> <name>cp</name> <init>= <expr><operator>new</operator> <call><name>CoreCodecProvider</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name><name>cp</name><operator>.</operator><name>register</name></name><argument_list>(<argument><expr><operator>new</operator> <call><name>StandardCodecWithOrds</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>cp</name><operator>.</operator><name>setDefaultFieldCodec</name></name><argument_list>(<argument><expr><literal type="string">"StandardOrds"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="line">// So checkIndex on close works</comment>
      <expr_stmt><expr><call><name><name>dir</name><operator>.</operator><name>setCodecProvider</name></name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>conf</name><operator>.</operator><name>setCodecProvider</name></name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    
    <decl_stmt><decl><type><specifier>final</specifier> <name>RandomIndexWriter</name></type> <name>w</name> <init>= <expr><operator>new</operator> <call><name>RandomIndexWriter</name><argument_list>(<argument><expr><name>random</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>, <argument><expr><name>conf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>final</specifier> <name><name>int</name><index>[]</index><index>[]</index></name></type> <name>idToOrds</name> <init>= <expr><operator>new</operator> <name><name>int</name><index>[<expr><name>NUM_DOCS</name></expr>]</index><index>[]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>final</specifier> <name><name>Set</name><argument_list type="generic">&lt;<argument><name>Integer</name></argument>&gt;</argument_list></name></type> <name>ordsForDocSet</name> <init>= <expr><operator>new</operator> <call><name><name>HashSet</name><argument_list type="generic">&lt;<argument><name>Integer</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <for>for<control>(<init><decl><type><name>int</name></type> <name>id</name><init>=<expr><literal type="number">0</literal></expr></init></decl>;</init><condition><expr><name>id</name><operator>&lt;</operator><name>NUM_DOCS</name></expr>;</condition><incr><expr><name>id</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
      <decl_stmt><decl><type><name>Document</name></type> <name>doc</name> <init>= <expr><operator>new</operator> <call><name>Document</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

      <decl_stmt><decl><type><name>NumericField</name></type> <name>idField</name> <init>= <expr><operator>new</operator> <call><name>NumericField</name><argument_list>(<argument><expr><literal type="string">"id"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name><name>doc</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><call><name><name>idField</name><operator>.</operator><name>setIntValue</name></name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      
      <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>termCount</name> <init>= <expr><call><name><name>_TestUtil</name><operator>.</operator><name>nextInt</name></name><argument_list>(<argument><expr><name>random</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">20</literal><operator>*</operator><name>RANDOM_MULTIPLIER</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <while>while<condition>(<expr><call><name><name>ordsForDocSet</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&lt;</operator> <name>termCount</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name><name>ordsForDocSet</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><call><name><name>random</name><operator>.</operator><name>nextInt</name></name><argument_list>(<argument><expr><name><name>termsArray</name><operator>.</operator><name>length</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></while>
      <decl_stmt><decl><type><specifier>final</specifier> <name><name>int</name><index>[]</index></name></type> <name>ordsForDoc</name> <init>= <expr><operator>new</operator> <name><name>int</name><index>[<expr><name>termCount</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>upto</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><name>VERBOSE</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name><name>System</name><operator>.</operator><name>out</name><operator>.</operator><name>println</name></name><argument_list>(<argument><expr><literal type="string">"TEST: doc id="</literal> <operator>+</operator> <name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <for>for<control>(<init><decl><type><name>int</name></type> <name>ord</name> <range>: <expr><name>ordsForDocSet</name></expr></range></decl></init>)</control> <block>{<block_content>
        <expr_stmt><expr><name><name>ordsForDoc</name><index>[<expr><name>upto</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>ord</name></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>Field</name></type> <name>field</name> <init>= <expr><call><name>newField</name><argument_list>(<argument><expr><literal type="string">"field"</literal></expr></argument>, <argument><expr><name><name>termsArray</name><index>[<expr><name>ord</name></expr>]</index></name><operator>.</operator><call><name>utf8ToString</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>Field</name><operator>.</operator><name>Index</name><operator>.</operator><name>NOT_ANALYZED</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>VERBOSE</name></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><call><name><name>System</name><operator>.</operator><name>out</name><operator>.</operator><name>println</name></name><argument_list>(<argument><expr><literal type="string">"  f="</literal> <operator>+</operator> <name><name>termsArray</name><index>[<expr><name>ord</name></expr>]</index></name><operator>.</operator><call><name>utf8ToString</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name><name>doc</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name>field</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
      <expr_stmt><expr><call><name><name>ordsForDocSet</name><operator>.</operator><name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>Arrays</name><operator>.</operator><name>sort</name></name><argument_list>(<argument><expr><name>ordsForDoc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>idToOrds</name><index>[<expr><name>id</name></expr>]</index></name> <operator>=</operator> <name>ordsForDoc</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>w</name><operator>.</operator><name>addDocument</name></name><argument_list>(<argument><expr><name>doc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    
    <decl_stmt><decl><type><specifier>final</specifier> <name>IndexReader</name></type> <name>r</name> <init>= <expr><call><name><name>w</name><operator>.</operator><name>getReader</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>w</name><operator>.</operator><name>close</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>VERBOSE</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name><name>System</name><operator>.</operator><name>out</name><operator>.</operator><name>println</name></name><argument_list>(<argument><expr><literal type="string">"TEST: reader="</literal> <operator>+</operator> <name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <for>for<control>(<init><decl><type><name>IndexReader</name></type> <name>subR</name> <range>: <expr><call><name><name>r</name><operator>.</operator><name>getSequentialSubReaders</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>VERBOSE</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name><name>System</name><operator>.</operator><name>out</name><operator>.</operator><name>println</name></name><argument_list>(<argument><expr><literal type="string">"\nTEST: sub="</literal> <operator>+</operator> <name>subR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>verify</name><argument_list>(<argument><expr><name>subR</name></expr></argument>, <argument><expr><name>idToOrds</name></expr></argument>, <argument><expr><name>termsArray</name></expr></argument>, <argument><expr><literal type="null">null</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="line">// Also test top-level reader: its enum does not support</comment>
    <comment type="line">// ord, so this forces the OrdWrapper to run:</comment>
    <if_stmt><if>if <condition>(<expr><name>VERBOSE</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name><name>System</name><operator>.</operator><name>out</name><operator>.</operator><name>println</name></name><argument_list>(<argument><expr><literal type="string">"TEST: top reader"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>verify</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>idToOrds</name></expr></argument>, <argument><expr><name>termsArray</name></expr></argument>, <argument><expr><literal type="null">null</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name><name>FieldCache</name><operator>.</operator><name>DEFAULT</name><operator>.</operator><name>purge</name></name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name><name>r</name><operator>.</operator><name>close</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>dir</name><operator>.</operator><name>close</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></function>

  <function><type><specifier>public</specifier> <name>void</name></type> <name>testRandomWithPrefix</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>Exception</name></expr></argument></throws> <block>{<block_content>
    <decl_stmt><decl><type><name>MockDirectoryWrapper</name></type> <name>dir</name> <init>= <expr><call><name>newDirectory</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>final</specifier> <name><name>Set</name><argument_list type="generic">&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>prefixes</name> <init>= <expr><operator>new</operator> <call><name><name>HashSet</name><argument_list type="generic">&lt;<argument><name>String</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>numPrefix</name> <init>= <expr><call><name><name>_TestUtil</name><operator>.</operator><name>nextInt</name></name><argument_list>(<argument><expr><name>random</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>VERBOSE</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name><name>System</name><operator>.</operator><name>out</name><operator>.</operator><name>println</name></name><argument_list>(<argument><expr><literal type="string">"TEST: use "</literal> <operator>+</operator> <name>numPrefix</name> <operator>+</operator> <literal type="string">" prefixes"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <while>while<condition>(<expr><call><name><name>prefixes</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&lt;</operator> <name>numPrefix</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name><name>prefixes</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><call><name><name>_TestUtil</name><operator>.</operator><name>randomRealisticUnicodeString</name></name><argument_list>(<argument><expr><name>random</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <comment type="line">//prefixes.add(_TestUtil.randomSimpleString(random));</comment>
    </block_content>}</block></while>
    <decl_stmt><decl><type><specifier>final</specifier> <name><name>String</name><index>[]</index></name></type> <name>prefixesArray</name> <init>= <expr><call><name><name>prefixes</name><operator>.</operator><name>toArray</name></name><argument_list>(<argument><expr><operator>new</operator> <name><name>String</name><index>[<expr><call><name><name>prefixes</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>NUM_TERMS</name> <init>= <expr><literal type="number">100</literal> <operator>*</operator> <name>RANDOM_MULTIPLIER</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>final</specifier> <name><name>Set</name><argument_list type="generic">&lt;<argument><name>BytesRef</name></argument>&gt;</argument_list></name></type> <name>terms</name> <init>= <expr><operator>new</operator> <call><name><name>HashSet</name><argument_list type="generic">&lt;<argument><name>BytesRef</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <while>while<condition>(<expr><call><name><name>terms</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&lt;</operator> <name>NUM_TERMS</name></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><specifier>final</specifier> <name>String</name></type> <name>s</name> <init>= <expr><name><name>prefixesArray</name><index>[<expr><call><name><name>random</name><operator>.</operator><name>nextInt</name></name><argument_list>(<argument><expr><name><name>prefixesArray</name><operator>.</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>+</operator> <call><name><name>_TestUtil</name><operator>.</operator><name>randomRealisticUnicodeString</name></name><argument_list>(<argument><expr><name>random</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <comment type="line">//final String s = prefixesArray[random.nextInt(prefixesArray.length)] + _TestUtil.randomSimpleString(random);</comment>
      <if_stmt><if>if <condition>(<expr><call><name><name>s</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name><name>terms</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><operator>new</operator> <call><name>BytesRef</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>
    <decl_stmt><decl><type><specifier>final</specifier> <name><name>BytesRef</name><index>[]</index></name></type> <name>termsArray</name> <init>= <expr><call><name><name>terms</name><operator>.</operator><name>toArray</name></name><argument_list>(<argument><expr><operator>new</operator> <name><name>BytesRef</name><index>[<expr><call><name><name>terms</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>Arrays</name><operator>.</operator><name>sort</name></name><argument_list>(<argument><expr><name>termsArray</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>NUM_DOCS</name> <init>= <expr><literal type="number">1000</literal> <operator>*</operator> <name>RANDOM_MULTIPLIER</name></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>IndexWriterConfig</name></type> <name>conf</name> <init>= <expr><call><name>newIndexWriterConfig</name><argument_list>(<argument><expr><name>TEST_VERSION_CURRENT</name></expr></argument>, <argument><expr><operator>new</operator> <call><name>MockAnalyzer</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="line">// Sometimes swap in codec that impls ord():</comment>
    <if_stmt><if>if <condition>(<expr><call><name><name>random</name><operator>.</operator><name>nextInt</name></name><argument_list>(<argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">7</literal></expr>)</condition> <block>{<block_content>
      <comment type="line">// Make sure terms index has ords:</comment>
      <decl_stmt><decl><type><name>CoreCodecProvider</name></type> <name>cp</name> <init>= <expr><operator>new</operator> <call><name>CoreCodecProvider</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name><name>cp</name><operator>.</operator><name>register</name></name><argument_list>(<argument><expr><operator>new</operator> <call><name>StandardCodecWithOrds</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>cp</name><operator>.</operator><name>setDefaultFieldCodec</name></name><argument_list>(<argument><expr><literal type="string">"StandardOrds"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="line">// So checkIndex on close works</comment>
      <expr_stmt><expr><call><name><name>dir</name><operator>.</operator><name>setCodecProvider</name></name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>conf</name><operator>.</operator><name>setCodecProvider</name></name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    
    <decl_stmt><decl><type><specifier>final</specifier> <name>RandomIndexWriter</name></type> <name>w</name> <init>= <expr><operator>new</operator> <call><name>RandomIndexWriter</name><argument_list>(<argument><expr><name>random</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>, <argument><expr><name>conf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>final</specifier> <name><name>int</name><index>[]</index><index>[]</index></name></type> <name>idToOrds</name> <init>= <expr><operator>new</operator> <name><name>int</name><index>[<expr><name>NUM_DOCS</name></expr>]</index><index>[]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>final</specifier> <name><name>Set</name><argument_list type="generic">&lt;<argument><name>Integer</name></argument>&gt;</argument_list></name></type> <name>ordsForDocSet</name> <init>= <expr><operator>new</operator> <call><name><name>HashSet</name><argument_list type="generic">&lt;<argument><name>Integer</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <for>for<control>(<init><decl><type><name>int</name></type> <name>id</name><init>=<expr><literal type="number">0</literal></expr></init></decl>;</init><condition><expr><name>id</name><operator>&lt;</operator><name>NUM_DOCS</name></expr>;</condition><incr><expr><name>id</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
      <decl_stmt><decl><type><name>Document</name></type> <name>doc</name> <init>= <expr><operator>new</operator> <call><name>Document</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

      <decl_stmt><decl><type><name>NumericField</name></type> <name>idField</name> <init>= <expr><operator>new</operator> <call><name>NumericField</name><argument_list>(<argument><expr><literal type="string">"id"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name><name>doc</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><call><name><name>idField</name><operator>.</operator><name>setIntValue</name></name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      
      <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>termCount</name> <init>= <expr><call><name><name>_TestUtil</name><operator>.</operator><name>nextInt</name></name><argument_list>(<argument><expr><name>random</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">20</literal><operator>*</operator><name>RANDOM_MULTIPLIER</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <while>while<condition>(<expr><call><name><name>ordsForDocSet</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&lt;</operator> <name>termCount</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name><name>ordsForDocSet</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><call><name><name>random</name><operator>.</operator><name>nextInt</name></name><argument_list>(<argument><expr><name><name>termsArray</name><operator>.</operator><name>length</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></while>
      <decl_stmt><decl><type><specifier>final</specifier> <name><name>int</name><index>[]</index></name></type> <name>ordsForDoc</name> <init>= <expr><operator>new</operator> <name><name>int</name><index>[<expr><name>termCount</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>upto</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><name>VERBOSE</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name><name>System</name><operator>.</operator><name>out</name><operator>.</operator><name>println</name></name><argument_list>(<argument><expr><literal type="string">"TEST: doc id="</literal> <operator>+</operator> <name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <for>for<control>(<init><decl><type><name>int</name></type> <name>ord</name> <range>: <expr><name>ordsForDocSet</name></expr></range></decl></init>)</control> <block>{<block_content>
        <expr_stmt><expr><name><name>ordsForDoc</name><index>[<expr><name>upto</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>ord</name></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>Field</name></type> <name>field</name> <init>= <expr><call><name>newField</name><argument_list>(<argument><expr><literal type="string">"field"</literal></expr></argument>, <argument><expr><name><name>termsArray</name><index>[<expr><name>ord</name></expr>]</index></name><operator>.</operator><call><name>utf8ToString</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>Field</name><operator>.</operator><name>Index</name><operator>.</operator><name>NOT_ANALYZED</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>VERBOSE</name></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><call><name><name>System</name><operator>.</operator><name>out</name><operator>.</operator><name>println</name></name><argument_list>(<argument><expr><literal type="string">"  f="</literal> <operator>+</operator> <name><name>termsArray</name><index>[<expr><name>ord</name></expr>]</index></name><operator>.</operator><call><name>utf8ToString</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name><name>doc</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name>field</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
      <expr_stmt><expr><call><name><name>ordsForDocSet</name><operator>.</operator><name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>Arrays</name><operator>.</operator><name>sort</name></name><argument_list>(<argument><expr><name>ordsForDoc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>idToOrds</name><index>[<expr><name>id</name></expr>]</index></name> <operator>=</operator> <name>ordsForDoc</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>w</name><operator>.</operator><name>addDocument</name></name><argument_list>(<argument><expr><name>doc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    
    <decl_stmt><decl><type><specifier>final</specifier> <name>IndexReader</name></type> <name>r</name> <init>= <expr><call><name><name>w</name><operator>.</operator><name>getReader</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>w</name><operator>.</operator><name>close</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>VERBOSE</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name><name>System</name><operator>.</operator><name>out</name><operator>.</operator><name>println</name></name><argument_list>(<argument><expr><literal type="string">"TEST: reader="</literal> <operator>+</operator> <name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    
    <for>for<control>(<init><decl><type><name>String</name></type> <name>prefix</name> <range>: <expr><name>prefixesArray</name></expr></range></decl></init>)</control> <block>{<block_content>

      <decl_stmt><decl><type><specifier>final</specifier> <name>BytesRef</name></type> <name>prefixRef</name> <init>= <expr><ternary><condition><expr><name>prefix</name> <operator>==</operator> <literal type="null">null</literal></expr> ?</condition><then> <expr><literal type="null">null</literal></expr> </then><else>: <expr><operator>new</operator> <call><name>BytesRef</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>

      <decl_stmt><decl><type><specifier>final</specifier> <name><name>int</name><index>[]</index><index>[]</index></name></type> <name>idToOrdsPrefix</name> <init>= <expr><operator>new</operator> <name><name>int</name><index>[<expr><name>NUM_DOCS</name></expr>]</index><index>[]</index></name></expr></init></decl>;</decl_stmt>
      <for>for<control>(<init><decl><type><name>int</name></type> <name>id</name><init>=<expr><literal type="number">0</literal></expr></init></decl>;</init><condition><expr><name>id</name><operator>&lt;</operator><name>NUM_DOCS</name></expr>;</condition><incr><expr><name>id</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><specifier>final</specifier> <name><name>int</name><index>[]</index></name></type> <name>docOrds</name> <init>= <expr><name><name>idToOrds</name><index>[<expr><name>id</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name><name>List</name><argument_list type="generic">&lt;<argument><name>Integer</name></argument>&gt;</argument_list></name></type> <name>newOrds</name> <init>= <expr><operator>new</operator> <call><name><name>ArrayList</name><argument_list type="generic">&lt;<argument><name>Integer</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for<control>(<init><decl><type><name>int</name></type> <name>ord</name> <range>: <expr><name><name>idToOrds</name><index>[<expr><name>id</name></expr>]</index></name></expr></range></decl></init>)</control> <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><name><name>termsArray</name><index>[<expr><name>ord</name></expr>]</index></name><operator>.</operator><call><name>startsWith</name><argument_list>(<argument><expr><name>prefixRef</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name><name>newOrds</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name>ord</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
        <decl_stmt><decl><type><specifier>final</specifier> <name><name>int</name><index>[]</index></name></type> <name>newOrdsArray</name> <init>= <expr><operator>new</operator> <name><name>int</name><index>[<expr><call><name><name>newOrds</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>upto</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <for>for<control>(<init><decl><type><name>int</name></type> <name>ord</name> <range>: <expr><name>newOrds</name></expr></range></decl></init>)</control> <block>{<block_content>
          <expr_stmt><expr><name><name>newOrdsArray</name><index>[<expr><name>upto</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>ord</name></expr>;</expr_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><name><name>idToOrdsPrefix</name><index>[<expr><name>id</name></expr>]</index></name> <operator>=</operator> <name>newOrdsArray</name></expr>;</expr_stmt>
      </block_content>}</block></for>

      <for>for<control>(<init><decl><type><name>IndexReader</name></type> <name>subR</name> <range>: <expr><call><name><name>r</name><operator>.</operator><name>getSequentialSubReaders</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>VERBOSE</name></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><call><name><name>System</name><operator>.</operator><name>out</name><operator>.</operator><name>println</name></name><argument_list>(<argument><expr><literal type="string">"\nTEST: sub="</literal> <operator>+</operator> <name>subR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>verify</name><argument_list>(<argument><expr><name>subR</name></expr></argument>, <argument><expr><name>idToOrdsPrefix</name></expr></argument>, <argument><expr><name>termsArray</name></expr></argument>, <argument><expr><name>prefixRef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>

      <comment type="line">// Also test top-level reader: its enum does not support</comment>
      <comment type="line">// ord, so this forces the OrdWrapper to run:</comment>
      <if_stmt><if>if <condition>(<expr><name>VERBOSE</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name><name>System</name><operator>.</operator><name>out</name><operator>.</operator><name>println</name></name><argument_list>(<argument><expr><literal type="string">"TEST: top reader"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>verify</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>idToOrdsPrefix</name></expr></argument>, <argument><expr><name>termsArray</name></expr></argument>, <argument><expr><name>prefixRef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name><name>FieldCache</name><operator>.</operator><name>DEFAULT</name><operator>.</operator><name>purge</name></name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name><name>r</name><operator>.</operator><name>close</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>dir</name><operator>.</operator><name>close</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></function>

  <function><type><specifier>private</specifier> <name>void</name></type> <name>verify</name><parameter_list>(<parameter><decl><type><name>IndexReader</name></type> <name>r</name></decl></parameter>, <parameter><decl><type><name><name>int</name><index>[]</index><index>[]</index></name></type> <name>idToOrds</name></decl></parameter>, <parameter><decl><type><name><name>BytesRef</name><index>[]</index></name></type> <name>termsArray</name></decl></parameter>, <parameter><decl><type><name>BytesRef</name></type> <name>prefixRef</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>Exception</name></expr></argument></throws> <block>{<block_content>

    <decl_stmt><decl><type><specifier>final</specifier> <name>DocTermOrds</name></type> <name>dto</name> <init>= <expr><operator>new</operator> <call><name>DocTermOrds</name><argument_list>(<argument><expr><name>r</name></expr></argument>,
                                            <argument><expr><literal type="string">"field"</literal></expr></argument>,
                                            <argument><expr><name>prefixRef</name></expr></argument>,
                                            <argument><expr><name><name>Integer</name><operator>.</operator><name>MAX_VALUE</name></name></expr></argument>,
                                            <argument><expr><call><name><name>_TestUtil</name><operator>.</operator><name>nextInt</name></name><argument_list>(<argument><expr><name>random</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                                            

    <decl_stmt><decl><type><specifier>final</specifier> <name><name>int</name><index>[]</index></name></type> <name>docIDToID</name> <init>= <expr><call><name><name>FieldCache</name><operator>.</operator><name>DEFAULT</name><operator>.</operator><name>getInts</name></name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><literal type="string">"id"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <comment type="block">/*
      for(int docID=0;docID&lt;subR.maxDoc();docID++) {
      System.out.println("  docID=" + docID + " id=" + docIDToID[docID]);
      }
    */</comment>

    <if_stmt><if>if <condition>(<expr><name>VERBOSE</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name><name>System</name><operator>.</operator><name>out</name><operator>.</operator><name>println</name></name><argument_list>(<argument><expr><literal type="string">"TEST: verify prefix="</literal> <operator>+</operator> <call><name><name>prefixRef</name><operator>.</operator><name>utf8ToString</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>System</name><operator>.</operator><name>out</name><operator>.</operator><name>println</name></name><argument_list>(<argument><expr><literal type="string">"TEST: all TERMS:"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <decl_stmt><decl><type><name>TermsEnum</name></type> <name>allTE</name> <init>= <expr><call><name><name>MultiFields</name><operator>.</operator><name>getTerms</name></name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><literal type="string">"field"</literal></expr></argument>)</argument_list></call><operator>.</operator><call><name>iterator</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>ord</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <while>while<condition>(<expr><call><name><name>allTE</name><operator>.</operator><name>next</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name><name>System</name><operator>.</operator><name>out</name><operator>.</operator><name>println</name></name><argument_list>(<argument><expr><literal type="string">"  ord="</literal> <operator>+</operator> <operator>(</operator><name>ord</name><operator>++</operator><operator>)</operator> <operator>+</operator> <literal type="string">" term="</literal> <operator>+</operator> <call><name><name>allTE</name><operator>.</operator><name>term</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>utf8ToString</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></while>
    </block_content>}</block></if></if_stmt>

    <comment type="line">//final TermsEnum te = subR.fields().terms("field").iterator();</comment>
    <decl_stmt><decl><type><specifier>final</specifier> <name>TermsEnum</name></type> <name>te</name> <init>= <expr><call><name><name>dto</name><operator>.</operator><name>getOrdTermsEnum</name></name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>te</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>prefixRef</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>assertNull</name><argument_list>(<argument><expr><call><name><name>r</name><operator>.</operator><name>fields</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>terms</name><argument_list>(<argument><expr><literal type="string">"field"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if> <else>else <block>{<block_content>
        <decl_stmt><decl><type><name>Terms</name></type> <name>terms</name> <init>= <expr><call><name><name>r</name><operator>.</operator><name>fields</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>terms</name><argument_list>(<argument><expr><literal type="string">"field"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>terms</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
          <decl_stmt><decl><type><name>TermsEnum</name></type> <name>termsEnum</name> <init>= <expr><call><name><name>terms</name><operator>.</operator><name>iterator</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><name><name>TermsEnum</name><operator>.</operator><name>SeekStatus</name></name></type> <name>result</name> <init>= <expr><call><name><name>termsEnum</name><operator>.</operator><name>seek</name></name><argument_list>(<argument><expr><name>prefixRef</name></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <if_stmt><if>if <condition>(<expr><name>result</name> <operator>!=</operator> <name><name>TermsEnum</name><operator>.</operator><name>SeekStatus</name><operator>.</operator><name>END</name></name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>assertFalse</name><argument_list>(<argument><expr><literal type="string">"term="</literal> <operator>+</operator> <call><name><name>termsEnum</name><operator>.</operator><name>term</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>utf8ToString</name><argument_list>()</argument_list></call> <operator>+</operator> <literal type="string">" matches prefix="</literal> <operator>+</operator> <call><name><name>prefixRef</name><operator>.</operator><name>utf8ToString</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>termsEnum</name><operator>.</operator><name>term</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>startsWith</name><argument_list>(<argument><expr><name>prefixRef</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if> <else>else <block>{<block_content>
            <comment type="line">// ok</comment>
          </block_content>}</block></else></if_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
          <comment type="line">// ok</comment>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></else></if_stmt>
      <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>VERBOSE</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name><name>System</name><operator>.</operator><name>out</name><operator>.</operator><name>println</name></name><argument_list>(<argument><expr><literal type="string">"TEST: TERMS:"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>te</name><operator>.</operator><name>seek</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <while>while<condition>(<expr><literal type="boolean">true</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name><name>System</name><operator>.</operator><name>out</name><operator>.</operator><name>println</name></name><argument_list>(<argument><expr><literal type="string">"  ord="</literal> <operator>+</operator> <call><name><name>te</name><operator>.</operator><name>ord</name></name><argument_list>()</argument_list></call> <operator>+</operator> <literal type="string">" term="</literal> <operator>+</operator> <call><name><name>te</name><operator>.</operator><name>term</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>utf8ToString</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name><name>te</name><operator>.</operator><name>next</name></name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
          <break>break;</break>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></while>
    </block_content>}</block></if></if_stmt>

    <decl_stmt><decl><type><name>TermOrdsIterator</name></type> <name>iter</name> <init>= <expr><literal type="null">null</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>final</specifier> <name><name>int</name><index>[]</index></name></type> <name>buffer</name> <init>= <expr><operator>new</operator> <name><name>int</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <for>for<control>(<init><decl><type><name>int</name></type> <name>docID</name><init>=<expr><literal type="number">0</literal></expr></init></decl>;</init><condition><expr><name>docID</name><operator>&lt;</operator><call><name><name>r</name><operator>.</operator><name>maxDoc</name></name><argument_list>()</argument_list></call></expr>;</condition><incr><expr><name>docID</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>VERBOSE</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name><name>System</name><operator>.</operator><name>out</name><operator>.</operator><name>println</name></name><argument_list>(<argument><expr><literal type="string">"TEST: docID="</literal> <operator>+</operator> <name>docID</name> <operator>+</operator> <literal type="string">" of "</literal> <operator>+</operator> <call><name><name>r</name><operator>.</operator><name>maxDoc</name></name><argument_list>()</argument_list></call> <operator>+</operator> <literal type="string">" (id="</literal> <operator>+</operator> <name><name>docIDToID</name><index>[<expr><name>docID</name></expr>]</index></name> <operator>+</operator> <literal type="string">")"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>iter</name> <operator>=</operator> <call><name><name>dto</name><operator>.</operator><name>lookup</name></name><argument_list>(<argument><expr><name>docID</name></expr></argument>, <argument><expr><name>iter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <decl_stmt><decl><type><specifier>final</specifier> <name><name>int</name><index>[]</index></name></type> <name>answers</name> <init>= <expr><name><name>idToOrds</name><index>[<expr><name><name>docIDToID</name><index>[<expr><name>docID</name></expr>]</index></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>upto</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <while>while<condition>(<expr><literal type="boolean">true</literal></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>chunk</name> <init>= <expr><call><name><name>iter</name><operator>.</operator><name>read</name></name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for<control>(<init><decl><type><name>int</name></type> <name>idx</name><init>=<expr><literal type="number">0</literal></expr></init></decl>;</init><condition><expr><name>idx</name><operator>&lt;</operator><name>chunk</name></expr>;</condition><incr><expr><name>idx</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
          <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><name><name>TermsEnum</name><operator>.</operator><name>SeekStatus</name><operator>.</operator><name>FOUND</name></name></expr></argument>, <argument><expr><call><name><name>te</name><operator>.</operator><name>seek</name></name><argument_list>(<argument><expr><operator>(</operator><name>long</name><operator>)</operator> <name><name>buffer</name><index>[<expr><name>idx</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <decl_stmt><decl><type><specifier>final</specifier> <name>BytesRef</name></type> <name>expected</name> <init>= <expr><name><name>termsArray</name><index>[<expr><name><name>answers</name><index>[<expr><name>upto</name><operator>++</operator></expr>]</index></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
          <if_stmt><if>if <condition>(<expr><name>VERBOSE</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name><name>System</name><operator>.</operator><name>out</name><operator>.</operator><name>println</name></name><argument_list>(<argument><expr><literal type="string">"  exp="</literal> <operator>+</operator> <call><name><name>expected</name><operator>.</operator><name>utf8ToString</name></name><argument_list>()</argument_list></call> <operator>+</operator> <literal type="string">" actual="</literal> <operator>+</operator> <call><name><name>te</name><operator>.</operator><name>term</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>utf8ToString</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><literal type="string">"expected="</literal> <operator>+</operator> <call><name><name>expected</name><operator>.</operator><name>utf8ToString</name></name><argument_list>()</argument_list></call> <operator>+</operator> <literal type="string">" actual="</literal> <operator>+</operator> <call><name><name>te</name><operator>.</operator><name>term</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>utf8ToString</name><argument_list>()</argument_list></call> <operator>+</operator> <literal type="string">" ord="</literal> <operator>+</operator> <name><name>buffer</name><index>[<expr><name>idx</name></expr>]</index></name></expr></argument>, <argument><expr><name>expected</name></expr></argument>, <argument><expr><call><name><name>te</name><operator>.</operator><name>term</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
        
        <if_stmt><if>if <condition>(<expr><name>chunk</name> <operator>&lt;</operator> <name><name>buffer</name><operator>.</operator><name>length</name></name></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><name><name>answers</name><operator>.</operator><name>length</name></name></expr></argument>, <argument><expr><name>upto</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <break>break;</break>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></while>
    </block_content>}</block></for>
  </block_content>}</block></function>
}</block></class>
<expr_stmt><expr><name>diff</name> <operator>--</operator><name>git</name> <name>a</name><operator>/</operator><name>solr</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>request</name><operator>/</operator><name><name>UnInvertedField</name><operator>.</operator><name>java</name></name> <name>b</name><operator>/</operator><name>solr</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>request</name><operator>/</operator><name><name>UnInvertedField</name><operator>.</operator><name>java</name></name>
<name>index</name> <name>ede2328b2f2</name><operator>..</operator><literal type="number">48ff9102281</literal> <literal type="number">100755</literal>
<operator>--</operator> <name>a</name><operator>/</operator><name>solr</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>request</name><operator>/</operator><name><name>UnInvertedField</name><operator>.</operator><name>java</name></name>
<operator>++</operator> <name>b</name><operator>/</operator><name>solr</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>request</name><operator>/</operator><name><name>UnInvertedField</name><operator>.</operator><name>java</name></name>
@@ <operator>-</operator><literal type="number">18</literal></expr><operator>,</operator><expr><literal type="number">16</literal> <operator>+</operator><literal type="number">18</literal></expr><operator>,</operator><expr><literal type="number">11</literal> @@</expr></expr_stmt>
 <package>package <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>request</name></name>;</package>
 
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>search</name><operator>.</operator><name>FieldCache</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>index</name><operator>.</operator><name>IndexReader</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>index</name><operator>.</operator><name>DocTermOrds</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>index</name><operator>.</operator><name>Term</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>index</name><operator>.</operator><name>DocsEnum</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>index</name><operator>.</operator><name>DocsAndPositionsEnum</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>index</name><operator>.</operator><name>TermsEnum</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>index</name><operator>.</operator><name>Terms</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>index</name><operator>.</operator><name>MultiFields</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>search</name><operator>.</operator><name>TermQuery</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>search</name><operator>.</operator><name>TermRangeQuery</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>util</name><operator>.</operator><name>PagedBytes</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>noggit</name><operator>.</operator><name>CharArr</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>common</name><operator>.</operator><name>params</name><operator>.</operator><name>FacetParams</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>common</name><operator>.</operator><name>util</name><operator>.</operator><name>NamedList</name></name>;</import>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">44</literal></expr><operator>,</operator><expr><literal type="number">15</literal> <operator>+</operator><literal type="number">39</literal></expr><operator>,</operator><expr><literal type="number">11</literal> @@</expr></expr_stmt> <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>handler</name><operator>.</operator><name>component</name><operator>.</operator><name>StatsValues</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>handler</name><operator>.</operator><name>component</name><operator>.</operator><name>FieldFacetStats</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>util</name><operator>.</operator><name>OpenBitSet</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>util</name><operator>.</operator><name>BytesRef</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>util</name><operator>.</operator><name>Bits</name></name>;</import>
 
 <import>import <name><name>java</name><operator>.</operator><name>io</name><operator>.</operator><name>IOException</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>ArrayList</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>Arrays</name></name>;</import>
 <import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>HashMap</name></name>;</import>
 <import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>LinkedHashMap</name></name>;</import>
 <import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>Map</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>Comparator</name></name>;</import>
 
 <import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>concurrent</name><operator>.</operator><name>atomic</name><operator>.</operator><name>AtomicLong</name></name>;</import>
 
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">86</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">77</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@</expr></expr_stmt> <import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>concurrent</name><operator>.</operator><name>atomic</name><operator>.</operator><name>AtomicLong</name></name>;</import>
  <expr_stmt><expr><operator>*</operator>   <name>much</name> <name>like</name> <name>Lucene</name><literal type="char">'s own internal term index).
  *
  */
public class UnInvertedField {
public class UnInvertedField extends DocTermOrds {
   private static int TNUM_OFFSET=2;
 
   static class TopTerm {
@@ -100,362 +91,109 @@ public class UnInvertedField {
     }
   }
 
  String field;
  int numTermsInField;
  int termsInverted;  // number of unique terms that were un-inverted
  long termInstances; // total number of references to term numbers
  final TermIndex ti;
   long memsz;
  int total_time;  // total time to uninvert the field
  int phase1_time;  // time for phase1 of the uninvert process
   final AtomicLong use = new AtomicLong(); // number of uses
 
  int[] index;
  byte[][] tnums = new byte[256][];
  int[] maxTermCounts;
  int[] maxTermCounts = new int[1024];

   final Map&lt;Integer,TopTerm&gt; bigTerms = new LinkedHashMap&lt;Integer,TopTerm&gt;();
 
  private SolrIndexSearcher.DocsEnumState deState;
  private final SolrIndexSearcher searcher;

  @Override
  protected void visitTerm(TermsEnum te, int termNum) throws IOException {

    if (termNum &gt;= maxTermCounts.length) {
      // resize by doubling - for very large number of unique terms, expanding
      // by 4K and resultant GC will dominate uninvert times.  Resize at end if material
      int[] newMaxTermCounts = new int[maxTermCounts.length*2];
      System.arraycopy(maxTermCounts, 0, newMaxTermCounts, 0, termNum);
      maxTermCounts = newMaxTermCounts;
    }

    final BytesRef term = te.term();

    if (te.docFreq() &gt; maxTermDocFreq) {
      TopTerm topTerm = new TopTerm();
      topTerm.term = new BytesRef(term);
      topTerm.termNum = termNum;
      bigTerms.put(topTerm.termNum, topTerm);

      if (deState == null) {
        deState = new SolrIndexSearcher.DocsEnumState();
        deState.termsEnum = te;
      }

      maxTermCounts[termNum] = searcher.getDocSet(new TermQuery(new Term(field, topTerm.term)), deState).size();
      System.out.println("  big term termNum=" + termNum + " term=" + topTerm.term.utf8ToString() + " size=" + maxTermCounts[termNum] + " dF=" + te.docFreq());
    }
  }

  @Override
  protected void setActualDocFreq(int termNum, int docFreq) {
    maxTermCounts[termNum] = docFreq;
  }
 
   public long memSize() {
     // can cache the mem size since it shouldn'</literal><name>t</name> <name>change</name></expr></expr_stmt>
     <if_stmt><if>if <condition>(<expr><name>memsz</name><operator>!=</operator><literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>memsz</name></expr>;</return></block_content></block></if></if_stmt>
    <decl_stmt><decl><type><name>long</name></type> <name>sz</name> <init>= <expr><literal type="number">8</literal><operator>*</operator><literal type="number">8</literal> <operator>+</operator> <literal type="number">32</literal></expr></init></decl>;</decl_stmt> <comment type="line">// local fields</comment>
    <decl_stmt><decl><type><name>long</name></type> <name>sz</name> <init>= <expr><call><name><name>super</name><operator>.</operator><name>ramUsedInBytes</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>sz</name> <operator>+=</operator> <literal type="number">8</literal><operator>*</operator><literal type="number">8</literal> <operator>+</operator> <literal type="number">32</literal></expr>;</expr_stmt> <comment type="line">// local fields</comment>
     <expr_stmt><expr><name>sz</name> <operator>+=</operator> <call><name><name>bigTerms</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>*</operator> <literal type="number">64</literal></expr>;</expr_stmt>
     <for>for <control>(<init><decl><type><name>TopTerm</name></type> <name>tt</name> <range>: <expr><call><name><name>bigTerms</name><operator>.</operator><name>values</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control> <block>{<block_content>
       <expr_stmt><expr><name>sz</name> <operator>+=</operator> <call><name><name>tt</name><operator>.</operator><name>memSize</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
     </block_content>}</block></for>
    <if_stmt><if>if <condition>(<expr><name>index</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>sz</name> <operator>+=</operator> <name><name>index</name><operator>.</operator><name>length</name></name> <operator>*</operator> <literal type="number">4</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>tnums</name><operator>!=</operator><literal type="null">null</literal></expr>)</condition> <block>{<block_content>
      <for>for <control>(<init><decl><type><name><name>byte</name><index>[]</index></name></type> <name>arr</name> <range>: <expr><name>tnums</name></expr></range></decl></init>)</control><block type="pseudo"><block_content>
        <if_stmt><if>if <condition>(<expr><name>arr</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>sz</name> <operator>+=</operator> <name><name>arr</name><operator>.</operator><name>length</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>
    </block_content>}</block></if></if_stmt>
     <if_stmt><if>if <condition>(<expr><name>maxTermCounts</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition><block type="pseudo"><block_content>
       <expr_stmt><expr><name>sz</name> <operator>+=</operator> <name><name>maxTermCounts</name><operator>.</operator><name>length</name></name> <operator>*</operator> <literal type="number">4</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>sz</name> <operator>+=</operator> <call><name><name>ti</name><operator>.</operator><name>memSize</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>indexedTermsArray</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
      <comment type="line">// assume 8 byte references?</comment>
      <expr_stmt><expr><name>sz</name> <operator>+=</operator> <literal type="number">8</literal><operator>+</operator><literal type="number">8</literal><operator>+</operator><literal type="number">8</literal><operator>+</operator><literal type="number">8</literal><operator>+</operator><operator>(</operator><name><name>indexedTermsArray</name><operator>.</operator><name>length</name></name><operator>&lt;&lt;</operator><literal type="number">3</literal><operator>)</operator><operator>+</operator><name>sizeOfIndexedStrings</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
     <expr_stmt><expr><name>memsz</name> <operator>=</operator> <name>sz</name></expr>;</expr_stmt>
     <return>return <expr><name>sz</name></expr>;</return>
   </block_content>}</block></function>
 

  <comment type="block" format="javadoc">/** Number of bytes to represent an unsigned int as a vint. */</comment>
  <function><type><specifier>static</specifier> <name>int</name></type> <name>vIntSize</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>x</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>x</name> <operator>&amp;</operator> <operator>(</operator><literal type="number">0xffffffff</literal> <operator>&lt;&lt;</operator> <operator>(</operator><literal type="number">7</literal><operator>*</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr> )</condition> <block>{<block_content>
      <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>x</name> <operator>&amp;</operator> <operator>(</operator><literal type="number">0xffffffff</literal> <operator>&lt;&lt;</operator> <operator>(</operator><literal type="number">7</literal><operator>*</operator><literal type="number">2</literal><operator>)</operator><operator>)</operator><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr> )</condition> <block>{<block_content>
      <return>return <expr><literal type="number">2</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>x</name> <operator>&amp;</operator> <operator>(</operator><literal type="number">0xffffffff</literal> <operator>&lt;&lt;</operator> <operator>(</operator><literal type="number">7</literal><operator>*</operator><literal type="number">3</literal><operator>)</operator><operator>)</operator><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr> )</condition> <block>{<block_content>
      <return>return <expr><literal type="number">3</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>x</name> <operator>&amp;</operator> <operator>(</operator><literal type="number">0xffffffff</literal> <operator>&lt;&lt;</operator> <operator>(</operator><literal type="number">7</literal><operator>*</operator><literal type="number">4</literal><operator>)</operator><operator>)</operator><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr> )</condition> <block>{<block_content>
      <return>return <expr><literal type="number">4</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><literal type="number">5</literal></expr>;</return>
  </block_content>}</block></function>


  <comment type="line">// todo: if we know the size of the vInt already, we could do</comment>
  <comment type="line">// a single switch on the size</comment>
  <function><type><specifier>static</specifier> <name>int</name></type> <name>writeInt</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name><name>byte</name><index>[]</index></name></type> <name>arr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pos</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>a</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>a</name> <operator>=</operator> <operator>(</operator><name>x</name> <operator>&gt;&gt;&gt;</operator> <operator>(</operator><literal type="number">7</literal><operator>*</operator><literal type="number">4</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>a</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name><name>arr</name><index>[<expr><name>pos</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>byte</name><operator>)</operator><operator>(</operator><name>a</name> <operator>|</operator> <literal type="number">0x80</literal><operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>a</name> <operator>=</operator> <operator>(</operator><name>x</name> <operator>&gt;&gt;&gt;</operator> <operator>(</operator><literal type="number">7</literal><operator>*</operator><literal type="number">3</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>a</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name><name>arr</name><index>[<expr><name>pos</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>byte</name><operator>)</operator><operator>(</operator><name>a</name> <operator>|</operator> <literal type="number">0x80</literal><operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>a</name> <operator>=</operator> <operator>(</operator><name>x</name> <operator>&gt;&gt;&gt;</operator> <operator>(</operator><literal type="number">7</literal><operator>*</operator><literal type="number">2</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>a</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name><name>arr</name><index>[<expr><name>pos</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>byte</name><operator>)</operator><operator>(</operator><name>a</name> <operator>|</operator> <literal type="number">0x80</literal><operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>a</name> <operator>=</operator> <operator>(</operator><name>x</name> <operator>&gt;&gt;&gt;</operator> <operator>(</operator><literal type="number">7</literal><operator>*</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>a</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name><name>arr</name><index>[<expr><name>pos</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>byte</name><operator>)</operator><operator>(</operator><name>a</name> <operator>|</operator> <literal type="number">0x80</literal><operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>arr</name><index>[<expr><name>pos</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>byte</name><operator>)</operator><operator>(</operator><name>x</name> <operator>&amp;</operator> <literal type="number">0x7f</literal><operator>)</operator></expr>;</expr_stmt>
    <return>return <expr><name>pos</name></expr>;</return>
  </block_content>}</block></function>



   <constructor><specifier>public</specifier> <name>UnInvertedField</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>field</name></decl></parameter>, <parameter><decl><type><name>SolrIndexSearcher</name></type> <name>searcher</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws> <block>{<block_content>
    <expr_stmt><expr><name><name>this</name><operator>.</operator><name>field</name></name> <operator>=</operator> <name>field</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>this</name><operator>.</operator><name>ti</name></name> <operator>=</operator> <operator>new</operator> <call><name>TermIndex</name><argument_list>(<argument><expr><name>field</name></expr></argument>,
            <argument><expr><call><name><name>TrieField</name><operator>.</operator><name>getMainValuePrefix</name></name><argument_list>(<argument><expr><call><name><name>searcher</name><operator>.</operator><name>getSchema</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getFieldType</name><argument_list>(<argument><expr><name>field</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>uninvert</name><argument_list>(<argument><expr><name>searcher</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></constructor>


  <function><type><specifier>private</specifier> <name>void</name></type> <name>uninvert</name><parameter_list>(<parameter><decl><type><name>SolrIndexSearcher</name></type> <name>searcher</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws> <block>{<block_content>
    <decl_stmt><decl><type><name>long</name></type> <name>startTime</name> <init>= <expr><call><name><name>System</name><operator>.</operator><name>currentTimeMillis</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>IndexReader</name></type> <name>reader</name> <init>= <expr><call><name><name>searcher</name><operator>.</operator><name>getIndexReader</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>maxDoc</name> <init>= <expr><call><name><name>reader</name><operator>.</operator><name>maxDoc</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name><name>int</name><index>[]</index></name></type> <name>index</name> <init>= <expr><operator>new</operator> <name><name>int</name><index>[<expr><name>maxDoc</name></expr>]</index></name></expr></init></decl>;</decl_stmt>       <comment type="line">// immediate term numbers, or the index into the byte[] representing the last number</comment>
    <expr_stmt><expr><name><name>this</name><operator>.</operator><name>index</name></name> <operator>=</operator> <name>index</name></expr>;</expr_stmt>
    <decl_stmt><decl><type><specifier>final</specifier> <name><name>int</name><index>[]</index></name></type> <name>lastTerm</name> <init>= <expr><operator>new</operator> <name><name>int</name><index>[<expr><name>maxDoc</name></expr>]</index></name></expr></init></decl>;</decl_stmt>    <comment type="line">// last term we saw for this document</comment>
    <decl_stmt><decl><type><specifier>final</specifier> <name><name>byte</name><index>[]</index><index>[]</index></name></type> <name>bytes</name> <init>= <expr><operator>new</operator> <name><name>byte</name><index>[<expr><name>maxDoc</name></expr>]</index><index>[]</index></name></expr></init></decl>;</decl_stmt> <comment type="line">// list of term numbers for the doc (delta encoded vInts)</comment>
    <expr_stmt><expr><name>maxTermCounts</name> <operator>=</operator> <operator>new</operator> <name><name>int</name><index>[<expr><literal type="number">1024</literal></expr>]</index></name></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>NumberedTermsEnum</name></type> <name>te</name> <init>= <expr><call><name><name>ti</name><operator>.</operator><name>getEnumerator</name></name><argument_list>(<argument><expr><name>reader</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="line">// threshold, over which we use set intersections instead of counting</comment>
    <comment type="line">// to (1) save memory, and (2) speed up faceting.</comment>
    <comment type="line">// Add 2 for testing purposes so that there will always be some terms under</comment>
    <comment type="line">// the threshold even when the index is very small.</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>threshold</name> <init>= <expr><name>maxDoc</name> <operator>/</operator> <literal type="number">20</literal> <operator>+</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt>
    <comment type="line">// threshold = 2000000000; //////////////////////////////// USE FOR TESTING</comment>

    <comment type="line">// we need a minimum of 9 bytes, but round up to 12 since the space would</comment>
    <comment type="line">// be wasted with most allocators anyway.</comment>
    <decl_stmt><decl><type><name><name>byte</name><index>[]</index></name></type> <name>tempArr</name> <init>= <expr><operator>new</operator> <name><name>byte</name><index>[<expr><literal type="number">12</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

    <comment type="line">//</comment>
    <comment type="line">// enumerate all terms, and build an intermediate form of the un-inverted field.</comment>
    <comment type="line">//</comment>
    <comment type="line">// During this intermediate form, every document has a (potential) byte[]</comment>
    <comment type="line">// and the int[maxDoc()] array either contains the termNumber list directly</comment>
    <comment type="line">// or the *end* offset of the termNumber list in it's byte array (for faster</comment>
    <comment type="line">// appending and faster creation of the final form).</comment>
    <comment type="line">//</comment>
    <comment type="line">// idea... if things are too large while building, we could do a range of docs</comment>
    <comment type="line">// at a time (but it would be a fair amount slower to build)</comment>
    <comment type="line">// could also do ranges in parallel to take advantage of multiple CPUs</comment>

    <comment type="line">// OPTIONAL: remap the largest df terms to the lowest 128 (single byte)</comment>
    <comment type="line">// values.  This requires going over the field first to find the most</comment>
    <comment type="line">// frequent terms ahead of time.</comment>

    <decl_stmt><decl><type><name><name>SolrIndexSearcher</name><operator>.</operator><name>DocsEnumState</name></name></type> <name>deState</name> <init>= <expr><literal type="null">null</literal></expr></init></decl>;</decl_stmt>

    <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
      <decl_stmt><decl><type><name>BytesRef</name></type> <name>t</name> <init>= <expr><call><name><name>te</name><operator>.</operator><name>term</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><name>t</name><operator>==</operator><literal type="null">null</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

      <decl_stmt><decl><type><name>int</name></type> <name>termNum</name> <init>= <expr><call><name><name>te</name><operator>.</operator><name>getTermNumber</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

      <if_stmt><if>if <condition>(<expr><name>termNum</name> <operator>&gt;=</operator> <name><name>maxTermCounts</name><operator>.</operator><name>length</name></name></expr>)</condition> <block>{<block_content>
        <comment type="line">// resize by doubling - for very large number of unique terms, expanding</comment>
        <comment type="line">// by 4K and resultant GC will dominate uninvert times.  Resize at end if material</comment>
        <decl_stmt><decl><type><name><name>int</name><index>[]</index></name></type> <name>newMaxTermCounts</name> <init>= <expr><operator>new</operator> <name><name>int</name><index>[<expr><name><name>maxTermCounts</name><operator>.</operator><name>length</name></name><operator>*</operator><literal type="number">2</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>System</name><operator>.</operator><name>arraycopy</name></name><argument_list>(<argument><expr><name>maxTermCounts</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>newMaxTermCounts</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>termNum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>maxTermCounts</name> <operator>=</operator> <name>newMaxTermCounts</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>

      <decl_stmt><decl><type><name>int</name></type> <name>df</name> <init>= <expr><call><name><name>te</name><operator>.</operator><name>docFreq</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><name>df</name> <operator>&gt;=</operator> <name>threshold</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>TopTerm</name></type> <name>topTerm</name> <init>= <expr><operator>new</operator> <call><name>TopTerm</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>topTerm</name><operator>.</operator><name>term</name></name> <operator>=</operator> <operator>new</operator> <call><name>BytesRef</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>topTerm</name><operator>.</operator><name>termNum</name></name> <operator>=</operator> <name>termNum</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>bigTerms</name><operator>.</operator><name>put</name></name><argument_list>(<argument><expr><name><name>topTerm</name><operator>.</operator><name>termNum</name></name></expr></argument>, <argument><expr><name>topTerm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>deState</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><name>deState</name> <operator>=</operator> <operator>new</operator> <call><name><name>SolrIndexSearcher</name><operator>.</operator><name>DocsEnumState</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>deState</name><operator>.</operator><name>termsEnum</name></name> <operator>=</operator> <name><name>te</name><operator>.</operator><name>tenum</name></name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>deState</name><operator>.</operator><name>reuse</name></name> <operator>=</operator> <name><name>te</name><operator>.</operator><name>docsEnum</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>super</name><argument_list>(<argument><expr><name>field</name></expr></argument>,
          <comment type="line">// threshold, over which we use set intersections instead of counting</comment>
          <comment type="line">// to (1) save memory, and (2) speed up faceting.</comment>
          <comment type="line">// Add 1 for testing purposes so that there will always be some terms under</comment>
          <comment type="line">// the threshold even when the index is very</comment>
          <comment type="line">// small.</comment>
          <argument><expr><call><name><name>searcher</name><operator>.</operator><name>maxDoc</name></name><argument_list>()</argument_list></call><operator>/</operator><literal type="number">20</literal> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
          <argument><expr><name>DEFAULT_INDEX_INTERVAL_BITS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="line">//System.out.println("maxTermDocFreq=" + maxTermDocFreq + " maxDoc=" + searcher.maxDoc());</comment>

    <decl_stmt><decl><type><specifier>final</specifier> <name>String</name></type> <name>prefix</name> <init>= <expr><call><name><name>TrieField</name><operator>.</operator><name>getMainValuePrefix</name></name><argument_list>(<argument><expr><call><name><name>searcher</name><operator>.</operator><name>getSchema</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getFieldType</name><argument_list>(<argument><expr><name>field</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>this</name><operator>.</operator><name>searcher</name></name> <operator>=</operator> <name>searcher</name></expr>;</expr_stmt>
    <try>try <block>{<block_content>
      <expr_stmt><expr><call><name>uninvert</name><argument_list>(<argument><expr><call><name><name>searcher</name><operator>.</operator><name>getIndexReader</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><ternary><condition><expr><name>prefix</name> <operator>==</operator> <literal type="null">null</literal></expr> ?</condition><then> <expr><literal type="null">null</literal></expr> </then><else>: <expr><operator>new</operator> <call><name>BytesRef</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block> <catch>catch <parameter_list>(<parameter><decl><type><name>IllegalStateException</name></type> <name>ise</name></decl></parameter>)</parameter_list> <block>{<block_content>
      <throw>throw <expr><operator>new</operator> <call><name>SolrException</name><argument_list>(<argument><expr><name><name>SolrException</name><operator>.</operator><name>ErrorCode</name><operator>.</operator><name>BAD_REQUEST</name></name></expr></argument>, <argument><expr><call><name><name>ise</name><operator>.</operator><name>getMessage</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw>
    </block_content>}</block></catch></try>
    <if_stmt><if>if <condition>(<expr><name>tnums</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
      <for>for<control>(<init><decl><type><name><name>byte</name><index>[]</index></name></type> <name>target</name> <range>: <expr><name>tnums</name></expr></range></decl></init>)</control> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>target</name> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <name><name>target</name><operator>.</operator><name>length</name></name> <operator>&gt;</operator> <operator>(</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><literal type="number">24</literal><operator>)</operator><operator>*</operator><literal type="number">.9</literal></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><call><name><name>SolrCore</name><operator>.</operator><name>log</name><operator>.</operator><name>warn</name></name><argument_list>(<argument><expr><literal type="string">"Approaching too many values for UnInvertedField faceting on field '"</literal><operator>+</operator><name>field</name><operator>+</operator><literal type="string">"' : bucket size="</literal> <operator>+</operator> <name><name>target</name><operator>.</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
         </block_content>}</block></if></if_stmt>
        <decl_stmt><decl><type><name>DocSet</name></type> <name>set</name> <init>= <expr><call><name><name>searcher</name><operator>.</operator><name>getDocSet</name></name><argument_list>(<argument><expr><operator>new</operator> <call><name>TermQuery</name><argument_list>(<argument><expr><operator>new</operator> <call><name>Term</name><argument_list>(<argument><expr><name><name>ti</name><operator>.</operator><name>field</name></name></expr></argument>, <argument><expr><name><name>topTerm</name><operator>.</operator><name>term</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>deState</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>te</name><operator>.</operator><name>docsEnum</name></name> <operator>=</operator> <name><name>deState</name><operator>.</operator><name>reuse</name></name></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>maxTermCounts</name><index>[<expr><name>termNum</name></expr>]</index></name> <operator>=</operator> <call><name><name>set</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name><name>te</name><operator>.</operator><name>next</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <continue>continue;</continue>
       </block_content>}</block></for>

      <expr_stmt><expr><name>termsInverted</name><operator>++</operator></expr>;</expr_stmt>

      <decl_stmt><decl><type><name>DocsEnum</name></type> <name>docsEnum</name> <init>= <expr><call><name><name>te</name><operator>.</operator><name>getDocsEnum</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

      <decl_stmt><decl><type><name><name>DocsEnum</name><operator>.</operator><name>BulkReadResult</name></name></type> <name>bulkResult</name> <init>= <expr><call><name><name>docsEnum</name><operator>.</operator><name>getBulkResult</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

      <for>for<control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><call><name><name>docsEnum</name><operator>.</operator><name>read</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>n</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

        <expr_stmt><expr><name><name>maxTermCounts</name><index>[<expr><name>termNum</name></expr>]</index></name> <operator>+=</operator> <name>n</name></expr>;</expr_stmt>

        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name><init>=<expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
          <expr_stmt><expr><name>termInstances</name><operator>++</operator></expr>;</expr_stmt>
          <decl_stmt><decl><type><name>int</name></type> <name>doc</name> <init>= <expr><name><name>bulkResult</name><operator>.</operator><name>docs</name><operator>.</operator><name>ints</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
          <comment type="line">// add 2 to the term number to make room for special reserved values:</comment>
          <comment type="line">// 0 (end term) and 1 (index into byte array follows)</comment>
          <decl_stmt><decl><type><name>int</name></type> <name>delta</name> <init>= <expr><name>termNum</name> <operator>-</operator> <name><name>lastTerm</name><index>[<expr><name>doc</name></expr>]</index></name> <operator>+</operator> <name>TNUM_OFFSET</name></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><name><name>lastTerm</name><index>[<expr><name>doc</name></expr>]</index></name> <operator>=</operator> <name>termNum</name></expr>;</expr_stmt>
          <decl_stmt><decl><type><name>int</name></type> <name>val</name> <init>= <expr><name><name>index</name><index>[<expr><name>doc</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

          <if_stmt><if>if <condition>(<expr><operator>(</operator><name>val</name> <operator>&amp;</operator> <literal type="number">0xff</literal><operator>)</operator><operator>==</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
            <comment type="line">// index into byte array (actually the end of</comment>
            <comment type="line">// the doc-specific byte[] when building)</comment>
            <decl_stmt><decl><type><name>int</name></type> <name>pos</name> <init>= <expr><name>val</name> <operator>&gt;&gt;&gt;</operator> <literal type="number">8</literal></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>ilen</name> <init>= <expr><call><name>vIntSize</name><argument_list>(<argument><expr><name>delta</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name><name>byte</name><index>[]</index></name></type> <name>arr</name> <init>= <expr><name><name>bytes</name><index>[<expr><name>doc</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>newend</name> <init>= <expr><name>pos</name><operator>+</operator><name>ilen</name></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>newend</name> <operator>&gt;</operator> <name><name>arr</name><operator>.</operator><name>length</name></name></expr>)</condition> <block>{<block_content>
              <comment type="line">// We avoid a doubling strategy to lower memory usage.</comment>
              <comment type="line">// this faceting method isn't for docs with many terms.</comment>
              <comment type="line">// In hotspot, objects have 2 words of overhead, then fields, rounded up to a 64-bit boundary.</comment>
              <comment type="line">// TODO: figure out what array lengths we can round up to w/o actually using more memory</comment>
              <comment type="line">// (how much space does a byte[] take up?  Is data preceded by a 32 bit length only?</comment>
              <comment type="line">// It should be safe to round up to the nearest 32 bits in any case.</comment>
              <decl_stmt><decl><type><name>int</name></type> <name>newLen</name> <init>= <expr><operator>(</operator><name>newend</name> <operator>+</operator> <literal type="number">3</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xfffffffc</literal></expr></init></decl>;</decl_stmt>  <comment type="line">// 4 byte alignment</comment>
              <decl_stmt><decl><type><name><name>byte</name><index>[]</index></name></type> <name>newarr</name> <init>= <expr><operator>new</operator> <name><name>byte</name><index>[<expr><name>newLen</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
              <expr_stmt><expr><call><name><name>System</name><operator>.</operator><name>arraycopy</name></name><argument_list>(<argument><expr><name>arr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>newarr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><name>arr</name> <operator>=</operator> <name>newarr</name></expr>;</expr_stmt>
              <expr_stmt><expr><name><name>bytes</name><index>[<expr><name>doc</name></expr>]</index></name> <operator>=</operator> <name>newarr</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>pos</name> <operator>=</operator> <call><name>writeInt</name><argument_list>(<argument><expr><name>delta</name></expr></argument>, <argument><expr><name>arr</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>index</name><index>[<expr><name>doc</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>pos</name><operator>&lt;&lt;</operator><literal type="number">8</literal><operator>)</operator> <operator>|</operator> <literal type="number">1</literal></expr>;</expr_stmt>  <comment type="line">// update pointer to end index in byte[]</comment>
          </block_content>}</block></if> <else>else <block>{<block_content>
            <comment type="line">// OK, this int has data in it... find the end (a zero starting byte - not</comment>
            <comment type="line">// part of another number, hence not following a byte with the high bit set).</comment>
            <decl_stmt><decl><type><name>int</name></type> <name>ipos</name></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>val</name><operator>==</operator><literal type="number">0</literal></expr>)</condition> <block>{<block_content>
              <expr_stmt><expr><name>ipos</name><operator>=</operator><literal type="number">0</literal></expr>;</expr_stmt>
            </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>(</operator><name>val</name> <operator>&amp;</operator> <literal type="number">0x0000ff80</literal><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr>)</condition> <block>{<block_content>
              <expr_stmt><expr><name>ipos</name><operator>=</operator><literal type="number">1</literal></expr>;</expr_stmt>
            </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>(</operator><name>val</name> <operator>&amp;</operator> <literal type="number">0x00ff8000</literal><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr>)</condition> <block>{<block_content>
              <expr_stmt><expr><name>ipos</name><operator>=</operator><literal type="number">2</literal></expr>;</expr_stmt>
            </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>(</operator><name>val</name> <operator>&amp;</operator> <literal type="number">0xff800000</literal><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr>)</condition> <block>{<block_content>
              <expr_stmt><expr><name>ipos</name><operator>=</operator><literal type="number">3</literal></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
              <expr_stmt><expr><name>ipos</name><operator>=</operator><literal type="number">4</literal></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>

            <decl_stmt><decl><type><name>int</name></type> <name>endPos</name> <init>= <expr><call><name>writeInt</name><argument_list>(<argument><expr><name>delta</name></expr></argument>, <argument><expr><name>tempArr</name></expr></argument>, <argument><expr><name>ipos</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>endPos</name> <operator>&lt;=</operator> <literal type="number">4</literal></expr>)</condition> <block>{<block_content>
              <comment type="line">// value will fit in the integer... move bytes back</comment>
              <for>for <control>(<init><decl><type><name>int</name></type> <name>j</name><init>=<expr><name>ipos</name></expr></init></decl>;</init> <condition><expr><name>j</name><operator>&lt;</operator><name>endPos</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
                <expr_stmt><expr><name>val</name> <operator>|=</operator> <operator>(</operator><name><name>tempArr</name><index>[<expr><name>j</name></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0xff</literal><operator>)</operator> <operator>&lt;&lt;</operator> <operator>(</operator><name>j</name><operator>&lt;&lt;</operator><literal type="number">3</literal><operator>)</operator></expr>;</expr_stmt>
              </block_content>}</block></for>
              <expr_stmt><expr><name><name>index</name><index>[<expr><name>doc</name></expr>]</index></name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
              <comment type="line">// value won't fit... move integer into byte[]</comment>
              <for>for <control>(<init><decl><type><name>int</name></type> <name>j</name><init>=<expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name><operator>&lt;</operator><name>ipos</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
                <expr_stmt><expr><name><name>tempArr</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>byte</name><operator>)</operator><name>val</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>val</name> <operator>&gt;&gt;&gt;=</operator><literal type="number">8</literal></expr>;</expr_stmt>
              </block_content>}</block></for>
              <comment type="line">// point at the end index in the byte[]</comment>
              <expr_stmt><expr><name><name>index</name><index>[<expr><name>doc</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>endPos</name><operator>&lt;&lt;</operator><literal type="number">8</literal><operator>)</operator> <operator>|</operator> <literal type="number">1</literal></expr>;</expr_stmt>
              <expr_stmt><expr><name><name>bytes</name><index>[<expr><name>doc</name></expr>]</index></name> <operator>=</operator> <name>tempArr</name></expr>;</expr_stmt>
              <expr_stmt><expr><name>tempArr</name> <operator>=</operator> <operator>new</operator> <name><name>byte</name><index>[<expr><literal type="number">12</literal></expr>]</index></name></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>

          </block_content>}</block></else></if_stmt>

        </block_content>}</block></for>

      </block_content>}</block></for>

      <expr_stmt><expr><call><name><name>te</name><operator>.</operator><name>next</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
     </block_content>}</block></if></if_stmt>
 
    <expr_stmt><expr><name>numTermsInField</name> <operator>=</operator> <call><name><name>te</name><operator>.</operator><name>getTermNumber</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>te</name><operator>.</operator><name>close</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

     <comment type="line">// free space if outrageously wasteful (tradeoff memory/cpu) </comment>

     <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>maxTermCounts</name><operator>.</operator><name>length</name></name> <operator>-</operator> <name>numTermsInField</name><operator>)</operator> <operator>&gt;</operator> <literal type="number">1024</literal></expr>)</condition> <block>{<block_content> <comment type="line">// too much waste!</comment>
       <decl_stmt><decl><type><name><name>int</name><index>[]</index></name></type> <name>newMaxTermCounts</name> <init>= <expr><operator>new</operator> <name><name>int</name><index>[<expr><name>numTermsInField</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
       <expr_stmt><expr><call><name><name>System</name><operator>.</operator><name>arraycopy</name></name><argument_list>(<argument><expr><name>maxTermCounts</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>newMaxTermCounts</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>numTermsInField</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
       <expr_stmt><expr><name>maxTermCounts</name> <operator>=</operator> <name>newMaxTermCounts</name></expr>;</expr_stmt>
   </block_content>}</block></if></if_stmt>

    <decl_stmt><decl><type><name>long</name></type> <name>midPoint</name> <init>= <expr><call><name><name>System</name><operator>.</operator><name>currentTimeMillis</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>termInstances</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <comment type="line">// we didn't invert anything</comment>
      <comment type="line">// lower memory consumption.</comment>
      <expr_stmt><expr><name>index</name> <operator>=</operator> <name><name>this</name><operator>.</operator><name>index</name></name> <operator>=</operator> <literal type="null">null</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>tnums</name> <operator>=</operator> <literal type="null">null</literal></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>

      <comment type="line">//</comment>
      <comment type="line">// transform intermediate form into the final form, building a single byte[]</comment>
      <comment type="line">// at a time, and releasing the intermediate byte[]s as we go to avoid</comment>
      <comment type="line">// increasing the memory footprint.</comment>
      <comment type="line">//</comment>
      <for>for <control>(<init><decl><type><name>int</name></type> <name>pass</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>pass</name><operator>&lt;</operator><literal type="number">256</literal></expr>;</condition> <incr><expr><name>pass</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name><name>byte</name><index>[]</index></name></type> <name>target</name> <init>= <expr><name><name>tnums</name><index>[<expr><name>pass</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>pos</name><init>=<expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>  <comment type="line">// end in target;</comment>
        <if_stmt><if>if <condition>(<expr><name>target</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><name>pos</name> <operator>=</operator> <name><name>target</name><operator>.</operator><name>length</name></name></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
          <expr_stmt><expr><name>target</name> <operator>=</operator> <operator>new</operator> <name><name>byte</name><index>[<expr><literal type="number">4096</literal></expr>]</index></name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <comment type="line">// loop over documents, 0x00ppxxxx, 0x01ppxxxx, 0x02ppxxxx</comment>
        <comment type="line">// where pp is the pass (which array we are building), and xx is all values.</comment>
        <comment type="line">// each pass shares the same byte[] for termNumber lists.</comment>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>docbase</name> <init>= <expr><name>pass</name><operator>&lt;&lt;</operator><literal type="number">16</literal></expr></init></decl>;</init> <condition><expr><name>docbase</name><operator>&lt;</operator><name>maxDoc</name></expr>;</condition> <incr><expr><name>docbase</name><operator>+=</operator><operator>(</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><literal type="number">24</literal><operator>)</operator></expr></incr>)</control> <block>{<block_content>
          <decl_stmt><decl><type><name>int</name></type> <name>lim</name> <init>= <expr><call><name><name>Math</name><operator>.</operator><name>min</name></name><argument_list>(<argument><expr><name>docbase</name> <operator>+</operator> <operator>(</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><literal type="number">16</literal><operator>)</operator></expr></argument>, <argument><expr><name>maxDoc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <for>for <control>(<init><decl><type><name>int</name></type> <name>doc</name><init>=<expr><name>docbase</name></expr></init></decl>;</init> <condition><expr><name>doc</name><operator>&lt;</operator><name>lim</name></expr>;</condition> <incr><expr><name>doc</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>val</name> <init>= <expr><name><name>index</name><index>[<expr><name>doc</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><name>val</name><operator>&amp;</operator><literal type="number">0xff</literal><operator>)</operator> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
              <decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><name>val</name> <operator>&gt;&gt;&gt;</operator> <literal type="number">8</literal></expr></init></decl>;</decl_stmt>
              <expr_stmt><expr><name><name>index</name><index>[<expr><name>doc</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>pos</name><operator>&lt;&lt;</operator><literal type="number">8</literal><operator>)</operator><operator>|</operator><literal type="number">1</literal></expr>;</expr_stmt> <comment type="line">// change index to point to start of array</comment>
              <if_stmt><if>if <condition>(<expr><operator>(</operator><name>pos</name> <operator>&amp;</operator> <literal type="number">0xff000000</literal><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <comment type="line">// we only have 24 bits for the array index</comment>
                <throw>throw <expr><operator>new</operator> <call><name>SolrException</name><argument_list>(<argument><expr><name><name>SolrException</name><operator>.</operator><name>ErrorCode</name><operator>.</operator><name>BAD_REQUEST</name></name></expr></argument>, <argument><expr><literal type="string">"Too many values for UnInvertedField faceting on field "</literal><operator>+</operator><name>field</name></expr></argument>)</argument_list></call></expr>;</throw>
              </block_content>}</block></if></if_stmt>
              <decl_stmt><decl><type><name><name>byte</name><index>[]</index></name></type> <name>arr</name> <init>= <expr><name><name>bytes</name><index>[<expr><name>doc</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
              <expr_stmt><expr><name><name>bytes</name><index>[<expr><name>doc</name></expr>]</index></name> <operator>=</operator> <literal type="null">null</literal></expr>;</expr_stmt>        <comment type="line">// IMPORTANT: allow GC to avoid OOM</comment>
              <if_stmt><if>if <condition>(<expr><name><name>target</name><operator>.</operator><name>length</name></name> <operator>&lt;=</operator> <name>pos</name> <operator>+</operator> <name>len</name></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name>int</name></type> <name>newlen</name> <init>= <expr><name><name>target</name><operator>.</operator><name>length</name></name></expr></init></decl>;</decl_stmt>
                <comment type="block" format="javadoc">/*** we don't have to worry about the array getting too large
                 * since the "pos" param will overflow first (only 24 bits available)
                if ((newlen&lt;&lt;1) &lt;= 0) {
                  // overflow...
                  newlen = Integer.MAX_VALUE;
                  if (newlen &lt;= pos + len) {
                    throw new SolrException(400,"Too many terms to uninvert field!");
                  }
                } else {
                  while (newlen &lt;= pos + len) newlen&lt;&lt;=1;  // doubling strategy
                }
                ****/</comment>
                <while>while <condition>(<expr><name>newlen</name> <operator>&lt;=</operator> <name>pos</name> <operator>+</operator> <name>len</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>newlen</name><operator>&lt;&lt;=</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></while>  <comment type="line">// doubling strategy                 </comment>
                <decl_stmt><decl><type><name><name>byte</name><index>[]</index></name></type> <name>newtarget</name> <init>= <expr><operator>new</operator> <name><name>byte</name><index>[<expr><name>newlen</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name><name>System</name><operator>.</operator><name>arraycopy</name></name><argument_list>(<argument><expr><name>target</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>newtarget</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>target</name> <operator>=</operator> <name>newtarget</name></expr>;</expr_stmt>
              </block_content>}</block></if></if_stmt>
              <expr_stmt><expr><call><name><name>System</name><operator>.</operator><name>arraycopy</name></name><argument_list>(<argument><expr><name>arr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>target</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><name>pos</name> <operator>+=</operator> <name>len</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>  <comment type="line">// skip single byte at end and leave it 0 for terminator</comment>
            </block_content>}</block></if></if_stmt>
          </block_content>}</block></for>
        </block_content>}</block></for>

        <comment type="line">// shrink array</comment>
        <if_stmt><if>if <condition>(<expr><name>pos</name> <operator>&lt;</operator> <name><name>target</name><operator>.</operator><name>length</name></name></expr>)</condition> <block>{<block_content>
          <decl_stmt><decl><type><name><name>byte</name><index>[]</index></name></type> <name>newtarget</name> <init>= <expr><operator>new</operator> <name><name>byte</name><index>[<expr><name>pos</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><call><name><name>System</name><operator>.</operator><name>arraycopy</name></name><argument_list>(<argument><expr><name>target</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>newtarget</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>target</name> <operator>=</operator> <name>newtarget</name></expr>;</expr_stmt>
          <if_stmt><if>if <condition>(<expr><name><name>target</name><operator>.</operator><name>length</name></name> <operator>&gt;</operator> <operator>(</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><literal type="number">24</literal><operator>)</operator><operator>*</operator><literal type="number">.9</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name><name>SolrCore</name><operator>.</operator><name>log</name><operator>.</operator><name>warn</name></name><argument_list>(<argument><expr><literal type="string">"Approaching too many values for UnInvertedField faceting on field '"</literal><operator>+</operator><name>field</name><operator>+</operator><literal type="string">"' : bucket size="</literal> <operator>+</operator> <name><name>target</name><operator>.</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        
        <expr_stmt><expr><name><name>tnums</name><index>[<expr><name>pass</name></expr>]</index></name> <operator>=</operator> <name>target</name></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>pass</name> <operator>&lt;&lt;</operator> <literal type="number">16</literal><operator>)</operator> <operator>&gt;</operator> <name>maxDoc</name></expr>)</condition><block type="pseudo"><block_content>
          <break>break;</break></block_content></block></if></if_stmt>
      </block_content>}</block></for>
     </block_content>}</block></else></if_stmt>
 
    <decl_stmt><decl><type><name>long</name></type> <name>endTime</name> <init>= <expr><call><name><name>System</name><operator>.</operator><name>currentTimeMillis</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>total_time</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>endTime</name><operator>-</operator><name>startTime</name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>phase1_time</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>midPoint</name><operator>-</operator><name>startTime</name><operator>)</operator></expr>;</expr_stmt>

     <expr_stmt><expr><call><name><name>SolrCore</name><operator>.</operator><name>log</name><operator>.</operator><name>info</name></name><argument_list>(<argument><expr><literal type="string">"UnInverted multi-valued field "</literal> <operator>+</operator> <call><name>toString</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="line">//System.out.println("CREATED: " + toString() + " ti.index=" + ti.index);</comment>
   </block_content>}</block></if></if_stmt>
 


  <function><type><specifier>public</specifier> <name>int</name></type> <name>getNumTerms</name><parameter_list>()</parameter_list> <block>{<block_content>
    <return>return <expr><name>numTermsInField</name></expr>;</return>
  </block_content>}</block></function>
 
   <function><type><specifier>public</specifier> <name><name>NamedList</name><argument_list type="generic">&lt;<argument><name>Integer</name></argument>&gt;</argument_list></name></type> <name>getCounts</name><parameter_list>(<parameter><decl><type><name>SolrIndexSearcher</name></type> <name>searcher</name></decl></parameter>, <parameter><decl><type><name>DocSet</name></type> <name>baseDocs</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>offset</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>limit</name></decl></parameter>, <parameter><decl><type><name>Integer</name></type> <name>mincount</name></decl></parameter>, <parameter><decl><type><name>boolean</name></type> <name>missing</name></decl></parameter>, <parameter><decl><type><name>String</name></type> <name>sort</name></decl></parameter>, <parameter><decl><type><name>String</name></type> <name>prefix</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws> <block>{<block_content>
     <expr_stmt><expr><call><name><name>use</name><operator>.</operator><name>incrementAndGet</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">468</literal></expr><operator>,</operator><expr><literal type="number">6</literal> <operator>+</operator><literal type="number">206</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@ <specifier>public</specifier> <name>class</name> <name>UnInvertedField</name> <block>{
     <expr><name>int</name> <name>baseSize</name> <operator>=</operator> <call><name><name>docs</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;
     <name>int</name> <name>maxDoc</name> <operator>=</operator> <call><name><name>searcher</name><operator>.</operator><name>maxDoc</name></name><argument_list>()</argument_list></call></block></expr>;</expr_stmt>
 
    <comment type="line">//System.out.println("GET COUNTS field=" + field + " baseSize=" + baseSize + " minCount=" + mincount + " maxDoc=" + maxDoc + " numTermsInField=" + numTermsInField);</comment>
     <if_stmt><if>if <condition>(<expr><name>baseSize</name> <operator>&gt;=</operator> <name>mincount</name></expr>)</condition> <block>{<block_content>
 
       <decl_stmt><decl><type><specifier>final</specifier> <name><name>int</name><index>[]</index></name></type> <name>index</name> <init>= <expr><name><name>this</name><operator>.</operator><name>index</name></name></expr></init></decl>;</decl_stmt>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">481</literal></expr><operator>,</operator><expr><literal type="number">14</literal> <operator>+</operator><literal type="number">220</literal></expr><operator>,</operator><expr><literal type="number">20</literal> @@ <specifier>public</specifier> <name>class</name> <name>UnInvertedField</name> <block>{
       <expr><name>int</name> <name>startTerm</name> <operator>=</operator> <literal type="number">0</literal></expr>;
       <name>int</name> <name>endTerm</name> <operator>=</operator> <name>numTermsInField</name></block></expr>;</expr_stmt>  <comment type="line">// one past the end</comment>
 
      <decl_stmt><decl><type><name>NumberedTermsEnum</name></type> <name>te</name> <init>= <expr><call><name><name>ti</name><operator>.</operator><name>getEnumerator</name></name><argument_list>(<argument><expr><call><name><name>searcher</name><operator>.</operator><name>getIndexReader</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>TermsEnum</name></type> <name>te</name> <init>= <expr><call><name>getOrdTermsEnum</name><argument_list>(<argument><expr><call><name><name>searcher</name><operator>.</operator><name>getIndexReader</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
       <if_stmt><if>if <condition>(<expr><name>prefix</name> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <call><name><name>prefix</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
         <decl_stmt><decl><type><name>BytesRef</name></type> <name>prefixBr</name> <init>= <expr><operator>new</operator> <call><name>BytesRef</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>te</name><operator>.</operator><name>skipTo</name></name><argument_list>(<argument><expr><name>prefixBr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>startTerm</name> <operator>=</operator> <call><name><name>te</name><operator>.</operator><name>getTermNumber</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name><name>te</name><operator>.</operator><name>seek</name></name><argument_list>(<argument><expr><name>prefixBr</name></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name><name>TermsEnum</name><operator>.</operator><name>SeekStatus</name><operator>.</operator><name>END</name></name></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><name>startTerm</name> <operator>=</operator> <name>numTermsInField</name></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
          <expr_stmt><expr><name>startTerm</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <call><name><name>te</name><operator>.</operator><name>ord</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
         <expr_stmt><expr><call><name><name>prefixBr</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name><name>ByteUtils</name><operator>.</operator><name>bigTerm</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>te</name><operator>.</operator><name>skipTo</name></name><argument_list>(<argument><expr><name>prefixBr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>endTerm</name> <operator>=</operator> <call><name><name>te</name><operator>.</operator><name>getTermNumber</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name><name>te</name><operator>.</operator><name>seek</name></name><argument_list>(<argument><expr><name>prefixBr</name></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name><name>TermsEnum</name><operator>.</operator><name>SeekStatus</name><operator>.</operator><name>END</name></name></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><name>endTerm</name> <operator>=</operator> <name>numTermsInField</name></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
          <expr_stmt><expr><name>endTerm</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <call><name><name>te</name><operator>.</operator><name>ord</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
       </block_content>}</block></if></if_stmt>
 
       <comment type="block" format="javadoc">/***********
@@ -514,13 +259,18 @@ public class UnInvertedField {
         docs = new BitDocSet(bs, maxDoc - baseSize);
         // simply negating will mean that we have deleted docs in the set.
         // that should be OK, as their entries in our table should be empty.
        //System.out.println("  NEG");
       }
 
       // For the biggest terms, do straight set intersections
       for (TopTerm tt : bigTerms.values()) {
        //System.out.println("  do big termNum=" + tt.termNum + " term=" + tt.term.utf8ToString());
         // TODO: counts could be deferred if sorted==false
         if (tt.termNum &gt;= startTerm &amp;&amp; tt.termNum &lt; endTerm) {
          counts[tt.termNum] = searcher.numDocs(new TermQuery(new Term(ti.field, tt.term)), docs);
          counts[tt.termNum] = searcher.numDocs(new TermQuery(new Term(field, tt.term)), docs);
          //System.out.println("    count=" + counts[tt.termNum]);
        } else {
          //System.out.println("SKIP term=" + tt.termNum);
         }
       }
 
@@ -537,9 +287,11 @@ public class UnInvertedField {
         DocIterator iter = docs.iterator();
         while (iter.hasNext()) {
           int doc = iter.nextDoc();
          //System.out.println("iter doc=" + doc);
           int code = index[doc];
 
           if ((code &amp; 0xff)==1) {
            //System.out.println("  ptr");
             int pos = code&gt;&gt;&gt;8;
             int whichArray = (doc &gt;&gt;&gt; 16) &amp; 0xff;
             byte[] arr = tnums[whichArray];
@@ -553,9 +305,11 @@ public class UnInvertedField {
               }
               if (delta == 0) break;
               tnum += delta - TNUM_OFFSET;
              //System.out.println("    tnum=" + tnum);
               counts[tnum]++;
             }
           } else {
            //System.out.println("  inlined");
             int tnum = 0;
             int delta = 0;
             for (;;) {
@@ -563,6 +317,7 @@ public class UnInvertedField {
               if ((code &amp; 0x80)==0) {
                 if (delta==0) break;
                 tnum += delta - TNUM_OFFSET;
                //System.out.println("    tnum=" + tnum);
                 counts[tnum]++;
                 delta = 0;
               }
@@ -583,6 +338,7 @@ public class UnInvertedField {
         LongPriorityQueue queue = new LongPriorityQueue(Math.min(maxsize,1000), maxsize, Long.MIN_VALUE);
 
         int min=mincount-1;  // the smallest value in the top 'N' values
        //System.out.println("START=" + startTerm + " END=" + endTerm);
         for (int i=startTerm; i&lt;endTerm; i++) {
           int c = doNegative ? maxTermCounts[i] - counts[i] : counts[i];
           if (c&gt;min) {
@@ -641,11 +397,14 @@ public class UnInvertedField {
           }
         });
 
        // convert the term numbers to term values and set as the label
        // convert the term numbers to term values and set
        // as the label
        //System.out.println("sortStart=" + sortedIdxStart + " end=" + sortedIdxEnd);
         for (int i=sortedIdxStart; i&lt;sortedIdxEnd; i++) {
           int idx = indirect[i];
           int tnum = (int)sorted[idx];
           String label = getReadableValue(getTermValue(te, tnum), ft, spare);
          //System.out.println("  label=" + label);
           res.setName(idx - sortedIdxStart, label);
         }
 
@@ -668,8 +427,6 @@ public class UnInvertedField {
           res.add(label, c);
         }
       }

      te.close();
     }
 
 
@@ -678,6 +435,8 @@ public class UnInvertedField {
       res.add(null, SimpleFacets.getFieldMissingCount(searcher, baseDocs, field));
     }
 
    //System.out.println("  res=" + res);

     return res;
   }
 
@@ -731,8 +490,7 @@ public class UnInvertedField {
     final int[] index = this.index;
     final int[] counts = new int[numTermsInField];//keep track of the number of times we see each word in the field for all the documents in the docset
 
    NumberedTermsEnum te = ti.getEnumerator(searcher.getIndexReader());

    TermsEnum te = getOrdTermsEnum(searcher.getIndexReader());
 
     boolean doNegative = false;
     if (finfo.length == 0) {
@@ -755,7 +513,7 @@ public class UnInvertedField {
     for (TopTerm tt : bigTerms.values()) {
       // TODO: counts could be deferred if sorted==false
       if (tt.termNum &gt;= 0 &amp;&amp; tt.termNum &lt; numTermsInField) {
        final Term t = new Term(ti.field, tt.term);
        final Term t = new Term(field, tt.term);
         if (finfo.length == 0) {
           counts[tt.termNum] = searcher.numDocs(new TermQuery(t), docs);
         } else {
@@ -836,7 +594,6 @@ public class UnInvertedField {
         f.accumulateTermNum(i, value);
       }
     }
    te.close();
 
     int c = missing.size();
     allstats.addMissing(c);
@@ -870,23 +627,26 @@ public class UnInvertedField {
   }
 
   /** may return a reused BytesRef */</comment>
  <function><type><name>BytesRef</name></type> <name>getTermValue</name><parameter_list>(<parameter><decl><type><name>NumberedTermsEnum</name></type> <name>te</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>termNum</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws> <block>{<block_content>
  <function><type><name>BytesRef</name></type> <name>getTermValue</name><parameter_list>(<parameter><decl><type><name>TermsEnum</name></type> <name>te</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>termNum</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws> <block>{<block_content>
    <comment type="line">//System.out.println("getTermValue termNum=" + termNum + " this=" + this + " numTerms=" + numTermsInField);</comment>
     <if_stmt><if>if <condition>(<expr><call><name><name>bigTerms</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
       <comment type="line">// see if the term is one of our big terms.</comment>
       <decl_stmt><decl><type><name>TopTerm</name></type> <name>tt</name> <init>= <expr><call><name><name>bigTerms</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>termNum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
       <if_stmt><if>if <condition>(<expr><name>tt</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
        <comment type="line">//System.out.println("  return big " + tt.term);</comment>
         <return>return <expr><name><name>tt</name><operator>.</operator><name>term</name></name></expr>;</return>
       </block_content>}</block></if></if_stmt>
     </block_content>}</block></if></if_stmt>
 
    <return>return <expr><call><name><name>te</name><operator>.</operator><name>skipTo</name></name><argument_list>(<argument><expr><name>termNum</name></expr></argument>)</argument_list></call></expr>;</return>
    <return>return <expr><call><name>lookupTerm</name><argument_list>(<argument><expr><name>te</name></expr></argument>, <argument><expr><name>termNum</name></expr></argument>)</argument_list></call></expr>;</return>
   </block_content>}</block></function>
 
   <function><annotation>@<name>Override</name></annotation>
   <type><specifier>public</specifier> <name>String</name></type> <name>toString</name><parameter_list>()</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><specifier>final</specifier> <name>long</name></type> <name>indexSize</name> <init>= <expr><ternary><condition><expr><name>indexedTermsArray</name> <operator>==</operator> <literal type="null">null</literal></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><operator>(</operator><literal type="number">8</literal><operator>+</operator><literal type="number">8</literal><operator>+</operator><literal type="number">8</literal><operator>+</operator><literal type="number">8</literal><operator>+</operator><operator>(</operator><name><name>indexedTermsArray</name><operator>.</operator><name>length</name></name><operator>&lt;&lt;</operator><literal type="number">3</literal><operator>)</operator><operator>+</operator><name>sizeOfIndexedStrings</name><operator>)</operator></expr></else></ternary></expr></init></decl>;</decl_stmt> <comment type="line">// assume 8 byte references?</comment>
     <return>return <expr><literal type="string">"{field="</literal> <operator>+</operator> <name>field</name>
             <operator>+</operator> <literal type="string">",memSize="</literal><operator>+</operator><call><name>memSize</name><argument_list>()</argument_list></call>
            <operator>+</operator> <literal type="string">",tindexSize="</literal><operator>+</operator><call><name><name>ti</name><operator>.</operator><name>memSize</name></name><argument_list>()</argument_list></call>
            <operator>+</operator> <literal type="string">",tindexSize="</literal><operator>+</operator><name>indexSize</name>
             <operator>+</operator> <literal type="string">",time="</literal><operator>+</operator><name>total_time</name>
             <operator>+</operator> <literal type="string">",phase1="</literal><operator>+</operator><name>phase1_time</name>
             <operator>+</operator> <literal type="string">",nTerms="</literal><operator>+</operator><name>numTermsInField</name>
@@ <operator>-</operator><literal type="number">896</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">656</literal></expr><operator>,</operator><expr><literal type="number">6</literal> @@ <specifier>public</specifier> <name>class</name> <name>UnInvertedField</name> <block>{
             <expr><operator>+</operator> <literal type="string">"}"</literal></expr>;
   }</block></expr></return>
 

   <comment type="line" format="doxygen">//////////////////////////////////////////////////////////////////</comment>
   <comment type="line" format="doxygen">//////////////////////////// caching /////////////////////////////</comment>
   <comment type="line" format="doxygen">//////////////////////////////////////////////////////////////////</comment>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">920</literal></expr><operator>,</operator><expr><literal type="number">287</literal> <operator>+</operator><literal type="number">679</literal></expr><operator>,</operator><expr><literal type="number">3</literal> @@ <specifier>public</specifier> <name>class</name> <name>UnInvertedField</name> <block>{
     <return>return <expr><name>uif</name></expr>;</return>
   }</block></expr></expr_stmt>
 </block_content>}</block></function>


<comment type="line">// How to share TermDocs (int[] score[])???</comment>
<comment type="line">// Hot to share TermPositions?</comment>
<comment type="block" format="javadoc">/***
class TermEnumListener {
  void doTerm(Term t) {
  }
  void done() {
  }
}
***/</comment>


<class>class <name>NumberedTermsEnum</name> <super_list><extends>extends <super><name>TermsEnum</name></super></extends></super_list> <block>{
  <decl_stmt><decl><type><specifier>protected</specifier> <specifier>final</specifier> <name>IndexReader</name></type> <name>reader</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>protected</specifier> <specifier>final</specifier> <name>TermIndex</name></type> <name>tindex</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>protected</specifier> <name>TermsEnum</name></type> <name>tenum</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>protected</specifier> <name>int</name></type> <name>pos</name><init>=<expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>protected</specifier> <name>BytesRef</name></type> <name>termText</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>protected</specifier> <name>DocsEnum</name></type> <name>docsEnum</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>protected</specifier> <name>Bits</name></type> <name>deletedDocs</name></decl>;</decl_stmt>


  <constructor><name>NumberedTermsEnum</name><parameter_list>(<parameter><decl><type><name>IndexReader</name></type> <name>reader</name></decl></parameter>, <parameter><decl><type><name>TermIndex</name></type> <name>tindex</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws> <block>{<block_content>
    <expr_stmt><expr><name><name>this</name><operator>.</operator><name>reader</name></name> <operator>=</operator> <name>reader</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>this</name><operator>.</operator><name>tindex</name></name> <operator>=</operator> <name>tindex</name></expr>;</expr_stmt>
  </block_content>}</block></constructor>


  <constructor><name>NumberedTermsEnum</name><parameter_list>(<parameter><decl><type><name>IndexReader</name></type> <name>reader</name></decl></parameter>, <parameter><decl><type><name>TermIndex</name></type> <name>tindex</name></decl></parameter>, <parameter><decl><type><name>BytesRef</name></type> <name>termValue</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pos</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws> <block>{<block_content>
    <expr_stmt><expr><name><name>this</name><operator>.</operator><name>reader</name></name> <operator>=</operator> <name>reader</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>this</name><operator>.</operator><name>tindex</name></name> <operator>=</operator> <name>tindex</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>this</name><operator>.</operator><name>pos</name></name> <operator>=</operator> <name>pos</name></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>Terms</name></type> <name>terms</name> <init>= <expr><call><name><name>MultiFields</name><operator>.</operator><name>getTerms</name></name><argument_list>(<argument><expr><name>reader</name></expr></argument>, <argument><expr><name><name>tindex</name><operator>.</operator><name>field</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>deletedDocs</name> <operator>=</operator> <call><name><name>MultiFields</name><operator>.</operator><name>getDeletedDocs</name></name><argument_list>(<argument><expr><name>reader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>terms</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>tenum</name> <operator>=</operator> <call><name><name>terms</name><operator>.</operator><name>iterator</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>tenum</name><operator>.</operator><name>seek</name></name><argument_list>(<argument><expr><name>termValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>setTerm</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></constructor>

  <function><annotation>@<name>Override</name></annotation>
  <type><specifier>public</specifier> <name><name>Comparator</name><argument_list type="generic">&lt;<argument><name>BytesRef</name></argument>&gt;</argument_list></name></type> <name>getComparator</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws> <block>{<block_content>
    <return>return <expr><call><name><name>tenum</name><operator>.</operator><name>getComparator</name></name><argument_list>()</argument_list></call></expr>;</return>
  </block_content>}</block></function>

  <function><type><specifier>public</specifier> <name>DocsEnum</name></type> <name>getDocsEnum</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws> <block>{<block_content>
    <expr_stmt><expr><name>docsEnum</name> <operator>=</operator> <call><name><name>tenum</name><operator>.</operator><name>docs</name></name><argument_list>(<argument><expr><name>deletedDocs</name></expr></argument>, <argument><expr><name>docsEnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>docsEnum</name></expr>;</return>
  </block_content>}</block></function>

  <function><type><specifier>protected</specifier> <name>BytesRef</name></type> <name>setTerm</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws> <block>{<block_content>
    <expr_stmt><expr><name>termText</name> <operator>=</operator> <call><name><name>tenum</name><operator>.</operator><name>term</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>tindex</name><operator>.</operator><name>prefix</name></name> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name><name>termText</name><operator>.</operator><name>startsWith</name></name><argument_list>(<argument><expr><name><name>tindex</name><operator>.</operator><name>prefix</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>termText</name> <operator>=</operator> <literal type="null">null</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>termText</name></expr>;</return>
  </block_content>}</block></function>

  <function><annotation>@<name>Override</name></annotation>
  <type><specifier>public</specifier> <name>BytesRef</name></type> <name>next</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws> <block>{<block_content>
    <expr_stmt><expr><name>pos</name><operator>++</operator></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name><name>tenum</name><operator>.</operator><name>next</name></name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>termText</name> <operator>=</operator> <literal type="null">null</literal></expr>;</expr_stmt>
      <return>return <expr><literal type="null">null</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><call><name>setTerm</name><argument_list>()</argument_list></call></expr>;</return>  <comment type="line">// this is extra work if we know we are in bounds...</comment>
  </block_content>}</block></function>

  <function><annotation>@<name>Override</name></annotation>
  <type><specifier>public</specifier> <name>BytesRef</name></type> <name>term</name><parameter_list>()</parameter_list> <block>{<block_content>
    <return>return <expr><name>termText</name></expr>;</return>
  </block_content>}</block></function>

  <function><annotation>@<name>Override</name></annotation>
  <type><specifier>public</specifier> <name>int</name></type> <name>docFreq</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws> <block>{<block_content>
    <return>return <expr><call><name><name>tenum</name><operator>.</operator><name>docFreq</name></name><argument_list>()</argument_list></call></expr>;</return>
  </block_content>}</block></function>

  <function><annotation>@<name>Override</name></annotation>
  <type><specifier>public</specifier> <name>long</name></type> <name>totalTermFreq</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws> <block>{<block_content>
    <return>return <expr><call><name><name>tenum</name><operator>.</operator><name>totalTermFreq</name></name><argument_list>()</argument_list></call></expr>;</return>
  </block_content>}</block></function>

  <function><type><specifier>public</specifier> <name>BytesRef</name></type> <name>skipTo</name><parameter_list>(<parameter><decl><type><name>BytesRef</name></type> <name>target</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws> <block>{<block_content>

    <comment type="line">// already here</comment>
    <if_stmt><if>if <condition>(<expr><name>termText</name> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <call><name><name>termText</name><operator>.</operator><name>equals</name></name><argument_list>(<argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>termText</name></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>tenum</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
      <return>return <expr><literal type="null">null</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <decl_stmt><decl><type><name>int</name></type> <name>startIdx</name> <init>= <expr><call><name><name>Arrays</name><operator>.</operator><name>binarySearch</name></name><argument_list>(<argument><expr><name><name>tindex</name><operator>.</operator><name>index</name></name></expr></argument>,<argument><expr><name>target</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>startIdx</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <comment type="line">// we hit the term exactly... lucky us!</comment>
      <decl_stmt><decl><type><name><name>TermsEnum</name><operator>.</operator><name>SeekStatus</name></name></type> <name>seekStatus</name> <init>= <expr><call><name><name>tenum</name><operator>.</operator><name>seek</name></name><argument_list>(<argument><expr><name>target</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <assert>assert <expr><name>seekStatus</name> <operator>==</operator> <name><name>TermsEnum</name><operator>.</operator><name>SeekStatus</name><operator>.</operator><name>FOUND</name></name></expr>;</assert>
      <expr_stmt><expr><name>pos</name> <operator>=</operator> <name>startIdx</name> <operator>&lt;&lt;</operator> <name><name>tindex</name><operator>.</operator><name>intervalBits</name></name></expr>;</expr_stmt>
      <return>return <expr><call><name>setTerm</name><argument_list>()</argument_list></call></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// we didn't hit the term exactly</comment>
    <expr_stmt><expr><name>startIdx</name><operator>=</operator><operator>-</operator><name>startIdx</name><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    
    <if_stmt><if>if <condition>(<expr><name>startIdx</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <comment type="line">// our target occurs *before* the first term</comment>
      <decl_stmt><decl><type><name><name>TermsEnum</name><operator>.</operator><name>SeekStatus</name></name></type> <name>seekStatus</name> <init>= <expr><call><name><name>tenum</name><operator>.</operator><name>seek</name></name><argument_list>(<argument><expr><name>target</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <assert>assert <expr><name>seekStatus</name> <operator>==</operator> <name><name>TermsEnum</name><operator>.</operator><name>SeekStatus</name><operator>.</operator><name>NOT_FOUND</name></name></expr>;</assert>
      <expr_stmt><expr><name>pos</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <return>return <expr><call><name>setTerm</name><argument_list>()</argument_list></call></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// back up to the start of the block</comment>
    <expr_stmt><expr><name>startIdx</name><operator>--</operator></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>pos</name> <operator>&gt;&gt;</operator> <name><name>tindex</name><operator>.</operator><name>intervalBits</name></name><operator>)</operator> <operator>==</operator> <name>startIdx</name> <operator>&amp;&amp;</operator> <name>termText</name> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <call><name><name>termText</name><operator>.</operator><name>compareTo</name></name><argument_list>(<argument><expr><name>target</name></expr></argument>)</argument_list></call><operator>&lt;=</operator><literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <comment type="line">// we are already in the right block and the current term is before the term we want,</comment>
      <comment type="line">// so we don't need to seek.</comment>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <comment type="line">// seek to the right block</comment>
      <decl_stmt><decl><type><name><name>TermsEnum</name><operator>.</operator><name>SeekStatus</name></name></type> <name>seekStatus</name> <init>= <expr><call><name><name>tenum</name><operator>.</operator><name>seek</name></name><argument_list>(<argument><expr><name><name>tindex</name><operator>.</operator><name>index</name><index>[<expr><name>startIdx</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <assert>assert <expr><name>seekStatus</name> <operator>==</operator> <name><name>TermsEnum</name><operator>.</operator><name>SeekStatus</name><operator>.</operator><name>FOUND</name></name></expr>;</assert>
      <expr_stmt><expr><name>pos</name> <operator>=</operator> <name>startIdx</name> <operator>&lt;&lt;</operator> <name><name>tindex</name><operator>.</operator><name>intervalBits</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>setTerm</name><argument_list>()</argument_list></call></expr>;</expr_stmt>  <comment type="line">// should be non-null since it's in the index</comment>
    </block_content>}</block></else></if_stmt>

    <while>while <condition>(<expr><name>termText</name> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <call><name><name>termText</name><operator>.</operator><name>compareTo</name></name><argument_list>(<argument><expr><name>target</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>next</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>

    <return>return <expr><name>termText</name></expr>;</return>
  </block_content>}</block></function>

  <function><type><specifier>public</specifier> <name>BytesRef</name></type> <name>skipTo</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>termNumber</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>delta</name> <init>= <expr><name>termNumber</name> <operator>-</operator> <name>pos</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>delta</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>delta</name> <operator>&gt;</operator> <name><name>tindex</name><operator>.</operator><name>interval</name></name> <operator>||</operator> <name>tenum</name><operator>==</operator><literal type="null">null</literal></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>idx</name> <init>= <expr><name>termNumber</name> <operator>&gt;&gt;&gt;</operator> <name><name>tindex</name><operator>.</operator><name>intervalBits</name></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>BytesRef</name></type> <name>base</name> <init>= <expr><name><name>tindex</name><operator>.</operator><name>index</name><index>[<expr><name>idx</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>pos</name> <operator>=</operator> <name>idx</name> <operator>&lt;&lt;</operator> <name><name>tindex</name><operator>.</operator><name>intervalBits</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>delta</name> <operator>=</operator> <name>termNumber</name> <operator>-</operator> <name>pos</name></expr>;</expr_stmt>
      <decl_stmt><decl><type><name><name>TermsEnum</name><operator>.</operator><name>SeekStatus</name></name></type> <name>seekStatus</name> <init>= <expr><call><name><name>tenum</name><operator>.</operator><name>seek</name></name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <assert>assert <expr><name>seekStatus</name> <operator>==</operator> <name><name>TermsEnum</name><operator>.</operator><name>SeekStatus</name><operator>.</operator><name>FOUND</name></name></expr>;</assert>
    </block_content>}</block></if></if_stmt>
    <while>while <condition>(<expr><operator>--</operator><name>delta</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>BytesRef</name></type> <name>br</name> <init>= <expr><call><name><name>tenum</name><operator>.</operator><name>next</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><name>br</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>termText</name> <operator>=</operator> <literal type="null">null</literal></expr>;</expr_stmt>
        <return>return <expr><literal type="null">null</literal></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><operator>++</operator><name>pos</name></expr>;</expr_stmt>
    </block_content>}</block></while>
    <return>return <expr><call><name>setTerm</name><argument_list>()</argument_list></call></expr>;</return>
  </block_content>}</block></function>

  <function><type><specifier>protected</specifier> <name>void</name></type> <name>close</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws> <block>{<block_content>
    <comment type="line">// no-op, needed so the anon subclass that does indexing</comment>
    <comment type="line">// can build its index</comment>
  </block_content>}</block></function>

  <comment type="block" format="javadoc">/** The current term number, starting at 0.
   * Only valid if the previous call to next() or skipTo() returned true.
   */</comment>
  <function><type><specifier>public</specifier> <name>int</name></type> <name>getTermNumber</name><parameter_list>()</parameter_list> <block>{<block_content>
    <return>return <expr><name>pos</name></expr>;</return>
  </block_content>}</block></function>

  <function><annotation>@<name>Override</name></annotation>
  <type><specifier>public</specifier> <name>long</name></type> <name>ord</name><parameter_list>()</parameter_list> <block>{<block_content>
    <throw>throw <expr><operator>new</operator> <call><name>UnsupportedOperationException</name><argument_list>()</argument_list></call></expr>;</throw>
  </block_content>}</block></function>

  <function><annotation>@<name>Override</name></annotation>
  <type><specifier>public</specifier> <name>SeekStatus</name></type> <name>seek</name><parameter_list>(<parameter><decl><type><name>long</name></type> <name>ord</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <throw>throw <expr><operator>new</operator> <call><name>UnsupportedOperationException</name><argument_list>()</argument_list></call></expr>;</throw>
  </block_content>}</block></function>

  <function><annotation>@<name>Override</name></annotation>
  <type><specifier>public</specifier> <name>DocsEnum</name></type> <name>docs</name><parameter_list>(<parameter><decl><type><name>Bits</name></type> <name>skipDocs</name></decl></parameter>, <parameter><decl><type><name>DocsEnum</name></type> <name>reuse</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <throw>throw <expr><operator>new</operator> <call><name>UnsupportedOperationException</name><argument_list>()</argument_list></call></expr>;</throw>
  </block_content>}</block></function>

  <function><annotation>@<name>Override</name></annotation>
  <type><specifier>public</specifier> <name>DocsAndPositionsEnum</name></type> <name>docsAndPositions</name><parameter_list>(<parameter><decl><type><name>Bits</name></type> <name>skipDocs</name></decl></parameter>, <parameter><decl><type><name>DocsAndPositionsEnum</name></type> <name>reuse</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <throw>throw <expr><operator>new</operator> <call><name>UnsupportedOperationException</name><argument_list>()</argument_list></call></expr>;</throw>
  </block_content>}</block></function>

  <function><annotation>@<name>Override</name></annotation>
  <type><specifier>public</specifier> <name>SeekStatus</name></type> <name>seek</name><parameter_list>(<parameter><decl><type><name>BytesRef</name></type> <name>target</name></decl></parameter>, <parameter><decl><type><name>boolean</name></type> <name>useCache</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <throw>throw <expr><operator>new</operator> <call><name>UnsupportedOperationException</name><argument_list>()</argument_list></call></expr>;</throw>
  </block_content>}</block></function>
}</block></class>


<comment type="block" format="javadoc">/**
 * Class to save memory by only storing every nth term (for random access), while
 * numbering the terms, allowing them to be retrieved later by number.
 * This is only valid when used with the IndexReader it was created with.
 * The IndexReader is not actually stored to facilitate caching by using it as a key in
 * a weak hash map.
 */</comment>
<class>class <name>TermIndex</name> <block>{
  <decl_stmt><decl><type><specifier>final</specifier> <specifier>static</specifier> <name>int</name></type> <name>intervalBits</name> <init>= <expr><literal type="number">7</literal></expr></init></decl>;</decl_stmt>  <comment type="line">// decrease to a low number like 2 for testing</comment>
  <decl_stmt><decl><type><specifier>final</specifier> <specifier>static</specifier> <name>int</name></type> <name>intervalMask</name> <init>= <expr><literal type="number">0xffffffff</literal> <operator>&gt;&gt;&gt;</operator> <operator>(</operator><literal type="number">32</literal><operator>-</operator><name>intervalBits</name><operator>)</operator></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>final</specifier> <specifier>static</specifier> <name>int</name></type> <name>interval</name> <init>= <expr><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>intervalBits</name></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><specifier>final</specifier> <name>String</name></type> <name>field</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>final</specifier> <name>BytesRef</name></type> <name>prefix</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>BytesRef</name><index>[]</index></name></type> <name>index</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nTerms</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>long</name></type> <name>sizeOfStrings</name></decl>;</decl_stmt>

  <constructor><name>TermIndex</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>field</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>this</name><argument_list>(<argument><expr><name>field</name></expr></argument>, <argument><expr><literal type="null">null</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></constructor>

  <constructor><name>TermIndex</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>field</name></decl></parameter>, <parameter><decl><type><name>String</name></type> <name>prefix</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><name><name>this</name><operator>.</operator><name>field</name></name> <operator>=</operator> <name>field</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>this</name><operator>.</operator><name>prefix</name></name> <operator>=</operator> <ternary><condition><expr><name>prefix</name> <operator>==</operator> <literal type="null">null</literal></expr> ?</condition><then> <expr><literal type="null">null</literal></expr> </then><else>: <expr><operator>new</operator> <call><name>BytesRef</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
  </block_content>}</block></constructor>

  <function><type><name>NumberedTermsEnum</name></type> <name>getEnumerator</name><parameter_list>(<parameter><decl><type><name>IndexReader</name></type> <name>reader</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>termNumber</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws> <block>{<block_content>
    <decl_stmt><decl><type><name>NumberedTermsEnum</name></type> <name>te</name> <init>= <expr><operator>new</operator> <call><name>NumberedTermsEnum</name><argument_list>(<argument><expr><name>reader</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>te</name><operator>.</operator><name>skipTo</name></name><argument_list>(<argument><expr><name>termNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>te</name></expr>;</return>
  </block_content>}</block></function>

  <comment type="block">/* The first time an enumerator is requested, it should be used
     with next() to fully traverse all of the terms so the index
     will be built.
   */</comment>
  <function><type><name>NumberedTermsEnum</name></type> <name>getEnumerator</name><parameter_list>(<parameter><decl><type><name>IndexReader</name></type> <name>reader</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>index</name><operator>==</operator><literal type="null">null</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>new</operator> <class><super><name>NumberedTermsEnum</name></super><argument_list>(<argument><expr><name>reader</name></expr></argument>,<argument><expr><name>this</name></expr></argument>, <argument><expr><ternary><condition><expr><name>prefix</name><operator>==</operator><literal type="null">null</literal></expr>?</condition><then><expr><operator>new</operator> <call><name>BytesRef</name><argument_list>()</argument_list></call></expr></then><else>:<expr><name>prefix</name></expr></else></ternary></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list> <block>{
      <decl_stmt><decl><type><name><name>ArrayList</name><argument_list type="generic">&lt;<argument><name>BytesRef</name></argument>&gt;</argument_list></name></type> <name>lst</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>PagedBytes</name></type> <name>bytes</name></decl>;</decl_stmt>

      <function><annotation>@<name>Override</name></annotation>
      <type><specifier>protected</specifier> <name>BytesRef</name></type> <name>setTerm</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws> <block>{<block_content>
        <decl_stmt><decl><type><name>BytesRef</name></type> <name>br</name> <init>= <expr><call><name><name>super</name><operator>.</operator><name>setTerm</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>br</name> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>pos</name> <operator>&amp;</operator> <name>intervalMask</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><name>sizeOfStrings</name> <operator>+=</operator> <name><name>br</name><operator>.</operator><name>length</name></name></expr>;</expr_stmt>
          <if_stmt><if>if <condition>(<expr><name>lst</name><operator>==</operator><literal type="null">null</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>lst</name> <operator>=</operator> <operator>new</operator> <call><name><name>ArrayList</name><argument_list type="generic">&lt;<argument><name>BytesRef</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>bytes</name> <operator>=</operator> <operator>new</operator> <call><name>PagedBytes</name><argument_list>(<argument><expr><literal type="number">15</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
          <decl_stmt><decl><type><name>BytesRef</name></type> <name>out</name> <init>= <expr><operator>new</operator> <call><name>BytesRef</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><call><name><name>bytes</name><operator>.</operator><name>copy</name></name><argument_list>(<argument><expr><name>br</name></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name><name>lst</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><name>br</name></expr>;</return>
      </block_content>}</block></function>

      <function><annotation>@<name>Override</name></annotation>
      <type><specifier>public</specifier> <name>BytesRef</name></type> <name>skipTo</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>termNumber</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws> <block>{<block_content>
        <throw>throw <expr><operator>new</operator> <call><name>UnsupportedOperationException</name><argument_list>()</argument_list></call></expr>;</throw>
      </block_content>}</block></function>

      <function><annotation>@<name>Override</name></annotation>
      <type><specifier>public</specifier> <name>void</name></type> <name>close</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws> <block>{<block_content>
        <expr_stmt><expr><name>nTerms</name><operator>=</operator><name>pos</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>super</name><operator>.</operator><name>close</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>index</name> <operator>=</operator> <ternary><condition><expr><name>lst</name><operator>!=</operator><literal type="null">null</literal></expr> ?</condition><then> <expr><call><name><name>lst</name><operator>.</operator><name>toArray</name></name><argument_list>(<argument><expr><operator>new</operator> <name><name>BytesRef</name><index>[<expr><call><name><name>lst</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>]</index></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><operator>new</operator> <name><name>BytesRef</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></else></ternary></expr>;</expr_stmt>
      </block_content>}</block></function>
    }</block></class></expr>;</return></block_content></block></if>
    <else>else<block type="pseudo"><block_content> <return>return <expr><operator>new</operator> <call><name>NumberedTermsEnum</name><argument_list>(<argument><expr><name>reader</name></expr></argument>,<argument><expr><name>this</name></expr></argument>,<argument><expr><operator>new</operator> <call><name>BytesRef</name><argument_list>()</argument_list></call></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
  </block_content>}</block></function>


  <comment type="block" format="javadoc">/**
   * Returns the approximate amount of memory taken by this TermIndex.
   * This is only an approximation and doesn't take into account java object overhead.
   *
   * @return
   * the approximate memory consumption in bytes
   */</comment>
  <function><type><specifier>public</specifier> <name>long</name></type> <name>memSize</name><parameter_list>()</parameter_list> <block>{<block_content>
    <comment type="line">// assume 8 byte references?</comment>
    <return>return <expr><literal type="number">8</literal><operator>+</operator><literal type="number">8</literal><operator>+</operator><literal type="number">8</literal><operator>+</operator><literal type="number">8</literal><operator>+</operator><operator>(</operator><name><name>index</name><operator>.</operator><name>length</name></name><operator>&lt;&lt;</operator><literal type="number">3</literal><operator>)</operator><operator>+</operator><name>sizeOfStrings</name></expr>;</return>
  </block_content>}</block></function>
}</block></class>

<expr_stmt><expr><name>diff</name> <operator>--</operator><name>git</name> <name>a</name><operator>/</operator><name>solr</name><operator>/</operator><name>src</name><operator>/</operator><name>test</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>request</name><operator>/</operator><name><name>TestFaceting</name><operator>.</operator><name>java</name></name> <name>b</name><operator>/</operator><name>solr</name><operator>/</operator><name>src</name><operator>/</operator><name>test</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>request</name><operator>/</operator><name><name>TestFaceting</name><operator>.</operator><name>java</name></name>
<name>index</name> <name>b9e1a5f8a9e</name><operator>..</operator><literal type="number">140de82e14a</literal> <literal type="number">100755</literal>
<operator>--</operator> <name>a</name><operator>/</operator><name>solr</name><operator>/</operator><name>src</name><operator>/</operator><name>test</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>request</name><operator>/</operator><name><name>TestFaceting</name><operator>.</operator><name>java</name></name>
<operator>++</operator> <name>b</name><operator>/</operator><name>solr</name><operator>/</operator><name>src</name><operator>/</operator><name>test</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>request</name><operator>/</operator><name><name>TestFaceting</name><operator>.</operator><name>java</name></name>
@@ <operator>-</operator><literal type="number">17</literal></expr><operator>,</operator><expr><literal type="number">14</literal> <operator>+</operator><literal type="number">17</literal></expr><operator>,</operator><expr><literal type="number">17</literal> @@</expr></expr_stmt>
 
 <package>package <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>request</name></name>;</package>
 
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>Locale</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>Random</name></name>;</import>

<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>index</name><operator>.</operator><name>DocTermOrds</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>index</name><operator>.</operator><name>Term</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>index</name><operator>.</operator><name>TermsEnum</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>util</name><operator>.</operator><name>BytesRef</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>SolrTestCaseJ4</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>junit</name><operator>.</operator><name>After</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>junit</name><operator>.</operator><name>BeforeClass</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>junit</name><operator>.</operator><name>Test</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>Locale</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>Random</name></name>;</import></block_content></block></function></block_content></block></if></if_stmt></block_content></block></function></block_content></block></if></if_stmt></block_content></block></for></block_content></block></function></block_content></block></function>
 
 <comment type="block" format="javadoc">/**
  * @version $Id$
@@ -62,43 +65,47 @@ public class TestFaceting extends SolrTestCaseJ4 {
   }
 
   void doTermEnum(int size) throws Exception {
    //System.out.println("doTermEnum size=" + size);
     close();
     createIndex(size);
     req = lrf.makeRequest("q","*:*");
 
    TermIndex ti = new TermIndex(proto.field());
    NumberedTermsEnum te = ti.getEnumerator(req.getSearcher().getIndexReader());
    UnInvertedField uif = new UnInvertedField(proto.field(), req.getSearcher());
 
    // iterate through first
    while(te.term() != null) te.next();
    assertEquals(size, te.getTermNumber());
    te.close();
    assertEquals(size, uif.getNumTerms());
 
    te = ti.getEnumerator(req.getSearcher().getIndexReader());
    TermsEnum te = uif.getOrdTermsEnum(req.getSearcher().getIndexReader());
    assertEquals(size == 0, te == null);
 
     Random r = new Random(size);
     // test seeking by term string
     for (int i=0; i&lt;size*2+10; i++) {
       int rnum = r.nextInt(size+2);
       String s = t(rnum);
      BytesRef br = te.skipTo(new BytesRef(s));
      //System.out.println("s=" + s);
      final BytesRef br;
      if (te == null) {
        br = null;
      } else {
        TermsEnum.SeekStatus status = te.seek(new BytesRef(s));
        if (status == TermsEnum.SeekStatus.END) {
          br = null;
        } else {
          br = te.term();
        }
      }
       assertEquals(br != null, rnum &lt; size);
       if (rnum &lt; size) {
        assertEquals(rnum, te.pos);
        assertEquals(rnum, (int) te.ord());
         assertEquals(s, te.term().utf8ToString());
      } else {
        assertEquals(null, te.term());
        assertEquals(size, te.getTermNumber());
       }
     }
 
     // test seeking before term
    assertEquals(size&gt;0, te.skipTo(new BytesRef("000")) != null);
    assertEquals(0, te.getTermNumber());
     if (size&gt;0) {
      assertEquals(size&gt;0, te.seek(new BytesRef("000"), true) != TermsEnum.SeekStatus.END);
      assertEquals(0, te.ord());
       assertEquals(t(0), te.term().utf8ToString());
    } else {
      assertEquals(null, te.term());
     }
 
     if (size&gt;0) {
@@ -106,9 +113,10 @@ public class TestFaceting extends SolrTestCaseJ4 {
       for (int i=0; i&lt;size*2+10; i++) {
         int rnum = r.nextInt(size);
         String s = t(rnum);
        BytesRef br = te.skipTo(rnum);
        assertTrue(te.seek((long) rnum) != TermsEnum.SeekStatus.END);
        BytesRef br = te.term();
         assertNotNull(br);
        assertEquals(rnum, te.pos);
        assertEquals(rnum, (int) te.ord());
         assertEquals(s, te.term().utf8ToString());
       }
     }
@@ -118,11 +126,12 @@ public class TestFaceting extends SolrTestCaseJ4 {
   public void testTermEnum() throws Exception {
     doTermEnum(0);
     doTermEnum(1);
    doTermEnum(TermIndex.interval - 1);  // test boundaries around the block size
    doTermEnum(TermIndex.interval);
    doTermEnum(TermIndex.interval + 1);
    doTermEnum(TermIndex.interval * 2 + 2);    
    // doTermEnum(TermIndex.interval * 3 + 3);    
    final int DEFAULT_INDEX_INTERVAL = 1 &lt;&lt; DocTermOrds.DEFAULT_INDEX_INTERVAL_BITS;
    doTermEnum(DEFAULT_INDEX_INTERVAL - 1);  // test boundaries around the block size
    doTermEnum(DEFAULT_INDEX_INTERVAL);
    doTermEnum(DEFAULT_INDEX_INTERVAL + 1);
    doTermEnum(DEFAULT_INDEX_INTERVAL * 2 + 2);    
    // doTermEnum(DEFAULT_INDEX_INTERVAL * 3 + 3);    
   }
 
   @Test
- 
2.19.1.windows.1

</comment></unit>
