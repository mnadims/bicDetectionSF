<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" revision="1.0.0" language="Java" filename="E:/01Courses@USASK/CMPT898-HumanDrivenSoftwareEngineeringForScientificResearch/ProjectProgress/data_files/final_dataset/gen_patch_codes/filtered/lucene/b895ebde43.java"><expr_stmt><expr><name>From</name> <name>b895ebde4340ed8ae903c7ae51750da3d9837394</name> <name>Mon</name> <name>Sep</name> <literal type="number">17</literal> <literal type="number">00</literal><operator>:</operator><literal type="number">00</literal><operator>:</operator><literal type="number">00</literal> <literal type="number">2001</literal>
<name>From</name><operator>:</operator> <name>Adrien</name> <name><name>Grand</name> <argument_list type="generic">&lt;<argument><name>jpountz</name><annotation>@<name><name>apache</name><operator>.</operator><name>org</name></name></annotation></argument>&gt;</argument_list></name>
<name>Date</name><operator>:</operator> <name>Fri</name></expr><operator>,</operator> <expr><literal type="number">3</literal> <name>May</name> <literal type="number">2013</literal> <literal type="number">13</literal><operator>:</operator><literal type="number">37</literal><operator>:</operator><literal type="number">45</literal> <operator>+</operator><literal type="number">0000</literal>
<name>Subject</name><operator>:</operator> <index>[<expr><name>PATCH</name></expr>]</index> <name>LUCENE</name><operator>-</operator><literal type="number">4946</literal><operator>:</operator> <name>Refactor</name> <call><name>SorterTemplate</name> <argument_list>(<argument><expr><name>now</name> <name>Sorter</name></expr></argument>)</argument_list></call><operator>.</operator>

<name>git</name><operator>-</operator><name>svn</name><operator>-</operator><name>id</name><operator>:</operator> <name>https</name><operator>:</operator><comment type="line">//svn.apache.org/repos/asf/lucene/dev/trunk@1478785 13f79535-47bb-0310-9956-ffa450edef68</comment>
<operator>--</operator>
 <name>lucene</name><operator>/</operator><name><name>CHANGES</name><operator>.</operator><name>txt</name></name>                            <operator>|</operator>   <literal type="number">4</literal> <operator>+</operator>
 <name>lucene</name><operator>/</operator><name><name>NOTICE</name><operator>.</operator><name>txt</name></name>                             <operator>|</operator>   <literal type="number">5</literal> <operator>-</operator>
 <operator>...</operator><operator>/</operator><name>index</name><operator>/</operator><name><name>ConcurrentMergeScheduler</name><operator>.</operator><name>java</name></name>       <operator>|</operator>   <literal type="number">2</literal> <operator>+</operator><operator>-</operator>
 <operator>...</operator><operator>/</operator><name>lucene</name><operator>/</operator><name>index</name><operator>/</operator><name><name>DocFieldProcessor</name><operator>.</operator><name>java</name></name>       <operator>|</operator>   <literal type="number">2</literal> <operator>+</operator><operator>-</operator>
 <operator>...</operator><operator>/</operator><name>lucene</name><operator>/</operator><name>index</name><operator>/</operator><name><name>FreqProxTermsWriter</name><operator>.</operator><name>java</name></name>     <operator>|</operator>   <literal type="number">2</literal> <operator>+</operator><operator>-</operator>
 <operator>...</operator><operator>/</operator><name>lucene</name><operator>/</operator><name>index</name><operator>/</operator><name><name>FrozenBufferedDeletes</name><operator>.</operator><name>java</name></name>   <operator>|</operator>   <literal type="number">2</literal> <operator>+</operator><operator>-</operator>
 <operator>...</operator><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>index</name><operator>/</operator><name><name>IndexFileDeleter</name><operator>.</operator><name>java</name></name> <operator>|</operator>   <literal type="number">2</literal> <operator>+</operator><operator>-</operator>
 <operator>...</operator><operator>/</operator><name>lucene</name><operator>/</operator><name>search</name><operator>/</operator><name><name>ConjunctionScorer</name><operator>.</operator><name>java</name></name>      <operator>|</operator>   <literal type="number">2</literal> <operator>+</operator><operator>-</operator>
 <operator>...</operator><operator>/</operator><name>search</name><operator>/</operator><name><name>MinShouldMatchSumScorer</name><operator>.</operator><name>java</name></name>       <operator>|</operator>   <literal type="number">2</literal> <operator>+</operator><operator>-</operator>
 <operator>...</operator><operator>/</operator><name>lucene</name><operator>/</operator><name>search</name><operator>/</operator><name><name>MultiPhraseQuery</name><operator>.</operator><name>java</name></name>       <operator>|</operator>   <literal type="number">2</literal> <operator>+</operator><operator>-</operator>
 <operator>...</operator><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>search</name><operator>/</operator><name><name>PhraseQuery</name><operator>.</operator><name>java</name></name> <operator>|</operator>   <literal type="number">2</literal> <operator>+</operator><operator>-</operator>
 <operator>...</operator><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>search</name><operator>/</operator><name><name>TopTermsRewrite</name><operator>.</operator><name>java</name></name> <operator>|</operator>   <literal type="number">2</literal> <operator>+</operator><operator>-</operator>
 <operator>...</operator><operator>/</operator><name>lucene</name><operator>/</operator><name>search</name><operator>/</operator><name>spans</name><operator>/</operator><name><name>NearSpansOrdered</name><operator>.</operator><name>java</name></name> <operator>|</operator>   <literal type="number">2</literal> <operator>+</operator><operator>-</operator>
 <operator>...</operator><operator>/</operator><name>lucene</name><operator>/</operator><name>util</name><operator>/</operator><name><name>ArrayInPlaceMergeSorter</name><operator>.</operator><name>java</name></name>  <operator>|</operator>  <literal type="number">47</literal> <operator>++</operator>
 <operator>...</operator><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>util</name><operator>/</operator><name><name>ArrayIntroSorter</name><operator>.</operator><name>java</name></name>  <operator>|</operator>  <literal type="number">59</literal> <operator>++</operator><operator>+</operator>
 <operator>...</operator><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>util</name><operator>/</operator><name><name>ArrayTimSorter</name><operator>.</operator><name>java</name></name>    <operator>|</operator>  <literal type="number">76</literal> <operator>++</operator><operator>+</operator>
 <operator>...</operator><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>util</name><operator>/</operator><name><name>ArrayUtil</name><operator>.</operator><name>java</name></name>     <operator>|</operator> <literal type="number">310</literal> <operator>++</operator><operator>--</operator><operator>--</operator><operator>--</operator><operator>--</operator><operator>--</operator>
 <operator>...</operator><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>util</name><operator>/</operator><name><name>BytesRefHash</name><operator>.</operator><name>java</name></name>  <operator>|</operator>   <literal type="number">4</literal> <operator>+</operator><operator>-</operator>
 <operator>...</operator><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>util</name><operator>/</operator><name><name>CollectionUtil</name><operator>.</operator><name>java</name></name>    <operator>|</operator> <literal type="number">258</literal> <operator>++</operator><operator>+</operator><operator>--</operator><operator>--</operator><operator>--</operator><operator>-</operator>
 <operator>...</operator><operator>/</operator><name>lucene</name><operator>/</operator><name>util</name><operator>/</operator><name><name>InPlaceMergeSorter</name><operator>.</operator><name>java</name></name>       <operator>|</operator>  <literal type="number">46</literal> <operator>++</operator>
 <operator>...</operator><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>util</name><operator>/</operator><name><name>IntroSorter</name><operator>.</operator><name>java</name></name>   <operator>|</operator>  <literal type="number">98</literal> <operator>++</operator><operator>++</operator>
 <operator>...</operator><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>util</name><operator>/</operator><name><name>Sorter</name><operator>.</operator><name>java</name></name>   <operator>|</operator> <literal type="number">248</literal> <operator>++</operator><operator>++</operator><operator>++</operator><operator>++</operator><operator>++</operator>
 <operator>...</operator><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>util</name><operator>/</operator><name><name>SorterTemplate</name><operator>.</operator><name>java</name></name>    <operator>|</operator> <literal type="number">445</literal> <operator>--</operator><operator>--</operator><operator>--</operator><operator>--</operator><operator>--</operator><operator>--</operator><operator>--</operator><operator>--</operator><operator>--</operator>
 <operator>...</operator><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>util</name><operator>/</operator><name><name>TimSorter</name><operator>.</operator><name>java</name></name>     <operator>|</operator> <literal type="number">373</literal> <operator>++</operator><operator>++</operator><operator>++</operator><operator>++</operator><operator>++</operator><operator>++</operator><operator>++</operator><operator>+</operator>
 <operator>...</operator><operator>/</operator><name>util</name><operator>/</operator><name>automaton</name><operator>/</operator><name><name>BasicOperations</name><operator>.</operator><name>java</name></name>       <operator>|</operator>   <literal type="number">4</literal> <operator>+</operator><operator>-</operator>
 <operator>...</operator><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>util</name><operator>/</operator><name>automaton</name><operator>/</operator><name><name>State</name><operator>.</operator><name>java</name></name>   <operator>|</operator>   <literal type="number">2</literal> <operator>+</operator><operator>-</operator>
 <operator>...</operator><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>util</name><operator>/</operator><name><name>BaseSortTestCase</name><operator>.</operator><name>java</name></name>  <operator>|</operator> <literal type="number">173</literal> <operator>++</operator><operator>++</operator><operator>++</operator><operator>+</operator>
 <operator>...</operator><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>util</name><operator>/</operator><name><name>TestArrayUtil</name><operator>.</operator><name>java</name></name> <operator>|</operator>  <literal type="number">84</literal> <operator>+</operator><operator>--</operator><operator>-</operator>
 <operator>...</operator><operator>/</operator><name>lucene</name><operator>/</operator><name>util</name><operator>/</operator><name><name>TestCollectionUtil</name><operator>.</operator><name>java</name></name>       <operator>|</operator>  <literal type="number">95</literal> <operator>+</operator><operator>--</operator><operator>-</operator>
 <operator>...</operator><operator>/</operator><name>lucene</name><operator>/</operator><name>util</name><operator>/</operator><name><name>TestInPlaceMergeSorter</name><operator>.</operator><name>java</name></name>   <operator>|</operator>  <literal type="number">36</literal> <operator>++</operator>
 <operator>...</operator><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>util</name><operator>/</operator><name><name>TestIntroSorter</name><operator>.</operator><name>java</name></name>   <operator>|</operator>  <literal type="number">32</literal> <operator>++</operator>
 <operator>...</operator><operator>/</operator><name>lucene</name><operator>/</operator><name>util</name><operator>/</operator><name><name>TestSorterTemplate</name><operator>.</operator><name>java</name></name>       <operator>|</operator> <literal type="number">181</literal> <operator>--</operator><operator>--</operator><operator>--</operator><operator>-</operator>
 <operator>...</operator><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>util</name><operator>/</operator><name><name>TestTimSorter</name><operator>.</operator><name>java</name></name> <operator>|</operator>  <literal type="number">31</literal> <operator>++</operator>
 <operator>...</operator><operator>/</operator><name>facet</name><operator>/</operator><name>search</name><operator>/</operator><name><name>TestDrillSideways</name><operator>.</operator><name>java</name></name>       <operator>|</operator>  <literal type="number">27</literal> <operator>+</operator><operator>-</operator>
 <operator>...</operator><operator>/</operator><name>lucene</name><operator>/</operator><name>search</name><operator>/</operator><name>highlight</name><operator>/</operator><name><name>TokenSources</name><operator>.</operator><name>java</name></name> <operator>|</operator>   <literal type="number">2</literal> <operator>+</operator><operator>-</operator>
 <operator>...</operator><operator>/</operator><name><name>TokenStreamFromTermPositionVector</name><operator>.</operator><name>java</name></name>    <operator>|</operator>   <literal type="number">2</literal> <operator>+</operator><operator>-</operator>
 <operator>...</operator><operator>/</operator><name>search</name><operator>/</operator><name>postingshighlight</name><operator>/</operator><name><name>Passage</name><operator>.</operator><name>java</name></name>     <operator>|</operator>  <literal type="number">17</literal> <operator>+</operator><operator>-</operator>
 <operator>...</operator><operator>/</operator><name><name>PostingsHighlighter</name><operator>.</operator><name>java</name></name>                  <operator>|</operator>  <literal type="number">19</literal> <operator>+</operator><operator>-</operator>
 <operator>...</operator><operator>/</operator><name>lucene</name><operator>/</operator><name>index</name><operator>/</operator><name>memory</name><operator>/</operator><name><name>MemoryIndex</name><operator>.</operator><name>java</name></name>      <operator>|</operator>   <literal type="number">2</literal> <operator>+</operator><operator>-</operator>
 <operator>...</operator><operator>/</operator><name>lucene</name><operator>/</operator><name>index</name><operator>/</operator><name><name>CompoundFileExtractor</name><operator>.</operator><name>java</name></name>   <operator>|</operator>   <literal type="number">2</literal> <operator>+</operator><operator>-</operator>
 <operator>...</operator><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>index</name><operator>/</operator><name>sorter</name><operator>/</operator><name><name>Sorter</name><operator>.</operator><name>java</name></name>    <operator>|</operator>  <literal type="number">45</literal> <operator>+</operator><operator>-</operator>
 <operator>...</operator><operator>/</operator><name>index</name><operator>/</operator><name>sorter</name><operator>/</operator><name><name>SortingAtomicReader</name><operator>.</operator><name>java</name></name>     <operator>|</operator> <literal type="number">152</literal> <operator>++</operator><operator>++</operator><operator>--</operator>
 <operator>...</operator><operator>/</operator><name>search</name><operator>/</operator><name>spell</name><operator>/</operator><name><name>DirectSpellChecker</name><operator>.</operator><name>java</name></name>      <operator>|</operator>   <literal type="number">2</literal> <operator>+</operator><operator>-</operator>
 <operator>...</operator><operator>/</operator><name>lucene</name><operator>/</operator><name>search</name><operator>/</operator><name>suggest</name><operator>/</operator><name><name>BytesRefArray</name><operator>.</operator><name>java</name></name>  <operator>|</operator>   <literal type="number">8</literal> <operator>+</operator><operator>-</operator>
 <operator>...</operator><operator>/</operator><name>handler</name><operator>/</operator><name><name>AnalysisRequestHandlerBase</name><operator>.</operator><name>java</name></name>   <operator>|</operator>   <literal type="number">2</literal> <operator>+</operator><operator>-</operator>
 <literal type="number">45</literal> <name>files</name> <name>changed</name></expr><operator>,</operator> <expr><literal type="number">1514</literal> <call><name>insertions</name><argument_list>(<argument><expr><operator>+</operator></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><literal type="number">1399</literal> <call><name>deletions</name><argument_list>(<argument><expr><operator>-</operator></expr></argument>)</argument_list></call>
 <name>create</name> <name>mode</name> <literal type="number">100644</literal> <name>lucene</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>util</name><operator>/</operator><name><name>ArrayInPlaceMergeSorter</name><operator>.</operator><name>java</name></name>
 <name>create</name> <name>mode</name> <literal type="number">100644</literal> <name>lucene</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>util</name><operator>/</operator><name><name>ArrayIntroSorter</name><operator>.</operator><name>java</name></name>
 <name>create</name> <name>mode</name> <literal type="number">100644</literal> <name>lucene</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>util</name><operator>/</operator><name><name>ArrayTimSorter</name><operator>.</operator><name>java</name></name>
 <name>create</name> <name>mode</name> <literal type="number">100644</literal> <name>lucene</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>util</name><operator>/</operator><name><name>InPlaceMergeSorter</name><operator>.</operator><name>java</name></name>
 <name>create</name> <name>mode</name> <literal type="number">100644</literal> <name>lucene</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>util</name><operator>/</operator><name><name>IntroSorter</name><operator>.</operator><name>java</name></name>
 <name>create</name> <name>mode</name> <literal type="number">100644</literal> <name>lucene</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>util</name><operator>/</operator><name><name>Sorter</name><operator>.</operator><name>java</name></name>
 <name>delete</name> <name>mode</name> <literal type="number">100644</literal> <name>lucene</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>util</name><operator>/</operator><name><name>SorterTemplate</name><operator>.</operator><name>java</name></name>
 <name>create</name> <name>mode</name> <literal type="number">100644</literal> <name>lucene</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>util</name><operator>/</operator><name><name>TimSorter</name><operator>.</operator><name>java</name></name>
 <name>create</name> <name>mode</name> <literal type="number">100644</literal> <name>lucene</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>test</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>util</name><operator>/</operator><name><name>BaseSortTestCase</name><operator>.</operator><name>java</name></name>
 <name>create</name> <name>mode</name> <literal type="number">100644</literal> <name>lucene</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>test</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>util</name><operator>/</operator><name><name>TestInPlaceMergeSorter</name><operator>.</operator><name>java</name></name>
 <name>create</name> <name>mode</name> <literal type="number">100644</literal> <name>lucene</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>test</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>util</name><operator>/</operator><name><name>TestIntroSorter</name><operator>.</operator><name>java</name></name>
 <name>delete</name> <name>mode</name> <literal type="number">100644</literal> <name>lucene</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>test</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>util</name><operator>/</operator><name><name>TestSorterTemplate</name><operator>.</operator><name>java</name></name>
 <name>create</name> <name>mode</name> <literal type="number">100644</literal> <name>lucene</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>test</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>util</name><operator>/</operator><name><name>TestTimSorter</name><operator>.</operator><name>java</name></name>

<name>diff</name> <operator>--</operator><name>git</name> <name>a</name><operator>/</operator><name>lucene</name><operator>/</operator><name><name>CHANGES</name><operator>.</operator><name>txt</name></name> <name>b</name><operator>/</operator><name>lucene</name><operator>/</operator><name><name>CHANGES</name><operator>.</operator><name>txt</name></name>
<name>index</name> <literal type="number">00848553c14</literal><operator>..</operator><literal type="number">28b1536c704</literal> <literal type="number">100644</literal>
<operator>--</operator> <name>a</name><operator>/</operator><name>lucene</name><operator>/</operator><name><name>CHANGES</name><operator>.</operator><name>txt</name></name>
<operator>++</operator> <name>b</name><operator>/</operator><name>lucene</name><operator>/</operator><name><name>CHANGES</name><operator>.</operator><name>txt</name></name>
@@ <operator>-</operator><literal type="number">55</literal></expr><operator>,</operator><expr><literal type="number">6</literal> <operator>+</operator><literal type="number">55</literal></expr><operator>,</operator><expr><literal type="number">10</literal> @@ <name>Changes</name> <name>in</name> <name>backwards</name> <name>compatibility</name> <name>policy</name>
 <operator>*</operator> <name>LUCENE</name><operator>-</operator><literal type="number">4973</literal><operator>:</operator> <name>SnapshotDeletionPolicy</name> <name>no</name> <name>longer</name> <name>requires</name> <name>a</name> <name>unique</name>
   <name>String</name> <call><name>id</name> <argument_list>(<argument><expr><name>Mike</name> <name>McCandless</name></expr></argument>, <argument><expr><name>Shai</name> <name>Erera</name></expr></argument>)</argument_list></call>
 
<operator>*</operator> <name>LUCENE</name><operator>-</operator><literal type="number">4946</literal><operator>:</operator> <name>The</name> <name>internal</name> <name>sorting</name> <call><name>API</name> <argument_list>(<argument><expr><name>SorterTemplate</name></expr></argument>, <argument><expr><name>now</name> <name>Sorter</name></expr></argument>)</argument_list></call> <name>has</name> <name>been</name>
  <name>completely</name> <name>refactored</name> <name>to</name> <name>allow</name></expr></expr_stmt> <for>for a better implementation of TimSort.
  <control>(<init><decl><type><name>Adrien</name></type> <name>Grand</name></decl>, <decl><type ref="prev"/><name>Uwe</name> <name>Schindler</name></decl>, <decl><type ref="prev"/><name>Dawid</name> <name>Weiss</name></decl></init>)</control><block type="pseudo"><block_content>

 <expr_stmt><expr><name>Bug</name> <name>Fixes</name>
 
 <operator>*</operator> <name>LUCENE</name><operator>-</operator><literal type="number">4935</literal><operator>:</operator> <name>CustomScoreQuery</name> <name>wrongly</name> <name>applied</name> <name>its</name> <name>query</name> <name>boost</name> <name>twice</name> 
<name>diff</name> <operator>--</operator><name>git</name> <name>a</name><operator>/</operator><name>lucene</name><operator>/</operator><name><name>NOTICE</name><operator>.</operator><name>txt</name></name> <name>b</name><operator>/</operator><name>lucene</name><operator>/</operator><name><name>NOTICE</name><operator>.</operator><name>txt</name></name>
<name>index</name> <literal type="number">34978650156..0cf70cb5ee2</literal> <literal type="number">100644</literal>
<operator>--</operator> <name>a</name><operator>/</operator><name>lucene</name><operator>/</operator><name><name>NOTICE</name><operator>.</operator><name>txt</name></name>
<operator>++</operator> <name>b</name><operator>/</operator><name>lucene</name><operator>/</operator><name><name>NOTICE</name><operator>.</operator><name>txt</name></name>
@@ <operator>-</operator><literal type="number">27</literal></expr><operator>,</operator><expr><literal type="number">11</literal> <operator>+</operator><literal type="number">27</literal></expr><operator>,</operator><expr><literal type="number">6</literal> @@ <name>Jean</name><operator>-</operator><name>Philippe</name> <name>Barrette</name><operator>-</operator><name><name>LaPierre</name><operator>.</operator> <name>This</name></name> <name>library</name> <name>is</name> <name>available</name> <name>under</name> <name>an</name> <name>MIT</name> <name>license</name></expr><operator>,</operator>
 <expr><name>see</name> <name>http</name><operator>:</operator><comment type="line">//sites.google.com/site/rrettesite/moman and </comment>
 <name>http</name><operator>:</operator><comment type="line">//bitbucket.org/jpbarrette/moman/overview/</comment>
 
<name>The</name> <name>class</name> <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>util</name><operator>.</operator><name>SorterTemplate</name></name> <name>was</name> <name>inspired</name> <name>by</name> <name>CGLIB</name><literal type="char">'s class
with the same name. The implementation part is mainly done using pre-existing
Lucene sorting code. In-place stable mergesort was borrowed from CGLIB,
which is Apache-licensed.

 The class org.apache.lucene.util.WeakIdentityMap was derived from
 the Apache CXF project and is Apache License 2.0.
 
diff --git a/lucene/core/src/java/org/apache/lucene/index/ConcurrentMergeScheduler.java b/lucene/core/src/java/org/apache/lucene/index/ConcurrentMergeScheduler.java
index ddda077e432..42212ec23e5 100644
-- a/lucene/core/src/java/org/apache/lucene/index/ConcurrentMergeScheduler.java
++ b/lucene/core/src/java/org/apache/lucene/index/ConcurrentMergeScheduler.java
@@ -184,7 +184,7 @@ public class ConcurrentMergeScheduler extends MergeScheduler {
     }
 
     // Sort the merge threads in descending order.
    CollectionUtil.mergeSort(activeMerges, compareByMergeDocCount);
    CollectionUtil.timSort(activeMerges, compareByMergeDocCount);
     
     int pri = mergeThreadPriority;
     final int activeMergeCount = activeMerges.size();
diff --git a/lucene/core/src/java/org/apache/lucene/index/DocFieldProcessor.java b/lucene/core/src/java/org/apache/lucene/index/DocFieldProcessor.java
index 30a4fe461e4..5584dfdbd40 100644
-- a/lucene/core/src/java/org/apache/lucene/index/DocFieldProcessor.java
++ b/lucene/core/src/java/org/apache/lucene/index/DocFieldProcessor.java
@@ -213,7 +213,7 @@ final class DocFieldProcessor extends DocConsumer {
     // sort the subset of fields that have vectors
     // enabled; we could save [small amount of] CPU
     // here.
    ArrayUtil.quickSort(fields, 0, fieldCount, fieldsComp);
    ArrayUtil.introSort(fields, 0, fieldCount, fieldsComp);
     for(int i=0;i&lt;fieldCount;i++) {
       final DocFieldProcessorPerField perField = fields[i];
       perField.consumer.processFields(perField.fields, perField.fieldCount);
diff --git a/lucene/core/src/java/org/apache/lucene/index/FreqProxTermsWriter.java b/lucene/core/src/java/org/apache/lucene/index/FreqProxTermsWriter.java
index 6937a09a521..476ac2aecd7 100644
-- a/lucene/core/src/java/org/apache/lucene/index/FreqProxTermsWriter.java
++ b/lucene/core/src/java/org/apache/lucene/index/FreqProxTermsWriter.java
@@ -54,7 +54,7 @@ final class FreqProxTermsWriter extends TermsHashConsumer {
     final int numAllFields = allFields.size();
 
     // Sort by field name
    CollectionUtil.quickSort(allFields);
    CollectionUtil.introSort(allFields);
 
     final FieldsConsumer consumer = state.segmentInfo.getCodec().postingsFormat().fieldsConsumer(state);
 
diff --git a/lucene/core/src/java/org/apache/lucene/index/FrozenBufferedDeletes.java b/lucene/core/src/java/org/apache/lucene/index/FrozenBufferedDeletes.java
index 916a53f98e7..7362957dd9d 100644
-- a/lucene/core/src/java/org/apache/lucene/index/FrozenBufferedDeletes.java
++ b/lucene/core/src/java/org/apache/lucene/index/FrozenBufferedDeletes.java
@@ -56,7 +56,7 @@ class FrozenBufferedDeletes {
     assert !isSegmentPrivate || deletes.terms.size() == 0 : "segment private package should only have del queries"; 
     Term termsArray[] = deletes.terms.keySet().toArray(new Term[deletes.terms.size()]);
     termCount = termsArray.length;
    ArrayUtil.mergeSort(termsArray);
    ArrayUtil.timSort(termsArray);
     PrefixCodedTerms.Builder builder = new PrefixCodedTerms.Builder();
     for (Term term : termsArray) {
       builder.add(term);
diff --git a/lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter.java b/lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter.java
index 9e8dc76f0c6..c6ec5d03e23 100644
-- a/lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter.java
++ b/lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter.java
@@ -232,7 +232,7 @@ final class IndexFileDeleter implements Closeable {
     }
 
     // We keep commits list in sorted order (oldest to newest):
    CollectionUtil.mergeSort(commits);
    CollectionUtil.timSort(commits);
 
     // Now delete anything with ref count at 0.  These are
     // presumably abandoned files eg due to crash of
diff --git a/lucene/core/src/java/org/apache/lucene/search/ConjunctionScorer.java b/lucene/core/src/java/org/apache/lucene/search/ConjunctionScorer.java
index d285c481c27..22476e777b6 100644
-- a/lucene/core/src/java/org/apache/lucene/search/ConjunctionScorer.java
++ b/lucene/core/src/java/org/apache/lucene/search/ConjunctionScorer.java
@@ -44,7 +44,7 @@ class ConjunctionScorer extends Scorer {
     }
     // Sort the array the first time to allow the least frequent DocsEnum to
     // lead the matching.
    ArrayUtil.mergeSort(docsAndFreqs, new Comparator&lt;DocsAndFreqs&gt;() {
    ArrayUtil.timSort(docsAndFreqs, new Comparator&lt;DocsAndFreqs&gt;() {
       @Override
       public int compare(DocsAndFreqs o1, DocsAndFreqs o2) {
         return Long.compare(o1.cost, o2.cost);
diff --git a/lucene/core/src/java/org/apache/lucene/search/MinShouldMatchSumScorer.java b/lucene/core/src/java/org/apache/lucene/search/MinShouldMatchSumScorer.java
index 5b88e5fd9a9..061ebcc499b 100644
-- a/lucene/core/src/java/org/apache/lucene/search/MinShouldMatchSumScorer.java
++ b/lucene/core/src/java/org/apache/lucene/search/MinShouldMatchSumScorer.java
@@ -87,7 +87,7 @@ class MinShouldMatchSumScorer extends Scorer {
     this.sortedSubScorers = subScorers.toArray(new Scorer[this.numScorers]);
     // sorting by decreasing subscorer cost should be inversely correlated with
     // next docid (assuming costs are due to generating many postings)
    ArrayUtil.mergeSort(sortedSubScorers, new Comparator&lt;Scorer&gt;() {
    ArrayUtil.timSort(sortedSubScorers, new Comparator&lt;Scorer&gt;() {
       @Override
       public int compare(Scorer o1, Scorer o2) {
         return Long.signum(o2.cost() - o1.cost());
diff --git a/lucene/core/src/java/org/apache/lucene/search/MultiPhraseQuery.java b/lucene/core/src/java/org/apache/lucene/search/MultiPhraseQuery.java
index 0bcac051f1e..ce446a82049 100644
-- a/lucene/core/src/java/org/apache/lucene/search/MultiPhraseQuery.java
++ b/lucene/core/src/java/org/apache/lucene/search/MultiPhraseQuery.java
@@ -241,7 +241,7 @@ public class MultiPhraseQuery extends Query {
 
       // sort by increasing docFreq order
       if (slop == 0) {
        ArrayUtil.mergeSort(postingsFreqs);
        ArrayUtil.timSort(postingsFreqs);
       }
 
       if (slop == 0) {
diff --git a/lucene/core/src/java/org/apache/lucene/search/PhraseQuery.java b/lucene/core/src/java/org/apache/lucene/search/PhraseQuery.java
index 5ee4c8a56a5..0911af45b7c 100644
-- a/lucene/core/src/java/org/apache/lucene/search/PhraseQuery.java
++ b/lucene/core/src/java/org/apache/lucene/search/PhraseQuery.java
@@ -278,7 +278,7 @@ public class PhraseQuery extends Query {
 
       // sort by increasing docFreq order
       if (slop == 0) {
        ArrayUtil.mergeSort(postingsFreqs);
        ArrayUtil.timSort(postingsFreqs);
       }
 
       if (slop == 0) {  // optimize exact case
diff --git a/lucene/core/src/java/org/apache/lucene/search/TopTermsRewrite.java b/lucene/core/src/java/org/apache/lucene/search/TopTermsRewrite.java
index 3e0cc556c57..b3c6ec4b09a 100644
-- a/lucene/core/src/java/org/apache/lucene/search/TopTermsRewrite.java
++ b/lucene/core/src/java/org/apache/lucene/search/TopTermsRewrite.java
@@ -156,7 +156,7 @@ public abstract class TopTermsRewrite&lt;Q extends Query&gt; extends TermCollectingRew
     
     final Q q = getTopLevelQuery();
     final ScoreTerm[] scoreTerms = stQueue.toArray(new ScoreTerm[stQueue.size()]);
    ArrayUtil.mergeSort(scoreTerms, scoreTermSortByTermComp);
    ArrayUtil.timSort(scoreTerms, scoreTermSortByTermComp);
     
     for (final ScoreTerm st : scoreTerms) {
       final Term term = new Term(query.field, st.bytes);
diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/NearSpansOrdered.java b/lucene/core/src/java/org/apache/lucene/search/spans/NearSpansOrdered.java
index 959253ab5bb..1ee44a566af 100644
-- a/lucene/core/src/java/org/apache/lucene/search/spans/NearSpansOrdered.java
++ b/lucene/core/src/java/org/apache/lucene/search/spans/NearSpansOrdered.java
@@ -204,7 +204,7 @@ public class NearSpansOrdered extends Spans {
 
   /** Advance the subSpans to the same document */
   private boolean toSameDoc() throws IOException {
    ArrayUtil.mergeSort(subSpansByDoc, spanDocComparator);
    ArrayUtil.timSort(subSpansByDoc, spanDocComparator);
     int firstIndex = 0;
     int maxDoc = subSpansByDoc[subSpansByDoc.length - 1].doc();
     while (subSpansByDoc[firstIndex].doc() != maxDoc) {
diff --git a/lucene/core/src/java/org/apache/lucene/util/ArrayInPlaceMergeSorter.java b/lucene/core/src/java/org/apache/lucene/util/ArrayInPlaceMergeSorter.java
new file mode 100644
index 00000000000..cacaceefbb6
-- /dev/null
++ b/lucene/core/src/java/org/apache/lucene/util/ArrayInPlaceMergeSorter.java
@@ -0,0 +1,47 @@
package org.apache.lucene.util;

/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import java.util.Comparator;

/**
 * An {@link InPlaceMergeSorter} for object arrays.
 * @lucene.internal
 */
final class ArrayInPlaceMergeSorter&lt;T&gt; extends InPlaceMergeSorter {

  private final T[] arr;
  private final Comparator&lt;? super T&gt; comparator;

  /** Create a new {@link ArrayInPlaceMergeSorter}. */
  public ArrayInPlaceMergeSorter(T[] arr, Comparator&lt;? super T&gt; comparator) {
    this.arr = arr;
    this.comparator = comparator;
  }

  @Override
  protected int compare(int i, int j) {
    return comparator.compare(arr[i], arr[j]);
  }

  @Override
  protected void swap(int i, int j) {
    ArrayUtil.swap(arr, i, j);
  }

}
diff --git a/lucene/core/src/java/org/apache/lucene/util/ArrayIntroSorter.java b/lucene/core/src/java/org/apache/lucene/util/ArrayIntroSorter.java
new file mode 100644
index 00000000000..072abf54367
-- /dev/null
++ b/lucene/core/src/java/org/apache/lucene/util/ArrayIntroSorter.java
@@ -0,0 +1,59 @@
package org.apache.lucene.util;

/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import java.util.Comparator;

/**
 * An {@link IntroSorter} for object arrays.
 * @lucene.internal
 */
final class ArrayIntroSorter&lt;T&gt; extends IntroSorter {

  private final T[] arr;
  private final Comparator&lt;? super T&gt; comparator;
  private T pivot;

  /** Create a new {@link ArrayInPlaceMergeSorter}. */
  public ArrayIntroSorter(T[] arr, Comparator&lt;? super T&gt; comparator) {
    this.arr = arr;
    this.comparator = comparator;
    pivot = null;
  }

  @Override
  protected int compare(int i, int j) {
    return comparator.compare(arr[i], arr[j]);
  }

  @Override
  protected void swap(int i, int j) {
    ArrayUtil.swap(arr, i, j);
  }

  @Override
  protected void setPivot(int i) {
    pivot = arr[i];
  }

  @Override
  protected int comparePivot(int i) {
    return comparator.compare(pivot, arr[i]);
  }

}
diff --git a/lucene/core/src/java/org/apache/lucene/util/ArrayTimSorter.java b/lucene/core/src/java/org/apache/lucene/util/ArrayTimSorter.java
new file mode 100644
index 00000000000..a9befe16b9e
-- /dev/null
++ b/lucene/core/src/java/org/apache/lucene/util/ArrayTimSorter.java
@@ -0,0 +1,76 @@
package org.apache.lucene.util;

/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import java.util.Comparator;

/**
 * A {@link TimSorter} for object arrays.
 * @lucene.internal
 */
final class ArrayTimSorter&lt;T&gt; extends TimSorter {

  private final Comparator&lt;? super T&gt; comparator;
  private final T[] arr;
  private final T[] tmp;

  /** Create a new {@link ArrayTimSorter}. */
  public ArrayTimSorter(T[] arr, Comparator&lt;? super T&gt; comparator, int maxTempSlots) {
    super(maxTempSlots);
    this.arr = arr;
    this.comparator = comparator;
    if (maxTempSlots &gt; 0) {
      @SuppressWarnings("unchecked")
      final T[] tmp = (T[]) new Object[maxTempSlots];
      this.tmp = tmp;
    } else {
      this.tmp = null;
    }
  }

  @Override
  protected int compare(int i, int j) {
    return comparator.compare(arr[i], arr[j]);
  }

  @Override
  protected void swap(int i, int j) {
    ArrayUtil.swap(arr, i, j);
  }

  @Override
  protected void copy(int src, int dest) {
    arr[dest] = arr[src];
  }

  @Override
  protected void save(int start, int len) {
    System.arraycopy(arr, start, tmp, 0, len);
  }

  @Override
  protected void restore(int src, int dest) {
    arr[dest] = tmp[src];
  }

  @Override
  protected int compareSaved(int i, int j) {
    return comparator.compare(tmp[i], arr[j]);
  }

}
diff --git a/lucene/core/src/java/org/apache/lucene/util/ArrayUtil.java b/lucene/core/src/java/org/apache/lucene/util/ArrayUtil.java
index 24da5101def..1d91c38a023 100644
-- a/lucene/core/src/java/org/apache/lucene/util/ArrayUtil.java
++ b/lucene/core/src/java/org/apache/lucene/util/ArrayUtil.java
@@ -28,11 +28,6 @@ import java.util.Comparator;
 
 public final class ArrayUtil {
 
  // affordable memory overhead to merge sorted arrays
  static final float MERGE_OVERHEAD_RATIO = 0.01f;
  // arrays below this size will always be sorted in-place
  static final int MERGE_EXTRA_MEMORY_THRESHOLD = (int) (15 / MERGE_OVERHEAD_RATIO);

   private ArrayUtil() {} // no instance
 
   /*
@@ -610,237 +605,85 @@ public final class ArrayUtil {
     return result;
   }
 
  private static abstract class ArraySorterTemplate&lt;T&gt; extends SorterTemplate {

    protected final T[] a;

    ArraySorterTemplate(T[] a) {
      this.a = a;
    }

    protected abstract int compare(T a, T b);

    @Override
    protected void swap(int i, int j) {
      final T o = a[i];
      a[i] = a[j];
      a[j] = o;
    }

    @Override
    protected int compare(int i, int j) {
      return compare(a[i], a[j]);
    }

  private static class NaturalComparator&lt;T extends Comparable&lt;? super T&gt;&gt; implements Comparator&lt;T&gt; {
    NaturalComparator() {}
     @Override
    protected void setPivot(int i) {
      pivot = a[i];
    }

    @Override
    protected int comparePivot(int j) {
      return compare(pivot, a[j]);
    }

    private T pivot;

  }

  // a template for merge-based sorts which uses extra memory to speed up merging
  private static abstract class ArrayMergeSorterTemplate&lt;T&gt; extends ArraySorterTemplate&lt;T&gt; {

    private final int threshold; // maximum length of a merge that can be made using extra memory
    private final T[] tmp;

    ArrayMergeSorterTemplate(T[] a, float overheadRatio) {
      super(a);
      this.threshold = (int) (a.length * overheadRatio);
      @SuppressWarnings("unchecked")
      final T[] tmpBuf = (T[]) new Object[threshold];
      this.tmp = tmpBuf;
    }

    private void mergeWithExtraMemory(int lo, int pivot, int hi, int len1, int len2) {
      System.arraycopy(a, lo, tmp, 0, len1);
      int i = 0, j = pivot, dest = lo;
      while (i &lt; len1 &amp;&amp; j &lt; hi) {
        if (compare(tmp[i], a[j]) &lt;= 0) {
          a[dest++] = tmp[i++];
        } else {
          a[dest++] = a[j++];
        }
      }
      while (i &lt; len1) {
        a[dest++] = tmp[i++];
      }
      assert j == dest;
    }

    @Override
    protected void merge(int lo, int pivot, int hi, int len1, int len2) {
      if (len1 &lt;= threshold) {
        mergeWithExtraMemory(lo, pivot, hi, len1, len2);
      } else {
        // since this method recurses to run merge on smaller arrays, it will
        // end up using mergeWithExtraMemory
        super.merge(lo, pivot, hi, len1, len2);
      }
    public int compare(T o1, T o2) {
      return o1.compareTo(o2);
     }

  }

  /** SorterTemplate with custom {@link Comparator} */
  private static &lt;T&gt; SorterTemplate getSorter(final T[] a, final Comparator&lt;? super T&gt; comp) {
    return new ArraySorterTemplate&lt;T&gt;(a) {

      @Override
      protected int compare(T a, T b) {
        return comp.compare(a, b);
      }

    };
   }
 
  /** Natural SorterTemplate */
  private static &lt;T extends Comparable&lt;? super T&gt;&gt; SorterTemplate getSorter(final T[] a) {
    return new ArraySorterTemplate&lt;T&gt;(a) {

      @Override
      protected int compare(T a, T b) {
        return a.compareTo(b);
      }
  private static final Comparator&lt;?&gt; NATURAL_COMPARATOR = new NaturalComparator&lt;&gt;();
 
    };
  /** Get the natural {@link Comparator} for the provided object class. */
  @SuppressWarnings("unchecked")
  public static &lt;T extends Comparable&lt;? super T&gt;&gt; Comparator&lt;T&gt; naturalComparator() {
    return (Comparator&lt;T&gt;) NATURAL_COMPARATOR;
   }
 
  /** SorterTemplate with custom {@link Comparator} for merge-based sorts. */
  private static &lt;T&gt; SorterTemplate getMergeSorter(final T[] a, final Comparator&lt;? super T&gt; comp) {
    if (a.length &lt; MERGE_EXTRA_MEMORY_THRESHOLD) {
      return getSorter(a, comp);
    } else {
      return new ArrayMergeSorterTemplate&lt;T&gt;(a, MERGE_OVERHEAD_RATIO) {

        @Override
        protected int compare(T a, T b) {
          return comp.compare(a, b);
        }

      };
    }
  /** Swap values stored in slots &lt;code&gt;i&lt;/code&gt; and &lt;code&gt;j&lt;/code&gt; */
  public static &lt;T&gt; void swap(T[] arr, int i, int j) {
    final T tmp = arr[i];
    arr[i] = arr[j];
    arr[j] = tmp;
   }
 
  /** Natural SorterTemplate for merge-based sorts. */
  private static &lt;T extends Comparable&lt;? super T&gt;&gt; SorterTemplate getMergeSorter(final T[] a) {
    if (a.length &lt; MERGE_EXTRA_MEMORY_THRESHOLD) {
      return getSorter(a);
    } else {
      return new ArrayMergeSorterTemplate&lt;T&gt;(a, MERGE_OVERHEAD_RATIO) {

        @Override
        protected int compare(T a, T b) {
          return a.compareTo(b);
        }

      };
    }
  }

  // quickSorts (endindex is exclusive!):
  // intro-sorts
   
   /**
   * Sorts the given array slice using the {@link Comparator}. This method uses the quick sort
   * Sorts the given array slice using the {@link Comparator}. This method uses the intro sort
    * algorithm, but falls back to insertion sort for small arrays.
    * @param fromIndex start index (inclusive)
    * @param toIndex end index (exclusive)
    */
  public static &lt;T&gt; void quickSort(T[] a, int fromIndex, int toIndex, Comparator&lt;? super T&gt; comp) {
  public static &lt;T&gt; void introSort(T[] a, int fromIndex, int toIndex, Comparator&lt;? super T&gt; comp) {
     if (toIndex-fromIndex &lt;= 1) return;
    getSorter(a, comp).quickSort(fromIndex, toIndex-1);
    new ArrayIntroSorter&lt;&gt;(a, comp).sort(fromIndex, toIndex);
   }
   
   /**
   * Sorts the given array using the {@link Comparator}. This method uses the quick sort
   * Sorts the given array using the {@link Comparator}. This method uses the intro sort
    * algorithm, but falls back to insertion sort for small arrays.
    */
  public static &lt;T&gt; void quickSort(T[] a, Comparator&lt;? super T&gt; comp) {
    quickSort(a, 0, a.length, comp);
  public static &lt;T&gt; void introSort(T[] a, Comparator&lt;? super T&gt; comp) {
    introSort(a, 0, a.length, comp);
   }
   
   /**
   * Sorts the given array slice in natural order. This method uses the quick sort
   * Sorts the given array slice in natural order. This method uses the intro sort
    * algorithm, but falls back to insertion sort for small arrays.
    * @param fromIndex start index (inclusive)
    * @param toIndex end index (exclusive)
    */
  public static &lt;T extends Comparable&lt;? super T&gt;&gt; void quickSort(T[] a, int fromIndex, int toIndex) {
  public static &lt;T extends Comparable&lt;? super T&gt;&gt; void introSort(T[] a, int fromIndex, int toIndex) {
     if (toIndex-fromIndex &lt;= 1) return;
    getSorter(a).quickSort(fromIndex, toIndex-1);
    final Comparator&lt;T&gt; comp = naturalComparator();
    introSort(a, fromIndex, toIndex, comp);
   }
   
   /**
   * Sorts the given array in natural order. This method uses the quick sort
   * Sorts the given array in natural order. This method uses the intro sort
    * algorithm, but falls back to insertion sort for small arrays.
    */
  public static &lt;T extends Comparable&lt;? super T&gt;&gt; void quickSort(T[] a) {
    quickSort(a, 0, a.length);
  public static &lt;T extends Comparable&lt;? super T&gt;&gt; void introSort(T[] a) {
    introSort(a, 0, a.length);
   }
 
  // mergeSorts:
  
  /**
   * Sorts the given array slice using the {@link Comparator}. This method uses the merge sort
   * algorithm, but falls back to insertion sort for small arrays.
   * @param fromIndex start index (inclusive)
   * @param toIndex end index (exclusive)
   */
  public static &lt;T&gt; void mergeSort(T[] a, int fromIndex, int toIndex, Comparator&lt;? super T&gt; comp) {
    if (toIndex-fromIndex &lt;= 1) return;
    //System.out.println("SORT: " + (toIndex-fromIndex));
    getMergeSorter(a, comp).mergeSort(fromIndex, toIndex-1);
  }
  
  /**
   * Sorts the given array using the {@link Comparator}. This method uses the merge sort
   * algorithm, but falls back to insertion sort for small arrays.
   */
  public static &lt;T&gt; void mergeSort(T[] a, Comparator&lt;? super T&gt; comp) {
    mergeSort(a, 0, a.length, comp);
  }
  
  /**
   * Sorts the given array slice in natural order. This method uses the merge sort
   * algorithm, but falls back to insertion sort for small arrays.
   * @param fromIndex start index (inclusive)
   * @param toIndex end index (exclusive)
   */
  public static &lt;T extends Comparable&lt;? super T&gt;&gt; void mergeSort(T[] a, int fromIndex, int toIndex) {
    if (toIndex-fromIndex &lt;= 1) return;
    getMergeSorter(a).mergeSort(fromIndex, toIndex-1);
  }
  // tim sorts:
   
   /**
   * Sorts the given array in natural order. This method uses the merge sort
   * algorithm, but falls back to insertion sort for small arrays.
   */
  public static &lt;T extends Comparable&lt;? super T&gt;&gt; void mergeSort(T[] a) {
    mergeSort(a, 0, a.length);
  }

  // timSorts:

  /**
   * Sorts the given array slice using the {@link Comparator}. This method uses the TimSort
   * Sorts the given array slice using the {@link Comparator}. This method uses the Tim sort
    * algorithm, but falls back to binary sort for small arrays.
    * @param fromIndex start index (inclusive)
    * @param toIndex end index (exclusive)
    */
   public static &lt;T&gt; void timSort(T[] a, int fromIndex, int toIndex, Comparator&lt;? super T&gt; comp) {
     if (toIndex-fromIndex &lt;= 1) return;
    getMergeSorter(a, comp).timSort(fromIndex, toIndex-1);
    new ArrayTimSorter&lt;&gt;(a, comp, a.length / 64).sort(fromIndex, toIndex);
   }
   
   /**
   * Sorts the given array using the {@link Comparator}. This method uses the TimSort
   * Sorts the given array using the {@link Comparator}. This method uses the Tim sort
    * algorithm, but falls back to binary sort for small arrays.
    */
   public static &lt;T&gt; void timSort(T[] a, Comparator&lt;? super T&gt; comp) {
@@ -848,102 +691,23 @@ public final class ArrayUtil {
   }
   
   /**
   * Sorts the given array slice in natural order. This method uses the TimSort
   * Sorts the given array slice in natural order. This method uses the Tim sort
    * algorithm, but falls back to binary sort for small arrays.
    * @param fromIndex start index (inclusive)
    * @param toIndex end index (exclusive)
    */
   public static &lt;T extends Comparable&lt;? super T&gt;&gt; void timSort(T[] a, int fromIndex, int toIndex) {
     if (toIndex-fromIndex &lt;= 1) return;
    getMergeSorter(a).timSort(fromIndex, toIndex-1);
    final Comparator&lt;T&gt; comp = naturalComparator();
    timSort(a, fromIndex, toIndex, comp);
   }
   
   /**
   * Sorts the given array in natural order. This method uses the TimSort
   * Sorts the given array in natural order. This method uses the Tim sort
    * algorithm, but falls back to binary sort for small arrays.
    */
   public static &lt;T extends Comparable&lt;? super T&gt;&gt; void timSort(T[] a) {
     timSort(a, 0, a.length);
   }
 
  // insertionSorts:
  
  /**
   * Sorts the given array slice using the {@link Comparator}. This method uses the insertion sort
   * algorithm. It is only recommended to use this algorithm for partially sorted small arrays!
   * @param fromIndex start index (inclusive)
   * @param toIndex end index (exclusive)
   */
  public static &lt;T&gt; void insertionSort(T[] a, int fromIndex, int toIndex, Comparator&lt;? super T&gt; comp) {
    if (toIndex-fromIndex &lt;= 1) return;
    getSorter(a, comp).insertionSort(fromIndex, toIndex-1);
  }
  
  /**
   * Sorts the given array using the {@link Comparator}. This method uses the insertion sort
   * algorithm. It is only recommended to use this algorithm for partially sorted small arrays!
   */
  public static &lt;T&gt; void insertionSort(T[] a, Comparator&lt;? super T&gt; comp) {
    insertionSort(a, 0, a.length, comp);
  }
  
  /**
   * Sorts the given array slice in natural order. This method uses the insertion sort
   * algorithm. It is only recommended to use this algorithm for partially sorted small arrays!
   * @param fromIndex start index (inclusive)
   * @param toIndex end index (exclusive)
   */
  public static &lt;T extends Comparable&lt;? super T&gt;&gt; void insertionSort(T[] a, int fromIndex, int toIndex) {
    if (toIndex-fromIndex &lt;= 1) return;
    getSorter(a).insertionSort(fromIndex, toIndex-1);
  }
  
  /**
   * Sorts the given array in natural order. This method uses the insertion sort
   * algorithm. It is only recommended to use this algorithm for partially sorted small arrays!
   */
  public static &lt;T extends Comparable&lt;? super T&gt;&gt; void insertionSort(T[] a) {
    insertionSort(a, 0, a.length);
  }

  // binarySorts:

  /**
   * Sorts the given array slice using the {@link Comparator}. This method uses the binary sort
   * algorithm. It is only recommended to use this algorithm for small arrays!
   * @param fromIndex start index (inclusive)
   * @param toIndex end index (exclusive)
   */
  public static &lt;T&gt; void binarySort(T[] a, int fromIndex, int toIndex, Comparator&lt;? super T&gt; comp) {
    if (toIndex-fromIndex &lt;= 1) return;
    getSorter(a, comp).binarySort(fromIndex, toIndex-1);
  }
  
  /**
   * Sorts the given array using the {@link Comparator}. This method uses the binary sort
   * algorithm. It is only recommended to use this algorithm for small arrays!
   */
  public static &lt;T&gt; void binarySort(T[] a, Comparator&lt;? super T&gt; comp) {
    binarySort(a, 0, a.length, comp);
  }
  
  /**
   * Sorts the given array slice in natural order. This method uses the binary sort
   * algorithm. It is only recommended to use this algorithm for small arrays!
   * @param fromIndex start index (inclusive)
   * @param toIndex end index (exclusive)
   */
  public static &lt;T extends Comparable&lt;? super T&gt;&gt; void binarySort(T[] a, int fromIndex, int toIndex) {
    if (toIndex-fromIndex &lt;= 1) return;
    getSorter(a).binarySort(fromIndex, toIndex-1);
  }
  
  /**
   * Sorts the given array in natural order. This method uses the binary sort
   * algorithm. It is only recommended to use this algorithm for small arrays!
   */
  public static &lt;T extends Comparable&lt;? super T&gt;&gt; void binarySort(T[] a) {
    binarySort(a, 0, a.length);
  }

}
\ No newline at end of file
}
diff --git a/lucene/core/src/java/org/apache/lucene/util/BytesRefHash.java b/lucene/core/src/java/org/apache/lucene/util/BytesRefHash.java
index f757f965976..ed28c7078b2 100644
-- a/lucene/core/src/java/org/apache/lucene/util/BytesRefHash.java
++ b/lucene/core/src/java/org/apache/lucene/util/BytesRefHash.java
@@ -163,7 +163,7 @@ public final class BytesRefHash {
    */
   public int[] sort(final Comparator&lt;BytesRef&gt; comp) {
     final int[] compact = compact();
    new SorterTemplate() {
    new IntroSorter() {
       @Override
       protected void swap(int i, int j) {
         final int o = compact[i];
@@ -197,7 +197,7 @@ public final class BytesRefHash {
       
       private final BytesRef pivot = new BytesRef(),
         scratch1 = new BytesRef(), scratch2 = new BytesRef();
    }.quickSort(0, count - 1);
    }.sort(0, count);
     return compact;
   }
 
diff --git a/lucene/core/src/java/org/apache/lucene/util/CollectionUtil.java b/lucene/core/src/java/org/apache/lucene/util/CollectionUtil.java
index 74877cca488..c8aef094912 100644
-- a/lucene/core/src/java/org/apache/lucene/util/CollectionUtil.java
++ b/lucene/core/src/java/org/apache/lucene/util/CollectionUtil.java
@@ -17,9 +17,6 @@ package org.apache.lucene.util;
  * limitations under the License.
  */
 
import static org.apache.lucene.util.ArrayUtil.MERGE_EXTRA_MEMORY_THRESHOLD;
import static org.apache.lucene.util.ArrayUtil.MERGE_OVERHEAD_RATIO;

 import java.util.Collections;
 import java.util.Comparator;
 import java.util.List;
@@ -37,16 +34,22 @@ import java.util.RandomAccess;
 public final class CollectionUtil {
 
   private CollectionUtil() {} // no instance
  private static final class ListIntroSorter&lt;T&gt; extends IntroSorter {
 
  private static abstract class ListSorterTemplate&lt;T&gt; extends SorterTemplate {

    protected final List&lt;T&gt; list;
    T pivot;
    final List&lt;T&gt; list;
    final Comparator&lt;? super T&gt; comp;
 
    ListSorterTemplate(List&lt;T&gt; list) {
    ListIntroSorter(List&lt;T&gt; list, Comparator&lt;? super T&gt; comp) {
      super();
       this.list = list;
      this.comp = comp;
     }
 
    protected abstract int compare(T a, T b);
    @Override
    protected void setPivot(int i) {
      pivot = list.get(i);
    }
 
     @Override
     protected void swap(int i, int j) {
@@ -55,257 +58,118 @@ public final class CollectionUtil {
 
     @Override
     protected int compare(int i, int j) {
      return compare(list.get(i), list.get(j));
    }

    @Override
    protected void setPivot(int i) {
      pivot = list.get(i);
      return comp.compare(list.get(i), list.get(j));
     }
 
     @Override
     protected int comparePivot(int j) {
      return compare(pivot, list.get(j));
      return comp.compare(pivot, list.get(j));
     }
 
    private T pivot;

   }
 
  // a template for merge-based sorts which uses extra memory to speed up merging
  private static abstract class ListMergeSorterTemplate&lt;T&gt; extends ListSorterTemplate&lt;T&gt; {
  private static final class ListTimSorter&lt;T&gt; extends TimSorter {
 
    private final int threshold; // maximum length of a merge that can be made using extra memory
    private final T[] tmp;
    final List&lt;T&gt; list;
    final Comparator&lt;? super T&gt; comp;
    final T[] tmp;
 
    ListMergeSorterTemplate(List&lt;T&gt; list, float overheadRatio) {
      super(list);
      this.threshold = (int) (list.size() * overheadRatio);
      @SuppressWarnings("unchecked")
      final T[] tmpBuf = (T[]) new Object[threshold];
      this.tmp = tmpBuf;
    }

    private void mergeWithExtraMemory(int lo, int pivot, int hi, int len1, int len2) {
      for (int i = 0; i &lt; len1; ++i) {
        tmp[i] = list.get(lo + i);
      }
      int i = 0, j = pivot, dest = lo;
      while (i &lt; len1 &amp;&amp; j &lt; hi) {
        if (compare(tmp[i], list.get(j)) &lt;= 0) {
          list.set(dest++, tmp[i++]);
        } else {
          list.set(dest++, list.get(j++));
        }
      }
      while (i &lt; len1) {
        list.set(dest++, tmp[i++]);
    @SuppressWarnings("unchecked")
    ListTimSorter(List&lt;T&gt; list, Comparator&lt;? super T&gt; comp, int maxTempSlots) {
      super(maxTempSlots);
      this.list = list;
      this.comp = comp;
      if (maxTempSlots &gt; 0) {
        this.tmp = (T[]) new Object[maxTempSlots];
      } else {
        this.tmp = null;
       }
      assert j == dest;
     }
 
     @Override
    protected void merge(int lo, int pivot, int hi, int len1, int len2) {
      if (len1 &lt;= threshold) {
        mergeWithExtraMemory(lo, pivot, hi, len1, len2);
      } else {
        // since this method recurses to run merge on smaller arrays, it will
        // end up using mergeWithExtraMemory
        super.merge(lo, pivot, hi, len1, len2);
      }
    protected void swap(int i, int j) {
      Collections.swap(list, i, j);
     }
 
  }

  /** SorterTemplate with custom {@link Comparator} */
  private static &lt;T&gt; SorterTemplate getSorter(final List&lt;T&gt; list, final Comparator&lt;? super T&gt; comp) {
    if (!(list instanceof RandomAccess))
      throw new IllegalArgumentException("CollectionUtil can only sort random access lists in-place.");
    return new ListSorterTemplate&lt;T&gt;(list) {

      @Override
      protected int compare(T a, T b) {
        return comp.compare(a, b);
      }

    };
  }
  
  /** Natural SorterTemplate */
  private static &lt;T extends Comparable&lt;? super T&gt;&gt; SorterTemplate getSorter(final List&lt;T&gt; list) {
    if (!(list instanceof RandomAccess))
      throw new IllegalArgumentException("CollectionUtil can only sort random access lists in-place.");
    return new ListSorterTemplate&lt;T&gt;(list) {
    @Override
    protected void copy(int src, int dest) {
      list.set(dest, list.get(src));
    }
 
      @Override
      protected int compare(T a, T b) {
        return a.compareTo(b);
    @Override
    protected void save(int i, int len) {
      for (int j = 0; j &lt; len; ++j) {
        tmp[j] = list.get(i + j);
       }
    }
 
    };
  }

  /** SorterTemplate with custom {@link Comparator} for merge-based sorts. */
  private static &lt;T&gt; SorterTemplate getMergeSorter(final List&lt;T&gt; list, final Comparator&lt;? super T&gt; comp) {
    if (!(list instanceof RandomAccess))
      throw new IllegalArgumentException("CollectionUtil can only sort random access lists in-place.");
    if (list.size() &lt; MERGE_EXTRA_MEMORY_THRESHOLD) {
      return getSorter(list, comp);
    } else {
      return new ListMergeSorterTemplate&lt;T&gt;(list, MERGE_OVERHEAD_RATIO) {

        @Override
        protected int compare(T a, T b) {
          return comp.compare(a, b);
        }

      };
    @Override
    protected void restore(int i, int j) {
      list.set(j, tmp[i]);
     }
  }
  
  /** Natural SorterTemplate for merge-based sorts. */
  private static &lt;T extends Comparable&lt;? super T&gt;&gt; SorterTemplate getMergeSorter(final List&lt;T&gt; list) {
    if (!(list instanceof RandomAccess))
      throw new IllegalArgumentException("CollectionUtil can only sort random access lists in-place.");
    if (list.size() &lt; MERGE_EXTRA_MEMORY_THRESHOLD) {
      return getSorter(list);
    } else {
      return new ListMergeSorterTemplate&lt;T&gt;(list, MERGE_OVERHEAD_RATIO) {
 
        @Override
        protected int compare(T a, T b) {
          return a.compareTo(b);
        }
    @Override
    protected int compare(int i, int j) {
      return comp.compare(list.get(i), list.get(j));
    }
 
      };
    @Override
    protected int compareSaved(int i, int j) {
      return comp.compare(tmp[i], list.get(j));
     }
  }
 
  /**
   * Sorts the given random access {@link List} using the {@link Comparator}.
   * The list must implement {@link RandomAccess}. This method uses the quick sort
   * algorithm, but falls back to insertion sort for small lists.
   * @throws IllegalArgumentException if list is e.g. a linked list without random access.
   */
  public static &lt;T&gt; void quickSort(List&lt;T&gt; list, Comparator&lt;? super T&gt; comp) {
    final int size = list.size();
    if (size &lt;= 1) return;
    getSorter(list, comp).quickSort(0, size-1);
  }
  
  /**
   * Sorts the given random access {@link List} in natural order.
   * The list must implement {@link RandomAccess}. This method uses the quick sort
   * algorithm, but falls back to insertion sort for small lists.
   * @throws IllegalArgumentException if list is e.g. a linked list without random access.
   */
  public static &lt;T extends Comparable&lt;? super T&gt;&gt; void quickSort(List&lt;T&gt; list) {
    final int size = list.size();
    if (size &lt;= 1) return;
    getSorter(list).quickSort(0, size-1);
   }
 
  // mergeSorts:
  
   /**
    * Sorts the given random access {@link List} using the {@link Comparator}.
   * The list must implement {@link RandomAccess}. This method uses the merge sort
   * The list must implement {@link RandomAccess}. This method uses the intro sort
    * algorithm, but falls back to insertion sort for small lists.
    * @throws IllegalArgumentException if list is e.g. a linked list without random access.
    */
  public static &lt;T&gt; void mergeSort(List&lt;T&gt; list, Comparator&lt;? super T&gt; comp) {
  public static &lt;T&gt; void introSort(List&lt;T&gt; list, Comparator&lt;? super T&gt; comp) {
     final int size = list.size();
     if (size &lt;= 1) return;
    getMergeSorter(list, comp).mergeSort(0, size-1);
    new ListIntroSorter&lt;&gt;(list, comp).sort(0, size);
   }
   
   /**
    * Sorts the given random access {@link List} in natural order.
   * The list must implement {@link RandomAccess}. This method uses the merge sort
   * The list must implement {@link RandomAccess}. This method uses the intro sort
    * algorithm, but falls back to insertion sort for small lists.
    * @throws IllegalArgumentException if list is e.g. a linked list without random access.
    */
  public static &lt;T extends Comparable&lt;? super T&gt;&gt; void mergeSort(List&lt;T&gt; list) {
  public static &lt;T extends Comparable&lt;? super T&gt;&gt; void introSort(List&lt;T&gt; list) {
     final int size = list.size();
     if (size &lt;= 1) return;
    getMergeSorter(list).mergeSort(0, size-1);
    final Comparator&lt;T&gt; comp = ArrayUtil.naturalComparator();
    introSort(list, comp);
   }
 
  // timSorts:
  // Tim sorts:
   
   /**
    * Sorts the given random access {@link List} using the {@link Comparator}.
   * The list must implement {@link RandomAccess}. This method uses the TimSort
   * The list must implement {@link RandomAccess}. This method uses the Tim sort
    * algorithm, but falls back to binary sort for small lists.
    * @throws IllegalArgumentException if list is e.g. a linked list without random access.
    */
   public static &lt;T&gt; void timSort(List&lt;T&gt; list, Comparator&lt;? super T&gt; comp) {
     final int size = list.size();
     if (size &lt;= 1) return;
    getMergeSorter(list, comp).timSort(0, size-1);
    new ListTimSorter&lt;&gt;(list, comp, list.size() / 64).sort(0, size);
   }
   
   /**
    * Sorts the given random access {@link List} in natural order.
   * The list must implement {@link RandomAccess}. This method uses the TimSort
   * The list must implement {@link RandomAccess}. This method uses the Tim sort
    * algorithm, but falls back to binary sort for small lists.
    * @throws IllegalArgumentException if list is e.g. a linked list without random access.
    */
   public static &lt;T extends Comparable&lt;? super T&gt;&gt; void timSort(List&lt;T&gt; list) {
     final int size = list.size();
     if (size &lt;= 1) return;
    getMergeSorter(list).timSort(0, size-1);
    final Comparator&lt;T&gt; comp = ArrayUtil.naturalComparator();
    timSort(list, comp);
   }
 
  // insertionSorts:
  
  /**
   * Sorts the given random access {@link List} using the {@link Comparator}.
   * The list must implement {@link RandomAccess}. This method uses the insertion sort
   * algorithm. It is only recommended to use this algorithm for partially sorted small lists!
   * @throws IllegalArgumentException if list is e.g. a linked list without random access.
   */
  public static &lt;T&gt; void insertionSort(List&lt;T&gt; list, Comparator&lt;? super T&gt; comp) {
    final int size = list.size();
    if (size &lt;= 1) return;
    getSorter(list, comp).insertionSort(0, size-1);
  }
  
  /**
   * Sorts the given random access {@link List} in natural order.
   * The list must implement {@link RandomAccess}. This method uses the insertion sort
   * algorithm. It is only recommended to use this algorithm for partially sorted small lists!
   * @throws IllegalArgumentException if list is e.g. a linked list without random access.
   */
  public static &lt;T extends Comparable&lt;? super T&gt;&gt; void insertionSort(List&lt;T&gt; list) {
    final int size = list.size();
    if (size &lt;= 1) return;
    getSorter(list).insertionSort(0, size-1);
  }

  // binarySorts:
  
  /**
   * Sorts the given random access {@link List} using the {@link Comparator}.
   * The list must implement {@link RandomAccess}. This method uses the binary sort
   * algorithm. It is only recommended to use this algorithm for small lists!
   * @throws IllegalArgumentException if list is e.g. a linked list without random access.
   */
  public static &lt;T&gt; void binarySort(List&lt;T&gt; list, Comparator&lt;? super T&gt; comp) {
    final int size = list.size();
    if (size &lt;= 1) return;
    getSorter(list, comp).binarySort(0, size-1);
  }
  
  /**
   * Sorts the given random access {@link List} in natural order.
   * The list must implement {@link RandomAccess}. This method uses the insertion sort
   * algorithm. It is only recommended to use this algorithm for small lists!
   * @throws IllegalArgumentException if list is e.g. a linked list without random access.
   */
  public static &lt;T extends Comparable&lt;? super T&gt;&gt; void binarySort(List&lt;T&gt; list) {
    final int size = list.size();
    if (size &lt;= 1) return;
    getSorter(list).binarySort(0, size-1);
  }
}
\ No newline at end of file
}
diff --git a/lucene/core/src/java/org/apache/lucene/util/InPlaceMergeSorter.java b/lucene/core/src/java/org/apache/lucene/util/InPlaceMergeSorter.java
new file mode 100644
index 00000000000..54e5bde40ea
-- /dev/null
++ b/lucene/core/src/java/org/apache/lucene/util/InPlaceMergeSorter.java
@@ -0,0 +1,46 @@
package org.apache.lucene.util;

/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/** {@link Sorter} implementation based on the merge-sort algorithm that merges
 *  in place (no extra memory will be allocated). Small arrays are sorted with
 *  insertion sort.
 *  @lucene.internal */
public abstract class InPlaceMergeSorter extends Sorter {

  /** Create a new {@link InPlaceMergeSorter} */
  public InPlaceMergeSorter() {}

  @Override
  public final void sort(int from, int to) {
    checkRange(from, to);
    mergeSort(from, to);
  }

  void mergeSort(int from, int to) {
    if (to - from &lt; THRESHOLD) {
      insertionSort(from, to);
    } else {
      final int mid = (from + to) &gt;&gt;&gt; 1;
      mergeSort(from, mid);
      mergeSort(mid, to);
      mergeInPlace(from, mid, to);
    }
  }

}
diff --git a/lucene/core/src/java/org/apache/lucene/util/IntroSorter.java b/lucene/core/src/java/org/apache/lucene/util/IntroSorter.java
new file mode 100644
index 00000000000..9efc4e8efe4
-- /dev/null
++ b/lucene/core/src/java/org/apache/lucene/util/IntroSorter.java
@@ -0,0 +1,98 @@
package org.apache.lucene.util;

/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * {@link Sorter} implementation based on a variant of the quicksort algorithm
 * called &lt;a href="http://en.wikipedia.org/wiki/Introsort"&gt;introsort&lt;/a&gt;: when
 * the recursion level exceeds the log of the length of the array to sort, it
 * falls back to heapsort. This prevents quicksort from running into its
 * worst-case quadratic runtime. Small arrays are sorted with
 * insertion sort.
 * @lucene.internal
 */
public abstract class IntroSorter extends Sorter {

  static int ceilLog2(int n) {
    return Integer.SIZE - Integer.numberOfLeadingZeros(n - 1);
  }

  /** Create a new {@link IntroSorter}. */
  public IntroSorter() {}

  @Override
  public final void sort(int from, int to) {
    checkRange(from, to);
    quicksort(from, to, ceilLog2(to - from));
  }

  void quicksort(int from, int to, int maxDepth) {
    if (to - from &lt; THRESHOLD) {
      insertionSort(from, to);
      return;
    } else if (--maxDepth &lt; 0) {
      heapSort(from, to);
      return;
    }

    final int mid = (from + to) &gt;&gt;&gt; 1;

    if (compare(from, mid) &gt; 0) {
      swap(from, mid);
    }

    if (compare(mid, to - 1) &gt; 0) {
      swap(mid, to - 1);
      if (compare(from, mid) &gt; 0) {
        swap(from, mid);
      }
    }

    int left = from + 1;
    int right = to - 2;

    setPivot(mid);
    for (;;) {
      while (comparePivot(right) &lt; 0) {
        --right;
      }

      while (left &lt; right &amp;&amp; comparePivot(left) &gt;= 0) {
        ++left;
      }

      if (left &lt; right) {
        swap(left, right);
        --right;
      } else {
        break;
      }
    }

    quicksort(from, left + 1, maxDepth);
    quicksort(left + 1, to, maxDepth);
  }

  /** Save the value at slot &lt;code&gt;i&lt;/code&gt; so that it can later be used as a
   * pivot, see {@link #comparePivot(int)}. */
  protected abstract void setPivot(int i);

  /** Compare the pivot with the slot at &lt;code&gt;j&lt;/code&gt;, similarly to
   *  {@link #compare(int, int) compare(i, j)}. */
  protected abstract int comparePivot(int j);
}
diff --git a/lucene/core/src/java/org/apache/lucene/util/Sorter.java b/lucene/core/src/java/org/apache/lucene/util/Sorter.java
new file mode 100644
index 00000000000..e54615cd1a8
-- /dev/null
++ b/lucene/core/src/java/org/apache/lucene/util/Sorter.java
@@ -0,0 +1,248 @@
package org.apache.lucene.util;

/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import java.util.Comparator;

/** Base class for sorting algorithms implementations.
 * @lucene.internal */
public abstract class Sorter {

  static final int THRESHOLD = 20;

  /** Sole constructor, used for inheritance. */
  protected Sorter() {}

  /** Compare entries found in slots &lt;code&gt;i&lt;/code&gt; and &lt;code&gt;j&lt;/code&gt;.
   *  The contract for the returned value is the same as
   *  {@link Comparator#compare(Object, Object)}. */
  protected abstract int compare(int i, int j);

  /** Swap values at slots &lt;code&gt;i&lt;/code&gt; and &lt;code&gt;j&lt;/code&gt;. */
  protected abstract void swap(int i, int j);

  /** Sort the slice which starts at &lt;code&gt;from&lt;/code&gt; (inclusive) and ends at
   *  &lt;code&gt;to&lt;/code&gt; (exclusive). */
  public abstract void sort(int from, int to);

  void checkRange(int from, int to) {
    if (to &lt; from) {
      throw new IllegalArgumentException("'</literal><name>to</name><literal type="char">' must be &gt;= '</literal><name>from</name><literal type="char">', got from=" + from + " and to=" + to);
    }
  }

  void mergeInPlace(int from, int mid, int to) {
    if (from == mid || mid == to || compare(mid - 1, mid) &lt;= 0) {
      return;
    } else if (to - from == 2) {
      swap(mid - 1, mid);
      return;
    }
    while (compare(from, mid) &lt;= 0) {
      ++from;
    }
    while (compare(mid - 1, to - 1) &lt;= 0) {
      --to;
    }
    int first_cut, second_cut;
    int len11, len22;
    if (mid - from &gt; to - mid) {
      len11 = (mid - from) &gt;&gt;&gt; 1;
      first_cut = from + len11;
      second_cut = lower(mid, to, first_cut);
      len22 = second_cut - mid;
    } else {
      len22 = (to - mid) &gt;&gt;&gt; 1;
      second_cut = mid + len22;
      first_cut = upper(from, mid, second_cut);
      len11 = first_cut - from;
    }
    rotate( first_cut, mid, second_cut);
    final int new_mid = first_cut + len22;
    mergeInPlace(from, first_cut, new_mid);
    mergeInPlace(new_mid, second_cut, to);
  }

  int lower(int from, int to, int val) {
    int len = to - from;
    while (len &gt; 0) {
      final int half = len &gt;&gt;&gt; 1;
      final int mid = from + half;
      if (compare(mid, val) &lt; 0) {
        from = mid + 1;
        len = len - half -1;
      } else {
        len = half;
      }
    }
    return from;
  }

  int upper(int from, int to, int val) {
    int len = to - from;
    while (len &gt; 0) {
      final int half = len &gt;&gt;&gt; 1;
      final int mid = from + half;
      if (compare(val, mid) &lt; 0) {
        len = half;
      } else {
        from = mid + 1;
        len = len - half -1;
      }
    }
    return from;
  }

  // faster than lower when val is at the end of [from:to[
  int lower2(int from, int to, int val) {
    int f = to - 1, t = to;
    while (f &gt; from) {
      if (compare(f, val) &lt; 0) {
        return lower(f, t, val);
      }
      final int delta = t - f;
      t = f;
      f -= delta &lt;&lt; 1;
    }
    return lower(from, t, val);
  }

  // faster than upper when val is at the beginning of [from:to[
  int upper2(int from, int to, int val) {
    int f = from, t = f + 1;
    while (t &lt; to) {
      if (compare(t, val) &gt; 0) {
        return upper(f, t, val);
      }
      final int delta = t - f;
      f = t;
      t += delta &lt;&lt; 1;
    }
    return upper(f, to, val);
  }

  final void reverse(int from, int to) {
    for (--to; from &lt; to; ++from, --to) {
      swap(from, to);
    }
  }

  void rotate(int lo, int mid, int hi) {
    if (mid - lo == hi - mid) {
      // happens rarely but saves n/2 swaps
      while (mid &lt; hi) {
        swap(lo++, mid++);
      }
    } else {
      reverse(lo, mid);
      reverse(mid, hi);
      reverse(lo, hi);
    }
  }

  void insertionSort(int from, int to) {
    for (int i = from + 1; i &lt; to; ++i) {
      for (int j = i; j &gt; from; --j) {
        if (compare(j - 1, j) &gt; 0) {
          swap(j - 1, j);
        } else {
          break;
        }
      }
    }
  }

  void binarySort(int from, int to) {
    binarySort(from, to, from + 1);
  }

  void binarySort(int from, int to, int i) {
    for ( ; i &lt; to; ++i) {
      int l = from;
      int h = i - 1;
      while (l &lt;= h) {
        final int mid = (l + h) &gt;&gt;&gt; 1;
        final int cmp = compare(i, mid);
        if (cmp &lt; 0) {
          h = mid - 1;
        } else {
          l = mid + 1;
        }
      }
      switch (i - l) {
      case 2:
        swap(l + 1, l + 2);
      case 1:
        swap(l, l + 1);
      case 0:
        break;
      default:
        for (int j = i; j &gt; l; --j) {
          swap(j - 1, j);
        }
        break;
      }
    }
  }

  void heapSort(int from, int to) {
    if (to - from &lt;= 1) {
      return;
    }
    heapify(from, to);
    for (int end = to - 1; end &gt; from; --end) {
      swap(from, end);
      siftDown(from, from, end);
    }
  }

  void heapify(int from, int to) {
    for (int i = heapParent(from, to - 1); i &gt;= from; --i) {
      siftDown(i, from, to);
    }
  }

  void siftDown(int i, int from, int to) {
    for (int leftChild = heapChild(from, i); leftChild &lt; to; leftChild = heapChild(from, i)) {
      final int rightChild = leftChild + 1;
      if (compare(i, leftChild) &lt; 0) {
        if (rightChild &lt; to &amp;&amp; compare(leftChild, rightChild) &lt; 0) {
          swap(i, rightChild);
          i = rightChild;
        } else {
          swap(i, leftChild);
          i = leftChild;
        }
      } else if (rightChild &lt; to &amp;&amp; compare(i, rightChild) &lt; 0) {
        swap(i, rightChild);
        i = rightChild;
      } else {
        break;
      }
    }
  }

  static int heapParent(int from, int i) {
    return ((i - 1 - from) &gt;&gt;&gt; 1) + from;
  }

  static int heapChild(int from, int i) {
    return ((i - from) &lt;&lt; 1) + 1 + from;
  }

}
diff --git a/lucene/core/src/java/org/apache/lucene/util/SorterTemplate.java b/lucene/core/src/java/org/apache/lucene/util/SorterTemplate.java
deleted file mode 100644
index 7ee69d997a3..00000000000
-- a/lucene/core/src/java/org/apache/lucene/util/SorterTemplate.java
++ /dev/null
@@ -1,445 +0,0 @@
package org.apache.lucene.util;


/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * This class was inspired by CGLIB, but provides a better
 * QuickSort algorithm without additional InsertionSort
 * at the end.
 * To use, subclass and override the four abstract methods
 * which compare and modify your data.
 * Allows custom swap so that two arrays can be sorted
 * at the same time.
 * @lucene.internal
 */
public abstract class SorterTemplate {

  private static final int TIMSORT_MINRUN = 32;
  private static final int TIMSORT_THRESHOLD = 64;
  private static final int TIMSORT_STACKSIZE = 40; // change if you change TIMSORT_MINRUN
  private static final int MERGESORT_THRESHOLD = 12;
  private static final int QUICKSORT_THRESHOLD = 7;

  static {
    // check whether TIMSORT_STACKSIZE is large enough
    // for a run length of TIMSORT_MINRUN and an array
    // of 2B values when TimSort invariants are verified
    final long[] lengths = new long[TIMSORT_STACKSIZE];
    lengths[0] = TIMSORT_MINRUN;
    lengths[1] = lengths[0] + 1;
    for (int i = 2; i &lt; TIMSORT_STACKSIZE; ++i) {
      lengths[i] = lengths[i-2] + lengths[i-1] + 1;
    }
    if (lengths[TIMSORT_STACKSIZE - 1] &lt; Integer.MAX_VALUE) {
      throw new Error("TIMSORT_STACKSIZE is too small");
    }
  }

  /** Implement this method, that swaps slots {@code i} and {@code j} in your data */
  protected abstract void swap(int i, int j);
  
  /** Compares slots {@code i} and {@code j} of you data.
   * Should be implemented like &lt;code&gt;&lt;em&gt;valueOf(i)&lt;/em&gt;.compareTo(&lt;em&gt;valueOf(j)&lt;/em&gt;)&lt;/code&gt; */
  protected abstract int compare(int i, int j);

  /** Implement this method, that stores the value of slot {@code i} as pivot value */
  protected abstract void setPivot(int i);
  
  /** Implements the compare function for the previously stored pivot value.
   * Should be implemented like &lt;code&gt;pivot.compareTo(&lt;em&gt;valueOf(j)&lt;/em&gt;)&lt;/code&gt; */
  protected abstract int comparePivot(int j);
  
  /** Sorts via stable in-place InsertionSort algorithm (O(n&lt;sup&gt;2&lt;/sup&gt;))
   *(ideal for small collections which are mostly presorted). */
  public final void insertionSort(int lo, int hi) {
    for (int i = lo + 1 ; i &lt;= hi; i++) {
      for (int j = i; j &gt; lo; j--) {
        if (compare(j - 1, j) &gt; 0) {
          swap(j - 1, j);
        } else {
          break;
        }
      }
    }
  }

  /** Sorts via stable in-place BinarySort algorithm (O(n&lt;sup&gt;2&lt;/sup&gt;))
   * (ideal for small collections which are in random order). */
  public final void binarySort(int lo, int hi) {
    for (int i = lo + 1; i &lt;= hi; ++i) {
      int l = lo;
      int h = i - 1;
      setPivot(i);
      while (l &lt;= h) {
        final int mid = (l + h) &gt;&gt;&gt; 1;
        final int cmp = comparePivot(mid);
        if (cmp &lt; 0) {
          h = mid - 1;
        } else {
          l = mid + 1;
        }
      }
      for (int j = i; j &gt; l; --j) {
        swap(j - 1, j);
      }
    }
  }

  /** Sorts via in-place, but unstable, QuickSort algorithm.
   * For small collections falls back to {@link #insertionSort(int,int)}. */
  public final void quickSort(final int lo, final int hi) {
    if (hi &lt;= lo) return;
    // from Integer'</literal><name>s</name> <name>Javadocs</name><operator>:</operator> <call><name>ceil</name><argument_list>(<argument><expr><call><name>log2</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>=</operator> <literal type="number">32</literal> <operator>-</operator> <call><name>numberOfLeadingZeros</name><argument_list>(<argument><expr><name>x</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call>
    <call><name>quickSort</name><argument_list>(<argument><expr><name>lo</name></expr></argument>, <argument><expr><name>hi</name></expr></argument>, <argument><expr><operator>(</operator><name><name>Integer</name><operator>.</operator><name>SIZE</name></name> <operator>-</operator> <call><name><name>Integer</name><operator>.</operator><name>numberOfLeadingZeros</name></name><argument_list>(<argument><expr><name>hi</name> <operator>-</operator> <name>lo</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
  }
  
  private <function><type><name>void</name></type> <name>quickSort</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>lo</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>hi</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>maxDepth</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <comment type="line">// fall back to insertion when array has short length</comment>
    <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>diff</name> <init>= <expr><name>hi</name> <operator>-</operator> <name>lo</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>diff</name> <operator>&lt;=</operator> <name>QUICKSORT_THRESHOLD</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>insertionSort</name><argument_list>(<argument><expr><name>lo</name></expr></argument>, <argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return;</return>
    </block_content>}</block></if></if_stmt>
    
    <comment type="line">// fall back to merge sort when recursion depth gets too big</comment>
    <if_stmt><if>if <condition>(<expr><operator>--</operator><name>maxDepth</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>mergeSort</name><argument_list>(<argument><expr><name>lo</name></expr></argument>, <argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return;</return>
    </block_content>}</block></if></if_stmt>
    
    <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>mid</name> <init>= <expr><name>lo</name> <operator>+</operator> <operator>(</operator><name>diff</name> <operator>&gt;&gt;&gt;</operator> <literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
    
    <if_stmt><if>if <condition>(<expr><call><name>compare</name><argument_list>(<argument><expr><name>lo</name></expr></argument>, <argument><expr><name>mid</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>swap</name><argument_list>(<argument><expr><name>lo</name></expr></argument>, <argument><expr><name>mid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>compare</name><argument_list>(<argument><expr><name>mid</name></expr></argument>, <argument><expr><name>hi</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>swap</name><argument_list>(<argument><expr><name>mid</name></expr></argument>, <argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><call><name>compare</name><argument_list>(<argument><expr><name>lo</name></expr></argument>, <argument><expr><name>mid</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>swap</name><argument_list>(<argument><expr><name>lo</name></expr></argument>, <argument><expr><name>mid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    
    <decl_stmt><decl><type><name>int</name></type> <name>left</name> <init>= <expr><name>lo</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>right</name> <init>= <expr><name>hi</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>setPivot</name><argument_list>(<argument><expr><name>mid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
      <while>while <condition>(<expr><call><name>comparePivot</name><argument_list>(<argument><expr><name>right</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>--</operator><name>right</name></expr>;</expr_stmt></block_content></block></while>

      <while>while <condition>(<expr><name>left</name> <operator>&lt;</operator> <name>right</name> <operator>&amp;&amp;</operator> <call><name>comparePivot</name><argument_list>(<argument><expr><name>left</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>++</operator><name>left</name></expr>;</expr_stmt></block_content></block></while>

      <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&lt;</operator> <name>right</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>swap</name><argument_list>(<argument><expr><name>left</name></expr></argument>, <argument><expr><name>right</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>--</operator><name>right</name></expr>;</expr_stmt>
      </block_content>}</block></if> <else>else <block>{<block_content>
        <break>break;</break>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>quickSort</name><argument_list>(<argument><expr><name>lo</name></expr></argument>, <argument><expr><name>left</name></expr></argument>, <argument><expr><name>maxDepth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>quickSort</name><argument_list>(<argument><expr><name>left</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>hi</name></expr></argument>, <argument><expr><name>maxDepth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></function>

  <comment type="block" format="javadoc">/** TimSort implementation. The only difference with the spec is that this
   *  impl reuses {@link SorterTemplate#merge(int, int, int, int, int)} to
   *  merge runs (in place) instead of the original merging routine from
   *  TimSort (which requires extra memory but might be slightly faster). */</comment>
  <class><specifier>private</specifier> class <name>TimSort</name> <block>{

    <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>hi</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>minRun</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>final</specifier> <name><name>int</name><index>[]</index></name></type> <name>runEnds</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>stackSize</name></decl>;</decl_stmt>

    <constructor><name>TimSort</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>lo</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>hi</name></decl></parameter>)</parameter_list> <block>{<block_content>
      <assert>assert <expr><name>hi</name> <operator>&gt;</operator> <name>lo</name></expr>;</assert>
      <comment type="line">// +1 because the first slot is reserved and always lo</comment>
      <expr_stmt><expr><name>runEnds</name> <operator>=</operator> <operator>new</operator> <name><name>int</name><index>[<expr><name>TIMSORT_STACKSIZE</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>runEnds</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>lo</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>stackSize</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>this</name><operator>.</operator><name>hi</name></name> <operator>=</operator> <name>hi</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>minRun</name> <operator>=</operator> <call><name>minRun</name><argument_list>(<argument><expr><name>hi</name> <operator>-</operator> <name>lo</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></constructor>

    <comment type="block" format="javadoc">/** Minimum run length for an array of length &lt;code&gt;length&lt;/code&gt;. */</comment>
    <function><type><name>int</name></type> <name>minRun</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>length</name></decl></parameter>)</parameter_list> <block>{<block_content>
      <assert>assert <expr><name>length</name> <operator>&gt;=</operator> <name>TIMSORT_MINRUN</name></expr>;</assert>
      <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><name>length</name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>r</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <while>while <condition>(<expr><name>n</name> <operator>&gt;=</operator> <literal type="number">64</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>r</name> <operator>|=</operator> <name>n</name> <operator>&amp;</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>n</name> <operator>&gt;&gt;&gt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></while>
      <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>minRun</name> <init>= <expr><name>n</name> <operator>+</operator> <name>r</name></expr></init></decl>;</decl_stmt>
      <assert>assert <expr><name>minRun</name> <operator>&gt;=</operator> <name>TIMSORT_MINRUN</name> <operator>&amp;&amp;</operator> <name>minRun</name> <operator>&lt;=</operator> <literal type="number">64</literal></expr>;</assert>
      <return>return <expr><name>minRun</name></expr>;</return>
    </block_content>}</block></function>

    <function><type><name>int</name></type> <name>runLen</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>)</parameter_list> <block>{<block_content>
      <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>off</name> <init>= <expr><name>stackSize</name> <operator>-</operator> <name>i</name></expr></init></decl>;</decl_stmt>
      <return>return <expr><name><name>runEnds</name><index>[<expr><name>off</name></expr>]</index></name> <operator>-</operator> <name><name>runEnds</name><index>[<expr><name>off</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</return>
    </block_content>}</block></function>

    <function><type><name>int</name></type> <name>runBase</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>)</parameter_list> <block>{<block_content>
      <return>return <expr><name><name>runEnds</name><index>[<expr><name>stackSize</name> <operator>-</operator> <name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</return>
    </block_content>}</block></function>

    <function><type><name>int</name></type> <name>runEnd</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>)</parameter_list> <block>{<block_content>
      <return>return <expr><name><name>runEnds</name><index>[<expr><name>stackSize</name> <operator>-</operator> <name>i</name></expr>]</index></name></expr>;</return>
    </block_content>}</block></function>

    <function><type><name>void</name></type> <name>setRunEnd</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>runEnd</name></decl></parameter>)</parameter_list> <block>{<block_content>
      <expr_stmt><expr><name><name>runEnds</name><index>[<expr><name>stackSize</name> <operator>-</operator> <name>i</name></expr>]</index></name> <operator>=</operator> <name>runEnd</name></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><type><name>void</name></type> <name>pushRunLen</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list> <block>{<block_content>
      <expr_stmt><expr><name><name>runEnds</name><index>[<expr><name>stackSize</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>runEnds</name><index>[<expr><name>stackSize</name></expr>]</index></name> <operator>+</operator> <name>len</name></expr>;</expr_stmt>
      <expr_stmt><expr><operator>++</operator><name>stackSize</name></expr>;</expr_stmt>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/** Merge run i with run i+1 */</comment>
    <function><type><name>void</name></type> <name>mergeAt</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>)</parameter_list> <block>{<block_content>
      <assert>assert <expr><name>stackSize</name> <operator>&gt;</operator> <name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>;</assert>
      <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>l</name> <init>= <expr><call><name>runBase</name><argument_list>(<argument><expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>pivot</name> <init>= <expr><call><name>runBase</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>h</name> <init>= <expr><call><name>runEnd</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>runMerge</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><name>pivot</name></expr></argument>, <argument><expr><name>h</name></expr></argument>, <argument><expr><name>pivot</name> <operator>-</operator> <name>l</name></expr></argument>, <argument><expr><name>h</name> <operator>-</operator> <name>pivot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><operator>--</operator><name>j</name></expr></incr>)</control> <block>{<block_content>
        <expr_stmt><expr><call><name>setRunEnd</name><argument_list>(<argument><expr><name>j</name></expr></argument>, <argument><expr><call><name>runEnd</name><argument_list>(<argument><expr><name>j</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
      <expr_stmt><expr><operator>--</operator><name>stackSize</name></expr>;</expr_stmt>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/** Compute the length of the next run, make the run sorted and return its
     *  length. */</comment>
    <function><type><name>int</name></type> <name>nextRun</name><parameter_list>()</parameter_list> <block>{<block_content>
      <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>runBase</name> <init>= <expr><call><name>runEnd</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><name>runBase</name> <operator>==</operator> <name>hi</name></expr>)</condition> <block>{<block_content>
        <return>return <expr><literal type="number">1</literal></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>l</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt> <comment type="line">// length of the run</comment>
      <if_stmt><if>if <condition>(<expr><call><name>compare</name><argument_list>(<argument><expr><name>runBase</name></expr></argument>, <argument><expr><name>runBase</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <comment type="line">// run must be strictly descending</comment>
        <while>while <condition>(<expr><name>runBase</name> <operator>+</operator> <name>l</name> <operator>&lt;=</operator> <name>hi</name> <operator>&amp;&amp;</operator> <call><name>compare</name><argument_list>(<argument><expr><name>runBase</name> <operator>+</operator> <name>l</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>runBase</name> <operator>+</operator> <name>l</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><operator>++</operator><name>l</name></expr>;</expr_stmt>
        </block_content>}</block></while>
        <if_stmt><if>if <condition>(<expr><name>l</name> <operator>&lt;</operator> <name>minRun</name> <operator>&amp;&amp;</operator> <name>runBase</name> <operator>+</operator> <name>l</name> <operator>&lt;=</operator> <name>hi</name></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><name>l</name> <operator>=</operator> <call><name><name>Math</name><operator>.</operator><name>min</name></name><argument_list>(<argument><expr><name>hi</name> <operator>-</operator> <name>runBase</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>minRun</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>binarySort</name><argument_list>(<argument><expr><name>runBase</name></expr></argument>, <argument><expr><name>runBase</name> <operator>+</operator> <name>l</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
          <comment type="line">// revert</comment>
          <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>halfL</name> <init>= <expr><name>l</name> <operator>&gt;&gt;&gt;</operator> <literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>halfL</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
            <expr_stmt><expr><call><name>swap</name><argument_list>(<argument><expr><name>runBase</name> <operator>+</operator> <name>i</name></expr></argument>, <argument><expr><name>runBase</name> <operator>+</operator> <name>l</name> <operator>-</operator> <name>i</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></for>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if> <else>else <block>{<block_content>
        <comment type="line">// run must be non-descending</comment>
        <while>while <condition>(<expr><name>runBase</name> <operator>+</operator> <name>l</name> <operator>&lt;=</operator> <name>hi</name> <operator>&amp;&amp;</operator> <call><name>compare</name><argument_list>(<argument><expr><name>runBase</name> <operator>+</operator> <name>l</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>runBase</name> <operator>+</operator> <name>l</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><operator>++</operator><name>l</name></expr>;</expr_stmt>
        </block_content>}</block></while>
        <if_stmt><if>if <condition>(<expr><name>l</name> <operator>&lt;</operator> <name>minRun</name> <operator>&amp;&amp;</operator> <name>runBase</name> <operator>+</operator> <name>l</name> <operator>&lt;=</operator> <name>hi</name></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><name>l</name> <operator>=</operator> <call><name><name>Math</name><operator>.</operator><name>min</name></name><argument_list>(<argument><expr><name>hi</name> <operator>-</operator> <name>runBase</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>minRun</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>binarySort</name><argument_list>(<argument><expr><name>runBase</name></expr></argument>, <argument><expr><name>runBase</name> <operator>+</operator> <name>l</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt> <comment type="line">// else nothing to do, the run is already sorted</comment>
      </block_content>}</block></else></if_stmt>
      <return>return <expr><name>l</name></expr>;</return>
    </block_content>}</block></function>

    <function><type><name>void</name></type> <name>ensureInvariants</name><parameter_list>()</parameter_list> <block>{<block_content>
      <while>while <condition>(<expr><name>stackSize</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>runLen0</name> <init>= <expr><call><name>runLen</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>runLen1</name> <init>= <expr><call><name>runLen</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>stackSize</name> <operator>&gt;</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
          <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>runLen2</name> <init>= <expr><call><name>runLen</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

          <if_stmt><if>if <condition>(<expr><name>runLen2</name> <operator>&lt;=</operator> <name>runLen1</name> <operator>+</operator> <name>runLen0</name></expr>)</condition> <block>{<block_content>
            <comment type="line">// merge the smaller of 0 and 2 with 1</comment>
            <if_stmt><if>if <condition>(<expr><name>runLen2</name> <operator>&lt;</operator> <name>runLen0</name></expr>)</condition> <block>{<block_content>
              <expr_stmt><expr><call><name>mergeAt</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
              <expr_stmt><expr><call><name>mergeAt</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
            <continue>continue;</continue>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>runLen1</name> <operator>&lt;=</operator> <name>runLen0</name></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><call><name>mergeAt</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>

        <break>break;</break>
      </block_content>}</block></while>
    </block_content>}</block></function>

    <function><type><name>void</name></type> <name>exhaustStack</name><parameter_list>()</parameter_list> <block>{<block_content>
      <while>while <condition>(<expr><name>stackSize</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>mergeAt</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></while>
    </block_content>}</block></function>

    <function><type><name>void</name></type> <name>sort</name><parameter_list>()</parameter_list> <block>{<block_content>
      <do>do <block>{<block_content>
        <expr_stmt><expr><call><name>ensureInvariants</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Push a new run onto the stack</comment>
        <expr_stmt><expr><call><name>pushRunLen</name><argument_list>(<argument><expr><call><name>nextRun</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      </block_content>}</block> while <condition>(<expr><call><name>runEnd</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <name>hi</name></expr>)</condition>;</do>

      <expr_stmt><expr><call><name>exhaustStack</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <assert>assert <expr><call><name>runEnd</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>hi</name> <operator>+</operator> <literal type="number">1</literal></expr>;</assert>
    </block_content>}</block></function>

  }</block></class>

  <comment type="block" format="javadoc">/** Sorts using &lt;a href="http://svn.python.org/projects/python/trunk/Objects/listsort.txt"&gt;TimSort&lt;/a&gt;, see 
   *  also &lt;a href="http://svn.python.org/projects/python/trunk/Objects/listobject.c"&gt;source code&lt;/a&gt;.
   *  TimSort is a stable sorting algorithm based on MergeSort but known to
   *  perform extremely well on partially-sorted inputs.
   *  For small collections, falls back to {@link #binarySort(int, int)}. */</comment>
  <function><type><specifier>public</specifier> <specifier>final</specifier> <name>void</name></type> <name>timSort</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>lo</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>hi</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>hi</name> <operator>-</operator> <name>lo</name> <operator>&lt;=</operator> <name>TIMSORT_THRESHOLD</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>binarySort</name><argument_list>(<argument><expr><name>lo</name></expr></argument>, <argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><operator>new</operator> <call><name>TimSort</name><argument_list>(<argument><expr><name>lo</name></expr></argument>, <argument><expr><name>hi</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>sort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></function>

  <comment type="block" format="javadoc">/** Sorts via stable in-place MergeSort algorithm
   * For small collections falls back to {@link #insertionSort(int,int)}. */</comment>
  <function><type><specifier>public</specifier> <specifier>final</specifier> <name>void</name></type> <name>mergeSort</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>lo</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>hi</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>diff</name> <init>= <expr><name>hi</name> <operator>-</operator> <name>lo</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>diff</name> <operator>&lt;=</operator> <name>MERGESORT_THRESHOLD</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>insertionSort</name><argument_list>(<argument><expr><name>lo</name></expr></argument>, <argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return;</return>
    </block_content>}</block></if></if_stmt>
    
    <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>mid</name> <init>= <expr><name>lo</name> <operator>+</operator> <operator>(</operator><name>diff</name> <operator>&gt;&gt;&gt;</operator> <literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
    
    <expr_stmt><expr><call><name>mergeSort</name><argument_list>(<argument><expr><name>lo</name></expr></argument>, <argument><expr><name>mid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>mergeSort</name><argument_list>(<argument><expr><name>mid</name></expr></argument>, <argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>runMerge</name><argument_list>(<argument><expr><name>lo</name></expr></argument>, <argument><expr><name>mid</name></expr></argument>, <argument><expr><name>hi</name></expr></argument>, <argument><expr><name>mid</name> <operator>-</operator> <name>lo</name></expr></argument>, <argument><expr><name>hi</name> <operator>-</operator> <name>mid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></function>

  <comment type="block" format="javadoc">/** Sort out trivial cases and reduce the scope of the merge as much as
   *  possible before calling {@link #merge}/ */</comment>
  <function><type><specifier>private</specifier> <name>void</name></type> <name>runMerge</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>lo</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pivot</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>hi</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len1</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len2</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>len1</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>len2</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <return>return;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>setPivot</name><argument_list>(<argument><expr><name>pivot</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>comparePivot</name><argument_list>(<argument><expr><name>pivot</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <comment type="line">// all values from the first run are below all values from the 2nd run</comment>
      <comment type="line">// this shortcut makes mergeSort run in linear time on sorted arrays</comment>
      <return>return;</return>
    </block_content>}</block></if></if_stmt>
    <while>while <condition>(<expr><call><name>comparePivot</name><argument_list>(<argument><expr><name>hi</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><operator>--</operator><name>hi</name></expr>;</expr_stmt>
      <expr_stmt><expr><operator>--</operator><name>len2</name></expr>;</expr_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>setPivot</name><argument_list>(<argument><expr><name>pivot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while <condition>(<expr><call><name>comparePivot</name><argument_list>(<argument><expr><name>lo</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><operator>++</operator><name>lo</name></expr>;</expr_stmt>
      <expr_stmt><expr><operator>--</operator><name>len1</name></expr>;</expr_stmt>
    </block_content>}</block></while>
    <if_stmt><if>if <condition>(<expr><name>len1</name> <operator>+</operator> <name>len2</name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
      <assert>assert <expr><name>len1</name> <operator>==</operator> <name>len2</name></expr>;</assert>
      <assert>assert <expr><call><name>compare</name><argument_list>(<argument><expr><name>lo</name></expr></argument>, <argument><expr><name>pivot</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</assert>
      <expr_stmt><expr><call><name>swap</name><argument_list>(<argument><expr><name>pivot</name></expr></argument>, <argument><expr><name>lo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>merge</name><argument_list>(<argument><expr><name>lo</name></expr></argument>, <argument><expr><name>pivot</name></expr></argument>, <argument><expr><name>hi</name></expr></argument>, <argument><expr><name>len1</name></expr></argument>, <argument><expr><name>len2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></function>

  <comment type="block" format="javadoc">/** Merge the slices [lo-pivot[ (of length len1) and [pivot-hi[ (of length
   *  len2) which are already sorted. This method merges in-place but can be
   *  extended to provide a faster implementation using extra memory. */</comment>
  <function><type><specifier>protected</specifier> <name>void</name></type> <name>merge</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>lo</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pivot</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>hi</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len1</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len2</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>first_cut</name></decl>, <decl><type ref="prev"/><name>second_cut</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>len11</name></decl>, <decl><type ref="prev"/><name>len22</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>len1</name> <operator>&gt;</operator> <name>len2</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>len11</name> <operator>=</operator> <name>len1</name> <operator>&gt;&gt;&gt;</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>first_cut</name> <operator>=</operator> <name>lo</name> <operator>+</operator> <name>len11</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>second_cut</name> <operator>=</operator> <call><name>lower</name><argument_list>(<argument><expr><name>pivot</name></expr></argument>, <argument><expr><name>hi</name></expr></argument>, <argument><expr><name>first_cut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>len22</name> <operator>=</operator> <name>second_cut</name> <operator>-</operator> <name>pivot</name></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><name>len22</name> <operator>=</operator> <name>len2</name> <operator>&gt;&gt;&gt;</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>second_cut</name> <operator>=</operator> <name>pivot</name> <operator>+</operator> <name>len22</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>first_cut</name> <operator>=</operator> <call><name>upper</name><argument_list>(<argument><expr><name>lo</name></expr></argument>, <argument><expr><name>pivot</name></expr></argument>, <argument><expr><name>second_cut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>len11</name> <operator>=</operator> <name>first_cut</name> <operator>-</operator> <name>lo</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>rotate</name><argument_list>(<argument><expr><name>first_cut</name></expr></argument>, <argument><expr><name>pivot</name></expr></argument>, <argument><expr><name>second_cut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>new_mid</name> <init>= <expr><name>first_cut</name> <operator>+</operator> <name>len22</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>runMerge</name><argument_list>(<argument><expr><name>lo</name></expr></argument>, <argument><expr><name>first_cut</name></expr></argument>, <argument><expr><name>new_mid</name></expr></argument>, <argument><expr><name>len11</name></expr></argument>, <argument><expr><name>len22</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>runMerge</name><argument_list>(<argument><expr><name>new_mid</name></expr></argument>, <argument><expr><name>second_cut</name></expr></argument>, <argument><expr><name>hi</name></expr></argument>, <argument><expr><name>len1</name> <operator>-</operator> <name>len11</name></expr></argument>, <argument><expr><name>len2</name> <operator>-</operator> <name>len22</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></function>

  <function><type><specifier>private</specifier> <name>void</name></type> <name>rotate</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>lo</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>mid</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>hi</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>lot</name> <init>= <expr><name>lo</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>hit</name> <init>= <expr><name>mid</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <while>while <condition>(<expr><name>lot</name> <operator>&lt;</operator> <name>hit</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>swap</name><argument_list>(<argument><expr><name>lot</name><operator>++</operator></expr></argument>, <argument><expr><name>hit</name><operator>--</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><name>lot</name> <operator>=</operator> <name>mid</name></expr>;</expr_stmt> <expr_stmt><expr><name>hit</name> <operator>=</operator> <name>hi</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <while>while <condition>(<expr><name>lot</name> <operator>&lt;</operator> <name>hit</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>swap</name><argument_list>(<argument><expr><name>lot</name><operator>++</operator></expr></argument>, <argument><expr><name>hit</name><operator>--</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><name>lot</name> <operator>=</operator> <name>lo</name></expr>;</expr_stmt> <expr_stmt><expr><name>hit</name> <operator>=</operator> <name>hi</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <while>while <condition>(<expr><name>lot</name> <operator>&lt;</operator> <name>hit</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>swap</name><argument_list>(<argument><expr><name>lot</name><operator>++</operator></expr></argument>, <argument><expr><name>hit</name><operator>--</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
  </block_content>}</block></function>

  <function><type><specifier>private</specifier> <name>int</name></type> <name>lower</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>lo</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>hi</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>val</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><name>hi</name> <operator>-</operator> <name>lo</name></expr></init></decl>;</decl_stmt>
    <while>while <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>half</name> <init>= <expr><name>len</name> <operator>&gt;&gt;&gt;</operator> <literal type="number">1</literal></expr></init></decl>,
        <decl><type ref="prev"/><name>mid</name> <init>= <expr><name>lo</name> <operator>+</operator> <name>half</name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><call><name>compare</name><argument_list>(<argument><expr><name>mid</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>lo</name> <operator>=</operator> <name>mid</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>len</name> <operator>=</operator> <name>len</name> <operator>-</operator> <name>half</name> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><name>len</name> <operator>=</operator> <name>half</name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></while>
    <return>return <expr><name>lo</name></expr>;</return>
  </block_content>}</block></function>

  <function><type><specifier>private</specifier> <name>int</name></type> <name>upper</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>lo</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>hi</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>val</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><name>hi</name> <operator>-</operator> <name>lo</name></expr></init></decl>;</decl_stmt>
    <while>while <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>half</name> <init>= <expr><name>len</name> <operator>&gt;&gt;&gt;</operator> <literal type="number">1</literal></expr></init></decl>,
        <decl><type ref="prev"/><name>mid</name> <init>= <expr><name>lo</name> <operator>+</operator> <name>half</name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><call><name>compare</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>mid</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>len</name> <operator>=</operator> <name>half</name></expr>;</expr_stmt>
      </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><name>lo</name> <operator>=</operator> <name>mid</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>len</name> <operator>=</operator> <name>len</name> <operator>-</operator> <name>half</name> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></while>
    <return>return <expr><name>lo</name></expr>;</return>
  </block_content>}</block></function>

}
diff <expr_stmt><expr><operator>--</operator><name>git</name> <name>a</name><operator>/</operator><name>lucene</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>util</name><operator>/</operator><name><name>TimSorter</name><operator>.</operator><name>java</name></name> <name>b</name><operator>/</operator><name>lucene</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>util</name><operator>/</operator><name><name>TimSorter</name><operator>.</operator><name>java</name></name>
<operator>new</operator> <name>file</name> <name>mode</name> <literal type="number">100644</literal>
<name>index</name> <literal type="number">00000000000..57e2f8d8c18</literal>
<operator>--</operator> <operator>/</operator><name>dev</name><operator>/</operator><literal type="null">null</literal>
<operator>++</operator> <name>b</name><operator>/</operator><name>lucene</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>util</name><operator>/</operator><name><name>TimSorter</name><operator>.</operator><name>java</name></name>
@@ <operator>-</operator><literal type="number">0</literal></expr><operator>,</operator><expr><literal type="number">0</literal> <operator>+</operator><literal type="number">1</literal></expr><operator>,</operator><expr><literal type="number">373</literal> @@</expr></expr_stmt>
<package>package <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>util</name></name>;</package>

<comment type="block">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</comment>

<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>Arrays</name></name>;</import>

<comment type="block" format="javadoc">/**
 * {@link Sorter} implementation based on the
 * &lt;a href="http://svn.python.org/projects/python/trunk/Objects/listsort.txt"&gt;TimSort&lt;/a&gt;
 * algorithm.
 * &lt;p&gt;This implementation is especially good at sorting partially-sorted
 * arrays and sorts small arrays with binary sort.
 * &lt;p&gt;&lt;b&gt;NOTE&lt;/b&gt;:There are a few differences with the original implementation:&lt;ul&gt;
 * &lt;li&gt;&lt;a name="maxTempSlots"/&gt;The extra amount of memory to perform merges is
 * configurable. This allows small merges to be very fast while large merges
 * will be performed in-place (slightly slower). You can make sure that the
 * fast merge routine will always be used by having &lt;code&gt;maxTempSlots&lt;/code&gt;
 * equal to half of the length of the slice of data to sort.
 * &lt;li&gt;Only the fast merge routine can gallop (the one that doesn't run
 * in-place) and it only gallops on the longest slice.
 * &lt;/ul&gt;
 * @lucene.internal
 */</comment>
<class><specifier>public</specifier> <specifier>abstract</specifier> class <name>TimSorter</name> <super_list><extends>extends <super><name>Sorter</name></super></extends></super_list> <block>{

  <decl_stmt><decl><type><specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>MINRUN</name> <init>= <expr><literal type="number">32</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>THRESHOLD</name> <init>= <expr><literal type="number">64</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>STACKSIZE</name> <init>= <expr><literal type="number">40</literal></expr></init></decl>;</decl_stmt> <comment type="line">// depends on MINRUN</comment>
  <decl_stmt><decl><type><specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>MIN_GALLOP</name> <init>= <expr><literal type="number">7</literal></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>maxTempSlots</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>minRun</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>to</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>stackSize</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>int</name><index>[]</index></name></type> <name>runEnds</name></decl>;</decl_stmt>

  <comment type="block" format="javadoc">/**
   * Create a new {@link TimSorter}.
   * @param maxTempSlots the &lt;a href="#maxTempSlots"&gt;maximum amount of extra memory to run merges&lt;/a&gt;
   */</comment>
  <constructor><specifier>protected</specifier> <name>TimSorter</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>maxTempSlots</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>super</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>runEnds</name> <operator>=</operator> <operator>new</operator> <name><name>int</name><index>[<expr><literal type="number">1</literal> <operator>+</operator> <name>STACKSIZE</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>this</name><operator>.</operator><name>maxTempSlots</name></name> <operator>=</operator> <name>maxTempSlots</name></expr>;</expr_stmt>
  </block_content>}</block></constructor>

  <comment type="block" format="javadoc">/** Minimum run length for an array of length &lt;code&gt;length&lt;/code&gt;. */</comment>
  <function><type><specifier>static</specifier> <name>int</name></type> <name>minRun</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>length</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <assert>assert <expr><name>length</name> <operator>&gt;=</operator> <name>MINRUN</name></expr>;</assert>
    <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><name>length</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>r</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <while>while <condition>(<expr><name>n</name> <operator>&gt;=</operator> <literal type="number">64</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>r</name> <operator>|=</operator> <name>n</name> <operator>&amp;</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>n</name> <operator>&gt;&gt;&gt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></while>
    <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>minRun</name> <init>= <expr><name>n</name> <operator>+</operator> <name>r</name></expr></init></decl>;</decl_stmt>
    <assert>assert <expr><name>minRun</name> <operator>&gt;=</operator> <name>MINRUN</name> <operator>&amp;&amp;</operator> <name>minRun</name> <operator>&lt;=</operator> <name>THRESHOLD</name></expr>;</assert>
    <return>return <expr><name>minRun</name></expr>;</return>
  </block_content>}</block></function>

  <function><type><name>int</name></type> <name>runLen</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>off</name> <init>= <expr><name>stackSize</name> <operator>-</operator> <name>i</name></expr></init></decl>;</decl_stmt>
    <return>return <expr><name><name>runEnds</name><index>[<expr><name>off</name></expr>]</index></name> <operator>-</operator> <name><name>runEnds</name><index>[<expr><name>off</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</return>
  </block_content>}</block></function>

  <function><type><name>int</name></type> <name>runBase</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <return>return <expr><name><name>runEnds</name><index>[<expr><name>stackSize</name> <operator>-</operator> <name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</return>
  </block_content>}</block></function>

  <function><type><name>int</name></type> <name>runEnd</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <return>return <expr><name><name>runEnds</name><index>[<expr><name>stackSize</name> <operator>-</operator> <name>i</name></expr>]</index></name></expr>;</return>
  </block_content>}</block></function>

  <function><type><name>void</name></type> <name>setRunEnd</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>runEnd</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><name><name>runEnds</name><index>[<expr><name>stackSize</name> <operator>-</operator> <name>i</name></expr>]</index></name> <operator>=</operator> <name>runEnd</name></expr>;</expr_stmt>
  </block_content>}</block></function>

  <function><type><name>void</name></type> <name>pushRunLen</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><name><name>runEnds</name><index>[<expr><name>stackSize</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>runEnds</name><index>[<expr><name>stackSize</name></expr>]</index></name> <operator>+</operator> <name>len</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>++</operator><name>stackSize</name></expr>;</expr_stmt>
  </block_content>}</block></function>

  <comment type="block" format="javadoc">/** Compute the length of the next run, make the run sorted and return its
   *  length. */</comment>
  <function><type><name>int</name></type> <name>nextRun</name><parameter_list>()</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>runBase</name> <init>= <expr><call><name>runEnd</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <assert>assert <expr><name>runBase</name> <operator>&lt;</operator> <name>to</name></expr>;</assert>
    <if_stmt><if>if <condition>(<expr><name>runBase</name> <operator>==</operator> <name>to</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
      <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>o</name> <init>= <expr><name>runBase</name> <operator>+</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>compare</name><argument_list>(<argument><expr><name>runBase</name></expr></argument>, <argument><expr><name>runBase</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <comment type="line">// run must be strictly descending</comment>
      <while>while <condition>(<expr><name>o</name> <operator>&lt;</operator> <name>to</name> <operator>&amp;&amp;</operator> <call><name>compare</name><argument_list>(<argument><expr><name>o</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>o</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><operator>++</operator><name>o</name></expr>;</expr_stmt>
      </block_content>}</block></while>
      <expr_stmt><expr><call><name>reverse</name><argument_list>(<argument><expr><name>runBase</name></expr></argument>, <argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <comment type="line">// run must be non-descending</comment>
      <while>while <condition>(<expr><name>o</name> <operator>&lt;</operator> <name>to</name> <operator>&amp;&amp;</operator> <call><name>compare</name><argument_list>(<argument><expr><name>o</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>o</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><operator>++</operator><name>o</name></expr>;</expr_stmt>
      </block_content>}</block></while>
    </block_content>}</block></else></if_stmt>
    <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>runHi</name> <init>= <expr><call><name><name>Math</name><operator>.</operator><name>max</name></name><argument_list>(<argument><expr><name>o</name></expr></argument>, <argument><expr><call><name><name>Math</name><operator>.</operator><name>min</name></name><argument_list>(<argument><expr><name>to</name></expr></argument>, <argument><expr><name>runBase</name> <operator>+</operator> <name>minRun</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>binarySort</name><argument_list>(<argument><expr><name>runBase</name></expr></argument>, <argument><expr><name>runHi</name></expr></argument>, <argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>runHi</name> <operator>-</operator> <name>runBase</name></expr>;</return>
  </block_content>}</block></function>

  <function><type><name>void</name></type> <name>ensureInvariants</name><parameter_list>()</parameter_list> <block>{<block_content>
    <while>while <condition>(<expr><name>stackSize</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>runLen0</name> <init>= <expr><call><name>runLen</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>runLen1</name> <init>= <expr><call><name>runLen</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

      <if_stmt><if>if <condition>(<expr><name>stackSize</name> <operator>&gt;</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>runLen2</name> <init>= <expr><call><name>runLen</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>runLen2</name> <operator>&lt;=</operator> <name>runLen1</name> <operator>+</operator> <name>runLen0</name></expr>)</condition> <block>{<block_content>
          <comment type="line">// merge the smaller of 0 and 2 with 1</comment>
          <if_stmt><if>if <condition>(<expr><name>runLen2</name> <operator>&lt;</operator> <name>runLen0</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>mergeAt</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><call><name>mergeAt</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></else></if_stmt>
          <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>

      <if_stmt><if>if <condition>(<expr><name>runLen1</name> <operator>&lt;=</operator> <name>runLen0</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>mergeAt</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <continue>continue;</continue>
      </block_content>}</block></if></if_stmt>

      <break>break;</break>
    </block_content>}</block></while>
  </block_content>}</block></function>

  <function><type><name>void</name></type> <name>exhaustStack</name><parameter_list>()</parameter_list> <block>{<block_content>
    <while>while <condition>(<expr><name>stackSize</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>mergeAt</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
  </block_content>}</block></function>

  <function><type><name>void</name></type> <name>reset</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>from</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>to</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><name>stackSize</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>Arrays</name><operator>.</operator><name>fill</name></name><argument_list>(<argument><expr><name>runEnds</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>runEnds</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>from</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>this</name><operator>.</operator><name>to</name></name> <operator>=</operator> <name>to</name></expr>;</expr_stmt>
    <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>length</name> <init>= <expr><name>to</name> <operator>-</operator> <name>from</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>this</name><operator>.</operator><name>minRun</name></name> <operator>=</operator> <ternary><condition><expr><name>length</name> <operator>&lt;=</operator> <name>THRESHOLD</name></expr> ?</condition><then> <expr><name>length</name></expr> </then><else>: <expr><call><name>minRun</name><argument_list>(<argument><expr><name>length</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
  </block_content>}</block></function>

  <function><type><name>void</name></type> <name>mergeAt</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <assert>assert <expr><name>stackSize</name> <operator>&gt;=</operator> <literal type="number">2</literal></expr>;</assert>
    <expr_stmt><expr><call><name>merge</name><argument_list>(<argument><expr><call><name>runBase</name><argument_list>(<argument><expr><name>n</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>runBase</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>runEnd</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><name>n</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><operator>--</operator><name>j</name></expr></incr>)</control> <block>{<block_content>
      <expr_stmt><expr><call><name>setRunEnd</name><argument_list>(<argument><expr><name>j</name></expr></argument>, <argument><expr><call><name>runEnd</name><argument_list>(<argument><expr><name>j</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><operator>--</operator><name>stackSize</name></expr>;</expr_stmt>
  </block_content>}</block></function>

  <function><type><name>void</name></type> <name>merge</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>lo</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>mid</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>hi</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>compare</name><argument_list>(<argument><expr><name>mid</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>mid</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <return>return;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>lo</name> <operator>=</operator> <call><name>upper2</name><argument_list>(<argument><expr><name>lo</name></expr></argument>, <argument><expr><name>mid</name></expr></argument>, <argument><expr><name>mid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>hi</name> <operator>=</operator> <call><name>lower2</name><argument_list>(<argument><expr><name>mid</name></expr></argument>, <argument><expr><name>hi</name></expr></argument>, <argument><expr><name>mid</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>hi</name> <operator>-</operator> <name>mid</name> <operator>&lt;=</operator> <name>mid</name> <operator>-</operator> <name>lo</name> <operator>&amp;&amp;</operator> <name>hi</name> <operator>-</operator> <name>mid</name> <operator>&lt;=</operator> <name>maxTempSlots</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>mergeHi</name><argument_list>(<argument><expr><name>lo</name></expr></argument>, <argument><expr><name>mid</name></expr></argument>, <argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>mid</name> <operator>-</operator> <name>lo</name> <operator>&lt;=</operator> <name>maxTempSlots</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>mergeLo</name><argument_list>(<argument><expr><name>lo</name></expr></argument>, <argument><expr><name>mid</name></expr></argument>, <argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><call><name>mergeInPlace</name><argument_list>(<argument><expr><name>lo</name></expr></argument>, <argument><expr><name>mid</name></expr></argument>, <argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></function>

  <function><annotation>@<name>Override</name></annotation>
  <type><specifier>public</specifier> <name>void</name></type> <name>sort</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>from</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>to</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>checkRange</name><argument_list>(<argument><expr><name>from</name></expr></argument>, <argument><expr><name>to</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>to</name> <operator>-</operator> <name>from</name> <operator>&lt;=</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
      <return>return;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>reset</name><argument_list>(<argument><expr><name>from</name></expr></argument>, <argument><expr><name>to</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <do>do <block>{<block_content>
      <expr_stmt><expr><call><name>ensureInvariants</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>pushRunLen</name><argument_list>(<argument><expr><call><name>nextRun</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block> while <condition>(<expr><call><name>runEnd</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>to</name></expr>)</condition>;</do>
    <expr_stmt><expr><call><name>exhaustStack</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <assert>assert <expr><call><name>runEnd</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>to</name></expr>;</assert>
  </block_content>}</block></function>

  <function><annotation>@<name>Override</name></annotation>
  <type><name>void</name></type> <name>rotate</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>lo</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>mid</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>hi</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>len1</name> <init>= <expr><name>mid</name> <operator>-</operator> <name>lo</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>len2</name> <init>= <expr><name>hi</name> <operator>-</operator> <name>mid</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>len1</name> <operator>==</operator> <name>len2</name></expr>)</condition> <block>{<block_content>
      <while>while <condition>(<expr><name>mid</name> <operator>&lt;</operator> <name>hi</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>swap</name><argument_list>(<argument><expr><name>lo</name><operator>++</operator></expr></argument>, <argument><expr><name>mid</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></while>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>len2</name> <operator>&lt;</operator> <name>len1</name> <operator>&amp;&amp;</operator> <name>len2</name> <operator>&lt;=</operator> <name>maxTempSlots</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>save</name><argument_list>(<argument><expr><name>mid</name></expr></argument>, <argument><expr><name>len2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><name>lo</name> <operator>+</operator> <name>len1</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>, <decl><type ref="prev"/><name>j</name> <init>= <expr><name>hi</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <name>lo</name></expr>;</condition> <incr><expr><operator>--</operator><name>i</name></expr><operator>,</operator> <expr><operator>--</operator><name>j</name></expr></incr>)</control> <block>{<block_content>
        <expr_stmt><expr><call><name>copy</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
      <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>j</name> <init>= <expr><name>lo</name></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>len2</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr><operator>,</operator> <expr><operator>++</operator><name>j</name></expr></incr>)</control> <block>{<block_content>
        <expr_stmt><expr><call><name>restore</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>len1</name> <operator>&lt;=</operator> <name>maxTempSlots</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>save</name><argument_list>(<argument><expr><name>lo</name></expr></argument>, <argument><expr><name>len1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><name>mid</name></expr></init></decl>, <decl><type ref="prev"/><name>j</name> <init>= <expr><name>lo</name></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>hi</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr><operator>,</operator> <expr><operator>++</operator><name>j</name></expr></incr>)</control> <block>{<block_content>
        <expr_stmt><expr><call><name>copy</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
      <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>j</name> <init>= <expr><name>lo</name> <operator>+</operator> <name>len2</name></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>hi</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr><operator>,</operator> <expr><operator>++</operator><name>j</name></expr></incr>)</control> <block>{<block_content>
        <expr_stmt><expr><call><name>restore</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><call><name>reverse</name><argument_list>(<argument><expr><name>lo</name></expr></argument>, <argument><expr><name>mid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>reverse</name><argument_list>(<argument><expr><name>mid</name></expr></argument>, <argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>reverse</name><argument_list>(<argument><expr><name>lo</name></expr></argument>, <argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></function>

  <function><type><name>void</name></type> <name>mergeLo</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>lo</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>mid</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>hi</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <assert>assert <expr><call><name>compare</name><argument_list>(<argument><expr><name>lo</name></expr></argument>, <argument><expr><name>mid</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</assert>
    <decl_stmt><decl><type><name>int</name></type> <name>len1</name> <init>= <expr><name>mid</name> <operator>-</operator> <name>lo</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>save</name><argument_list>(<argument><expr><name>lo</name></expr></argument>, <argument><expr><name>len1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>copy</name><argument_list>(<argument><expr><name>mid</name></expr></argument>, <argument><expr><name>lo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>j</name> <init>= <expr><name>mid</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>, <decl><type ref="prev"/><name>dest</name> <init>= <expr><name>lo</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <label><name>outer</name>:</label> <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
      <for>for <control>(<init><decl><type><name>int</name></type> <name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>count</name> <operator>&lt;</operator> <name>MIN_GALLOP</name></expr>;</condition> <incr/>)</control> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;=</operator> <name>len1</name> <operator>||</operator> <name>j</name> <operator>&gt;=</operator> <name>hi</name></expr>)</condition> <block>{<block_content>
          <break>break <name>outer</name>;</break>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>compareSaved</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><call><name>restore</name><argument_list>(<argument><expr><name>i</name><operator>++</operator></expr></argument>, <argument><expr><name>dest</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
          <expr_stmt><expr><call><name>copy</name><argument_list>(<argument><expr><name>j</name><operator>++</operator></expr></argument>, <argument><expr><name>dest</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><operator>++</operator><name>count</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></for>
      <comment type="line">// galloping...</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>next</name> <init>= <expr><call><name>lowerSaved3</name><argument_list>(<argument><expr><name>j</name></expr></argument>, <argument><expr><name>hi</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <for>for <control>(<init>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>next</name></expr>;</condition> <incr><expr><operator>++</operator><name>dest</name></expr></incr>)</control> <block>{<block_content>
        <expr_stmt><expr><call><name>copy</name><argument_list>(<argument><expr><name>j</name><operator>++</operator></expr></argument>, <argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
      <expr_stmt><expr><call><name>restore</name><argument_list>(<argument><expr><name>i</name><operator>++</operator></expr></argument>, <argument><expr><name>dest</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <for>for <control>(<init>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>len1</name></expr>;</condition> <incr><expr><operator>++</operator><name>dest</name></expr></incr>)</control> <block>{<block_content>
      <expr_stmt><expr><call><name>restore</name><argument_list>(<argument><expr><name>i</name><operator>++</operator></expr></argument>, <argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <assert>assert <expr><name>j</name> <operator>==</operator> <name>dest</name></expr>;</assert>
  </block_content>}</block></function>

  <function><type><name>void</name></type> <name>mergeHi</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>lo</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>mid</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>hi</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <assert>assert <expr><call><name>compare</name><argument_list>(<argument><expr><name>mid</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>hi</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</assert>
    <decl_stmt><decl><type><name>int</name></type> <name>len2</name> <init>= <expr><name>hi</name> <operator>-</operator> <name>mid</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>save</name><argument_list>(<argument><expr><name>mid</name></expr></argument>, <argument><expr><name>len2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>copy</name><argument_list>(<argument><expr><name>mid</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>hi</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><name>mid</name> <operator>-</operator> <literal type="number">2</literal></expr></init></decl>, <decl><type ref="prev"/><name>j</name> <init>= <expr><name>len2</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>, <decl><type ref="prev"/><name>dest</name> <init>= <expr><name>hi</name> <operator>-</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt>
    <label><name>outer</name>:</label> <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
      <for>for <control>(<init><decl><type><name>int</name></type> <name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>count</name> <operator>&lt;</operator> <name>MIN_GALLOP</name></expr>;</condition> <incr/>)</control> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <name>lo</name> <operator>||</operator> <name>j</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
          <break>break <name>outer</name>;</break>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>compareSaved</name><argument_list>(<argument><expr><name>j</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><call><name>restore</name><argument_list>(<argument><expr><name>j</name><operator>--</operator></expr></argument>, <argument><expr><name>dest</name><operator>--</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
          <expr_stmt><expr><call><name>copy</name><argument_list>(<argument><expr><name>i</name><operator>--</operator></expr></argument>, <argument><expr><name>dest</name><operator>--</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><operator>++</operator><name>count</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></for>
      <comment type="line">// galloping</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>next</name> <init>= <expr><call><name>upperSaved3</name><argument_list>(<argument><expr><name>lo</name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <while>while <condition>(<expr><name>i</name> <operator>&gt;=</operator> <name>next</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>copy</name><argument_list>(<argument><expr><name>i</name><operator>--</operator></expr></argument>, <argument><expr><name>dest</name><operator>--</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></while>
      <expr_stmt><expr><call><name>restore</name><argument_list>(<argument><expr><name>j</name><operator>--</operator></expr></argument>, <argument><expr><name>dest</name><operator>--</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <for>for <control>(<init>;</init> <condition><expr><name>j</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><operator>--</operator><name>dest</name></expr></incr>)</control> <block>{<block_content>
      <expr_stmt><expr><call><name>restore</name><argument_list>(<argument><expr><name>j</name><operator>--</operator></expr></argument>, <argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <assert>assert <expr><name>i</name> <operator>==</operator> <name>dest</name></expr>;</assert>
  </block_content>}</block></function>

  <function><type><name>int</name></type> <name>lowerSaved</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>from</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>to</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>val</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><name>to</name> <operator>-</operator> <name>from</name></expr></init></decl>;</decl_stmt>
    <while>while <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>half</name> <init>= <expr><name>len</name> <operator>&gt;&gt;&gt;</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>mid</name> <init>= <expr><name>from</name> <operator>+</operator> <name>half</name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><call><name>compareSaved</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>mid</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>from</name> <operator>=</operator> <name>mid</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>len</name> <operator>=</operator> <name>len</name> <operator>-</operator> <name>half</name> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><name>len</name> <operator>=</operator> <name>half</name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></while>
    <return>return <expr><name>from</name></expr>;</return>
  </block_content>}</block></function>

  <function><type><name>int</name></type> <name>upperSaved</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>from</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>to</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>val</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><name>to</name> <operator>-</operator> <name>from</name></expr></init></decl>;</decl_stmt>
    <while>while <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>half</name> <init>= <expr><name>len</name> <operator>&gt;&gt;&gt;</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>mid</name> <init>= <expr><name>from</name> <operator>+</operator> <name>half</name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><call><name>compareSaved</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>mid</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>len</name> <operator>=</operator> <name>half</name></expr>;</expr_stmt>
      </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><name>from</name> <operator>=</operator> <name>mid</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>len</name> <operator>=</operator> <name>len</name> <operator>-</operator> <name>half</name> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></while>
    <return>return <expr><name>from</name></expr>;</return>
  </block_content>}</block></function>

  <comment type="line">// faster than lowerSaved when val is at the beginning of [from:to[</comment>
  <function><type><name>int</name></type> <name>lowerSaved3</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>from</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>to</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>val</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>f</name> <init>= <expr><name>from</name></expr></init></decl>, <decl><type ref="prev"/><name>t</name> <init>= <expr><name>f</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <while>while <condition>(<expr><name>t</name> <operator>&lt;</operator> <name>to</name></expr>)</condition> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><call><name>compareSaved</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <return>return <expr><call><name>lowerSaved</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>delta</name> <init>= <expr><name>t</name> <operator>-</operator> <name>f</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>f</name> <operator>=</operator> <name>t</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>t</name> <operator>+=</operator> <name>delta</name> <operator>&lt;&lt;</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></while>
    <return>return <expr><call><name>lowerSaved</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>to</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></function>

  <comment type="line">//faster than upperSaved when val is at the end of [from:to[</comment>
  <function><type><name>int</name></type> <name>upperSaved3</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>from</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>to</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>val</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>f</name> <init>= <expr><name>to</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>, <decl><type ref="prev"/><name>t</name> <init>= <expr><name>to</name></expr></init></decl>;</decl_stmt>
    <while>while <condition>(<expr><name>f</name> <operator>&gt;</operator> <name>from</name></expr>)</condition> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><call><name>compareSaved</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <return>return <expr><call><name>upperSaved</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>delta</name> <init>= <expr><name>t</name> <operator>-</operator> <name>f</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>t</name> <operator>=</operator> <name>f</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>f</name> <operator>-=</operator> <name>delta</name> <operator>&lt;&lt;</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></while>
    <return>return <expr><call><name>upperSaved</name><argument_list>(<argument><expr><name>from</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></function>

  <comment type="block" format="javadoc">/** Copy data from slot &lt;code&gt;src&lt;/code&gt; to slot &lt;code&gt;dest&lt;/code&gt;. */</comment>
  <function_decl><type><specifier>protected</specifier> <specifier>abstract</specifier> <name>void</name></type> <name>copy</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>dest</name></decl></parameter>)</parameter_list>;</function_decl>

  <comment type="block" format="javadoc">/** Save all elements between slots &lt;code&gt;i&lt;/code&gt; and &lt;code&gt;i+len&lt;/code&gt;
   *  into the temporary storage. */</comment>
  <function_decl><type><specifier>protected</specifier> <specifier>abstract</specifier> <name>void</name></type> <name>save</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>;</function_decl>

  <comment type="block" format="javadoc">/** Restore element &lt;code&gt;j&lt;/code&gt; from the temporary storage into slot &lt;code&gt;i&lt;/code&gt;. */</comment>
  <function_decl><type><specifier>protected</specifier> <specifier>abstract</specifier> <name>void</name></type> <name>restore</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>j</name></decl></parameter>)</parameter_list>;</function_decl>

  <comment type="block" format="javadoc">/** Compare element &lt;code&gt;i&lt;/code&gt; from the temporary storage with element
   *  &lt;code&gt;j&lt;/code&gt; from the slice to sort, similarly to
   *  {@link #compare(int, int)}. */</comment>
  <function_decl><type><specifier>protected</specifier> <specifier>abstract</specifier> <name>int</name></type> <name>compareSaved</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>j</name></decl></parameter>)</parameter_list>;</function_decl>

}</block></class>
<expr_stmt><expr><name>diff</name> <operator>--</operator><name>git</name> <name>a</name><operator>/</operator><name>lucene</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>util</name><operator>/</operator><name>automaton</name><operator>/</operator><name><name>BasicOperations</name><operator>.</operator><name>java</name></name> <name>b</name><operator>/</operator><name>lucene</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>util</name><operator>/</operator><name>automaton</name><operator>/</operator><name><name>BasicOperations</name><operator>.</operator><name>java</name></name>
<name>index</name> <literal type="number">7424615eb0f</literal><operator>..</operator><literal type="number">781a4e262e3</literal> <literal type="number">100644</literal>
<operator>--</operator> <name>a</name><operator>/</operator><name>lucene</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>util</name><operator>/</operator><name>automaton</name><operator>/</operator><name><name>BasicOperations</name><operator>.</operator><name>java</name></name>
<operator>++</operator> <name>b</name><operator>/</operator><name>lucene</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>util</name><operator>/</operator><name>automaton</name><operator>/</operator><name><name>BasicOperations</name><operator>.</operator><name>java</name></name>
@@ <operator>-</operator><literal type="number">557</literal></expr><operator>,</operator><expr><literal type="number">8</literal> <operator>+</operator><literal type="number">557</literal></expr><operator>,</operator><expr><literal type="number">8</literal> @@ <name>final</name> <specifier>public</specifier> <name>class</name> <name>BasicOperations</name> <block>{
     }</block>
 
     <specifier>public</specifier> <name>void</name> <call><name>sort</name><argument_list>()</argument_list></call> <block>{
      <comment type="line">// mergesort seems to perform better on already sorted arrays:</comment>
      <if_stmt><if>if <condition>(<expr><name>count</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name><name>ArrayUtil</name><operator>.</operator><name>mergeSort</name></name><argument_list>(<argument><expr><name>points</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block></expr></expr_stmt>
      <comment type="line">// Tim sort performs well on already sorted arrays:</comment>
      <if_stmt><if>if <condition>(<expr><name>count</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name><name>ArrayUtil</name><operator>.</operator><name>timSort</name></name><argument_list>(<argument><expr><name>points</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
     }
 
     public <function><type><name>void</name></type> <name>add</name><parameter_list>(<parameter><decl><type><name>Transition</name></type> <name>t</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>diff</name> <operator>--</operator><name>git</name> <name>a</name><operator>/</operator><name>lucene</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>util</name><operator>/</operator><name>automaton</name><operator>/</operator><name><name>State</name><operator>.</operator><name>java</name></name> <name>b</name><operator>/</operator><name>lucene</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>util</name><operator>/</operator><name>automaton</name><operator>/</operator><name><name>State</name><operator>.</operator><name>java</name></name>
<name>index</name> <name>fb185a3f2a9</name><operator>..</operator><literal type="number">9dc229fd7db</literal> <literal type="number">100644</literal>
<operator>--</operator> <name>a</name><operator>/</operator><name>lucene</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>util</name><operator>/</operator><name>automaton</name><operator>/</operator><name><name>State</name><operator>.</operator><name>java</name></name>
<operator>++</operator> <name>b</name><operator>/</operator><name>lucene</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>util</name><operator>/</operator><name>automaton</name><operator>/</operator><name><name>State</name><operator>.</operator><name>java</name></name>
@@ <operator>-</operator><literal type="number">239</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">239</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@ <specifier>public</specifier> <name>class</name> <name>State</name> implements <name><name>Comparable</name><argument_list type="generic">&lt;<argument><name>State</name></argument>&gt;</argument_list></name> <block>{
   <comment type="block" format="javadoc">/** Sorts transitions array in-place. */</comment>
   <expr><specifier>public</specifier> <name>void</name> <call><name>sortTransitions</name><argument_list>(<argument><expr><name><name>Comparator</name><argument_list type="generic">&lt;<argument><name>Transition</name></argument>&gt;</argument_list></name> <name>comparator</name></expr></argument>)</argument_list></call> <block>{
     <comment type="line">// mergesort seems to perform better on already sorted arrays:</comment>
    <if_stmt><if>if <condition>(<expr><name>numTransitions</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name><name>ArrayUtil</name><operator>.</operator><name>mergeSort</name></name><argument_list>(<argument><expr><name>transitionsArray</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>numTransitions</name></expr></argument>, <argument><expr><name>comparator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block></expr>
    <if_stmt><if>if <condition>(<expr><name>numTransitions</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name><name>ArrayUtil</name><operator>.</operator><name>timSort</name></name><argument_list>(<argument><expr><name>transitionsArray</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>numTransitions</name></expr></argument>, <argument><expr><name>comparator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
   }</block></expr></expr_stmt>
   
   <comment type="block" format="javadoc">/**
diff --git a/lucene/core/src/test/org/apache/lucene/util/BaseSortTestCase.java b/lucene/core/src/test/org/apache/lucene/util/BaseSortTestCase.java
new file mode 100644
index 00000000000..8646f23f475
-- /dev/null
++ b/lucene/core/src/test/org/apache/lucene/util/BaseSortTestCase.java
@@ -0,0 +1,173 @@
package org.apache.lucene.util;

/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</comment>

<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>Arrays</name></name>;</import>

<class><specifier>public</specifier> <specifier>abstract</specifier> class <name>BaseSortTestCase</name> <super_list><extends>extends <super><name>LuceneTestCase</name></super></extends></super_list> <block>{

  <class><specifier>public</specifier> <specifier>static</specifier> class <name>Entry</name> <super_list><implements>implements <super><name><name>java</name><operator>.</operator><name>lang</name><operator>.</operator><name><name>Comparable</name><argument_list type="generic">&lt;<argument><name>Entry</name></argument>&gt;</argument_list></name></name></super></implements></super_list> <block>{

    <decl_stmt><decl><type><specifier>public</specifier> <specifier>final</specifier> <name>int</name></type> <name>value</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>public</specifier> <specifier>final</specifier> <name>int</name></type> <name>ord</name></decl>;</decl_stmt>

    <constructor><specifier>public</specifier> <name>Entry</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ord</name></decl></parameter>)</parameter_list> <block>{<block_content>
      <expr_stmt><expr><name><name>this</name><operator>.</operator><name>value</name></name> <operator>=</operator> <name>value</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>this</name><operator>.</operator><name>ord</name></name> <operator>=</operator> <name>ord</name></expr>;</expr_stmt>
    </block_content>}</block></constructor>

    <function><annotation>@<name>Override</name></annotation>
    <type><specifier>public</specifier> <name>int</name></type> <name>compareTo</name><parameter_list>(<parameter><decl><type><name>Entry</name></type> <name>other</name></decl></parameter>)</parameter_list> <block>{<block_content>
      <return>return <expr><ternary><condition><expr><name>value</name> <operator>&lt;</operator> <name><name>other</name><operator>.</operator><name>value</name></name></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><ternary><condition><expr><name>value</name> <operator>==</operator> <name><name>other</name><operator>.</operator><name>value</name></name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr></else></ternary></expr>;</return>
    </block_content>}</block></function>

  }</block></class>

  <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>boolean</name></type> <name>stable</name></decl>;</decl_stmt>

  <constructor><specifier>public</specifier> <name>BaseSortTestCase</name><parameter_list>(<parameter><decl><type><name>boolean</name></type> <name>stable</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><name><name>this</name><operator>.</operator><name>stable</name></name> <operator>=</operator> <name>stable</name></expr>;</expr_stmt>
  </block_content>}</block></constructor>

  <decl_stmt><decl><type><specifier>public</specifier> <specifier>abstract</specifier> <name>Sorter</name></type> <name>newSorter</name><argument_list>(<argument><expr><name><name>Entry</name><index>[]</index></name> <name>arr</name></expr></argument>)</argument_list></decl>;</decl_stmt>

  <function><type><specifier>public</specifier> <name>void</name></type> <name>assertSorted</name><parameter_list>(<parameter><decl><type><name><name>Entry</name><index>[]</index></name></type> <name>original</name></decl></parameter>, <parameter><decl><type><name><name>Entry</name><index>[]</index></name></type> <name>sorted</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><name><name>original</name><operator>.</operator><name>length</name></name></expr></argument>, <argument><expr><name><name>sorted</name><operator>.</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name><name>Entry</name><index>[]</index></name></type> <name>actuallySorted</name> <init>= <expr><call><name><name>Arrays</name><operator>.</operator><name>copyOf</name></name><argument_list>(<argument><expr><name>original</name></expr></argument>, <argument><expr><name><name>original</name><operator>.</operator><name>length</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>Arrays</name><operator>.</operator><name>sort</name></name><argument_list>(<argument><expr><name>actuallySorted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>original</name><operator>.</operator><name>length</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
      <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><name><name>actuallySorted</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>value</name></expr></argument>, <argument><expr><name><name>sorted</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>stable</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><name><name>actuallySorted</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ord</name></expr></argument>, <argument><expr><name><name>sorted</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ord</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
  </block_content>}</block></function>

  <function><type><specifier>public</specifier> <name>void</name></type> <name>test</name><parameter_list>(<parameter><decl><type><name><name>Entry</name><index>[]</index></name></type> <name>arr</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>o</name> <init>= <expr><call><name>random</name><argument_list>()</argument_list></call><operator>.</operator><call><name>nextInt</name><argument_list>(<argument><expr><literal type="number">1000</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>final</specifier> <name><name>Entry</name><index>[]</index></name></type> <name>toSort</name> <init>= <expr><operator>new</operator> <name><name>Entry</name><index>[<expr><name>o</name> <operator>+</operator> <name><name>arr</name><operator>.</operator><name>length</name></name> <operator>+</operator> <call><name>random</name><argument_list>()</argument_list></call><operator>.</operator><call><name>nextInt</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>System</name><operator>.</operator><name>arraycopy</name></name><argument_list>(<argument><expr><name>arr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>toSort</name></expr></argument>, <argument><expr><name>o</name></expr></argument>, <argument><expr><name><name>arr</name><operator>.</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><specifier>final</specifier> <name>Sorter</name></type> <name>sorter</name> <init>= <expr><call><name>newSorter</name><argument_list>(<argument><expr><name>toSort</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>sorter</name><operator>.</operator><name>sort</name></name><argument_list>(<argument><expr><name>o</name></expr></argument>, <argument><expr><name>o</name> <operator>+</operator> <name><name>arr</name><operator>.</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assertSorted</name><argument_list>(<argument><expr><name>arr</name></expr></argument>, <argument><expr><call><name><name>Arrays</name><operator>.</operator><name>copyOfRange</name></name><argument_list>(<argument><expr><name>toSort</name></expr></argument>, <argument><expr><name>o</name></expr></argument>, <argument><expr><name>o</name> <operator>+</operator> <name><name>arr</name><operator>.</operator><name>length</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></function>

  <enum>enum <name>Strategy</name> <block>{
    <decl><name>RANDOM</name> <block>{
      <function><annotation>@<name>Override</name></annotation>
      <type><specifier>public</specifier> <name>void</name></type> <name>set</name><parameter_list>(<parameter><decl><type><name><name>Entry</name><index>[]</index></name></type> <name>arr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <expr_stmt><expr><name><name>arr</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>new</operator> <call><name>Entry</name><argument_list>(<argument><expr><call><name>random</name><argument_list>()</argument_list></call><operator>.</operator><call><name>nextInt</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></function>
    }</block></decl>,
    <decl><name>RANDOM_LOW_CARDINALITY</name> <block>{
      <function><annotation>@<name>Override</name></annotation>
      <type><specifier>public</specifier> <name>void</name></type> <name>set</name><parameter_list>(<parameter><decl><type><name><name>Entry</name><index>[]</index></name></type> <name>arr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <expr_stmt><expr><name><name>arr</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>new</operator> <call><name>Entry</name><argument_list>(<argument><expr><call><name>random</name><argument_list>()</argument_list></call><operator>.</operator><call><name>nextInt</name><argument_list>(<argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></function>
    }</block></decl>,
    <decl><name>ASCENDING</name> <block>{
      <function><annotation>@<name>Override</name></annotation>
      <type><specifier>public</specifier> <name>void</name></type> <name>set</name><parameter_list>(<parameter><decl><type><name><name>Entry</name><index>[]</index></name></type> <name>arr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <expr_stmt><expr><name><name>arr</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <ternary><condition><expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>
            ?</condition><then> <expr><operator>new</operator> <call><name>Entry</name><argument_list>(<argument><expr><call><name>random</name><argument_list>()</argument_list></call><operator>.</operator><call><name>nextInt</name><argument_list>(<argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>
            </then><else>: <expr><operator>new</operator> <call><name>Entry</name><argument_list>(<argument><expr><name><name>arr</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>value</name> <operator>+</operator> <call><name>random</name><argument_list>()</argument_list></call><operator>.</operator><call><name>nextInt</name><argument_list>(<argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
      </block_content>}</block></function>
    }</block></decl>,
    <decl><name>DESCENDING</name> <block>{
      <function><annotation>@<name>Override</name></annotation>
      <type><specifier>public</specifier> <name>void</name></type> <name>set</name><parameter_list>(<parameter><decl><type><name><name>Entry</name><index>[]</index></name></type> <name>arr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <expr_stmt><expr><name><name>arr</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <ternary><condition><expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>
            ?</condition><then> <expr><operator>new</operator> <call><name>Entry</name><argument_list>(<argument><expr><call><name>random</name><argument_list>()</argument_list></call><operator>.</operator><call><name>nextInt</name><argument_list>(<argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>
            </then><else>: <expr><operator>new</operator> <call><name>Entry</name><argument_list>(<argument><expr><name><name>arr</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>value</name> <operator>-</operator> <call><name>random</name><argument_list>()</argument_list></call><operator>.</operator><call><name>nextInt</name><argument_list>(<argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
      </block_content>}</block></function>
    }</block></decl>,
    <decl><name>STRICTLY_DESCENDING</name> <block>{
      <function><annotation>@<name>Override</name></annotation>
      <type><specifier>public</specifier> <name>void</name></type> <name>set</name><parameter_list>(<parameter><decl><type><name><name>Entry</name><index>[]</index></name></type> <name>arr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <expr_stmt><expr><name><name>arr</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <ternary><condition><expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>
            ?</condition><then> <expr><operator>new</operator> <call><name>Entry</name><argument_list>(<argument><expr><call><name>random</name><argument_list>()</argument_list></call><operator>.</operator><call><name>nextInt</name><argument_list>(<argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>
            </then><else>: <expr><operator>new</operator> <call><name>Entry</name><argument_list>(<argument><expr><name><name>arr</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>value</name> <operator>-</operator> <call><name><name>_TestUtil</name><operator>.</operator><name>nextInt</name></name><argument_list>(<argument><expr><call><name>random</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
      </block_content>}</block></function>
    }</block></decl>,
    <decl><name>ASCENDING_SEQUENCES</name> <block>{
      <function><annotation>@<name>Override</name></annotation>
      <type><specifier>public</specifier> <name>void</name></type> <name>set</name><parameter_list>(<parameter><decl><type><name><name>Entry</name><index>[]</index></name></type> <name>arr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <expr_stmt><expr><name><name>arr</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <ternary><condition><expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>
            ?</condition><then> <expr><operator>new</operator> <call><name>Entry</name><argument_list>(<argument><expr><call><name>random</name><argument_list>()</argument_list></call><operator>.</operator><call><name>nextInt</name><argument_list>(<argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>
            </then><else>: <expr><operator>new</operator> <call><name>Entry</name><argument_list>(<argument><expr><ternary><condition><expr><call><name>rarely</name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><call><name>random</name><argument_list>()</argument_list></call><operator>.</operator><call><name>nextInt</name><argument_list>(<argument><expr><literal type="number">1000</literal></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name><name>arr</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>value</name> <operator>+</operator> <call><name>random</name><argument_list>()</argument_list></call><operator>.</operator><call><name>nextInt</name><argument_list>(<argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
      </block_content>}</block></function>
    }</block></decl>,
    <decl><name>MOSTLY_ASCENDING</name> <block>{
      <function><annotation>@<name>Override</name></annotation>
      <type><specifier>public</specifier> <name>void</name></type> <name>set</name><parameter_list>(<parameter><decl><type><name><name>Entry</name><index>[]</index></name></type> <name>arr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <expr_stmt><expr><name><name>arr</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <ternary><condition><expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>
            ?</condition><then> <expr><operator>new</operator> <call><name>Entry</name><argument_list>(<argument><expr><call><name>random</name><argument_list>()</argument_list></call><operator>.</operator><call><name>nextInt</name><argument_list>(<argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>
            </then><else>: <expr><operator>new</operator> <call><name>Entry</name><argument_list>(<argument><expr><name><name>arr</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>value</name> <operator>+</operator> <call><name><name>_TestUtil</name><operator>.</operator><name>nextInt</name></name><argument_list>(<argument><expr><call><name>random</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">8</literal></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
      </block_content>}</block></function>
    }</block></decl>;
    <decl_stmt><decl><type><specifier>public</specifier> <specifier>abstract</specifier> <name>void</name></type> <name>set</name><argument_list>(<argument><expr><name><name>Entry</name><index>[]</index></name> <name>arr</name></expr></argument>, <argument><expr><name>int</name> <name>i</name></expr></argument>)</argument_list></decl>;</decl_stmt>
  }</block></enum>

  <function><type><specifier>public</specifier> <name>void</name></type> <name>test</name><parameter_list>(<parameter><decl><type><name>Strategy</name></type> <name>strategy</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>length</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><specifier>final</specifier> <name><name>Entry</name><index>[]</index></name></type> <name>arr</name> <init>= <expr><operator>new</operator> <name><name>Entry</name><index>[<expr><name>length</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>arr</name><operator>.</operator><name>length</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
      <expr_stmt><expr><call><name><name>strategy</name><operator>.</operator><name>set</name></name><argument_list>(<argument><expr><name>arr</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>test</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></function>

  <function><type><specifier>public</specifier> <name>void</name></type> <name>test</name><parameter_list>(<parameter><decl><type><name>Strategy</name></type> <name>strategy</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>test</name><argument_list>(<argument><expr><name>strategy</name></expr></argument>, <argument><expr><call><name>random</name><argument_list>()</argument_list></call><operator>.</operator><call><name>nextInt</name><argument_list>(<argument><expr><literal type="number">20000</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></function>

  <function><type><specifier>public</specifier> <name>void</name></type> <name>testEmpty</name><parameter_list>()</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>test</name><argument_list>(<argument><expr><operator>new</operator> <name><name>Entry</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></function>

  <function><type><specifier>public</specifier> <name>void</name></type> <name>testOne</name><parameter_list>()</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>test</name><argument_list>(<argument><expr><name><name>Strategy</name><operator>.</operator><name>RANDOM</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></function>

  <function><type><specifier>public</specifier> <name>void</name></type> <name>testTwo</name><parameter_list>()</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>test</name><argument_list>(<argument><expr><name><name>Strategy</name><operator>.</operator><name>RANDOM_LOW_CARDINALITY</name></name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></function>

  <function><type><specifier>public</specifier> <name>void</name></type> <name>testRandom</name><parameter_list>()</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>test</name><argument_list>(<argument><expr><name><name>Strategy</name><operator>.</operator><name>RANDOM</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></function>

  <function><type><specifier>public</specifier> <name>void</name></type> <name>testRandomLowCardinality</name><parameter_list>()</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>test</name><argument_list>(<argument><expr><name><name>Strategy</name><operator>.</operator><name>RANDOM_LOW_CARDINALITY</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></function>

  <function><type><specifier>public</specifier> <name>void</name></type> <name>testAscending</name><parameter_list>()</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>test</name><argument_list>(<argument><expr><name><name>Strategy</name><operator>.</operator><name>ASCENDING</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></function>

  <function><type><specifier>public</specifier> <name>void</name></type> <name>testAscendingSequences</name><parameter_list>()</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>test</name><argument_list>(<argument><expr><name><name>Strategy</name><operator>.</operator><name>ASCENDING_SEQUENCES</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></function>

  <function><type><specifier>public</specifier> <name>void</name></type> <name>testDescending</name><parameter_list>()</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>test</name><argument_list>(<argument><expr><name><name>Strategy</name><operator>.</operator><name>DESCENDING</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></function>

  <function><type><specifier>public</specifier> <name>void</name></type> <name>testStrictlyDescending</name><parameter_list>()</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>test</name><argument_list>(<argument><expr><name><name>Strategy</name><operator>.</operator><name>STRICTLY_DESCENDING</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></function>
}</block></class>
<expr_stmt><expr><name>diff</name> <operator>--</operator><name>git</name> <name>a</name><operator>/</operator><name>lucene</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>test</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>util</name><operator>/</operator><name><name>TestArrayUtil</name><operator>.</operator><name>java</name></name> <name>b</name><operator>/</operator><name>lucene</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>test</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>util</name><operator>/</operator><name><name>TestArrayUtil</name><operator>.</operator><name>java</name></name>
<name>index</name> <name>f59af0e06dc</name><operator>..</operator><literal type="number">5d3bdc92723</literal> <literal type="number">100644</literal>
<operator>--</operator> <name>a</name><operator>/</operator><name>lucene</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>test</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>util</name><operator>/</operator><name><name>TestArrayUtil</name><operator>.</operator><name>java</name></name>
<operator>++</operator> <name>b</name><operator>/</operator><name>lucene</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>test</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>util</name><operator>/</operator><name><name>TestArrayUtil</name><operator>.</operator><name>java</name></name>
@@ <operator>-</operator><literal type="number">128</literal></expr><operator>,</operator><expr><literal type="number">21</literal> <operator>+</operator><literal type="number">128</literal></expr><operator>,</operator><expr><literal type="number">21</literal> @@ <specifier>public</specifier> <name>class</name> <name>TestArrayUtil</name> extends <name>LuceneTestCase</name> <block>{
     <return>return <expr><name>a</name></expr>;</return>
   }</block></expr></expr_stmt>
   
  <function><type><specifier>public</specifier> <name>void</name></type> <name>testQuickSort</name><parameter_list>()</parameter_list> <block>{<block_content>
  <function><type><specifier>public</specifier> <name>void</name></type> <name>testIntroSort</name><parameter_list>()</parameter_list> <block>{<block_content>
     <decl_stmt><decl><type><name>int</name></type> <name>num</name> <init>= <expr><call><name>atLeast</name><argument_list>(<argument><expr><literal type="number">50</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
     <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
       <decl_stmt><decl><type><name><name>Integer</name><index>[]</index></name></type> <name>a1</name> <init>= <expr><call><name>createRandomArray</name><argument_list>(<argument><expr><literal type="number">2000</literal></expr></argument>)</argument_list></call></expr></init></decl>, <decl><type ref="prev"/><name>a2</name> <init>= <expr><call><name><name>a1</name><operator>.</operator><name>clone</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name><name>ArrayUtil</name><operator>.</operator><name>quickSort</name></name><argument_list>(<argument><expr><name>a1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>ArrayUtil</name><operator>.</operator><name>introSort</name></name><argument_list>(<argument><expr><name>a1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
       <expr_stmt><expr><call><name><name>Arrays</name><operator>.</operator><name>sort</name></name><argument_list>(<argument><expr><name>a2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
       <expr_stmt><expr><call><name>assertArrayEquals</name><argument_list>(<argument><expr><name>a2</name></expr></argument>, <argument><expr><name>a1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
       
       <expr_stmt><expr><name>a1</name> <operator>=</operator> <call><name>createRandomArray</name><argument_list>(<argument><expr><literal type="number">2000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
       <expr_stmt><expr><name>a2</name> <operator>=</operator> <call><name><name>a1</name><operator>.</operator><name>clone</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>ArrayUtil</name><operator>.</operator><name>quickSort</name></name><argument_list>(<argument><expr><name>a1</name></expr></argument>, <argument><expr><call><name><name>Collections</name><operator>.</operator><name>reverseOrder</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>ArrayUtil</name><operator>.</operator><name>introSort</name></name><argument_list>(<argument><expr><name>a1</name></expr></argument>, <argument><expr><call><name><name>Collections</name><operator>.</operator><name>reverseOrder</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
       <expr_stmt><expr><call><name><name>Arrays</name><operator>.</operator><name>sort</name></name><argument_list>(<argument><expr><name>a2</name></expr></argument>, <argument><expr><call><name><name>Collections</name><operator>.</operator><name>reverseOrder</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
       <expr_stmt><expr><call><name>assertArrayEquals</name><argument_list>(<argument><expr><name>a2</name></expr></argument>, <argument><expr><name>a1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
       <comment type="line">// reverse back, so we can test that completely backwards sorted array (worst case) is working:</comment>
      <expr_stmt><expr><call><name><name>ArrayUtil</name><operator>.</operator><name>quickSort</name></name><argument_list>(<argument><expr><name>a1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>ArrayUtil</name><operator>.</operator><name>introSort</name></name><argument_list>(<argument><expr><name>a1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
       <expr_stmt><expr><call><name><name>Arrays</name><operator>.</operator><name>sort</name></name><argument_list>(<argument><expr><name>a2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
       <expr_stmt><expr><call><name>assertArrayEquals</name><argument_list>(<argument><expr><name>a2</name></expr></argument>, <argument><expr><name>a1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
     </block_content>}</block></for>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">158</literal></expr><operator>,</operator><expr><literal type="number">38</literal> <operator>+</operator><literal type="number">158</literal></expr><operator>,</operator><expr><literal type="number">18</literal> @@ <specifier>public</specifier> <name>class</name> <name>TestArrayUtil</name> extends <name>LuceneTestCase</name> <block>{
   }</block>
   
   <comment type="line">// This is a test for LUCENE-3054 (which fails without the merge sort fall back with stack overflow in most cases)</comment>
  <specifier>public</specifier> <name>void</name> <call><name>testQuickToMergeSortFallback</name><argument_list>()</argument_list></call> <block>{
  <expr><specifier>public</specifier> <name>void</name> <call><name>testQuickToHeapSortFallback</name><argument_list>()</argument_list></call> <block>{
     <expr><name>int</name> <name>num</name> <operator>=</operator> <call><name>atLeast</name><argument_list>(<argument><expr><literal type="number">50</literal></expr></argument>)</argument_list></call></expr>;
     <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
       <decl_stmt><decl><type><name><name>Integer</name><index>[]</index></name></type> <name>a1</name> <init>= <expr><call><name>createSparseRandomArray</name><argument_list>(<argument><expr><literal type="number">40000</literal></expr></argument>)</argument_list></call></expr></init></decl>, <decl><type ref="prev"/><name>a2</name> <init>= <expr><call><name><name>a1</name><operator>.</operator><name>clone</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name><name>ArrayUtil</name><operator>.</operator><name>quickSort</name></name><argument_list>(<argument><expr><name>a1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>ArrayUtil</name><operator>.</operator><name>introSort</name></name><argument_list>(<argument><expr><name>a1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
       <expr_stmt><expr><call><name><name>Arrays</name><operator>.</operator><name>sort</name></name><argument_list>(<argument><expr><name>a2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
       <expr_stmt><expr><call><name>assertArrayEquals</name><argument_list>(<argument><expr><name>a2</name></expr></argument>, <argument><expr><name>a1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
     <expr_stmt/></block_content></block></for>}</block></expr>
   }</block>
   
  <specifier>public</specifier> <name>void</name> <call><name>testMergeSort</name><argument_list>()</argument_list></call> <block>{
    <expr><name>int</name> <name>num</name> <operator>=</operator> <call><name>atLeast</name><argument_list>(<argument><expr><literal type="number">50</literal></expr></argument>)</argument_list></call></expr>;
    <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
      <decl_stmt><decl><type><name><name>Integer</name><index>[]</index></name></type> <name>a1</name> <init>= <expr><call><name>createRandomArray</name><argument_list>(<argument><expr><literal type="number">2000</literal></expr></argument>)</argument_list></call></expr></init></decl>, <decl><type ref="prev"/><name>a2</name> <init>= <expr><call><name><name>a1</name><operator>.</operator><name>clone</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name><name>ArrayUtil</name><operator>.</operator><name>mergeSort</name></name><argument_list>(<argument><expr><name>a1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>Arrays</name><operator>.</operator><name>sort</name></name><argument_list>(<argument><expr><name>a2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assertArrayEquals</name><argument_list>(<argument><expr><name>a2</name></expr></argument>, <argument><expr><name>a1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      
      <expr_stmt><expr><name>a1</name> <operator>=</operator> <call><name>createRandomArray</name><argument_list>(<argument><expr><literal type="number">2000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>a2</name> <operator>=</operator> <call><name><name>a1</name><operator>.</operator><name>clone</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>ArrayUtil</name><operator>.</operator><name>mergeSort</name></name><argument_list>(<argument><expr><name>a1</name></expr></argument>, <argument><expr><call><name><name>Collections</name><operator>.</operator><name>reverseOrder</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>Arrays</name><operator>.</operator><name>sort</name></name><argument_list>(<argument><expr><name>a2</name></expr></argument>, <argument><expr><call><name><name>Collections</name><operator>.</operator><name>reverseOrder</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assertArrayEquals</name><argument_list>(<argument><expr><name>a2</name></expr></argument>, <argument><expr><name>a1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <comment type="line">// reverse back, so we can test that completely backwards sorted array (worst case) is working:</comment>
      <expr_stmt><expr><call><name><name>ArrayUtil</name><operator>.</operator><name>mergeSort</name></name><argument_list>(<argument><expr><name>a1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>Arrays</name><operator>.</operator><name>sort</name></name><argument_list>(<argument><expr><name>a2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assertArrayEquals</name><argument_list>(<argument><expr><name>a2</name></expr></argument>, <argument><expr><name>a1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt/></block_content></block></for>}</block></expr></expr_stmt>
  </block_content>}</block></function>

   <function><type><specifier>public</specifier> <name>void</name></type> <name>testTimSort</name><parameter_list>()</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>num</name> <init>= <expr><call><name>atLeast</name><argument_list>(<argument><expr><literal type="number">65</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>num</name> <init>= <expr><call><name>atLeast</name><argument_list>(<argument><expr><literal type="number">50</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
     <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
       <decl_stmt><decl><type><name><name>Integer</name><index>[]</index></name></type> <name>a1</name> <init>= <expr><call><name>createRandomArray</name><argument_list>(<argument><expr><literal type="number">2000</literal></expr></argument>)</argument_list></call></expr></init></decl>, <decl><type ref="prev"/><name>a2</name> <init>= <expr><call><name><name>a1</name><operator>.</operator><name>clone</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
       <expr_stmt><expr><call><name><name>ArrayUtil</name><operator>.</operator><name>timSort</name></name><argument_list>(<argument><expr><name>a1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">207</literal></expr><operator>,</operator><expr><literal type="number">44</literal> <operator>+</operator><literal type="number">187</literal></expr><operator>,</operator><expr><literal type="number">6</literal> @@ <specifier>public</specifier> <name>class</name> <name>TestArrayUtil</name> extends <name>LuceneTestCase</name> <block>{
       <expr><call><name>assertArrayEquals</name><argument_list>(<argument><expr><name>a2</name></expr></argument>, <argument><expr><name>a1</name></expr></argument>)</argument_list></call></expr>;
     }</block></expr></expr_stmt>
   </block_content>}</block></for>

  <function><type><specifier>public</specifier> <name>void</name></type> <name>testInsertionSort</name><parameter_list>()</parameter_list> <block>{<block_content>
    <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>c</name> <init>= <expr><call><name>atLeast</name><argument_list>(<argument><expr><literal type="number">500</literal></expr></argument>)</argument_list></call></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>c</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
      <decl_stmt><decl><type><name><name>Integer</name><index>[]</index></name></type> <name>a1</name> <init>= <expr><call><name>createRandomArray</name><argument_list>(<argument><expr><literal type="number">30</literal></expr></argument>)</argument_list></call></expr></init></decl>, <decl><type ref="prev"/><name>a2</name> <init>= <expr><call><name><name>a1</name><operator>.</operator><name>clone</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name><name>ArrayUtil</name><operator>.</operator><name>insertionSort</name></name><argument_list>(<argument><expr><name>a1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>Arrays</name><operator>.</operator><name>sort</name></name><argument_list>(<argument><expr><name>a2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assertArrayEquals</name><argument_list>(<argument><expr><name>a2</name></expr></argument>, <argument><expr><name>a1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      
      <expr_stmt><expr><name>a1</name> <operator>=</operator> <call><name>createRandomArray</name><argument_list>(<argument><expr><literal type="number">30</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>a2</name> <operator>=</operator> <call><name><name>a1</name><operator>.</operator><name>clone</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>ArrayUtil</name><operator>.</operator><name>insertionSort</name></name><argument_list>(<argument><expr><name>a1</name></expr></argument>, <argument><expr><call><name><name>Collections</name><operator>.</operator><name>reverseOrder</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>Arrays</name><operator>.</operator><name>sort</name></name><argument_list>(<argument><expr><name>a2</name></expr></argument>, <argument><expr><call><name><name>Collections</name><operator>.</operator><name>reverseOrder</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assertArrayEquals</name><argument_list>(<argument><expr><name>a2</name></expr></argument>, <argument><expr><name>a1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <comment type="line">// reverse back, so we can test that completely backwards sorted array (worst case) is working:</comment>
      <expr_stmt><expr><call><name><name>ArrayUtil</name><operator>.</operator><name>insertionSort</name></name><argument_list>(<argument><expr><name>a1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>Arrays</name><operator>.</operator><name>sort</name></name><argument_list>(<argument><expr><name>a2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assertArrayEquals</name><argument_list>(<argument><expr><name>a2</name></expr></argument>, <argument><expr><name>a1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block></function>
  
  <function><type><specifier>public</specifier> <name>void</name></type> <name>testBinarySort</name><parameter_list>()</parameter_list> <block>{<block_content>
    <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>c</name> <init>= <expr><call><name>atLeast</name><argument_list>(<argument><expr><literal type="number">500</literal></expr></argument>)</argument_list></call></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>c</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
      <decl_stmt><decl><type><name><name>Integer</name><index>[]</index></name></type> <name>a1</name> <init>= <expr><call><name>createRandomArray</name><argument_list>(<argument><expr><literal type="number">30</literal></expr></argument>)</argument_list></call></expr></init></decl>, <decl><type ref="prev"/><name>a2</name> <init>= <expr><call><name><name>a1</name><operator>.</operator><name>clone</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name><name>ArrayUtil</name><operator>.</operator><name>binarySort</name></name><argument_list>(<argument><expr><name>a1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>Arrays</name><operator>.</operator><name>sort</name></name><argument_list>(<argument><expr><name>a2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assertArrayEquals</name><argument_list>(<argument><expr><name>a2</name></expr></argument>, <argument><expr><name>a1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      
      <expr_stmt><expr><name>a1</name> <operator>=</operator> <call><name>createRandomArray</name><argument_list>(<argument><expr><literal type="number">30</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>a2</name> <operator>=</operator> <call><name><name>a1</name><operator>.</operator><name>clone</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>ArrayUtil</name><operator>.</operator><name>binarySort</name></name><argument_list>(<argument><expr><name>a1</name></expr></argument>, <argument><expr><call><name><name>Collections</name><operator>.</operator><name>reverseOrder</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>Arrays</name><operator>.</operator><name>sort</name></name><argument_list>(<argument><expr><name>a2</name></expr></argument>, <argument><expr><call><name><name>Collections</name><operator>.</operator><name>reverseOrder</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assertArrayEquals</name><argument_list>(<argument><expr><name>a2</name></expr></argument>, <argument><expr><name>a1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <comment type="line">// reverse back, so we can test that completely backwards sorted array (worst case) is working:</comment>
      <expr_stmt><expr><call><name><name>ArrayUtil</name><operator>.</operator><name>binarySort</name></name><argument_list>(<argument><expr><name>a1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>Arrays</name><operator>.</operator><name>sort</name></name><argument_list>(<argument><expr><name>a2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assertArrayEquals</name><argument_list>(<argument><expr><name>a2</name></expr></argument>, <argument><expr><name>a1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block></function>
   
   <class><specifier>static</specifier> class <name>Item</name> <super_list><implements>implements <super><name><name>Comparable</name><argument_list type="generic">&lt;<argument><name>Item</name></argument>&gt;</argument_list></name></super></implements></super_list> <block>{
     <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>val</name></decl>, <decl><type ref="prev"/><name>order</name></decl>;</decl_stmt>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">279</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">221</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@ <specifier>public</specifier> <name>class</name> <name>TestArrayUtil</name> extends <name>LuceneTestCase</name> <block>{
     
     <if_stmt><if>if <condition>(<expr><name>VERBOSE</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name><name>System</name><operator>.</operator><name>out</name><operator>.</operator><name>println</name></name><argument_list>(<argument><expr><literal type="string">"Before: "</literal> <operator>+</operator> <call><name><name>Arrays</name><operator>.</operator><name>toString</name></name><argument_list>(<argument><expr><name>items</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
     <comment type="line">// if you replace this with ArrayUtil.quickSort(), test should fail:</comment>
    <call><name><name>ArrayUtil</name><operator>.</operator><name>mergeSort</name></name><argument_list>(<argument><expr><name>items</name></expr></argument>)</argument_list></call></block></expr>;</expr_stmt>
    <constructor_decl><name><name>ArrayUtil</name><operator>.</operator><name>timSort</name></name><parameter_list>(<parameter><decl><type><name>items</name></type></decl></parameter>)</parameter_list>;</constructor_decl>
     <if_stmt><if>if <condition>(<expr><name>VERBOSE</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name><name>System</name><operator>.</operator><name>out</name><operator>.</operator><name>println</name></name><argument_list>(<argument><expr><literal type="string">"Sorted: "</literal> <operator>+</operator> <call><name><name>Arrays</name><operator>.</operator><name>toString</name></name><argument_list>(<argument><expr><name>items</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
     
     <decl_stmt><decl><type><name>Item</name></type> <name>last</name> <init>= <expr><name><name>items</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">326</literal></expr><operator>,</operator><expr><literal type="number">16</literal> <operator>+</operator><literal type="number">268</literal></expr><operator>,</operator><expr><literal type="number">10</literal> @@ <specifier>public</specifier> <name>class</name> <name>TestArrayUtil</name> extends <name>LuceneTestCase</name> <block>{
   <comment type="line">// should produce no exceptions</comment>
   <expr><specifier>public</specifier> <name>void</name> <call><name>testEmptyArraySort</name><argument_list>()</argument_list></call> <block>{
     <expr><name><name>Integer</name><index>[]</index></name> <name>a</name> <operator>=</operator> <operator>new</operator> <name><name>Integer</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;
    <expr><call><name><name>ArrayUtil</name><operator>.</operator><name>quickSort</name></name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;
    <expr><call><name><name>ArrayUtil</name><operator>.</operator><name>mergeSort</name></name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;
    <expr><call><name><name>ArrayUtil</name><operator>.</operator><name>insertionSort</name></name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;
    <expr><call><name><name>ArrayUtil</name><operator>.</operator><name>binarySort</name></name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;
    <expr><call><name><name>ArrayUtil</name><operator>.</operator><name>introSort</name></name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;
     <expr><call><name><name>ArrayUtil</name><operator>.</operator><name>timSort</name></name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;
    <expr><call><name><name>ArrayUtil</name><operator>.</operator><name>quickSort</name></name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><call><name><name>Collections</name><operator>.</operator><name>reverseOrder</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
    <expr><call><name><name>ArrayUtil</name><operator>.</operator><name>mergeSort</name></name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><call><name><name>Collections</name><operator>.</operator><name>reverseOrder</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
    <expr><call><name><name>ArrayUtil</name><operator>.</operator><name>introSort</name></name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><call><name><name>Collections</name><operator>.</operator><name>reverseOrder</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
     <expr><call><name><name>ArrayUtil</name><operator>.</operator><name>timSort</name></name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><call><name><name>Collections</name><operator>.</operator><name>reverseOrder</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
    <expr><call><name><name>ArrayUtil</name><operator>.</operator><name>insertionSort</name></name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><call><name><name>Collections</name><operator>.</operator><name>reverseOrder</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
    <expr><call><name><name>ArrayUtil</name><operator>.</operator><name>binarySort</name></name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><call><name><name>Collections</name><operator>.</operator><name>reverseOrder</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
   }</block></expr>
   
 }</block>
<name>diff</name> <operator>--</operator><name>git</name> <name>a</name><operator>/</operator><name>lucene</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>test</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>util</name><operator>/</operator><name><name>TestCollectionUtil</name><operator>.</operator><name>java</name></name> <name>b</name><operator>/</operator><name>lucene</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>test</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>util</name><operator>/</operator><name><name>TestCollectionUtil</name><operator>.</operator><name>java</name></name>
<name>index</name> <name>c45130f5b4b</name><operator>..</operator><literal type="number">36558562e46</literal> <literal type="number">100644</literal>
<operator>--</operator> <name>a</name><operator>/</operator><name>lucene</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>test</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>util</name><operator>/</operator><name><name>TestCollectionUtil</name><operator>.</operator><name>java</name></name>
<operator>++</operator> <name>b</name><operator>/</operator><name>lucene</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>test</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>util</name><operator>/</operator><name><name>TestCollectionUtil</name><operator>.</operator><name>java</name></name>
@@ <operator>-</operator><literal type="number">35</literal></expr><operator>,</operator><expr><literal type="number">39</literal> <operator>+</operator><literal type="number">35</literal></expr><operator>,</operator><expr><literal type="number">20</literal> @@ <specifier>public</specifier> <name>class</name> <name>TestCollectionUtil</name> extends <name>LuceneTestCase</name> <block>{
     <return>return <expr><call><name><name>Arrays</name><operator>.</operator><name>asList</name></name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</return>
   }</block></expr></expr_stmt>
   
  <function><type><specifier>public</specifier> <name>void</name></type> <name>testQuickSort</name><parameter_list>()</parameter_list> <block>{<block_content>
  <function><type><specifier>public</specifier> <name>void</name></type> <name>testIntroSort</name><parameter_list>()</parameter_list> <block>{<block_content>
     <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>c</name> <init>= <expr><call><name>atLeast</name><argument_list>(<argument><expr><literal type="number">500</literal></expr></argument>)</argument_list></call></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>c</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
       <decl_stmt><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name>Integer</name></argument>&gt;</argument_list></name></type> <name>list1</name> <init>= <expr><call><name>createRandomList</name><argument_list>(<argument><expr><literal type="number">2000</literal></expr></argument>)</argument_list></call></expr></init></decl>, <decl><type ref="prev"/><name>list2</name> <init>= <expr><operator>new</operator> <call><name><name>ArrayList</name><argument_list type="generic">&lt;<argument><name>Integer</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>list1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name><name>CollectionUtil</name><operator>.</operator><name>quickSort</name></name><argument_list>(<argument><expr><name>list1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>CollectionUtil</name><operator>.</operator><name>introSort</name></name><argument_list>(<argument><expr><name>list1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
       <expr_stmt><expr><call><name><name>Collections</name><operator>.</operator><name>sort</name></name><argument_list>(<argument><expr><name>list2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
       <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><name>list2</name></expr></argument>, <argument><expr><name>list1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
       
       <expr_stmt><expr><name>list1</name> <operator>=</operator> <call><name>createRandomList</name><argument_list>(<argument><expr><literal type="number">2000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
       <expr_stmt><expr><name>list2</name> <operator>=</operator> <operator>new</operator> <call><name><name>ArrayList</name><argument_list type="generic">&lt;<argument><name>Integer</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>list1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>CollectionUtil</name><operator>.</operator><name>quickSort</name></name><argument_list>(<argument><expr><name>list1</name></expr></argument>, <argument><expr><call><name><name>Collections</name><operator>.</operator><name>reverseOrder</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>CollectionUtil</name><operator>.</operator><name>introSort</name></name><argument_list>(<argument><expr><name>list1</name></expr></argument>, <argument><expr><call><name><name>Collections</name><operator>.</operator><name>reverseOrder</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
       <expr_stmt><expr><call><name><name>Collections</name><operator>.</operator><name>sort</name></name><argument_list>(<argument><expr><name>list2</name></expr></argument>, <argument><expr><call><name><name>Collections</name><operator>.</operator><name>reverseOrder</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
       <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><name>list2</name></expr></argument>, <argument><expr><name>list1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
       <comment type="line">// reverse back, so we can test that completely backwards sorted array (worst case) is working:</comment>
      <expr_stmt><expr><call><name><name>CollectionUtil</name><operator>.</operator><name>quickSort</name></name><argument_list>(<argument><expr><name>list1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>Collections</name><operator>.</operator><name>sort</name></name><argument_list>(<argument><expr><name>list2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><name>list2</name></expr></argument>, <argument><expr><name>list1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block></function>
  
  <function><type><specifier>public</specifier> <name>void</name></type> <name>testMergeSort</name><parameter_list>()</parameter_list> <block>{<block_content>
    <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>c</name> <init>= <expr><call><name>atLeast</name><argument_list>(<argument><expr><literal type="number">500</literal></expr></argument>)</argument_list></call></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>c</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
      <decl_stmt><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name>Integer</name></argument>&gt;</argument_list></name></type> <name>list1</name> <init>= <expr><call><name>createRandomList</name><argument_list>(<argument><expr><literal type="number">2000</literal></expr></argument>)</argument_list></call></expr></init></decl>, <decl><type ref="prev"/><name>list2</name> <init>= <expr><operator>new</operator> <call><name><name>ArrayList</name><argument_list type="generic">&lt;<argument><name>Integer</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>list1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name><name>CollectionUtil</name><operator>.</operator><name>mergeSort</name></name><argument_list>(<argument><expr><name>list1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>Collections</name><operator>.</operator><name>sort</name></name><argument_list>(<argument><expr><name>list2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><name>list2</name></expr></argument>, <argument><expr><name>list1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      
      <expr_stmt><expr><name>list1</name> <operator>=</operator> <call><name>createRandomList</name><argument_list>(<argument><expr><literal type="number">2000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>list2</name> <operator>=</operator> <operator>new</operator> <call><name><name>ArrayList</name><argument_list type="generic">&lt;<argument><name>Integer</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>list1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>CollectionUtil</name><operator>.</operator><name>mergeSort</name></name><argument_list>(<argument><expr><name>list1</name></expr></argument>, <argument><expr><call><name><name>Collections</name><operator>.</operator><name>reverseOrder</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>Collections</name><operator>.</operator><name>sort</name></name><argument_list>(<argument><expr><name>list2</name></expr></argument>, <argument><expr><call><name><name>Collections</name><operator>.</operator><name>reverseOrder</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><name>list2</name></expr></argument>, <argument><expr><name>list1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <comment type="line">// reverse back, so we can test that completely backwards sorted array (worst case) is working:</comment>
      <expr_stmt><expr><call><name><name>CollectionUtil</name><operator>.</operator><name>mergeSort</name></name><argument_list>(<argument><expr><name>list1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>CollectionUtil</name><operator>.</operator><name>introSort</name></name><argument_list>(<argument><expr><name>list1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
       <expr_stmt><expr><call><name><name>Collections</name><operator>.</operator><name>sort</name></name><argument_list>(<argument><expr><name>list2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
       <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><name>list2</name></expr></argument>, <argument><expr><name>list1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
     </block_content>}</block></for>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">92</literal></expr><operator>,</operator><expr><literal type="number">86</literal> <operator>+</operator><literal type="number">73</literal></expr><operator>,</operator><expr><literal type="number">30</literal> @@ <specifier>public</specifier> <name>class</name> <name>TestCollectionUtil</name> extends <name>LuceneTestCase</name> <block>{
     }</block></expr></expr_stmt>
   </block_content>}</block></function>
 
  <function><type><specifier>public</specifier> <name>void</name></type> <name>testInsertionSort</name><parameter_list>()</parameter_list> <block>{<block_content>
    <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>c</name> <init>= <expr><call><name>atLeast</name><argument_list>(<argument><expr><literal type="number">500</literal></expr></argument>)</argument_list></call></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>c</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
      <decl_stmt><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name>Integer</name></argument>&gt;</argument_list></name></type> <name>list1</name> <init>= <expr><call><name>createRandomList</name><argument_list>(<argument><expr><literal type="number">30</literal></expr></argument>)</argument_list></call></expr></init></decl>, <decl><type ref="prev"/><name>list2</name> <init>= <expr><operator>new</operator> <call><name><name>ArrayList</name><argument_list type="generic">&lt;<argument><name>Integer</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>list1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name><name>CollectionUtil</name><operator>.</operator><name>insertionSort</name></name><argument_list>(<argument><expr><name>list1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>Collections</name><operator>.</operator><name>sort</name></name><argument_list>(<argument><expr><name>list2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><name>list2</name></expr></argument>, <argument><expr><name>list1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      
      <expr_stmt><expr><name>list1</name> <operator>=</operator> <call><name>createRandomList</name><argument_list>(<argument><expr><literal type="number">30</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>list2</name> <operator>=</operator> <operator>new</operator> <call><name><name>ArrayList</name><argument_list type="generic">&lt;<argument><name>Integer</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>list1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>CollectionUtil</name><operator>.</operator><name>insertionSort</name></name><argument_list>(<argument><expr><name>list1</name></expr></argument>, <argument><expr><call><name><name>Collections</name><operator>.</operator><name>reverseOrder</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>Collections</name><operator>.</operator><name>sort</name></name><argument_list>(<argument><expr><name>list2</name></expr></argument>, <argument><expr><call><name><name>Collections</name><operator>.</operator><name>reverseOrder</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><name>list2</name></expr></argument>, <argument><expr><name>list1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <comment type="line">// reverse back, so we can test that completely backwards sorted array (worst case) is working:</comment>
      <expr_stmt><expr><call><name><name>CollectionUtil</name><operator>.</operator><name>insertionSort</name></name><argument_list>(<argument><expr><name>list1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>Collections</name><operator>.</operator><name>sort</name></name><argument_list>(<argument><expr><name>list2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><name>list2</name></expr></argument>, <argument><expr><name>list1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block></function>

  <function><type><specifier>public</specifier> <name>void</name></type> <name>testBinarySort</name><parameter_list>()</parameter_list> <block>{<block_content>
    <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>c</name> <init>= <expr><call><name>atLeast</name><argument_list>(<argument><expr><literal type="number">500</literal></expr></argument>)</argument_list></call></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>c</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
      <decl_stmt><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name>Integer</name></argument>&gt;</argument_list></name></type> <name>list1</name> <init>= <expr><call><name>createRandomList</name><argument_list>(<argument><expr><literal type="number">30</literal></expr></argument>)</argument_list></call></expr></init></decl>, <decl><type ref="prev"/><name>list2</name> <init>= <expr><operator>new</operator> <call><name><name>ArrayList</name><argument_list type="generic">&lt;<argument><name>Integer</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>list1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name><name>CollectionUtil</name><operator>.</operator><name>binarySort</name></name><argument_list>(<argument><expr><name>list1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>Collections</name><operator>.</operator><name>sort</name></name><argument_list>(<argument><expr><name>list2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><name>list2</name></expr></argument>, <argument><expr><name>list1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      
      <expr_stmt><expr><name>list1</name> <operator>=</operator> <call><name>createRandomList</name><argument_list>(<argument><expr><literal type="number">30</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>list2</name> <operator>=</operator> <operator>new</operator> <call><name><name>ArrayList</name><argument_list type="generic">&lt;<argument><name>Integer</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>list1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>CollectionUtil</name><operator>.</operator><name>binarySort</name></name><argument_list>(<argument><expr><name>list1</name></expr></argument>, <argument><expr><call><name><name>Collections</name><operator>.</operator><name>reverseOrder</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>Collections</name><operator>.</operator><name>sort</name></name><argument_list>(<argument><expr><name>list2</name></expr></argument>, <argument><expr><call><name><name>Collections</name><operator>.</operator><name>reverseOrder</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><name>list2</name></expr></argument>, <argument><expr><name>list1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <comment type="line">// reverse back, so we can test that completely backwards sorted array (worst case) is working:</comment>
      <expr_stmt><expr><call><name><name>CollectionUtil</name><operator>.</operator><name>binarySort</name></name><argument_list>(<argument><expr><name>list1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>Collections</name><operator>.</operator><name>sort</name></name><argument_list>(<argument><expr><name>list2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><name>list2</name></expr></argument>, <argument><expr><name>list1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block></function>

   <function><type><specifier>public</specifier> <name>void</name></type> <name>testEmptyListSort</name><parameter_list>()</parameter_list> <block>{<block_content>
     <comment type="line">// should produce no exceptions</comment>
     <decl_stmt><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name>Integer</name></argument>&gt;</argument_list></name></type> <name>list</name> <init>= <expr><call><name><name>Arrays</name><operator>.</operator><name>asList</name></name><argument_list>(<argument><expr><operator>new</operator> <name><name>Integer</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt> <comment type="line">// LUCENE-2989</comment>
    <expr_stmt><expr><call><name><name>CollectionUtil</name><operator>.</operator><name>quickSort</name></name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>CollectionUtil</name><operator>.</operator><name>mergeSort</name></name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>CollectionUtil</name><operator>.</operator><name>introSort</name></name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
     <expr_stmt><expr><call><name><name>CollectionUtil</name><operator>.</operator><name>timSort</name></name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>CollectionUtil</name><operator>.</operator><name>insertionSort</name></name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>CollectionUtil</name><operator>.</operator><name>binarySort</name></name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>CollectionUtil</name><operator>.</operator><name>quickSort</name></name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><call><name><name>Collections</name><operator>.</operator><name>reverseOrder</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>CollectionUtil</name><operator>.</operator><name>mergeSort</name></name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><call><name><name>Collections</name><operator>.</operator><name>reverseOrder</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>CollectionUtil</name><operator>.</operator><name>introSort</name></name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><call><name><name>Collections</name><operator>.</operator><name>reverseOrder</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
     <expr_stmt><expr><call><name><name>CollectionUtil</name><operator>.</operator><name>timSort</name></name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><call><name><name>Collections</name><operator>.</operator><name>reverseOrder</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>CollectionUtil</name><operator>.</operator><name>insertionSort</name></name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><call><name><name>Collections</name><operator>.</operator><name>reverseOrder</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>CollectionUtil</name><operator>.</operator><name>binarySort</name></name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><call><name><name>Collections</name><operator>.</operator><name>reverseOrder</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
     
     <comment type="line">// check that empty non-random access lists pass sorting without ex (as sorting is not needed)</comment>
     <expr_stmt><expr><name>list</name> <operator>=</operator> <operator>new</operator> <call><name><name>LinkedList</name><argument_list type="generic">&lt;<argument><name>Integer</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>CollectionUtil</name><operator>.</operator><name>quickSort</name></name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>CollectionUtil</name><operator>.</operator><name>mergeSort</name></name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>CollectionUtil</name><operator>.</operator><name>introSort</name></name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
     <expr_stmt><expr><call><name><name>CollectionUtil</name><operator>.</operator><name>timSort</name></name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>CollectionUtil</name><operator>.</operator><name>insertionSort</name></name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>CollectionUtil</name><operator>.</operator><name>binarySort</name></name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>CollectionUtil</name><operator>.</operator><name>quickSort</name></name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><call><name><name>Collections</name><operator>.</operator><name>reverseOrder</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>CollectionUtil</name><operator>.</operator><name>mergeSort</name></name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><call><name><name>Collections</name><operator>.</operator><name>reverseOrder</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>CollectionUtil</name><operator>.</operator><name>introSort</name></name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><call><name><name>Collections</name><operator>.</operator><name>reverseOrder</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
     <expr_stmt><expr><call><name><name>CollectionUtil</name><operator>.</operator><name>timSort</name></name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><call><name><name>Collections</name><operator>.</operator><name>reverseOrder</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>CollectionUtil</name><operator>.</operator><name>insertionSort</name></name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><call><name><name>Collections</name><operator>.</operator><name>reverseOrder</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>CollectionUtil</name><operator>.</operator><name>binarySort</name></name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><call><name><name>Collections</name><operator>.</operator><name>reverseOrder</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
   </block_content>}</block></function>
   
   <function><type><specifier>public</specifier> <name>void</name></type> <name>testOneElementListSort</name><parameter_list>()</parameter_list> <block>{<block_content>
     <comment type="line">// check that one-element non-random access lists pass sorting without ex (as sorting is not needed)</comment>
     <decl_stmt><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name>Integer</name></argument>&gt;</argument_list></name></type> <name>list</name> <init>= <expr><operator>new</operator> <call><name><name>LinkedList</name><argument_list type="generic">&lt;<argument><name>Integer</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
     <expr_stmt><expr><call><name><name>list</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>CollectionUtil</name><operator>.</operator><name>quickSort</name></name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>CollectionUtil</name><operator>.</operator><name>mergeSort</name></name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>CollectionUtil</name><operator>.</operator><name>introSort</name></name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
     <expr_stmt><expr><call><name><name>CollectionUtil</name><operator>.</operator><name>timSort</name></name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>CollectionUtil</name><operator>.</operator><name>insertionSort</name></name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>CollectionUtil</name><operator>.</operator><name>binarySort</name></name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>CollectionUtil</name><operator>.</operator><name>quickSort</name></name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><call><name><name>Collections</name><operator>.</operator><name>reverseOrder</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>CollectionUtil</name><operator>.</operator><name>mergeSort</name></name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><call><name><name>Collections</name><operator>.</operator><name>reverseOrder</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>CollectionUtil</name><operator>.</operator><name>introSort</name></name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><call><name><name>Collections</name><operator>.</operator><name>reverseOrder</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
     <expr_stmt><expr><call><name><name>CollectionUtil</name><operator>.</operator><name>timSort</name></name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><call><name><name>Collections</name><operator>.</operator><name>reverseOrder</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>CollectionUtil</name><operator>.</operator><name>insertionSort</name></name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><call><name><name>Collections</name><operator>.</operator><name>reverseOrder</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>CollectionUtil</name><operator>.</operator><name>binarySort</name></name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><call><name><name>Collections</name><operator>.</operator><name>reverseOrder</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
   </block_content>}</block></function>
   
 </block_content>}</block></function>
<expr_stmt><expr><name>diff</name> <operator>--</operator><name>git</name> <name>a</name><operator>/</operator><name>lucene</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>test</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>util</name><operator>/</operator><name><name>TestInPlaceMergeSorter</name><operator>.</operator><name>java</name></name> <name>b</name><operator>/</operator><name>lucene</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>test</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>util</name><operator>/</operator><name><name>TestInPlaceMergeSorter</name><operator>.</operator><name>java</name></name>
<operator>new</operator> <name>file</name> <name>mode</name> <literal type="number">100644</literal>
<name>index</name> <literal type="number">00000000000..6c1fe5762b1</literal>
<operator>--</operator> <operator>/</operator><name>dev</name><operator>/</operator><literal type="null">null</literal>
<operator>++</operator> <name>b</name><operator>/</operator><name>lucene</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>test</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>util</name><operator>/</operator><name><name>TestInPlaceMergeSorter</name><operator>.</operator><name>java</name></name>
@@ <operator>-</operator><literal type="number">0</literal></expr><operator>,</operator><expr><literal type="number">0</literal> <operator>+</operator><literal type="number">1</literal></expr><operator>,</operator><expr><literal type="number">36</literal> @@</expr></expr_stmt>
<package>package <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>util</name></name>;</package>

<comment type="block">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</comment>

<import>import <name><name>org</name><operator>.</operator><name>junit</name><operator>.</operator><name>runner</name><operator>.</operator><name>RunWith</name></name>;</import>

<import>import <name><name>com</name><operator>.</operator><name>carrotsearch</name><operator>.</operator><name>randomizedtesting</name><operator>.</operator><name>RandomizedRunner</name></name>;</import>

<class><annotation>@<name>RunWith</name><argument_list>(<argument><expr><name><name>RandomizedRunner</name><operator>.</operator><name>class</name></name></expr></argument>)</argument_list></annotation>
<specifier>public</specifier> class <name>TestInPlaceMergeSorter</name> <super_list><extends>extends <super><name>BaseSortTestCase</name></super></extends></super_list> <block>{

  <constructor><specifier>public</specifier> <name>TestInPlaceMergeSorter</name><parameter_list>()</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>super</name><argument_list>(<argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></constructor>

  <function><annotation>@<name>Override</name></annotation>
  <type><specifier>public</specifier> <name>Sorter</name></type> <name>newSorter</name><parameter_list>(<parameter><decl><type><name><name>Entry</name><index>[]</index></name></type> <name>arr</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <return>return <expr><operator>new</operator> <call><name><name>ArrayInPlaceMergeSorter</name><argument_list type="generic">&lt;<argument><name>Entry</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>arr</name></expr></argument>, <argument><expr><name><name>ArrayUtil</name><operator>.</operator></name>&lt;<name>Entry</name><operator>&gt;</operator><call><name>naturalComparator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></function>

}</block></class>
<expr_stmt><expr><name>diff</name> <operator>--</operator><name>git</name> <name>a</name><operator>/</operator><name>lucene</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>test</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>util</name><operator>/</operator><name><name>TestIntroSorter</name><operator>.</operator><name>java</name></name> <name>b</name><operator>/</operator><name>lucene</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>test</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>util</name><operator>/</operator><name><name>TestIntroSorter</name><operator>.</operator><name>java</name></name>
<operator>new</operator> <name>file</name> <name>mode</name> <literal type="number">100644</literal>
<name>index</name> <literal type="number">00000000000..63e9f9548e8</literal>
<operator>--</operator> <operator>/</operator><name>dev</name><operator>/</operator><literal type="null">null</literal>
<operator>++</operator> <name>b</name><operator>/</operator><name>lucene</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>test</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>util</name><operator>/</operator><name><name>TestIntroSorter</name><operator>.</operator><name>java</name></name>
@@ <operator>-</operator><literal type="number">0</literal></expr><operator>,</operator><expr><literal type="number">0</literal> <operator>+</operator><literal type="number">1</literal></expr><operator>,</operator><expr><literal type="number">32</literal> @@</expr></expr_stmt>
<package>package <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>util</name></name>;</package>

<comment type="block">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</comment>


<class><specifier>public</specifier> class <name>TestIntroSorter</name> <super_list><extends>extends <super><name>BaseSortTestCase</name></super></extends></super_list> <block>{

  <constructor><specifier>public</specifier> <name>TestIntroSorter</name><parameter_list>()</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>super</name><argument_list>(<argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></constructor>

  <function><annotation>@<name>Override</name></annotation>
  <type><specifier>public</specifier> <name>Sorter</name></type> <name>newSorter</name><parameter_list>(<parameter><decl><type><name><name>Entry</name><index>[]</index></name></type> <name>arr</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <return>return <expr><operator>new</operator> <call><name><name>ArrayIntroSorter</name><argument_list type="generic">&lt;<argument><name>Entry</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>arr</name></expr></argument>, <argument><expr><name><name>ArrayUtil</name><operator>.</operator></name>&lt;<name>Entry</name><operator>&gt;</operator><call><name>naturalComparator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></function>

}</block></class>
<expr_stmt><expr><name>diff</name> <operator>--</operator><name>git</name> <name>a</name><operator>/</operator><name>lucene</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>test</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>util</name><operator>/</operator><name><name>TestSorterTemplate</name><operator>.</operator><name>java</name></name> <name>b</name><operator>/</operator><name>lucene</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>test</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>util</name><operator>/</operator><name><name>TestSorterTemplate</name><operator>.</operator><name>java</name></name>
<name>deleted</name> <name>file</name> <name>mode</name> <literal type="number">100644</literal>
<name>index</name> <name>ca824fc3f94</name><operator>..</operator><literal type="number">00000000000</literal>
<operator>--</operator> <name>a</name><operator>/</operator><name>lucene</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>test</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>util</name><operator>/</operator><name><name>TestSorterTemplate</name><operator>.</operator><name>java</name></name>
<operator>++</operator> <operator>/</operator><name>dev</name><operator>/</operator><literal type="null">null</literal>
@@ <operator>-</operator><literal type="number">1</literal></expr><operator>,</operator><expr><literal type="number">181</literal> <operator>+</operator><literal type="number">0</literal></expr><operator>,</operator><expr><literal type="number">0</literal> @@</expr></expr_stmt>
<package>package <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>util</name></name>;</package>

<comment type="block">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</comment>

<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>Arrays</name></name>;</import>

<class><specifier>public</specifier> class <name>TestSorterTemplate</name> <super_list><extends>extends <super><name>LuceneTestCase</name></super></extends></super_list> <block>{

  <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>SLOW_SORT_THRESHOLD</name> <init>= <expr><literal type="number">1000</literal></expr></init></decl>;</decl_stmt>

  <comment type="line">// A sorter template that compares only the last 32 bits</comment>
  <class><specifier>static</specifier> class <name>Last32BitsSorterTemplate</name> <super_list><extends>extends <super><name>SorterTemplate</name></super></extends></super_list> <block>{

    <decl_stmt><decl><type><specifier>final</specifier> <name><name>long</name><index>[]</index></name></type> <name>arr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>long</name></type> <name>pivot</name></decl>;</decl_stmt>

    <constructor><name>Last32BitsSorterTemplate</name><parameter_list>(<parameter><decl><type><name><name>long</name><index>[]</index></name></type> <name>arr</name></decl></parameter>)</parameter_list> <block>{<block_content>
      <expr_stmt><expr><name><name>this</name><operator>.</operator><name>arr</name></name> <operator>=</operator> <name>arr</name></expr>;</expr_stmt>
    </block_content>}</block></constructor>

    <function><annotation>@<name>Override</name></annotation>
    <type><specifier>protected</specifier> <name>void</name></type> <name>swap</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>j</name></decl></parameter>)</parameter_list> <block>{<block_content>
      <decl_stmt><decl><type><specifier>final</specifier> <name>long</name></type> <name>tmp</name> <init>= <expr><name><name>arr</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>arr</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>arr</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>arr</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><type><specifier>private</specifier> <name>int</name></type> <name>compareValues</name><parameter_list>(<parameter><decl><type><name>long</name></type> <name>i</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>j</name></decl></parameter>)</parameter_list> <block>{<block_content>
      <comment type="line">// only compare the last 32 bits</comment>
      <decl_stmt><decl><type><specifier>final</specifier> <name>long</name></type> <name>a</name> <init>= <expr><name>i</name> <operator>&amp;</operator> <literal type="number">0xFFFFFFFFL</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>final</specifier> <name>long</name></type> <name>b</name> <init>= <expr><name>j</name> <operator>&amp;</operator> <literal type="number">0xFFFFFFFFL</literal></expr></init></decl>;</decl_stmt>
      <return>return <expr><call><name><name>Long</name><operator>.</operator><name>compare</name></name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><annotation>@<name>Override</name></annotation>
    <type><specifier>protected</specifier> <name>int</name></type> <name>compare</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>j</name></decl></parameter>)</parameter_list> <block>{<block_content>
      <return>return <expr><call><name>compareValues</name><argument_list>(<argument><expr><name><name>arr</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>arr</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><annotation>@<name>Override</name></annotation>
    <type><specifier>protected</specifier> <name>void</name></type> <name>setPivot</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>)</parameter_list> <block>{<block_content>
      <expr_stmt><expr><name>pivot</name> <operator>=</operator> <name><name>arr</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><annotation>@<name>Override</name></annotation>
    <type><specifier>protected</specifier> <name>int</name></type> <name>comparePivot</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>j</name></decl></parameter>)</parameter_list> <block>{<block_content>
      <return>return <expr><call><name>compareValues</name><argument_list>(<argument><expr><name>pivot</name></expr></argument>, <argument><expr><name><name>arr</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><annotation>@<name>Override</name></annotation>
    <type><specifier>protected</specifier> <name>void</name></type> <name>merge</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>lo</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pivot</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>hi</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len1</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len2</name></decl></parameter>)</parameter_list> <block>{<block_content>
      <comment type="line">// timSort and mergeSort should call runMerge to sort out trivial cases</comment>
      <expr_stmt><expr><call><name>assertTrue</name><argument_list>(<argument><expr><name>len1</name> <operator>&gt;=</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assertTrue</name><argument_list>(<argument><expr><name>len2</name> <operator>&gt;=</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assertTrue</name><argument_list>(<argument><expr><name>len1</name> <operator>+</operator> <name>len2</name> <operator>&gt;=</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assertTrue</name><argument_list>(<argument><expr><call><name>compare</name><argument_list>(<argument><expr><name>lo</name></expr></argument>, <argument><expr><name>pivot</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assertTrue</name><argument_list>(<argument><expr><call><name>compare</name><argument_list>(<argument><expr><name>pivot</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>hi</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assertFalse</name><argument_list>(<argument><expr><call><name>compare</name><argument_list>(<argument><expr><name>pivot</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>pivot</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>super</name><operator>.</operator><name>merge</name></name><argument_list>(<argument><expr><name>lo</name></expr></argument>, <argument><expr><name>pivot</name></expr></argument>, <argument><expr><name>hi</name></expr></argument>, <argument><expr><name>len1</name></expr></argument>, <argument><expr><name>len2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

  }</block></class>

  <function><type><name>void</name></type> <name>testSort</name><parameter_list>(<parameter><decl><type><name><name>int</name><index>[]</index></name></type> <name>intArr</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <comment type="line">// we modify the array as a long[] and store the original ord in the first 32 bits</comment>
    <comment type="line">// to be able to check stability</comment>
    <decl_stmt><decl><type><specifier>final</specifier> <name><name>long</name><index>[]</index></name></type> <name>arr</name> <init>= <expr><call><name>toLongsAndOrds</name><argument_list>(<argument><expr><name>intArr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="line">// use MergeSort as a reference</comment>
    <comment type="line">// assertArrayEquals checks for sorting + stability</comment>
    <comment type="line">// assertArrayEquals(toInts) checks for sorting only</comment>
    <decl_stmt><decl><type><specifier>final</specifier> <name><name>long</name><index>[]</index></name></type> <name>mergeSorted</name> <init>= <expr><call><name><name>Arrays</name><operator>.</operator><name>copyOf</name></name><argument_list>(<argument><expr><name>arr</name></expr></argument>, <argument><expr><name><name>arr</name><operator>.</operator><name>length</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><operator>new</operator> <call><name>Last32BitsSorterTemplate</name><argument_list>(<argument><expr><name>mergeSorted</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>mergeSort</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>arr</name><operator>.</operator><name>length</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>arr</name><operator>.</operator><name>length</name></name> <operator>&lt;</operator> <name>SLOW_SORT_THRESHOLD</name></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><specifier>final</specifier> <name><name>long</name><index>[]</index></name></type> <name>insertionSorted</name> <init>= <expr><call><name><name>Arrays</name><operator>.</operator><name>copyOf</name></name><argument_list>(<argument><expr><name>arr</name></expr></argument>, <argument><expr><name><name>arr</name><operator>.</operator><name>length</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><operator>new</operator> <call><name>Last32BitsSorterTemplate</name><argument_list>(<argument><expr><name>insertionSorted</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>insertionSort</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>arr</name><operator>.</operator><name>length</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assertArrayEquals</name><argument_list>(<argument><expr><name>mergeSorted</name></expr></argument>, <argument><expr><name>insertionSorted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      
      <decl_stmt><decl><type><specifier>final</specifier> <name><name>long</name><index>[]</index></name></type> <name>binarySorted</name> <init>= <expr><call><name><name>Arrays</name><operator>.</operator><name>copyOf</name></name><argument_list>(<argument><expr><name>arr</name></expr></argument>, <argument><expr><name><name>arr</name><operator>.</operator><name>length</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><operator>new</operator> <call><name>Last32BitsSorterTemplate</name><argument_list>(<argument><expr><name>binarySorted</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>binarySort</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>arr</name><operator>.</operator><name>length</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assertArrayEquals</name><argument_list>(<argument><expr><name>mergeSorted</name></expr></argument>, <argument><expr><name>binarySorted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <decl_stmt><decl><type><specifier>final</specifier> <name><name>long</name><index>[]</index></name></type> <name>quickSorted</name> <init>= <expr><call><name><name>Arrays</name><operator>.</operator><name>copyOf</name></name><argument_list>(<argument><expr><name>arr</name></expr></argument>, <argument><expr><name><name>arr</name><operator>.</operator><name>length</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><operator>new</operator> <call><name>Last32BitsSorterTemplate</name><argument_list>(<argument><expr><name>quickSorted</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>quickSort</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>arr</name><operator>.</operator><name>length</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assertArrayEquals</name><argument_list>(<argument><expr><call><name>toInts</name><argument_list>(<argument><expr><name>mergeSorted</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>toInts</name><argument_list>(<argument><expr><name>quickSorted</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><specifier>final</specifier> <name><name>long</name><index>[]</index></name></type> <name>timSorted</name> <init>= <expr><call><name><name>Arrays</name><operator>.</operator><name>copyOf</name></name><argument_list>(<argument><expr><name>arr</name></expr></argument>, <argument><expr><name><name>arr</name><operator>.</operator><name>length</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><operator>new</operator> <call><name>Last32BitsSorterTemplate</name><argument_list>(<argument><expr><name>timSorted</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>timSort</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>arr</name><operator>.</operator><name>length</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assertArrayEquals</name><argument_list>(<argument><expr><name>mergeSorted</name></expr></argument>, <argument><expr><name>timSorted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></function>

  <function><type><specifier>private</specifier> <name><name>int</name><index>[]</index></name></type> <name>toInts</name><parameter_list>(<parameter><decl><type><name><name>long</name><index>[]</index></name></type> <name>longArr</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name><name>int</name><index>[]</index></name></type> <name>arr</name> <init>= <expr><operator>new</operator> <name><name>int</name><index>[<expr><name><name>longArr</name><operator>.</operator><name>length</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>longArr</name><operator>.</operator><name>length</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
      <expr_stmt><expr><name><name>arr</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <name><name>longArr</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
    </block_content>}</block></for>
    <return>return <expr><name>arr</name></expr>;</return>
  </block_content>}</block></function>

  <function><type><specifier>private</specifier> <name><name>long</name><index>[]</index></name></type> <name>toLongsAndOrds</name><parameter_list>(<parameter><decl><type><name><name>int</name><index>[]</index></name></type> <name>intArr</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><specifier>final</specifier> <name><name>long</name><index>[]</index></name></type> <name>arr</name> <init>= <expr><operator>new</operator> <name><name>long</name><index>[<expr><name><name>intArr</name><operator>.</operator><name>length</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>intArr</name><operator>.</operator><name>length</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
      <expr_stmt><expr><name><name>arr</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name>long</name><operator>)</operator> <name>i</name><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">32</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><name><name>intArr</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0xFFFFFFFFL</literal><operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block></for>
    <return>return <expr><name>arr</name></expr>;</return>
  </block_content>}</block></function>

  <function><type><name>int</name></type> <name>randomLength</name><parameter_list>()</parameter_list> <block>{<block_content>
    <return>return <expr><call><name><name>_TestUtil</name><operator>.</operator><name>nextInt</name></name><argument_list>(<argument><expr><call><name>random</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><ternary><condition><expr><call><name>random</name><argument_list>()</argument_list></call><operator>.</operator><call><name>nextBoolean</name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><name>SLOW_SORT_THRESHOLD</name></expr> </then><else>: <expr><literal type="number">100000</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></function>

  <function><type><specifier>public</specifier> <name>void</name></type> <name>testEmpty</name><parameter_list>()</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>testSort</name><argument_list>(<argument><expr><operator>new</operator> <name><name>int</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></function>

  <function><type><specifier>public</specifier> <name>void</name></type> <name>testAscending</name><parameter_list>()</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>length</name> <init>= <expr><call><name>randomLength</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>final</specifier> <name><name>int</name><index>[]</index></name></type> <name>arr</name> <init>= <expr><operator>new</operator> <name><name>int</name><index>[<expr><name>length</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>arr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>random</name><argument_list>()</argument_list></call><operator>.</operator><call><name>nextInt</name><argument_list>(<argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>arr</name><operator>.</operator><name>length</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
      <expr_stmt><expr><name><name>arr</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>arr</name><index>[<expr><name>i</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>+</operator> <call><name><name>_TestUtil</name><operator>.</operator><name>nextInt</name></name><argument_list>(<argument><expr><call><name>random</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>testSort</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></function>

  <function><type><specifier>public</specifier> <name>void</name></type> <name>testDescending</name><parameter_list>()</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>length</name> <init>= <expr><call><name>randomLength</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>final</specifier> <name><name>int</name><index>[]</index></name></type> <name>arr</name> <init>= <expr><operator>new</operator> <name><name>int</name><index>[<expr><name>length</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>arr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>random</name><argument_list>()</argument_list></call><operator>.</operator><call><name>nextInt</name><argument_list>(<argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>arr</name><operator>.</operator><name>length</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
      <expr_stmt><expr><name><name>arr</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>arr</name><index>[<expr><name>i</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>-</operator> <call><name><name>_TestUtil</name><operator>.</operator><name>nextInt</name></name><argument_list>(<argument><expr><call><name>random</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>testSort</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></function>

  <function><type><specifier>public</specifier> <name>void</name></type> <name>testStrictlyDescending</name><parameter_list>()</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>length</name> <init>= <expr><call><name>randomLength</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>final</specifier> <name><name>int</name><index>[]</index></name></type> <name>arr</name> <init>= <expr><operator>new</operator> <name><name>int</name><index>[<expr><name>length</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>arr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>random</name><argument_list>()</argument_list></call><operator>.</operator><call><name>nextInt</name><argument_list>(<argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>arr</name><operator>.</operator><name>length</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
      <expr_stmt><expr><name><name>arr</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>arr</name><index>[<expr><name>i</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>-</operator> <call><name><name>_TestUtil</name><operator>.</operator><name>nextInt</name></name><argument_list>(<argument><expr><call><name>random</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>testSort</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></function>

  <function><type><specifier>public</specifier> <name>void</name></type> <name>testRandom1</name><parameter_list>()</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>length</name> <init>= <expr><call><name>randomLength</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>final</specifier> <name><name>int</name><index>[]</index></name></type> <name>arr</name> <init>= <expr><operator>new</operator> <name><name>int</name><index>[<expr><name>length</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>arr</name><operator>.</operator><name>length</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
      <expr_stmt><expr><name><name>arr</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>random</name><argument_list>()</argument_list></call><operator>.</operator><call><name>nextInt</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>testSort</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></function>

  <function><type><specifier>public</specifier> <name>void</name></type> <name>testRandom2</name><parameter_list>()</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>length</name> <init>= <expr><call><name>randomLength</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>final</specifier> <name><name>int</name><index>[]</index></name></type> <name>arr</name> <init>= <expr><operator>new</operator> <name><name>int</name><index>[<expr><name>length</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>arr</name><operator>.</operator><name>length</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
      <expr_stmt><expr><name><name>arr</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>random</name><argument_list>()</argument_list></call><operator>.</operator><call><name>nextInt</name><argument_list>(<argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>testSort</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></function>

}</block></class>
<expr_stmt><expr><name>diff</name> <operator>--</operator><name>git</name> <name>a</name><operator>/</operator><name>lucene</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>test</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>util</name><operator>/</operator><name><name>TestTimSorter</name><operator>.</operator><name>java</name></name> <name>b</name><operator>/</operator><name>lucene</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>test</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>util</name><operator>/</operator><name><name>TestTimSorter</name><operator>.</operator><name>java</name></name>
<operator>new</operator> <name>file</name> <name>mode</name> <literal type="number">100644</literal>
<name>index</name> <literal type="number">00000000000..df1899644e9</literal>
<operator>--</operator> <operator>/</operator><name>dev</name><operator>/</operator><literal type="null">null</literal>
<operator>++</operator> <name>b</name><operator>/</operator><name>lucene</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>test</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>util</name><operator>/</operator><name><name>TestTimSorter</name><operator>.</operator><name>java</name></name>
@@ <operator>-</operator><literal type="number">0</literal></expr><operator>,</operator><expr><literal type="number">0</literal> <operator>+</operator><literal type="number">1</literal></expr><operator>,</operator><expr><literal type="number">31</literal> @@</expr></expr_stmt>
<package>package <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>util</name></name>;</package>

<comment type="block">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</comment>

<class><specifier>public</specifier> class <name>TestTimSorter</name> <super_list><extends>extends <super><name>BaseSortTestCase</name></super></extends></super_list> <block>{

  <constructor><specifier>public</specifier> <name>TestTimSorter</name><parameter_list>()</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>super</name><argument_list>(<argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></constructor>

  <function><annotation>@<name>Override</name></annotation>
  <type><specifier>public</specifier> <name>Sorter</name></type> <name>newSorter</name><parameter_list>(<parameter><decl><type><name><name>Entry</name><index>[]</index></name></type> <name>arr</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <return>return <expr><operator>new</operator> <call><name><name>ArrayTimSorter</name><argument_list type="generic">&lt;<argument><name>Entry</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>arr</name></expr></argument>, <argument><expr><name><name>ArrayUtil</name><operator>.</operator></name>&lt;<name>Entry</name><operator>&gt;</operator><call><name>naturalComparator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>random</name><argument_list>()</argument_list></call><operator>.</operator><call><name>nextInt</name><argument_list>(<argument><expr><name><name>arr</name><operator>.</operator><name>length</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></function>

}</block></class>
<expr_stmt><expr><name>diff</name> <operator>--</operator><name>git</name> <name>a</name><operator>/</operator><name>lucene</name><operator>/</operator><name>facet</name><operator>/</operator><name>src</name><operator>/</operator><name>test</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>facet</name><operator>/</operator><name>search</name><operator>/</operator><name><name>TestDrillSideways</name><operator>.</operator><name>java</name></name> <name>b</name><operator>/</operator><name>lucene</name><operator>/</operator><name>facet</name><operator>/</operator><name>src</name><operator>/</operator><name>test</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>facet</name><operator>/</operator><name>search</name><operator>/</operator><name><name>TestDrillSideways</name><operator>.</operator><name>java</name></name>
<name>index</name> <name>b2e403cb983</name><operator>..</operator><literal type="number">79b62c79e70</literal> <literal type="number">100644</literal>
<operator>--</operator> <name>a</name><operator>/</operator><name>lucene</name><operator>/</operator><name>facet</name><operator>/</operator><name>src</name><operator>/</operator><name>test</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>facet</name><operator>/</operator><name>search</name><operator>/</operator><name><name>TestDrillSideways</name><operator>.</operator><name>java</name></name>
<operator>++</operator> <name>b</name><operator>/</operator><name>lucene</name><operator>/</operator><name>facet</name><operator>/</operator><name>src</name><operator>/</operator><name>test</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>facet</name><operator>/</operator><name>search</name><operator>/</operator><name><name>TestDrillSideways</name><operator>.</operator><name>java</name></name>
@@ <operator>-</operator><literal type="number">65</literal></expr><operator>,</operator><expr><literal type="number">8</literal> <operator>+</operator><literal type="number">65</literal></expr><operator>,</operator><expr><literal type="number">8</literal> @@</expr></expr_stmt> <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>store</name><operator>.</operator><name>Directory</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>util</name><operator>.</operator><name>Bits</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>util</name><operator>.</operator><name>BytesRef</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>util</name><operator>.</operator><name>FixedBitSet</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>util</name><operator>.</operator><name>InPlaceMergeSorter</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>util</name><operator>.</operator><name>InfoStream</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>util</name><operator>.</operator><name>SorterTemplate</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>util</name><operator>.</operator><name>_TestUtil</name></name>;</import>
 
 <class><specifier>public</specifier> class <name>TestDrillSideways</name> <super_list><extends>extends <super><name>FacetTestCase</name></super></extends></super_list> <block>{
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">875</literal></expr><operator>,</operator><expr><literal type="number">9</literal> <operator>+</operator><literal type="number">875</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@ <specifier>public</specifier> <name>class</name> <name>TestDrillSideways</name> extends <name>FacetTestCase</name> <block>{
 
     <comment type="line">// Naive (on purpose, to reduce bug in tester/gold):</comment>
     <comment type="line">// sort all ids, then return top N slice:</comment>
    <expr><operator>new</operator> <class><super><name>SorterTemplate</name></super><argument_list>()</argument_list> <block>{

      <decl_stmt><decl><type><specifier>private</specifier> <name>int</name></type> <name>pivot</name></decl>;</decl_stmt>
    <expr_stmt><expr><operator>new</operator> <class><super><name>InPlaceMergeSorter</name></super><argument_list>()</argument_list> <block>{
 
       <function><annotation>@<name>Override</name></annotation>
       <type><specifier>protected</specifier> <name>void</name></type> <name>swap</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>j</name></decl></parameter>)</parameter_list> <block>{<block_content>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">901</literal></expr><operator>,</operator><expr><literal type="number">26</literal> <operator>+</operator><literal type="number">899</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@ <specifier>public</specifier> <name>class</name> <name>TestDrillSideways</name> extends <name>FacetTestCase</name> <block>{
         }</block></expr></expr_stmt></block_content></block></function></block></class></expr></expr_stmt></block></class></expr>
       }</block>
 
      @<name>Override</name>
      <specifier>protected</specifier> <name>void</name> <call><name>setPivot</name><argument_list>(<argument><expr><name>int</name> <name>i</name></expr></argument>)</argument_list></call> <block>{
        <expr><name>pivot</name> <operator>=</operator> <name><name>ids</name><index>[<expr><name>i</name></expr>]</index></name></expr>;
      }</block>

      @<name>Override</name>
      <specifier>protected</specifier> <name>int</name> <call><name>comparePivot</name><argument_list>(<argument><expr><name>int</name> <name>j</name></expr></argument>)</argument_list></call> <block>{
        <expr><name>int</name> <name>counti</name> <operator>=</operator> <name><name>counts</name><index>[<expr><name>pivot</name></expr>]</index></name></expr>;
        <expr><name>int</name> <name>countj</name> <operator>=</operator> <name><name>counts</name><index>[<expr><name><name>ids</name><index>[<expr><name>j</name></expr>]</index></name></expr>]</index></name></expr>;
        <comment type="line">// Sort by count descending...</comment>
        <if_stmt><if>if <condition>(<expr><name>counti</name> <operator>&gt;</operator> <name>countj</name></expr>)</condition> <block>{<block_content>
          <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
        <expr_stmt/></block_content></block></if></if_stmt>}</block></expr></expr_stmt> <if_stmt><if type="elseif">else if <condition>(<expr><name>counti</name> <operator>&lt;</operator> <name>countj</name></expr>)</condition> <block>{<block_content>
          <return>return <expr><literal type="number">1</literal></expr>;</return>
        </block_content>}</block></if> <else>else <block>{<block_content>
          <comment type="line">// ... then by ord ascending:</comment>
          <return>return <expr><operator>new</operator> <call><name>BytesRef</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><name>pivot</name></expr>]</index></name></expr></argument>)</argument_list></call><operator>.</operator><call><name>compareTo</name><argument_list>(<argument><expr><operator>new</operator> <call><name>BytesRef</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><name><name>ids</name><index>[<expr><name>j</name></expr>]</index></name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block></else></if_stmt>
      }</block></class>
    }</block></class><expr_stmt><expr><operator>.</operator><call><name>mergeSort</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>ids</name><operator>.</operator><name>length</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function><expr_stmt><expr><operator>.</operator><call><name>sort</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>ids</name><operator>.</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
 
     <if_stmt><if>if <condition>(<expr><name>topN</name> <operator>&gt;</operator> <name><name>ids</name><operator>.</operator><name>length</name></name></expr>)</condition> <block>{<block_content>
       <expr_stmt><expr><name>topN</name> <operator>=</operator> <name><name>ids</name><operator>.</operator><name>length</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>diff</name> <operator>--</operator><name>git</name> <name>a</name><operator>/</operator><name>lucene</name><operator>/</operator><name>highlighter</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>search</name><operator>/</operator><name>highlight</name><operator>/</operator><name><name>TokenSources</name><operator>.</operator><name>java</name></name> <name>b</name><operator>/</operator><name>lucene</name><operator>/</operator><name>highlighter</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>search</name><operator>/</operator><name>highlight</name><operator>/</operator><name><name>TokenSources</name><operator>.</operator><name>java</name></name>
<name>index</name> <literal type="number">4d1d11b3c89</literal><operator>..</operator><name>db45d8bdd76</name> <literal type="number">100644</literal>
<operator>--</operator> <name>a</name><operator>/</operator><name>lucene</name><operator>/</operator><name>highlighter</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>search</name><operator>/</operator><name>highlight</name><operator>/</operator><name><name>TokenSources</name><operator>.</operator><name>java</name></name>
<operator>++</operator> <name>b</name><operator>/</operator><name>lucene</name><operator>/</operator><name>highlighter</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>search</name><operator>/</operator><name>highlight</name><operator>/</operator><name><name>TokenSources</name><operator>.</operator><name>java</name></name>
@@ <operator>-</operator><literal type="number">251</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">251</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@ <specifier>public</specifier> <name>class</name> <name>TokenSources</name> <block>{
     <if_stmt><if>if <condition>(<expr><name>unsortedTokens</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
       <expr_stmt><expr><name>tokensInOriginalOrder</name> <operator>=</operator> <call><name><name>unsortedTokens</name><operator>.</operator><name>toArray</name></name><argument_list>(<argument><expr><operator>new</operator> <name><name>Token</name><index>[<expr><call><name><name>unsortedTokens</name>
           <operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>ArrayUtil</name><operator>.</operator><name>mergeSort</name></name><argument_list>(<argument><expr><name>tokensInOriginalOrder</name></expr></argument>, <argument><expr><operator>new</operator> <class><super><name><name>Comparator</name><argument_list type="generic">&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></super><argument_list>()</argument_list> <block>{
      <expr_stmt><expr><call><name><name>ArrayUtil</name><operator>.</operator><name>timSort</name></name><argument_list>(<argument><expr><name>tokensInOriginalOrder</name></expr></argument>, <argument><expr><operator>new</operator> <class><super><name><name>Comparator</name><argument_list type="generic">&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></super><argument_list>()</argument_list> <block>{
         <function><annotation>@<name>Override</name></annotation>
         <type><specifier>public</specifier> <name>int</name></type> <name>compare</name><parameter_list>(<parameter><decl><type><name>Token</name></type> <name>t1</name></decl></parameter>, <parameter><decl><type><name>Token</name></type> <name>t2</name></decl></parameter>)</parameter_list> <block>{<block_content>
           <if_stmt><if>if <condition>(<expr><call><name><name>t1</name><operator>.</operator><name>startOffset</name></name><argument_list>()</argument_list></call> <operator>==</operator> <call><name><name>t2</name><operator>.</operator><name>startOffset</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name><name>t1</name><operator>.</operator><name>endOffset</name></name><argument_list>()</argument_list></call>
<name>diff</name> <operator>--</operator><name>git</name> <name>a</name><operator>/</operator><name>lucene</name><operator>/</operator><name>highlighter</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>search</name><operator>/</operator><name>highlight</name><operator>/</operator><name><name>TokenStreamFromTermPositionVector</name><operator>.</operator><name>java</name></name> <name>b</name><operator>/</operator><name>lucene</name><operator>/</operator><name>highlighter</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>search</name><operator>/</operator><name>highlight</name><operator>/</operator><name><name>TokenStreamFromTermPositionVector</name><operator>.</operator><name>java</name></name>
<name>index</name> <name>dd07e296640</name><operator>..</operator><literal type="number">4057bd96950</literal> <literal type="number">100644</literal>
<operator>--</operator> <name>a</name><operator>/</operator><name>lucene</name><operator>/</operator><name>highlighter</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>search</name><operator>/</operator><name>highlight</name><operator>/</operator><name><name>TokenStreamFromTermPositionVector</name><operator>.</operator><name>java</name></name>
<operator>++</operator> <name>b</name><operator>/</operator><name>lucene</name><operator>/</operator><name>highlighter</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>search</name><operator>/</operator><name>highlight</name><operator>/</operator><name><name>TokenStreamFromTermPositionVector</name><operator>.</operator><name>java</name></name>
@@ <operator>-</operator><literal type="number">86</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">86</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@ <specifier>public</specifier> <name>final</name> class <name>TokenStreamFromTermPositionVector</name> extends <name>TokenStream</name> <block>{
         <expr><call><name><name>this</name><operator>.</operator><name>positionedTokens</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>;
       }</block></expr></return></block_content></block></if></if_stmt>
     </block_content>}</block></function>
    <constructor_decl><name><name>CollectionUtil</name><operator>.</operator><name>mergeSort</name></name><parameter_list>(<parameter><decl><type><name><name>this</name><operator>.</operator><name>positionedTokens</name></name></type></decl></parameter>, <parameter><decl><type><name>tokenComparator</name></type></decl></parameter>)</parameter_list>;</constructor_decl>
    <constructor_decl><name><name>CollectionUtil</name><operator>.</operator><name>timSort</name></name><parameter_list>(<parameter><decl><type><name><name>this</name><operator>.</operator><name>positionedTokens</name></name></type></decl></parameter>, <parameter><decl><type><name>tokenComparator</name></type></decl></parameter>)</parameter_list>;</constructor_decl>
     <decl_stmt><decl><type><name>int</name></type> <name>lastPosition</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
     <for>for <control>(<init><decl><type><specifier>final</specifier> <name>Token</name></type> <name>token</name> <range>: <expr><name><name>this</name><operator>.</operator><name>positionedTokens</name></name></expr></range></decl></init>)</control> <block>{<block_content>
       <decl_stmt><decl><type><name>int</name></type> <name>thisPosition</name> <init>= <expr><call><name><name>token</name><operator>.</operator><name>getPositionIncrement</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>diff</name> <operator>--</operator><name>git</name> <name>a</name><operator>/</operator><name>lucene</name><operator>/</operator><name>highlighter</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>search</name><operator>/</operator><name>postingshighlight</name><operator>/</operator><name><name>Passage</name><operator>.</operator><name>java</name></name> <name>b</name><operator>/</operator><name>lucene</name><operator>/</operator><name>highlighter</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>search</name><operator>/</operator><name>postingshighlight</name><operator>/</operator><name><name>Passage</name><operator>.</operator><name>java</name></name>
<name>index</name> <literal type="number">734869bece5</literal><operator>..</operator><name>aea1a179f19</name> <literal type="number">100644</literal>
<operator>--</operator> <name>a</name><operator>/</operator><name>lucene</name><operator>/</operator><name>highlighter</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>search</name><operator>/</operator><name>postingshighlight</name><operator>/</operator><name><name>Passage</name><operator>.</operator><name>java</name></name>
<operator>++</operator> <name>b</name><operator>/</operator><name>lucene</name><operator>/</operator><name>highlighter</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>search</name><operator>/</operator><name>postingshighlight</name><operator>/</operator><name><name>Passage</name><operator>.</operator><name>java</name></name>
@@ <operator>-</operator><literal type="number">19</literal></expr><operator>,</operator><expr><literal type="number">8</literal> <operator>+</operator><literal type="number">19</literal></expr><operator>,</operator><expr><literal type="number">8</literal> @@</expr></expr_stmt> <package>package <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>search</name><operator>.</operator><name>postingshighlight</name></name>;</package>
 
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>util</name><operator>.</operator><name>ArrayUtil</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>util</name><operator>.</operator><name>BytesRef</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>util</name><operator>.</operator><name>InPlaceMergeSorter</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>util</name><operator>.</operator><name>RamUsageEstimator</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>util</name><operator>.</operator><name>SorterTemplate</name></name>;</import>
 
 <comment type="block" format="javadoc">/**
  * Represents a passage (typically a sentence of the document). 
@@ -64,7 +64,7 @@ public final class Passage {
     final int starts[] = matchStarts;
     final int ends[] = matchEnds;
     final BytesRef terms[] = matchTerms;
    new SorterTemplate() {
    new InPlaceMergeSorter() {
       @Override
       protected void swap(int i, int j) {
         int temp = starts[i];
@@ -85,18 +85,7 @@ public final class Passage {
         return Integer.compare(starts[i], starts[j]);
       }
 
      @Override
      protected void setPivot(int i) {
        pivot = starts[i];
      }

      @Override
      protected int comparePivot(int j) {
        return Integer.compare(pivot, starts[j]);
      }
      
      int pivot;
    }.mergeSort(0, numMatches-1);
    }.sort(0, numMatches);
   }
   
   void reset() {
diff --git a/lucene/highlighter/src/java/org/apache/lucene/search/postingshighlight/PostingsHighlighter.java b/lucene/highlighter/src/java/org/apache/lucene/search/postingshighlight/PostingsHighlighter.java
index d89b191edef..850c77a437d 100644
-- a/lucene/highlighter/src/java/org/apache/lucene/search/postingshighlight/PostingsHighlighter.java
++ b/lucene/highlighter/src/java/org/apache/lucene/search/postingshighlight/PostingsHighlighter.java
@@ -48,7 +48,7 @@ import org.apache.lucene.search.Query;
 import org.apache.lucene.search.ScoreDoc;
 import org.apache.lucene.search.TopDocs;
 import org.apache.lucene.util.BytesRef;
import org.apache.lucene.util.SorterTemplate;
import org.apache.lucene.util.InPlaceMergeSorter;
 import org.apache.lucene.util.UnicodeUtil;
 
 /**
@@ -313,9 +313,8 @@ public class PostingsHighlighter {
 
     // sort for sequential io
     Arrays.sort(docids);
    new SorterTemplate() {
      String pivot;
      
    new InPlaceMergeSorter() {

       @Override
       protected void swap(int i, int j) {
         String tmp = fields[i];
@@ -330,18 +329,8 @@ public class PostingsHighlighter {
       protected int compare(int i, int j) {
         return fields[i].compareTo(fields[j]);
       }

      @Override
      protected void setPivot(int i) {
        pivot = fields[i];
      }

      @Override
      protected int comparePivot(int j) {
        return pivot.compareTo(fields[j]);
      }
       
    }.mergeSort(0, fields.length-1);
    }.sort(0, fields.length);
     
     // pull stored data:
     String[][] contents = loadFieldValues(searcher, fields, docids, maxLength);
diff --git a/lucene/memory/src/java/org/apache/lucene/index/memory/MemoryIndex.java b/lucene/memory/src/java/org/apache/lucene/index/memory/MemoryIndex.java
index d6a31ae03ad..43feb828fb5 100644
-- a/lucene/memory/src/java/org/apache/lucene/index/memory/MemoryIndex.java
++ b/lucene/memory/src/java/org/apache/lucene/index/memory/MemoryIndex.java
@@ -572,7 +572,7 @@ public class MemoryIndex {
       entries[i] = iter.next();
     }
     
    if (size &gt; 1) ArrayUtil.quickSort(entries, termComparator);
    if (size &gt; 1) ArrayUtil.introSort(entries, termComparator);
     return entries;
   }
   
diff --git a/lucene/misc/src/java/org/apache/lucene/index/CompoundFileExtractor.java b/lucene/misc/src/java/org/apache/lucene/index/CompoundFileExtractor.java
index 2b80764632a..f12d5f8e42f 100644
-- a/lucene/misc/src/java/org/apache/lucene/index/CompoundFileExtractor.java
++ b/lucene/misc/src/java/org/apache/lucene/index/CompoundFileExtractor.java
@@ -87,7 +87,7 @@ public class CompoundFileExtractor {
       cfr = new CompoundFileDirectory(dir, filename, IOContext.DEFAULT, false);
 
       String [] files = cfr.listAll();
      ArrayUtil.mergeSort(files);   // sort the array of filename so that the output is more readable
      ArrayUtil.timSort(files);   // sort the array of filename so that the output is more readable
 
       for (int i = 0; i &lt; files.length; ++i) {
         long len = cfr.fileLength(files[i]);
diff --git a/lucene/misc/src/java/org/apache/lucene/index/sorter/Sorter.java b/lucene/misc/src/java/org/apache/lucene/index/sorter/Sorter.java
index 325b2dc3df0..05e8563ff4e 100644
-- a/lucene/misc/src/java/org/apache/lucene/index/sorter/Sorter.java
++ b/lucene/misc/src/java/org/apache/lucene/index/sorter/Sorter.java
@@ -22,7 +22,7 @@ import java.util.Comparator;
 
 import org.apache.lucene.index.AtomicReader;
 import org.apache.lucene.index.IndexReader;
import org.apache.lucene.util.SorterTemplate;
import org.apache.lucene.util.TimSorter;
 import org.apache.lucene.util.packed.MonotonicAppendingLongBuffer;
 
 /**
@@ -113,16 +113,17 @@ public abstract class Sorter {
     }
   };
   
  private static final class DocValueSorterTemplate extends SorterTemplate {
  private static final class DocValueSorter extends TimSorter {
     
     private final int[] docs;
     private final Sorter.DocComparator comparator;
    private final int[] tmp;
     
    private int pivot;
    
    public DocValueSorterTemplate(int[] docs, Sorter.DocComparator comparator) {
    public DocValueSorter(int[] docs, Sorter.DocComparator comparator) {
      super(docs.length / 64);
       this.docs = docs;
       this.comparator = comparator;
      tmp = new int[docs.length / 64];
     }
     
     @Override
@@ -130,22 +131,32 @@ public abstract class Sorter {
       return comparator.compare(docs[i], docs[j]);
     }
     
    @Override
    protected int comparePivot(int j) {
      return comparator.compare(pivot, docs[j]);
    }
    
    @Override
    protected void setPivot(int i) {
      pivot = docs[i];
    }
    
     @Override
     protected void swap(int i, int j) {
       int tmpDoc = docs[i];
       docs[i] = docs[j];
       docs[j] = tmpDoc;
     }

    @Override
    protected void copy(int src, int dest) {
      docs[dest] = docs[src];
    }

    @Override
    protected void save(int i, int len) {
      System.arraycopy(docs, i, tmp, 0, len);
    }

    @Override
    protected void restore(int i, int j) {
      docs[j] = tmp[i];
    }

    @Override
    protected int compareSaved(int i, int j) {
      return comparator.compare(tmp[i], docs[j]);
    }
   }
 
   /** Computes the old-to-new permutation over the given comparator. */</comment>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">168</literal></expr><operator>,</operator><expr><literal type="number">10</literal> <operator>+</operator><literal type="number">179</literal></expr><operator>,</operator><expr><literal type="number">10</literal> @@ <specifier>public</specifier> <specifier>abstract</specifier> class <name>Sorter</name> <block>{
       <expr><name><name>docs</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>i</name></expr>;
     }</block></expr></expr_stmt>
     
    <decl_stmt><decl><type><name>SorterTemplate</name></type> <name>sorter</name> <init>= <expr><operator>new</operator> <call><name>DocValueSorterTemplate</name><argument_list>(<argument><expr><name>docs</name></expr></argument>, <argument><expr><name>comparator</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>DocValueSorter</name></type> <name>sorter</name> <init>= <expr><operator>new</operator> <call><name>DocValueSorter</name><argument_list>(<argument><expr><name>docs</name></expr></argument>, <argument><expr><name>comparator</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
     <comment type="line">// It can be common to sort a reader, add docs, sort it again, ... and in</comment>
     <comment type="line">// that case timSort can save a lot of time</comment>
    <expr_stmt><expr><call><name><name>sorter</name><operator>.</operator><name>timSort</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>docs</name><operator>.</operator><name>length</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// docs is now the newToOld mapping</comment>
    <expr_stmt><expr><call><name><name>sorter</name><operator>.</operator><name>sort</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>docs</name><operator>.</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// docs is now the newToOld mapping</comment>
 
     <comment type="line">// The reason why we use MonotonicAppendingLongBuffer here is that it</comment>
     <comment type="line">// wastes very little memory if the index is in random order but can save</comment>
<expr_stmt><expr><name>diff</name> <operator>--</operator><name>git</name> <name>a</name><operator>/</operator><name>lucene</name><operator>/</operator><name>misc</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>index</name><operator>/</operator><name>sorter</name><operator>/</operator><name><name>SortingAtomicReader</name><operator>.</operator><name>java</name></name> <name>b</name><operator>/</operator><name>lucene</name><operator>/</operator><name>misc</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>index</name><operator>/</operator><name>sorter</name><operator>/</operator><name><name>SortingAtomicReader</name><operator>.</operator><name>java</name></name>
<name>index</name> <literal type="number">62a681f3e95</literal><operator>..</operator><name>f7cce128692</name> <literal type="number">100644</literal>
<operator>--</operator> <name>a</name><operator>/</operator><name>lucene</name><operator>/</operator><name>misc</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>index</name><operator>/</operator><name>sorter</name><operator>/</operator><name><name>SortingAtomicReader</name><operator>.</operator><name>java</name></name>
<operator>++</operator> <name>b</name><operator>/</operator><name>lucene</name><operator>/</operator><name>misc</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>index</name><operator>/</operator><name>sorter</name><operator>/</operator><name><name>SortingAtomicReader</name><operator>.</operator><name>java</name></name>
@@ <operator>-</operator><literal type="number">43</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">43</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@</expr></expr_stmt> <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>store</name><operator>.</operator><name>RAMOutputStream</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>util</name><operator>.</operator><name>ArrayUtil</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>util</name><operator>.</operator><name>Bits</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>util</name><operator>.</operator><name>BytesRef</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>util</name><operator>.</operator><name>SorterTemplate</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>util</name><operator>.</operator><name>TimSorter</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>util</name><operator>.</operator><name>automaton</name><operator>.</operator><name>CompiledAutomaton</name></name>;</import>
 
 <comment type="block" format="javadoc">/**
@@ -157,7 +157,7 @@ public class SortingAtomicReader extends FilterAtomicReader {
 
       final DocsEnum inDocs = in.docs(newToOld(liveDocs), inReuse, flags);
       final boolean withFreqs = indexOptions.compareTo(IndexOptions.DOCS_AND_FREQS) &gt;=0 &amp;&amp; (flags &amp; DocsEnum.FLAG_FREQS) != 0;
      return new SortingDocsEnum(wrapReuse, inDocs, withFreqs, docMap);
      return new SortingDocsEnum(docMap.size(), wrapReuse, inDocs, withFreqs, docMap);
     }
 
     @Override
@@ -184,7 +184,7 @@ public class SortingAtomicReader extends FilterAtomicReader {
       // ask for everything. if that assumption changes in the future, we can
       // factor in whether 'flags' says offsets are not required.
       final boolean storeOffsets = indexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) &gt;= 0;
      return new SortingDocsAndPositionsEnum(wrapReuse, inDocsAndPositions, docMap, storeOffsets);
      return new SortingDocsAndPositionsEnum(docMap.size(), wrapReuse, inDocsAndPositions, docMap, storeOffsets);
     }
 
   }
@@ -295,33 +295,31 @@ public class SortingAtomicReader extends FilterAtomicReader {
 
   static class SortingDocsEnum extends FilterDocsEnum {
     
    private static final class DocFreqSorterTemplate extends SorterTemplate {
    private static final class DocFreqSorter extends TimSorter {
       
      private final int[] docs;
      private final int[] freqs;
      private int[] docs;
      private int[] freqs;
      private final int[] tmpDocs;
      private int[] tmpFreqs;
       
      private int pivot;
      
      public DocFreqSorterTemplate(int[] docs, int[] freqs) {
      public DocFreqSorter(int maxDoc) {
        super(maxDoc / 64);
        this.tmpDocs = new int[maxDoc / 64];
      }

      public void reset(int[] docs, int[] freqs) {
         this.docs = docs;
         this.freqs = freqs;
        if (freqs != null &amp;&amp; tmpFreqs == null) {
          tmpFreqs = new int[tmpDocs.length];
        }
       }
      

       @Override
       protected int compare(int i, int j) {
         return docs[i] - docs[j];
       }
       
      @Override
      protected int comparePivot(int j) {
        return pivot - docs[j];
      }
      
      @Override
      protected void setPivot(int i) {
        pivot = docs[i];
      }
      
       @Override
       protected void swap(int i, int j) {
         int tmpDoc = docs[i];
@@ -334,22 +332,60 @@ public class SortingAtomicReader extends FilterAtomicReader {
           freqs[j] = tmpFreq;
         }
       }

      @Override
      protected void copy(int src, int dest) {
        docs[dest] = docs[src];
        if (freqs != null) {
          freqs[dest] = freqs[src];
        }
      }

      @Override
      protected void save(int i, int len) {
        System.arraycopy(docs, i, tmpDocs, 0, len);
        if (freqs != null) {
          System.arraycopy(freqs, i, tmpFreqs, 0, len);
        }
      }

      @Override
      protected void restore(int i, int j) {
        docs[j] = tmpDocs[i];
        if (freqs != null) {
          freqs[j] = tmpFreqs[i];
        }
      }

      @Override
      protected int compareSaved(int i, int j) {
        return tmpDocs[i] - docs[j];
      }
     }
    

    private final int maxDoc;
    private final DocFreqSorter sorter;
     private int[] docs;
     private int[] freqs;
     private int docIt = -1;
     private final int upto;
     private final boolean withFreqs;
 
    SortingDocsEnum(SortingDocsEnum reuse, final DocsEnum in, boolean withFreqs, final Sorter.DocMap docMap) throws IOException {
    SortingDocsEnum(int maxDoc, SortingDocsEnum reuse, final DocsEnum in, boolean withFreqs, final Sorter.DocMap docMap) throws IOException {
       super(in);
      this.maxDoc = maxDoc;
       this.withFreqs = withFreqs;
       if (reuse != null) {
        if (reuse.maxDoc == maxDoc) {
          sorter = reuse.sorter;
        } else {
          sorter = new DocFreqSorter(maxDoc);
        }
         docs = reuse.docs;
         freqs = reuse.freqs; // maybe null
       } else {
         docs = new int[64];
        sorter = new DocFreqSorter(maxDoc);
       }
       docIt = -1;
       int i = 0;
@@ -378,7 +414,8 @@ public class SortingAtomicReader extends FilterAtomicReader {
       }
       // TimSort can save much time compared to other sorts in case of
       // reverse sorting, or when sorting a concatenation of sorted readers
      new DocFreqSorterTemplate(docs, freqs).timSort(0, i - 1);
      sorter.reset(docs, freqs);
      sorter.sort(0, i);
       upto = i;
     }
 
@@ -422,37 +459,33 @@ public class SortingAtomicReader extends FilterAtomicReader {
   static class SortingDocsAndPositionsEnum extends FilterDocsAndPositionsEnum {
     
     /**
     * A {@link SorterTemplate} which sorts two parallel arrays of doc IDs and
     * A {@link Sorter} which sorts two parallel arrays of doc IDs and
      * offsets in one go. Everytime a doc ID is 'swapped', its correponding offset
      * is swapped too.
      */</comment>
    <class><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> class <name>DocOffsetSorterTemplate</name> <super_list><extends>extends <super><name>SorterTemplate</name></super></extends></super_list> <block>{
    <class><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> class <name>DocOffsetSorter</name> <super_list><extends>extends <super><name>TimSorter</name></super></extends></super_list> <block>{
       
      <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name><name>int</name><index>[]</index></name></type> <name>docs</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name><name>long</name><index>[]</index></name></type> <name>offsets</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>private</specifier> <name><name>int</name><index>[]</index></name></type> <name>docs</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>private</specifier> <name><name>long</name><index>[]</index></name></type> <name>offsets</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name><name>int</name><index>[]</index></name></type> <name>tmpDocs</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name><name>long</name><index>[]</index></name></type> <name>tmpOffsets</name></decl>;</decl_stmt>
       
      <decl_stmt><decl><type><specifier>private</specifier> <name>int</name></type> <name>pivot</name></decl>;</decl_stmt>
      
      <constructor><specifier>public</specifier> <name>DocOffsetSorterTemplate</name><parameter_list>(<parameter><decl><type><name><name>int</name><index>[]</index></name></type> <name>docs</name></decl></parameter>, <parameter><decl><type><name><name>long</name><index>[]</index></name></type> <name>offsets</name></decl></parameter>)</parameter_list> <block>{<block_content>
      <constructor><specifier>public</specifier> <name>DocOffsetSorter</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>maxDoc</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <expr_stmt><expr><call><name>super</name><argument_list>(<argument><expr><name>maxDoc</name> <operator>/</operator> <literal type="number">64</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>tmpDocs</name></name> <operator>=</operator> <operator>new</operator> <name><name>int</name><index>[<expr><name>maxDoc</name> <operator>/</operator> <literal type="number">64</literal></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>this</name><operator>.</operator><name>tmpOffsets</name></name> <operator>=</operator> <operator>new</operator> <name><name>long</name><index>[<expr><name>maxDoc</name> <operator>/</operator> <literal type="number">64</literal></expr>]</index></name></expr>;</expr_stmt>
      </block_content>}</block></constructor>

      <function><type><specifier>public</specifier> <name>void</name></type> <name>reset</name><parameter_list>(<parameter><decl><type><name><name>int</name><index>[]</index></name></type> <name>docs</name></decl></parameter>, <parameter><decl><type><name><name>long</name><index>[]</index></name></type> <name>offsets</name></decl></parameter>)</parameter_list> <block>{<block_content>
         <expr_stmt><expr><name><name>this</name><operator>.</operator><name>docs</name></name> <operator>=</operator> <name>docs</name></expr>;</expr_stmt>
         <expr_stmt><expr><name><name>this</name><operator>.</operator><name>offsets</name></name> <operator>=</operator> <name>offsets</name></expr>;</expr_stmt>
       </block_content>}</block></function>
      

       <function><annotation>@<name>Override</name></annotation>
       <type><specifier>protected</specifier> <name>int</name></type> <name>compare</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>j</name></decl></parameter>)</parameter_list> <block>{<block_content>
         <return>return <expr><name><name>docs</name><index>[<expr><name>i</name></expr>]</index></name> <operator>-</operator> <name><name>docs</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</return>
       </block_content>}</block></function>
       
      <function><annotation>@<name>Override</name></annotation>
      <type><specifier>protected</specifier> <name>int</name></type> <name>comparePivot</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>j</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <return>return <expr><name>pivot</name> <operator>-</operator> <name><name>docs</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</return>
      </block_content>}</block></function>
      
      <function><annotation>@<name>Override</name></annotation>
      <type><specifier>protected</specifier> <name>void</name></type> <name>setPivot</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <expr_stmt><expr><name>pivot</name> <operator>=</operator> <name><name>docs</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
      </block_content>}</block></function>
      
       <function><annotation>@<name>Override</name></annotation>
       <type><specifier>protected</specifier> <name>void</name></type> <name>swap</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>j</name></decl></parameter>)</parameter_list> <block>{<block_content>
         <decl_stmt><decl><type><name>int</name></type> <name>tmpDoc</name> <init>= <expr><name><name>docs</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">463</literal></expr><operator>,</operator><expr><literal type="number">8</literal> <operator>+</operator><literal type="number">496</literal></expr><operator>,</operator><expr><literal type="number">33</literal> @@ <specifier>public</specifier> class <name>SortingAtomicReader</name> extends <name>FilterAtomicReader</name> <block>{
         <expr><name><name>offsets</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>offsets</name><index>[<expr><name>j</name></expr>]</index></name></expr>;
         <name><name>offsets</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>tmpOffset</name></block></expr>;</expr_stmt>
       </block_content>}</block></function>

      <function><annotation>@<name>Override</name></annotation>
      <type><specifier>protected</specifier> <name>void</name></type> <name>copy</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>dest</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <expr_stmt><expr><name><name>docs</name><index>[<expr><name>dest</name></expr>]</index></name> <operator>=</operator> <name><name>docs</name><index>[<expr><name>src</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>offsets</name><index>[<expr><name>dest</name></expr>]</index></name> <operator>=</operator> <name><name>offsets</name><index>[<expr><name>src</name></expr>]</index></name></expr>;</expr_stmt>
      </block_content>}</block></function>

      <function><annotation>@<name>Override</name></annotation>
      <type><specifier>protected</specifier> <name>void</name></type> <name>save</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <expr_stmt><expr><call><name><name>System</name><operator>.</operator><name>arraycopy</name></name><argument_list>(<argument><expr><name>docs</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>tmpDocs</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>System</name><operator>.</operator><name>arraycopy</name></name><argument_list>(<argument><expr><name>offsets</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>tmpOffsets</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></function>

      <function><annotation>@<name>Override</name></annotation>
      <type><specifier>protected</specifier> <name>void</name></type> <name>restore</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>j</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <expr_stmt><expr><name><name>docs</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name><name>tmpDocs</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>offsets</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name><name>tmpOffsets</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
      </block_content>}</block></function>

      <function><annotation>@<name>Override</name></annotation>
      <type><specifier>protected</specifier> <name>int</name></type> <name>compareSaved</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>j</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <return>return <expr><name><name>tmpDocs</name><index>[<expr><name>i</name></expr>]</index></name> <operator>-</operator> <name><name>docs</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</return>
      </block_content>}</block></function>
     </block_content>}</block></constructor>
     
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>int</name></type> <name>maxDoc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>DocOffsetSorter</name></type> <name>sorter</name></decl>;</decl_stmt>
     <decl_stmt><decl><type><specifier>private</specifier> <name><name>int</name><index>[]</index></name></type> <name>docs</name></decl>;</decl_stmt>
     <decl_stmt><decl><type><specifier>private</specifier> <name><name>long</name><index>[]</index></name></type> <name>offsets</name></decl>;</decl_stmt>
     <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>int</name></type> <name>upto</name></decl>;</decl_stmt>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">481</literal></expr><operator>,</operator><expr><literal type="number">19</literal> <operator>+</operator><literal type="number">539</literal></expr><operator>,</operator><expr><literal type="number">26</literal> @@ <specifier>public</specifier> class <name>SortingAtomicReader</name> extends <name>FilterAtomicReader</name> <block>{
 
     <expr><specifier>private</specifier> <name>final</name> <name>RAMFile</name> <name>file</name></expr>;
 
    <call><name>SortingDocsAndPositionsEnum</name><argument_list>(<argument><expr><name>SortingDocsAndPositionsEnum</name> <name>reuse</name></expr></argument>, <argument><expr><name>final</name> <name>DocsAndPositionsEnum</name> <name>in</name></expr></argument>, <argument><expr><name><name>Sorter</name><operator>.</operator><name>DocMap</name></name> <name>docMap</name></expr></argument>, <argument><expr><name>boolean</name> <name>storeOffsets</name></expr></argument>)</argument_list></call> <throws>throws <argument><expr><name>IOException</name> <block>{
    <expr><call><name>SortingDocsAndPositionsEnum</name><argument_list>(<argument><expr><name>int</name> <name>maxDoc</name></expr></argument>, <argument><expr><name>SortingDocsAndPositionsEnum</name> <name>reuse</name></expr></argument>, <argument><expr><name>final</name> <name>DocsAndPositionsEnum</name> <name>in</name></expr></argument>, <argument><expr><name><name>Sorter</name><operator>.</operator><name>DocMap</name></name> <name>docMap</name></expr></argument>, <argument><expr><name>boolean</name> <name>storeOffsets</name></expr></argument>)</argument_list></call></expr></block></expr></argument></throws> <throws>throws <argument><expr><name>IOException</name> <block>{
       <expr><call><name>super</name><argument_list>(<argument><expr><name>in</name></expr></argument>)</argument_list></call></expr></block></expr></argument></throws></block></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>this</name><operator>.</operator><name>maxDoc</name></name> <operator>=</operator> <name>maxDoc</name></expr>;</expr_stmt>
       <expr_stmt><expr><name><name>this</name><operator>.</operator><name>storeOffsets</name></name> <operator>=</operator> <name>storeOffsets</name></expr>;</expr_stmt>
       <if_stmt><if>if <condition>(<expr><name>reuse</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
         <expr_stmt><expr><name>docs</name> <operator>=</operator> <name><name>reuse</name><operator>.</operator><name>docs</name></name></expr>;</expr_stmt>
         <expr_stmt><expr><name>offsets</name> <operator>=</operator> <name><name>reuse</name><operator>.</operator><name>offsets</name></name></expr>;</expr_stmt>
         <expr_stmt><expr><name>payload</name> <operator>=</operator> <name><name>reuse</name><operator>.</operator><name>payload</name></name></expr>;</expr_stmt>
         <expr_stmt><expr><name>file</name> <operator>=</operator> <name><name>reuse</name><operator>.</operator><name>file</name></name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>reuse</name><operator>.</operator><name>maxDoc</name></name> <operator>==</operator> <name>maxDoc</name></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><name>sorter</name> <operator>=</operator> <name><name>reuse</name><operator>.</operator><name>sorter</name></name></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
          <expr_stmt><expr><name>sorter</name> <operator>=</operator> <operator>new</operator> <call><name>DocOffsetSorter</name><argument_list>(<argument><expr><name>maxDoc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
       </block_content>}</block></if> <else>else <block>{<block_content>
         <expr_stmt><expr><name>docs</name> <operator>=</operator> <operator>new</operator> <name><name>int</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></expr>;</expr_stmt>
         <expr_stmt><expr><name>offsets</name> <operator>=</operator> <operator>new</operator> <name><name>long</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></expr>;</expr_stmt>
         <expr_stmt><expr><name>payload</name> <operator>=</operator> <operator>new</operator> <call><name>BytesRef</name><argument_list>(<argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
         <expr_stmt><expr><name>file</name> <operator>=</operator> <operator>new</operator> <call><name>RAMFile</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>sorter</name> <operator>=</operator> <operator>new</operator> <call><name>DocOffsetSorter</name><argument_list>(<argument><expr><name>maxDoc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
       </block_content>}</block></else></if_stmt>
       <decl_stmt><decl><type><specifier>final</specifier> <name>IndexOutput</name></type> <name>out</name> <init>= <expr><operator>new</operator> <call><name>RAMOutputStream</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
       <decl_stmt><decl><type><name>int</name></type> <name>doc</name></decl>;</decl_stmt>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">510</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">575</literal></expr><operator>,</operator><expr><literal type="number">8</literal> @@ <specifier>public</specifier> class <name>SortingAtomicReader</name> extends <name>FilterAtomicReader</name> <block>{
         <expr><name>i</name><operator>++</operator></expr>;
       }</block></expr></expr_stmt>
       <expr_stmt><expr><name>upto</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
      <expr_stmt><expr><operator>new</operator> <call><name>DocOffsetSorterTemplate</name><argument_list>(<argument><expr><name>docs</name></expr></argument>, <argument><expr><name>offsets</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>timSort</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>upto</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <constructor_decl><name><name>sorter</name><operator>.</operator><name>reset</name></name><parameter_list>(<parameter><decl><type><name>docs</name></type></decl></parameter>, <parameter><decl><type><name>offsets</name></type></decl></parameter>)</parameter_list>;</constructor_decl>
      <expr_stmt><expr><call><name><name>sorter</name><operator>.</operator><name>sort</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>upto</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
       <constructor_decl><name><name>out</name><operator>.</operator><name>close</name></name><parameter_list>()</parameter_list>;</constructor_decl>
       <expr_stmt><expr><name><name>this</name><operator>.</operator><name>postingInput</name></name> <operator>=</operator> <operator>new</operator> <call><name>RAMInputStream</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
     }</block></class>
<expr_stmt><expr><name>diff</name> <operator>--</operator><name>git</name> <name>a</name><operator>/</operator><name>lucene</name><operator>/</operator><name>suggest</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>search</name><operator>/</operator><name>spell</name><operator>/</operator><name><name>DirectSpellChecker</name><operator>.</operator><name>java</name></name> <name>b</name><operator>/</operator><name>lucene</name><operator>/</operator><name>suggest</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>search</name><operator>/</operator><name>spell</name><operator>/</operator><name><name>DirectSpellChecker</name><operator>.</operator><name>java</name></name>
<name>index</name> <name>b88a8c0ba6f</name><operator>..</operator><literal type="number">4df757b05b8</literal> <literal type="number">100644</literal>
<operator>--</operator> <name>a</name><operator>/</operator><name>lucene</name><operator>/</operator><name>suggest</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>search</name><operator>/</operator><name>spell</name><operator>/</operator><name><name>DirectSpellChecker</name><operator>.</operator><name>java</name></name>
<operator>++</operator> <name>b</name><operator>/</operator><name>lucene</name><operator>/</operator><name>suggest</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>search</name><operator>/</operator><name>spell</name><operator>/</operator><name><name>DirectSpellChecker</name><operator>.</operator><name>java</name></name>
@@ <operator>-</operator><literal type="number">376</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">376</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@ <specifier>public</specifier> class <name>DirectSpellChecker</name> <block>{
       <expr><name><name>suggestions</name><index>[<expr><name>index</name><operator>--</operator></expr>]</index></name> <operator>=</operator> <name>suggestion</name></expr>;
     }</block></expr></expr_stmt>
     
    <expr_stmt><expr><call><name><name>ArrayUtil</name><operator>.</operator><name>mergeSort</name></name><argument_list>(<argument><expr><name>suggestions</name></expr></argument>, <argument><expr><call><name><name>Collections</name><operator>.</operator><name>reverseOrder</name></name><argument_list>(<argument><expr><name>comparator</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>ArrayUtil</name><operator>.</operator><name>timSort</name></name><argument_list>(<argument><expr><name>suggestions</name></expr></argument>, <argument><expr><call><name><name>Collections</name><operator>.</operator><name>reverseOrder</name></name><argument_list>(<argument><expr><name>comparator</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
     <if_stmt><if>if <condition>(<expr><name>numSug</name> <operator>&lt;</operator> <name><name>suggestions</name><operator>.</operator><name>length</name></name></expr>)</condition> <block>{<block_content>
       <decl_stmt><decl><type><name>SuggestWord</name></type> <name><name>trimmed</name><index>[]</index></name> <init>= <expr><operator>new</operator> <name><name>SuggestWord</name><index>[<expr><name>numSug</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
       <expr_stmt><expr><call><name><name>System</name><operator>.</operator><name>arraycopy</name></name><argument_list>(<argument><expr><name>suggestions</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>trimmed</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>numSug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>diff</name> <operator>--</operator><name>git</name> <name>a</name><operator>/</operator><name>lucene</name><operator>/</operator><name>suggest</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>search</name><operator>/</operator><name>suggest</name><operator>/</operator><name><name>BytesRefArray</name><operator>.</operator><name>java</name></name> <name>b</name><operator>/</operator><name>lucene</name><operator>/</operator><name>suggest</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>search</name><operator>/</operator><name>suggest</name><operator>/</operator><name><name>BytesRefArray</name><operator>.</operator><name>java</name></name>
<name>index</name> <literal type="number">98f5291e9cc</literal><operator>..</operator><literal type="number">9fa96bac55a</literal> <literal type="number">100644</literal>
<operator>--</operator> <name>a</name><operator>/</operator><name>lucene</name><operator>/</operator><name>suggest</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>search</name><operator>/</operator><name>suggest</name><operator>/</operator><name><name>BytesRefArray</name><operator>.</operator><name>java</name></name>
<operator>++</operator> <name>b</name><operator>/</operator><name>lucene</name><operator>/</operator><name>suggest</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>search</name><operator>/</operator><name>suggest</name><operator>/</operator><name><name>BytesRefArray</name><operator>.</operator><name>java</name></name>
@@ <operator>-</operator><literal type="number">21</literal></expr><operator>,</operator><expr><literal type="number">12</literal> <operator>+</operator><literal type="number">21</literal></expr><operator>,</operator><expr><literal type="number">12</literal> @@</expr></expr_stmt> <import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>Arrays</name></name>;</import>
 <import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>Comparator</name></name>;</import>
 
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>util</name><operator>.</operator><name>ArrayUtil</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>util</name><operator>.</operator><name>BytesRef</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>util</name><operator>.</operator><name>ByteBlockPool</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>util</name><operator>.</operator><name>BytesRef</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>util</name><operator>.</operator><name>BytesRefIterator</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>util</name><operator>.</operator><name>Counter</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>util</name><operator>.</operator><name>IntroSorter</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>util</name><operator>.</operator><name>RamUsageEstimator</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>util</name><operator>.</operator><name>SorterTemplate</name></name>;</import></block_content></block></if></if_stmt></block></class></block_content></block></for></block></class></expr></argument></argument_list></call></expr></expr_stmt></block></class></expr></argument></argument_list></call></expr></expr_stmt></block_content></block></if></if_stmt></block></expr></expr_stmt></block_content></block></if></if_stmt></block_content></block></function></block_content></block></function>
 
 <comment type="block" format="javadoc">/**
  * A simple append only random-access {@link BytesRef} array that stores full
@@ -120,7 +120,7 @@ public final class BytesRefArray {
     for (int i = 0; i &lt; orderedEntries.length; i++) {
       orderedEntries[i] = i;
     }
    new SorterTemplate() {
    new IntroSorter() {
       @Override
       protected void swap(int i, int j) {
         final int o = orderedEntries[i];
@@ -148,7 +148,7 @@ public final class BytesRefArray {
       
       private final BytesRef pivot = new BytesRef(), scratch1 = new BytesRef(),
           scratch2 = new BytesRef();
    }.quickSort(0, size() - 1);
    }.sort(0, size());
     return orderedEntries;
   }
   
diff --git a/solr/core/src/java/org/apache/solr/handler/AnalysisRequestHandlerBase.java b/solr/core/src/java/org/apache/solr/handler/AnalysisRequestHandlerBase.java
index 35f8678929b..7cf5f830fa1 100644
-- a/solr/core/src/java/org/apache/solr/handler/AnalysisRequestHandlerBase.java
++ b/solr/core/src/java/org/apache/solr/handler/AnalysisRequestHandlerBase.java
@@ -211,7 +211,7 @@ public abstract class AnalysisRequestHandlerBase extends RequestHandlerBase {
     final AttributeSource[] tokens = tokenList.toArray(new AttributeSource[tokenList.size()]);
     
     // sort the tokens by absoulte position
    ArrayUtil.mergeSort(tokens, new Comparator&lt;AttributeSource&gt;() {
    ArrayUtil.timSort(tokens, new Comparator&lt;AttributeSource&gt;() {
       @Override
       public int compare(AttributeSource a, AttributeSource b) {
         return arrayCompare(
- 
2.19.1.windows.1

</comment></unit>
