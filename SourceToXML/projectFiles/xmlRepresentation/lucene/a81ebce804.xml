<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" revision="1.0.0" language="Java" filename="E:/01Courses@USASK/CMPT898-HumanDrivenSoftwareEngineeringForScientificResearch/ProjectProgress/data_files/final_dataset/gen_patch_codes/filtered/lucene/a81ebce804.java"><expr_stmt><expr><name>From</name> <name>a81ebce804947685b86b50f7525335120fde38b4</name> <name>Mon</name> <name>Sep</name> <literal type="number">17</literal> <literal type="number">00</literal><operator>:</operator><literal type="number">00</literal><operator>:</operator><literal type="number">00</literal> <literal type="number">2001</literal>
<name>From</name><operator>:</operator> <name>Matt</name> <name><name>Weber</name> <argument_list type="generic">&lt;<argument><name>matt</name><annotation>@<name><name>mattweber</name><operator>.</operator><name>org</name></name></annotation></argument>&gt;</argument_list></name>
<name>Date</name><operator>:</operator> <name>Mon</name></expr><operator>,</operator> <expr><literal type="number">26</literal> <name>Dec</name> <literal type="number">2016</literal> <literal type="number">07</literal><operator>:</operator><literal type="number">50</literal><operator>:</operator><literal type="number">58</literal> <operator>-</operator><literal type="number">0800</literal>
<name>Subject</name><operator>:</operator> <index>[<expr><name>PATCH</name></expr>]</index> <name>Support</name> <name>Graph</name> <name>Token</name> <name>Streams</name> <name>in</name> <name>QueryBuilder</name>

<name>Adds</name> <name>support</name></expr></expr_stmt> <for>for handling graph token streams inside the
QueryBuilder util class used by query parsers.
--
 .../org/apache/lucene/search/GraphQuery.java  <operator>|</operator> 136 +++++++++++
 .../org/apache/lucene/util/QueryBuilder.java  <operator>|</operator> 113 +++++++--
 .../graph/GraphTokenStreamFiniteStrings.java  <operator>|</operator> 230 ++++++++++++++++++
 .../apache/lucene/search/TestGraphQuery.java  <operator>|</operator>  79 ++++++
 .../apache/lucene/util/TestQueryBuilder.java  <operator>|</operator>  15 +-
 .../TestGraphTokenStreamFiniteStrings.java    <operator>|</operator> 217 +++++++++++++++++
 .../queryparser/classic/QueryParserBase.java  <operator>|</operator>  42 +++-
 .../classic/TestMultiFieldQueryParser.java    <operator>|</operator>  11 +-
 .../queryparser/classic/TestQueryParser.java  <operator>|</operator> 131 +++++-----
 9 files changed<operator>,</operator> <expr_stmt><expr><literal type="number">877</literal> <call><name>insertions</name><argument_list>(<argument><expr><operator>+</operator></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><literal type="number">97</literal> <call><name>deletions</name><argument_list>(<argument><expr><operator>-</operator></expr></argument>)</argument_list></call>
 <name>create</name> <name>mode</name> <literal type="number">100644</literal> <name>lucene</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>search</name><operator>/</operator><name><name>GraphQuery</name><operator>.</operator><name>java</name></name>
 <name>create</name> <name>mode</name> <literal type="number">100644</literal> <name>lucene</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>util</name><operator>/</operator><name>graph</name><operator>/</operator><name><name>GraphTokenStreamFiniteStrings</name><operator>.</operator><name>java</name></name>
 <name>create</name> <name>mode</name> <literal type="number">100644</literal> <name>lucene</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>test</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>search</name><operator>/</operator><name><name>TestGraphQuery</name><operator>.</operator><name>java</name></name>
 <name>create</name> <name>mode</name> <literal type="number">100644</literal> <name>lucene</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>test</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>util</name><operator>/</operator><name>graph</name><operator>/</operator><name><name>TestGraphTokenStreamFiniteStrings</name><operator>.</operator><name>java</name></name>

<name>diff</name> <operator>--</operator><name>git</name> <name>a</name><operator>/</operator><name>lucene</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>search</name><operator>/</operator><name><name>GraphQuery</name><operator>.</operator><name>java</name></name> <name>b</name><operator>/</operator><name>lucene</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>search</name><operator>/</operator><name><name>GraphQuery</name><operator>.</operator><name>java</name></name>
<operator>new</operator> <name>file</name> <name>mode</name> <literal type="number">100644</literal>
<name>index</name> <literal type="number">00000000000..a1308c9cb4c</literal>
<operator>--</operator> <operator>/</operator><name>dev</name><operator>/</operator><literal type="null">null</literal>
<operator>++</operator> <name>b</name><operator>/</operator><name>lucene</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>search</name><operator>/</operator><name><name>GraphQuery</name><operator>.</operator><name>java</name></name>
@@ <operator>-</operator><literal type="number">0</literal></expr><operator>,</operator><expr><literal type="number">0</literal> <operator>+</operator><literal type="number">1</literal></expr><operator>,</operator><expr><literal type="number">136</literal> @@</expr></expr_stmt></for>
<comment type="block">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</comment>

<package>package <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>search</name></name>;</package>

<import>import <name><name>java</name><operator>.</operator><name>io</name><operator>.</operator><name>IOException</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>Arrays</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>Collections</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>List</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>Objects</name></name>;</import>

<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>index</name><operator>.</operator><name>IndexReader</name></name>;</import>

<comment type="block" format="javadoc">/**
 * A query that wraps multiple sub-queries generated from a graph token stream.
 */</comment>
<class><specifier>public</specifier> <specifier>final</specifier> class <name>GraphQuery</name> <super_list><extends>extends <super><name>Query</name></super></extends></super_list> <block>{
  <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name><name>Query</name><index>[]</index></name></type> <name>queries</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>private</specifier> <name>boolean</name></type> <name>hasBoolean</name> <init>= <expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>private</specifier> <name>boolean</name></type> <name>hasPhrase</name> <init>= <expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt>

  <comment type="block" format="javadoc">/**
   * Constructor sets the queries and checks if any of them are
   * a boolean query.
   *
   * @param queries the non-null array of queries
   */</comment>
  <constructor><specifier>public</specifier> <name>GraphQuery</name><parameter_list>(<parameter><decl><type><name>Query</name><modifier>...</modifier></type> <name>queries</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><name><name>this</name><operator>.</operator><name>queries</name></name> <operator>=</operator> <call><name><name>Objects</name><operator>.</operator><name>requireNonNull</name></name><argument_list>(<argument><expr><name>queries</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>clone</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><decl><type><name>Query</name></type> <name>query</name> <range>: <expr><name>queries</name></expr></range></decl></init>)</control> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>query</name> <operator>instanceof</operator> <name>BooleanQuery</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>hasBoolean</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
      </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>query</name> <operator>instanceof</operator> <name>PhraseQuery</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>hasPhrase</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
  </block_content>}</block></constructor>

  <comment type="block" format="javadoc">/**
   * Gets the queries
   *
   * @return unmodifiable list of Query
   */</comment>
  <function><type><specifier>public</specifier> <name><name>List</name><argument_list type="generic">&lt;<argument><name>Query</name></argument>&gt;</argument_list></name></type> <name>getQueries</name><parameter_list>()</parameter_list> <block>{<block_content>
    <return>return <expr><call><name><name>Collections</name><operator>.</operator><name>unmodifiableList</name></name><argument_list>(<argument><expr><call><name><name>Arrays</name><operator>.</operator><name>asList</name></name><argument_list>(<argument><expr><name>queries</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></function>

  <comment type="block" format="javadoc">/**
   * If there is at least one boolean query or not.
   *
   * @return true if there is a boolean, false if not
   */</comment>
  <function><type><specifier>public</specifier> <name>boolean</name></type> <name>hasBoolean</name><parameter_list>()</parameter_list> <block>{<block_content>
    <return>return <expr><name>hasBoolean</name></expr>;</return>
  </block_content>}</block></function>

  <comment type="block" format="javadoc">/**
   * If there is at least one phrase query or not.
   *
   * @return true if there is a phrase query, false if not
   */</comment>
  <function><type><specifier>public</specifier> <name>boolean</name></type> <name>hasPhrase</name><parameter_list>()</parameter_list> <block>{<block_content>
    <return>return <expr><name>hasPhrase</name></expr>;</return>
  </block_content>}</block></function>

  <comment type="block" format="javadoc">/**
   * Rewrites to a single query or a boolean query where each query is a SHOULD clause.
   */</comment>
  <function><annotation>@<name>Override</name></annotation>
  <type><specifier>public</specifier> <name>Query</name></type> <name>rewrite</name><parameter_list>(<parameter><decl><type><name>IndexReader</name></type> <name>reader</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>queries</name><operator>.</operator><name>length</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <return>return <expr><operator>new</operator> <call><name><name>BooleanQuery</name><operator>.</operator><name>Builder</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>build</name><argument_list>()</argument_list></call></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>queries</name><operator>.</operator><name>length</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
      <return>return <expr><name><name>queries</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <decl_stmt><decl><type><name><name>BooleanQuery</name><operator>.</operator><name>Builder</name></name></type> <name>q</name> <init>= <expr><operator>new</operator> <call><name><name>BooleanQuery</name><operator>.</operator><name>Builder</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <for>for <control>(<init><decl><type><name>Query</name></type> <name>clause</name> <range>: <expr><name>queries</name></expr></range></decl></init>)</control> <block>{<block_content>
      <expr_stmt><expr><call><name><name>q</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name>clause</name></expr></argument>, <argument><expr><name><name>BooleanClause</name><operator>.</operator><name>Occur</name><operator>.</operator><name>SHOULD</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <return>return <expr><call><name><name>q</name><operator>.</operator><name>build</name></name><argument_list>()</argument_list></call></expr>;</return>
  </block_content>}</block></function>

  <function><annotation>@<name>Override</name></annotation>
  <type><specifier>public</specifier> <name>String</name></type> <name>toString</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>field</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>StringBuilder</name></type> <name>builder</name> <init>= <expr><operator>new</operator> <call><name>StringBuilder</name><argument_list>(<argument><expr><literal type="string">"Graph("</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>queries</name><operator>.</operator><name>length</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>i</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name><name>builder</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name><name>builder</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><call><name><name>Objects</name><operator>.</operator><name>toString</name></name><argument_list>(<argument><expr><name><name>queries</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <if_stmt><if>if <condition>(<expr><name><name>queries</name><operator>.</operator><name>length</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name><name>builder</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name><name>builder</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><literal type="string">"hasBoolean="</literal></expr></argument>)</argument_list></call>
        <operator>.</operator><call><name>append</name><argument_list>(<argument><expr><name>hasBoolean</name></expr></argument>)</argument_list></call>
        <operator>.</operator><call><name>append</name><argument_list>(<argument><expr><literal type="string">", hasPhrase="</literal></expr></argument>)</argument_list></call>
        <operator>.</operator><call><name>append</name><argument_list>(<argument><expr><name>hasPhrase</name></expr></argument>)</argument_list></call>
        <operator>.</operator><call><name>append</name><argument_list>(<argument><expr><literal type="string">")"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><call><name><name>builder</name><operator>.</operator><name>toString</name></name><argument_list>()</argument_list></call></expr>;</return>
  </block_content>}</block></function>

  <function><annotation>@<name>Override</name></annotation>
  <type><specifier>public</specifier> <name>boolean</name></type> <name>equals</name><parameter_list>(<parameter><decl><type><name>Object</name></type> <name>other</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <return>return <expr><call><name>sameClassAs</name><argument_list>(<argument><expr><name>other</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
        <name>hasBoolean</name> <operator>==</operator> <operator>(</operator><operator>(</operator><name>GraphQuery</name><operator>)</operator> <name>other</name><operator>)</operator><operator>.</operator><name>hasBoolean</name> <operator>&amp;&amp;</operator>
        <name>hasPhrase</name> <operator>==</operator> <operator>(</operator><operator>(</operator><name>GraphQuery</name><operator>)</operator> <name>other</name><operator>)</operator><operator>.</operator><name>hasPhrase</name> <operator>&amp;&amp;</operator>
        <call><name><name>Arrays</name><operator>.</operator><name>equals</name></name><argument_list>(<argument><expr><name>queries</name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>GraphQuery</name><operator>)</operator> <name>other</name><operator>)</operator><operator>.</operator><name>queries</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></function>

  <function><annotation>@<name>Override</name></annotation>
  <type><specifier>public</specifier> <name>int</name></type> <name>hashCode</name><parameter_list>()</parameter_list> <block>{<block_content>
    <return>return <expr><literal type="number">31</literal> <operator>*</operator> <call><name>classHash</name><argument_list>()</argument_list></call> <operator>+</operator> <call><name><name>Arrays</name><operator>.</operator><name>deepHashCode</name></name><argument_list>(<argument><expr><operator>new</operator> <name><name>Object</name><index>[]</index></name><block>{<expr><name>hasBoolean</name></expr>, <expr><name>hasPhrase</name></expr>, <expr><name>queries</name></expr>}</block></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></function>
}</block></class>
<expr_stmt><expr><operator>\</operator> <name>No</name> <name>newline</name> <name>at</name> <name>end</name> <name>of</name> <name>file</name>
<name>diff</name> <operator>--</operator><name>git</name> <name>a</name><operator>/</operator><name>lucene</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>util</name><operator>/</operator><name><name>QueryBuilder</name><operator>.</operator><name>java</name></name> <name>b</name><operator>/</operator><name>lucene</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>util</name><operator>/</operator><name><name>QueryBuilder</name><operator>.</operator><name>java</name></name>
<name>index</name> <literal type="number">6c5ea15aac5</literal><operator>..</operator><name>a8c0a82e156</name> <literal type="number">100644</literal>
<operator>--</operator> <name>a</name><operator>/</operator><name>lucene</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>util</name><operator>/</operator><name><name>QueryBuilder</name><operator>.</operator><name>java</name></name>
<operator>++</operator> <name>b</name><operator>/</operator><name>lucene</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>util</name><operator>/</operator><name><name>QueryBuilder</name><operator>.</operator><name>java</name></name>
@@ <operator>-</operator><literal type="number">25</literal></expr><operator>,</operator><expr><literal type="number">15</literal> <operator>+</operator><literal type="number">25</literal></expr><operator>,</operator><expr><literal type="number">18</literal> @@</expr></expr_stmt> <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>analysis</name><operator>.</operator><name>Analyzer</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>analysis</name><operator>.</operator><name>CachingTokenFilter</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>analysis</name><operator>.</operator><name>TokenStream</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>analysis</name><operator>.</operator><name>tokenattributes</name><operator>.</operator><name>PositionIncrementAttribute</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>analysis</name><operator>.</operator><name>tokenattributes</name><operator>.</operator><name>PositionLengthAttribute</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>analysis</name><operator>.</operator><name>tokenattributes</name><operator>.</operator><name>TermToBytesRefAttribute</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>index</name><operator>.</operator><name>Term</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>search</name><operator>.</operator><name>BooleanClause</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>search</name><operator>.</operator><name>BooleanQuery</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>search</name><operator>.</operator><name>GraphQuery</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>search</name><operator>.</operator><name>MultiPhraseQuery</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>search</name><operator>.</operator><name>PhraseQuery</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>search</name><operator>.</operator><name>Query</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>search</name><operator>.</operator><name>SynonymQuery</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>search</name><operator>.</operator><name>TermQuery</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>util</name><operator>.</operator><name>graph</name><operator>.</operator><name>GraphTokenStreamFiniteStrings</name></name>;</import>
 
 <comment type="block" format="javadoc">/**
  * Creates queries from the {@link Analyzer} chain.
@@ -135,17 +138,39 @@ public class QueryBuilder {
     
     Query query = createFieldQuery(analyzer, BooleanClause.Occur.SHOULD, field, queryText, false, 0);
     if (query instanceof BooleanQuery) {
      BooleanQuery bq = (BooleanQuery) query;
      BooleanQuery.Builder builder = new BooleanQuery.Builder();
      builder.setMinimumNumberShouldMatch((int) (fraction * bq.clauses().size()));
      for (BooleanClause clause : bq) {
        builder.add(clause);
      query = addMinShouldMatchToBoolean((BooleanQuery) query, fraction);
    } else if (query instanceof GraphQuery &amp;&amp; ((GraphQuery) query).hasBoolean()) {
      // we have a graph query that has at least one boolean sub-query
      // re-build and set minimum should match on each boolean found
      List&lt;Query&gt; oldQueries = ((GraphQuery) query).getQueries();
      Query[] queries = new Query[oldQueries.size()];
      for (int i = 0; i &lt; queries.length; i++) {
        Query oldQuery = oldQueries.get(i);
        if (oldQuery instanceof BooleanQuery) {
          queries[i] = addMinShouldMatchToBoolean((BooleanQuery) oldQuery, fraction);
        } else {
          queries[i] = oldQuery;
        }
       }
      query = builder.build();

      query = new GraphQuery(queries);
     }
     return query;
   }
  

  /**
   * Rebuilds a boolean query and sets a new minimum number should match value.
   */</comment>
  <function><type><specifier>private</specifier> <name>BooleanQuery</name></type> <name>addMinShouldMatchToBoolean</name><parameter_list>(<parameter><decl><type><name>BooleanQuery</name></type> <name>query</name></decl></parameter>, <parameter><decl><type><name>float</name></type> <name>fraction</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name><name>BooleanQuery</name><operator>.</operator><name>Builder</name></name></type> <name>builder</name> <init>= <expr><operator>new</operator> <call><name><name>BooleanQuery</name><operator>.</operator><name>Builder</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>builder</name><operator>.</operator><name>setMinimumNumberShouldMatch</name></name><argument_list>(<argument><expr><operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><name>fraction</name> <operator>*</operator> <call><name><name>query</name><operator>.</operator><name>clauses</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>size</name><argument_list>()</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><decl><type><name>BooleanClause</name></type> <name>clause</name> <range>: <expr><name>query</name></expr></range></decl></init>)</control> <block>{<block_content>
      <expr_stmt><expr><call><name><name>builder</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <return>return <expr><call><name><name>builder</name><operator>.</operator><name>build</name></name><argument_list>()</argument_list></call></expr>;</return>
  </block_content>}</block></function>

   <comment type="block" format="javadoc">/** 
    * Returns the analyzer. 
    * @see #setAnalyzer(Analyzer)
@@ -183,6 +208,7 @@ public class QueryBuilder {
     this.enablePositionIncrements = enable;
   }
 

   /**
    * Creates a query from the analysis chain.
    * &lt;p&gt;
@@ -192,25 +218,44 @@ public class QueryBuilder {
    * it is usually not necessary to override it in a subclass; instead, override
    * methods like {@link #newBooleanQuery}, etc., if possible.
    *
   * @param analyzer analyzer used for this query
   * @param operator default boolean operator used for this query
   * @param field field to create queries against
   * @param queryText text to be passed to the analysis chain
   * @param quoted true if phrases should be generated when terms occur at more than one position
   * @param analyzer   analyzer used for this query
   * @param operator   default boolean operator used for this query
   * @param field      field to create queries against
   * @param queryText  text to be passed to the analysis chain
   * @param quoted     true if phrases should be generated when terms occur at more than one position
    * @param phraseSlop slop factor for phrase/multiphrase queries
    */</comment>
   <function><type><specifier>protected</specifier> <name>Query</name></type> <name>createFieldQuery</name><parameter_list>(<parameter><decl><type><name>Analyzer</name></type> <name>analyzer</name></decl></parameter>, <parameter><decl><type><name><name>BooleanClause</name><operator>.</operator><name>Occur</name></name></type> <name>operator</name></decl></parameter>, <parameter><decl><type><name>String</name></type> <name>field</name></decl></parameter>, <parameter><decl><type><name>String</name></type> <name>queryText</name></decl></parameter>, <parameter><decl><type><name>boolean</name></type> <name>quoted</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>phraseSlop</name></decl></parameter>)</parameter_list> <block>{<block_content>
     <assert>assert <expr><name>operator</name> <operator>==</operator> <name><name>BooleanClause</name><operator>.</operator><name>Occur</name><operator>.</operator><name>SHOULD</name></name> <operator>||</operator> <name>operator</name> <operator>==</operator> <name><name>BooleanClause</name><operator>.</operator><name>Occur</name><operator>.</operator><name>MUST</name></name></expr>;</assert>
    

     <comment type="line">// Use the analyzer to get all the tokens, and then build an appropriate</comment>
     <comment type="line">// query based on the analysis chain.</comment>
    
    <try>try <init>(<decl><type><name>TokenStream</name></type> <name>source</name> <init>= <expr><call><name><name>analyzer</name><operator>.</operator><name>tokenStream</name></name><argument_list>(<argument><expr><name>field</name></expr></argument>, <argument><expr><name>queryText</name></expr></argument>)</argument_list></call></expr></init></decl>;
         <decl><type><name>CachingTokenFilter</name></type> <name>stream</name> <init>= <expr><operator>new</operator> <call><name>CachingTokenFilter</name><argument_list>(<argument><expr><name>source</name></expr></argument>)</argument_list></call></expr></init></decl>)</init> <block>{<block_content>
    <try>try <init>(<decl><type><name>TokenStream</name></type> <name>source</name> <init>= <expr><call><name><name>analyzer</name><operator>.</operator><name>tokenStream</name></name><argument_list>(<argument><expr><name>field</name></expr></argument>, <argument><expr><name>queryText</name></expr></argument>)</argument_list></call></expr></init></decl>)</init> <block>{<block_content>
      <return>return <expr><call><name>createFieldQuery</name><argument_list>(<argument><expr><name>source</name></expr></argument>, <argument><expr><name>operator</name></expr></argument>, <argument><expr><name>field</name></expr></argument>, <argument><expr><name>quoted</name></expr></argument>, <argument><expr><name>phraseSlop</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block> <catch>catch <parameter_list>(<parameter><decl><type><name>IOException</name></type> <name>e</name></decl></parameter>)</parameter_list> <block>{<block_content>
      <throw>throw <expr><operator>new</operator> <call><name>RuntimeException</name><argument_list>(<argument><expr><literal type="string">"Error analyzing query text"</literal></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</throw>
    </block_content>}</block></catch></try>
  </block_content>}</block></try>

  <comment type="block" format="javadoc">/**
   * Creates a query from a token stream.
   *
   * @param source     the token stream to create the query from
   * @param operator   default boolean operator used for this query
   * @param field      field to create queries against
   * @param quoted     true if phrases should be generated when terms occur at more than one position
   * @param phraseSlop slop factor for phrase/multiphrase queries
   */</comment>
  <function><type><specifier>protected</specifier> <name>Query</name></type> <name>createFieldQuery</name><parameter_list>(<parameter><decl><type><name>TokenStream</name></type> <name>source</name></decl></parameter>, <parameter><decl><type><name><name>BooleanClause</name><operator>.</operator><name>Occur</name></name></type> <name>operator</name></decl></parameter>, <parameter><decl><type><name>String</name></type> <name>field</name></decl></parameter>, <parameter><decl><type><name>boolean</name></type> <name>quoted</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>phraseSlop</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <assert>assert <expr><name>operator</name> <operator>==</operator> <name><name>BooleanClause</name><operator>.</operator><name>Occur</name><operator>.</operator><name>SHOULD</name></name> <operator>||</operator> <name>operator</name> <operator>==</operator> <name><name>BooleanClause</name><operator>.</operator><name>Occur</name><operator>.</operator><name>MUST</name></name></expr>;</assert>

    <comment type="line">// Build an appropriate query based on the analysis chain.</comment>
    <try>try <init>(<decl><type><name>CachingTokenFilter</name></type> <name>stream</name> <init>= <expr><operator>new</operator> <call><name>CachingTokenFilter</name><argument_list>(<argument><expr><name>source</name></expr></argument>)</argument_list></call></expr></init></decl>)</init> <block>{<block_content>
       
       <decl_stmt><decl><type><name>TermToBytesRefAttribute</name></type> <name>termAtt</name> <init>= <expr><call><name><name>stream</name><operator>.</operator><name>getAttribute</name></name><argument_list>(<argument><expr><name><name>TermToBytesRefAttribute</name><operator>.</operator><name>class</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
       <decl_stmt><decl><type><name>PositionIncrementAttribute</name></type> <name>posIncAtt</name> <init>= <expr><call><name><name>stream</name><operator>.</operator><name>addAttribute</name></name><argument_list>(<argument><expr><name><name>PositionIncrementAttribute</name><operator>.</operator><name>class</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      
      <decl_stmt><decl><type><name>PositionLengthAttribute</name></type> <name>posLenAtt</name> <init>= <expr><call><name><name>stream</name><operator>.</operator><name>addAttribute</name></name><argument_list>(<argument><expr><name><name>PositionLengthAttribute</name><operator>.</operator><name>class</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

       <if_stmt><if>if <condition>(<expr><name>termAtt</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
         <return>return <expr><literal type="null">null</literal></expr>;</return> 
       </block_content>}</block></if></if_stmt>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">221</literal></expr><operator>,</operator><expr><literal type="number">6</literal> <operator>+</operator><literal type="number">266</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@ <specifier>public</specifier> <name>class</name> <name>QueryBuilder</name> <block>{
       <expr><name>int</name> <name>numTokens</name> <operator>=</operator> <literal type="number">0</literal></expr>;
       <expr><name>int</name> <name>positionCount</name> <operator>=</operator> <literal type="number">0</literal></expr>;
       <expr><name>boolean</name> <name>hasSynonyms</name> <operator>=</operator> <literal type="boolean">false</literal></expr>;
      <expr><name>boolean</name> <name>isGraph</name> <operator>=</operator> <literal type="boolean">false</literal></expr>;
 
       <expr><call><name><name>stream</name><operator>.</operator><name>reset</name></name><argument_list>()</argument_list></call></expr>;
       <while>while <condition>(<expr><call><name><name>stream</name><operator>.</operator><name>incrementToken</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">231</literal></expr><operator>,</operator><expr><literal type="number">6</literal> <operator>+</operator><literal type="number">277</literal></expr><operator>,</operator><expr><literal type="number">11</literal> @@ <specifier>public</specifier> <name>class</name> <name>QueryBuilder</name> <block>{
         }</block></expr></expr_stmt> <if_stmt><else>else <block>{<block_content>
           <expr_stmt><expr><name>hasSynonyms</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
         <expr_stmt/></block_content></block></else></if_stmt></block_content></block></while>}</block>

        <name>int</name> <name>positionLength</name> <operator>=</operator> <call><name><name>posLenAtt</name><operator>.</operator><name>getPositionLength</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>isGraph</name> <operator>&amp;&amp;</operator> <name>positionLength</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><name>isGraph</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
       </block_content>}</block></try>
       
       <comment type="line">// phase 2: based on token count, presence of synonyms, and options</comment>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">241</literal></expr><operator>,</operator><expr><literal type="number">6</literal> <operator>+</operator><literal type="number">292</literal></expr><operator>,</operator><expr><literal type="number">9</literal> @@ <specifier>public</specifier> <name>class</name> <name>QueryBuilder</name> <block>{
       }</block></expr></expr_stmt> <if_stmt><if type="elseif">else if <condition>(<expr><name>numTokens</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
         <comment type="line">// single term</comment>
         <return>return <expr><call><name>analyzeTerm</name><argument_list>(<argument><expr><name>field</name></expr></argument>, <argument><expr><name>stream</name></expr></argument>)</argument_list></call></expr>;</return>
      </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>isGraph</name></expr>)</condition> <block>{<block_content>
        <comment type="line">// graph</comment>
        <return>return <expr><call><name>analyzeGraph</name><argument_list>(<argument><expr><name>stream</name></expr></argument>, <argument><expr><name>operator</name></expr></argument>, <argument><expr><name>field</name></expr></argument>, <argument><expr><name>quoted</name></expr></argument>, <argument><expr><name>phraseSlop</name></expr></argument>)</argument_list></call></expr>;</return>
       </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>quoted</name> <operator>&amp;&amp;</operator> <name>positionCount</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
         <comment type="line">// phrase</comment>
         <if_stmt><if>if <condition>(<expr><name>hasSynonyms</name></expr>)</condition> <block>{<block_content>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">388</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">442</literal></expr><operator>,</operator><expr><literal type="number">30</literal> @@ <specifier>public</specifier> <name>class</name> <name>QueryBuilder</name> <block>{
     }</block></expr></expr_stmt>
     <return>return <expr><call><name><name>mpqb</name><operator>.</operator><name>build</name></name><argument_list>()</argument_list></call></expr>;</return>
   </block_content>}</block></if></if_stmt>
  

  <comment type="block" format="javadoc">/**
   * Creates a query from a graph token stream by extracting all the finite strings from the graph and using them to create the query.
   */</comment>
  <function><type><specifier>protected</specifier> <name>Query</name></type> <name>analyzeGraph</name><parameter_list>(<parameter><decl><type><name>TokenStream</name></type> <name>source</name></decl></parameter>, <parameter><decl><type><name><name>BooleanClause</name><operator>.</operator><name>Occur</name></name></type> <name>operator</name></decl></parameter>, <parameter><decl><type><name>String</name></type> <name>field</name></decl></parameter>, <parameter><decl><type><name>boolean</name></type> <name>quoted</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>phraseSlop</name></decl></parameter>)</parameter_list>
      <throws>throws <argument><expr><name>IOException</name></expr></argument></throws> <block>{<block_content>
    <expr_stmt><expr><call><name><name>source</name><operator>.</operator><name>reset</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name>TokenStream</name></argument>&gt;</argument_list></name></type> <name>tokenStreams</name> <init>= <expr><call><name><name>GraphTokenStreamFiniteStrings</name><operator>.</operator><name>getTokenStreams</name></name><argument_list>(<argument><expr><name>source</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name><name>tokenStreams</name><operator>.</operator><name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
      <return>return <expr><literal type="null">null</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <decl_stmt><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name>Query</name></argument>&gt;</argument_list></name></type> <name>queries</name> <init>= <expr><operator>new</operator> <call><name><name>ArrayList</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>tokenStreams</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <for>for <control>(<init><decl><type><name>TokenStream</name></type> <name>ts</name> <range>: <expr><name>tokenStreams</name></expr></range></decl></init>)</control> <block>{<block_content>
      <decl_stmt><decl><type><name>Query</name></type> <name>query</name> <init>= <expr><call><name>createFieldQuery</name><argument_list>(<argument><expr><name>ts</name></expr></argument>, <argument><expr><name>operator</name></expr></argument>, <argument><expr><name>field</name></expr></argument>, <argument><expr><name>quoted</name></expr></argument>, <argument><expr><name>phraseSlop</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><name>query</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name><name>queries</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <return>return <expr><operator>new</operator> <call><name>GraphQuery</name><argument_list>(<argument><expr><call><name><name>queries</name><operator>.</operator><name>toArray</name></name><argument_list>(<argument><expr><operator>new</operator> <name><name>Query</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></function>

   <comment type="block" format="javadoc">/**
    * Builds a new BooleanQuery instance.
    * &lt;p&gt;
diff --git a/lucene/core/src/java/org/apache/lucene/util/graph/GraphTokenStreamFiniteStrings.java b/lucene/core/src/java/org/apache/lucene/util/graph/GraphTokenStreamFiniteStrings.java
new file mode 100644
index 00000000000..cec65fadfad
-- /dev/null
++ b/lucene/core/src/java/org/apache/lucene/util/graph/GraphTokenStreamFiniteStrings.java
@@ -0,0 +1,230 @@
/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</comment>

<package>package <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>util</name><operator>.</operator><name>graph</name></name>;</package>

<import>import <name><name>java</name><operator>.</operator><name>io</name><operator>.</operator><name>IOException</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>ArrayList</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>HashMap</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>List</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>Map</name></name>;</import>

<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>analysis</name><operator>.</operator><name>TokenStream</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>analysis</name><operator>.</operator><name>tokenattributes</name><operator>.</operator><name>BytesTermAttribute</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>analysis</name><operator>.</operator><name>tokenattributes</name><operator>.</operator><name>PositionIncrementAttribute</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>analysis</name><operator>.</operator><name>tokenattributes</name><operator>.</operator><name>PositionLengthAttribute</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>analysis</name><operator>.</operator><name>tokenattributes</name><operator>.</operator><name>TermToBytesRefAttribute</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>util</name><operator>.</operator><name>BytesRef</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>util</name><operator>.</operator><name>IntsRef</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>util</name><operator>.</operator><name>automaton</name><operator>.</operator><name>Automaton</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>util</name><operator>.</operator><name>automaton</name><operator>.</operator><name>FiniteStringsIterator</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>util</name><operator>.</operator><name>automaton</name><operator>.</operator><name>Operations</name></name>;</import>

<import>import static <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>util</name><operator>.</operator><name>automaton</name><operator>.</operator><name>Operations</name><operator>.</operator><name>DEFAULT_MAX_DETERMINIZED_STATES</name></name>;</import>

<comment type="block" format="javadoc">/**
 * Creates a list of {@link TokenStream} where each stream is the tokens that make up a finite string in graph token stream.  To do this,
 * the graph token stream is converted to an {@link Automaton} and from there we use a {@link FiniteStringsIterator} to collect the various
 * token streams for each finite string.
 */</comment>
<class><specifier>public</specifier> <specifier>final</specifier> class <name>GraphTokenStreamFiniteStrings</name> <block>{
  <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name><name>Automaton</name><operator>.</operator><name>Builder</name></name></type> <name>builder</name> <init>= <expr><operator>new</operator> <call><name><name>Automaton</name><operator>.</operator><name>Builder</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name><name>Map</name><argument_list type="generic">&lt;<argument><name>BytesRef</name></argument>, <argument><name>Integer</name></argument>&gt;</argument_list></name></type> <name>termToID</name> <init>= <expr><operator>new</operator> <call><name><name>HashMap</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name><name>Map</name><argument_list type="generic">&lt;<argument><name>Integer</name></argument>, <argument><name>BytesRef</name></argument>&gt;</argument_list></name></type> <name>idToTerm</name> <init>= <expr><operator>new</operator> <call><name><name>HashMap</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name><name>Map</name><argument_list type="generic">&lt;<argument><name>Integer</name></argument>, <argument><name>Integer</name></argument>&gt;</argument_list></name></type> <name>idToInc</name> <init>= <expr><operator>new</operator> <call><name><name>HashMap</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>private</specifier> <name>Automaton</name></type> <name>det</name></decl>;</decl_stmt>

  <class><specifier>private</specifier> class <name>FiniteStringsTokenStream</name> <super_list><extends>extends <super><name>TokenStream</name></super></extends></super_list> <block>{
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>BytesTermAttribute</name></type> <name>termAtt</name> <init>= <expr><call><name>addAttribute</name><argument_list>(<argument><expr><name><name>BytesTermAttribute</name><operator>.</operator><name>class</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>PositionIncrementAttribute</name></type> <name>posIncAtt</name> <init>= <expr><call><name>addAttribute</name><argument_list>(<argument><expr><name><name>PositionIncrementAttribute</name><operator>.</operator><name>class</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>IntsRef</name></type> <name>ids</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>int</name></type> <name>end</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name>int</name></type> <name>offset</name></decl>;</decl_stmt>

    <constructor><name>FiniteStringsTokenStream</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>IntsRef</name></type> <name>ids</name></decl></parameter>)</parameter_list> <block>{<block_content>
      <assert>assert <expr><name>ids</name> <operator>!=</operator> <literal type="null">null</literal></expr>;</assert>
      <expr_stmt><expr><name><name>this</name><operator>.</operator><name>ids</name></name> <operator>=</operator> <name>ids</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>this</name><operator>.</operator><name>offset</name></name> <operator>=</operator> <name><name>ids</name><operator>.</operator><name>offset</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>this</name><operator>.</operator><name>end</name></name> <operator>=</operator> <name><name>ids</name><operator>.</operator><name>offset</name></name> <operator>+</operator> <name><name>ids</name><operator>.</operator><name>length</name></name></expr>;</expr_stmt>
    </block_content>}</block></constructor>

    <function><annotation>@<name>Override</name></annotation>
    <type><specifier>public</specifier> <name>boolean</name></type> <name>incrementToken</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>offset</name> <operator>&lt;</operator> <name>end</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>clearAttributes</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>id</name> <init>= <expr><name><name>ids</name><operator>.</operator><name>ints</name><index>[<expr><name>offset</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>termAtt</name><operator>.</operator><name>setBytesRef</name></name><argument_list>(<argument><expr><call><name><name>idToTerm</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <decl_stmt><decl><type><name>int</name></type> <name>incr</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><call><name><name>idToInc</name><operator>.</operator><name>containsKey</name></name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><name>incr</name> <operator>=</operator> <call><name><name>idToInc</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name><name>posIncAtt</name><operator>.</operator><name>setPositionIncrement</name></name><argument_list>(<argument><expr><name>incr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>offset</name><operator>++</operator></expr>;</expr_stmt>
        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
      </block_content>}</block></if></if_stmt>

      <return>return <expr><literal type="boolean">false</literal></expr>;</return>
    </block_content>}</block></function>
  }</block></class>

  <constructor><specifier>private</specifier> <name>GraphTokenStreamFiniteStrings</name><parameter_list>()</parameter_list> <block>{<block_content>
  </block_content>}</block></constructor>

  <comment type="block" format="javadoc">/**
   * Gets the list of finite string token streams from the given input graph token stream.
   */</comment>
  <function><type><specifier>public</specifier> <specifier>static</specifier> <name><name>List</name><argument_list type="generic">&lt;<argument><name>TokenStream</name></argument>&gt;</argument_list></name></type> <name>getTokenStreams</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>TokenStream</name></type> <name>in</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws> <block>{<block_content>
    <decl_stmt><decl><type><name>GraphTokenStreamFiniteStrings</name></type> <name>gfs</name> <init>= <expr><operator>new</operator> <call><name>GraphTokenStreamFiniteStrings</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <return>return <expr><call><name><name>gfs</name><operator>.</operator><name>process</name></name><argument_list>(<argument><expr><name>in</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></function>

  <comment type="block" format="javadoc">/**
   * Builds automaton and builds the finite string token streams.
   */</comment>
  <function><type><specifier>private</specifier> <name><name>List</name><argument_list type="generic">&lt;<argument><name>TokenStream</name></argument>&gt;</argument_list></name></type> <name>process</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>TokenStream</name></type> <name>in</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws> <block>{<block_content>
    <expr_stmt><expr><call><name>build</name><argument_list>(<argument><expr><name>in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name>TokenStream</name></argument>&gt;</argument_list></name></type> <name>tokenStreams</name> <init>= <expr><operator>new</operator> <call><name><name>ArrayList</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>final</specifier> <name>FiniteStringsIterator</name></type> <name>finiteStrings</name> <init>= <expr><operator>new</operator> <call><name>FiniteStringsIterator</name><argument_list>(<argument><expr><name>det</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <for>for <control>(<init><decl><type><name>IntsRef</name></type> <name>ids</name></decl>;</init> <condition><expr><operator>(</operator><name>ids</name> <operator>=</operator> <call><name><name>finiteStrings</name><operator>.</operator><name>next</name></name><argument_list>()</argument_list></call><operator>)</operator> <operator>!=</operator> <literal type="null">null</literal></expr>;</condition> <incr/>)</control> <block>{<block_content>
      <expr_stmt><expr><call><name><name>tokenStreams</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><operator>new</operator> <call><name>FiniteStringsTokenStream</name><argument_list>(<argument><expr><call><name><name>IntsRef</name><operator>.</operator><name>deepCopyOf</name></name><argument_list>(<argument><expr><name>ids</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <return>return <expr><name>tokenStreams</name></expr>;</return>
  </block_content>}</block></function>

  <function><type><specifier>private</specifier> <name>void</name></type> <name>build</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>TokenStream</name></type> <name>in</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>det</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
      <throw>throw <expr><operator>new</operator> <call><name>IllegalStateException</name><argument_list>(<argument><expr><literal type="string">"Automation already built"</literal></expr></argument>)</argument_list></call></expr>;</throw>
    </block_content>}</block></if></if_stmt>

    <decl_stmt><decl><type><specifier>final</specifier> <name>TermToBytesRefAttribute</name></type> <name>termBytesAtt</name> <init>= <expr><call><name><name>in</name><operator>.</operator><name>addAttribute</name></name><argument_list>(<argument><expr><name><name>TermToBytesRefAttribute</name><operator>.</operator><name>class</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>final</specifier> <name>PositionIncrementAttribute</name></type> <name>posIncAtt</name> <init>= <expr><call><name><name>in</name><operator>.</operator><name>addAttribute</name></name><argument_list>(<argument><expr><name><name>PositionIncrementAttribute</name><operator>.</operator><name>class</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>final</specifier> <name>PositionLengthAttribute</name></type> <name>posLengthAtt</name> <init>= <expr><call><name><name>in</name><operator>.</operator><name>addAttribute</name></name><argument_list>(<argument><expr><name><name>PositionLengthAttribute</name><operator>.</operator><name>class</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name><name>in</name><operator>.</operator><name>reset</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>int</name></type> <name>pos</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>prevIncr</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>state</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <while>while <condition>(<expr><call><name><name>in</name><operator>.</operator><name>incrementToken</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>currentIncr</name> <init>= <expr><call><name><name>posIncAtt</name><operator>.</operator><name>getPositionIncrement</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><name>pos</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>currentIncr</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <throw>throw <expr><operator>new</operator> <call><name>IllegalStateException</name><argument_list>(<argument><expr><literal type="string">"Malformed TokenStream, start token can't have increment less than 1"</literal></expr></argument>)</argument_list></call></expr>;</throw>
      </block_content>}</block></if></if_stmt>

      <comment type="line">// always use inc 1 while building, but save original increment</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>incr</name> <init>= <expr><call><name><name>Math</name><operator>.</operator><name>min</name></name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>currentIncr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><name>incr</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>pos</name> <operator>+=</operator> <name>incr</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>

      <decl_stmt><decl><type><name>int</name></type> <name>endPos</name> <init>= <expr><name>pos</name> <operator>+</operator> <call><name><name>posLengthAtt</name><operator>.</operator><name>getPositionLength</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
      <while>while <condition>(<expr><name>state</name> <operator>&lt;</operator> <name>endPos</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>state</name> <operator>=</operator> <call><name>createState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></while>

      <decl_stmt><decl><type><name>BytesRef</name></type> <name>term</name> <init>= <expr><call><name><name>termBytesAtt</name><operator>.</operator><name>getBytesRef</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>id</name> <init>= <expr><call><name>getTermID</name><argument_list>(<argument><expr><name>currentIncr</name></expr></argument>, <argument><expr><name>prevIncr</name></expr></argument>, <argument><expr><name>term</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>addTransition</name><argument_list>(<argument><expr><name>pos</name></expr></argument>, <argument><expr><name>endPos</name></expr></argument>, <argument><expr><name>currentIncr</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="line">// only save last increment on non-zero increment in case we have multiple stacked tokens</comment>
      <if_stmt><if>if <condition>(<expr><name>currentIncr</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>prevIncr</name> <operator>=</operator> <name>currentIncr</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>

    <expr_stmt><expr><call><name><name>in</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>setAccept</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>finish</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></function>

  <comment type="block" format="javadoc">/**
   * Returns a new state; state 0 is always the initial state.
   */</comment>
  <function><type><specifier>private</specifier> <name>int</name></type> <name>createState</name><parameter_list>()</parameter_list> <block>{<block_content>
    <return>return <expr><call><name><name>builder</name><operator>.</operator><name>createState</name></name><argument_list>()</argument_list></call></expr>;</return>
  </block_content>}</block></function>

  <comment type="block" format="javadoc">/**
   * Marks the specified state as accept or not.
   */</comment>
  <function><type><specifier>private</specifier> <name>void</name></type> <name>setAccept</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>state</name></decl></parameter>, <parameter><decl><type><name>boolean</name></type> <name>accept</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name><name>builder</name><operator>.</operator><name>setAccept</name></name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>accept</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></function>

  <comment type="block" format="javadoc">/**
   * Adds a transition to the automaton.
   */</comment>
  <function><type><specifier>private</specifier> <name>void</name></type> <name>addTransition</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>source</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>dest</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>incr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>id</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name><name>builder</name><operator>.</operator><name>addTransition</name></name><argument_list>(<argument><expr><name>source</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></function>

  <comment type="block" format="javadoc">/**
   * Call this once you are done adding states/transitions.
   */</comment>
  <function><type><specifier>private</specifier> <name>void</name></type> <name>finish</name><parameter_list>()</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>finish</name><argument_list>(<argument><expr><name>DEFAULT_MAX_DETERMINIZED_STATES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></function>

  <comment type="block" format="javadoc">/**
   * Call this once you are done adding states/transitions.
   *
   * @param maxDeterminizedStates Maximum number of states created when determinizing the automaton.  Higher numbers allow this operation
   *                              to consume more memory but allow more complex automatons.
   */</comment>
  <function><type><specifier>private</specifier> <name>void</name></type> <name>finish</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>maxDeterminizedStates</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>Automaton</name></type> <name>automaton</name> <init>= <expr><call><name><name>builder</name><operator>.</operator><name>finish</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>det</name> <operator>=</operator> <call><name><name>Operations</name><operator>.</operator><name>removeDeadStates</name></name><argument_list>(<argument><expr><call><name><name>Operations</name><operator>.</operator><name>determinize</name></name><argument_list>(<argument><expr><name>automaton</name></expr></argument>, <argument><expr><name>maxDeterminizedStates</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></function>

  <comment type="block" format="javadoc">/**
   * Gets an integer id for a given term.
   *
   * If there is no position gaps for this token then we can reuse the id for the same term if it appeared at another
   * position without a gap.  If we have a position gap generate a new id so we can keep track of the position
   * increment.
   */</comment>
  <function><type><specifier>private</specifier> <name>int</name></type> <name>getTermID</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>incr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>prevIncr</name></decl></parameter>, <parameter><decl><type><name>BytesRef</name></type> <name>term</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <assert>assert <expr><name>term</name> <operator>!=</operator> <literal type="null">null</literal></expr>;</assert>
    <decl_stmt><decl><type><name>boolean</name></type> <name>isStackedGap</name> <init>= <expr><name>incr</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>prevIncr</name> <operator>&gt;</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>boolean</name></type> <name>hasGap</name> <init>= <expr><name>incr</name> <operator>&gt;</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Integer</name></type> <name>id</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>hasGap</name> <operator>||</operator> <name>isStackedGap</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>id</name> <operator>=</operator> <call><name><name>idToTerm</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>idToTerm</name><operator>.</operator><name>put</name></name><argument_list>(<argument><expr><name>id</name></expr></argument>, <argument><expr><call><name><name>BytesRef</name><operator>.</operator><name>deepCopyOf</name></name><argument_list>(<argument><expr><name>term</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="line">// stacked token should have the same increment as original token at this position</comment>
      <if_stmt><if>if <condition>(<expr><name>isStackedGap</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name><name>idToInc</name><operator>.</operator><name>put</name></name><argument_list>(<argument><expr><name>id</name></expr></argument>, <argument><expr><name>prevIncr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><call><name><name>idToInc</name><operator>.</operator><name>put</name></name><argument_list>(<argument><expr><name>id</name></expr></argument>, <argument><expr><name>incr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><name>id</name> <operator>=</operator> <call><name><name>termToID</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>term</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>id</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>term</name> <operator>=</operator> <call><name><name>BytesRef</name><operator>.</operator><name>deepCopyOf</name></name><argument_list>(<argument><expr><name>term</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>id</name> <operator>=</operator> <call><name><name>idToTerm</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>termToID</name><operator>.</operator><name>put</name></name><argument_list>(<argument><expr><name>term</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>idToTerm</name><operator>.</operator><name>put</name></name><argument_list>(<argument><expr><name>id</name></expr></argument>, <argument><expr><name>term</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>

    <return>return <expr><name>id</name></expr>;</return>
  </block_content>}</block></function>
}</block></class>
<expr_stmt><expr><operator>\</operator> <name>No</name> <name>newline</name> <name>at</name> <name>end</name> <name>of</name> <name>file</name>
<name>diff</name> <operator>--</operator><name>git</name> <name>a</name><operator>/</operator><name>lucene</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>test</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>search</name><operator>/</operator><name><name>TestGraphQuery</name><operator>.</operator><name>java</name></name> <name>b</name><operator>/</operator><name>lucene</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>test</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>search</name><operator>/</operator><name><name>TestGraphQuery</name><operator>.</operator><name>java</name></name>
<operator>new</operator> <name>file</name> <name>mode</name> <literal type="number">100644</literal>
<name>index</name> <literal type="number">00000000000..412fac4654c</literal>
<operator>--</operator> <operator>/</operator><name>dev</name><operator>/</operator><literal type="null">null</literal>
<operator>++</operator> <name>b</name><operator>/</operator><name>lucene</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>test</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>search</name><operator>/</operator><name><name>TestGraphQuery</name><operator>.</operator><name>java</name></name>
@@ <operator>-</operator><literal type="number">0</literal></expr><operator>,</operator><expr><literal type="number">0</literal> <operator>+</operator><literal type="number">1</literal></expr><operator>,</operator><expr><literal type="number">79</literal> @@</expr></expr_stmt>
<comment type="block">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</comment>
<package>package <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>search</name></name>;</package>


<import>import <name><name>java</name><operator>.</operator><name>io</name><operator>.</operator><name>IOException</name></name>;</import>

<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>index</name><operator>.</operator><name>Term</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>util</name><operator>.</operator><name>LuceneTestCase</name></name>;</import>

<class><specifier>public</specifier> class <name>TestGraphQuery</name> <super_list><extends>extends <super><name>LuceneTestCase</name></super></extends></super_list> <block>{

  <function><type><specifier>public</specifier> <name>void</name></type> <name>testEquals</name><parameter_list>()</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name><name>QueryUtils</name><operator>.</operator><name>checkEqual</name></name><argument_list>(<argument><expr><operator>new</operator> <call><name>GraphQuery</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><operator>new</operator> <call><name>GraphQuery</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>QueryUtils</name><operator>.</operator><name>checkEqual</name></name><argument_list>(<argument><expr><operator>new</operator> <call><name>GraphQuery</name><argument_list>(<argument><expr><operator>new</operator> <call><name>MatchAllDocsQuery</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>new</operator> <call><name>GraphQuery</name><argument_list>(<argument><expr><operator>new</operator> <call><name>MatchAllDocsQuery</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>QueryUtils</name><operator>.</operator><name>checkEqual</name></name><argument_list>(
        <argument><expr><operator>new</operator> <call><name>GraphQuery</name><argument_list>(<argument><expr><operator>new</operator> <call><name>TermQuery</name><argument_list>(<argument><expr><operator>new</operator> <call><name>Term</name><argument_list>(<argument><expr><literal type="string">"a"</literal></expr></argument>, <argument><expr><literal type="string">"a"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>new</operator> <call><name>TermQuery</name><argument_list>(<argument><expr><operator>new</operator> <call><name>Term</name><argument_list>(<argument><expr><literal type="string">"a"</literal></expr></argument>, <argument><expr><literal type="string">"b"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
        <argument><expr><operator>new</operator> <call><name>GraphQuery</name><argument_list>(<argument><expr><operator>new</operator> <call><name>TermQuery</name><argument_list>(<argument><expr><operator>new</operator> <call><name>Term</name><argument_list>(<argument><expr><literal type="string">"a"</literal></expr></argument>, <argument><expr><literal type="string">"a"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>new</operator> <call><name>TermQuery</name><argument_list>(<argument><expr><operator>new</operator> <call><name>Term</name><argument_list>(<argument><expr><literal type="string">"a"</literal></expr></argument>, <argument><expr><literal type="string">"b"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></function>

  <function><type><specifier>public</specifier> <name>void</name></type> <name>testBooleanDetection</name><parameter_list>()</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>assertFalse</name><argument_list>(<argument><expr><operator>new</operator> <call><name>GraphQuery</name><argument_list>()</argument_list></call><operator>.</operator><call><name>hasBoolean</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assertFalse</name><argument_list>(<argument><expr><operator>new</operator> <call><name>GraphQuery</name><argument_list>(<argument><expr><operator>new</operator> <call><name>MatchAllDocsQuery</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><operator>new</operator> <call><name>TermQuery</name><argument_list>(<argument><expr><operator>new</operator> <call><name>Term</name><argument_list>(<argument><expr><literal type="string">"a"</literal></expr></argument>, <argument><expr><literal type="string">"a"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>.</operator><call><name>hasBoolean</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assertTrue</name><argument_list>(<argument><expr><operator>new</operator> <call><name>GraphQuery</name><argument_list>(<argument><expr><operator>new</operator> <call><name><name>BooleanQuery</name><operator>.</operator><name>Builder</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>build</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>.</operator><call><name>hasBoolean</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assertTrue</name><argument_list>(<argument><expr><operator>new</operator> <call><name>GraphQuery</name><argument_list>(<argument><expr><operator>new</operator> <call><name>TermQuery</name><argument_list>(<argument><expr><operator>new</operator> <call><name>Term</name><argument_list>(<argument><expr><literal type="string">"a"</literal></expr></argument>, <argument><expr><literal type="string">"a"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>new</operator> <call><name><name>BooleanQuery</name><operator>.</operator><name>Builder</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>build</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>.</operator><call><name>hasBoolean</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></function>

  <function><type><specifier>public</specifier> <name>void</name></type> <name>testPhraseDetection</name><parameter_list>()</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>assertFalse</name><argument_list>(<argument><expr><operator>new</operator> <call><name>GraphQuery</name><argument_list>()</argument_list></call><operator>.</operator><call><name>hasPhrase</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assertFalse</name><argument_list>(<argument><expr><operator>new</operator> <call><name>GraphQuery</name><argument_list>(<argument><expr><operator>new</operator> <call><name>MatchAllDocsQuery</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><operator>new</operator> <call><name>TermQuery</name><argument_list>(<argument><expr><operator>new</operator> <call><name>Term</name><argument_list>(<argument><expr><literal type="string">"a"</literal></expr></argument>, <argument><expr><literal type="string">"a"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>.</operator><call><name>hasPhrase</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assertTrue</name><argument_list>(<argument><expr><operator>new</operator> <call><name>GraphQuery</name><argument_list>(<argument><expr><operator>new</operator> <call><name><name>PhraseQuery</name><operator>.</operator><name>Builder</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>build</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>.</operator><call><name>hasPhrase</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assertTrue</name><argument_list>(<argument><expr><operator>new</operator> <call><name>GraphQuery</name><argument_list>(<argument><expr><operator>new</operator> <call><name>TermQuery</name><argument_list>(<argument><expr><operator>new</operator> <call><name>Term</name><argument_list>(<argument><expr><literal type="string">"a"</literal></expr></argument>, <argument><expr><literal type="string">"a"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>new</operator> <call><name><name>PhraseQuery</name><operator>.</operator><name>Builder</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>build</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>.</operator><call><name>hasPhrase</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></function>

  <function><type><specifier>public</specifier> <name>void</name></type> <name>testToString</name><parameter_list>()</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><literal type="string">"Graph(hasBoolean=false, hasPhrase=false)"</literal></expr></argument>, <argument><expr><operator>new</operator> <call><name>GraphQuery</name><argument_list>()</argument_list></call><operator>.</operator><call><name>toString</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><literal type="string">"Graph(a:a, a:b, hasBoolean=true, hasPhrase=false)"</literal></expr></argument>,
        <argument><expr><operator>new</operator> <call><name>GraphQuery</name><argument_list>(<argument><expr><operator>new</operator> <call><name>TermQuery</name><argument_list>(<argument><expr><operator>new</operator> <call><name>Term</name><argument_list>(<argument><expr><literal type="string">"a"</literal></expr></argument>, <argument><expr><literal type="string">"a"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
            <argument><expr><operator>new</operator> <call><name><name>BooleanQuery</name><operator>.</operator><name>Builder</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>add</name><argument_list>(<argument><expr><operator>new</operator> <call><name>TermQuery</name><argument_list>(<argument><expr><operator>new</operator> <call><name>Term</name><argument_list>(<argument><expr><literal type="string">"a"</literal></expr></argument>, <argument><expr><literal type="string">"b"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>BooleanClause</name><operator>.</operator><name>Occur</name><operator>.</operator><name>SHOULD</name></name></expr></argument>)</argument_list></call>
                <operator>.</operator><call><name>build</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>.</operator><call><name>toString</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><literal type="string">"Graph(a:\"a b\", a:b, hasBoolean=true, hasPhrase=true)"</literal></expr></argument>,
        <argument><expr><operator>new</operator> <call><name>GraphQuery</name><argument_list>(
            <argument><expr><operator>new</operator> <call><name><name>PhraseQuery</name><operator>.</operator><name>Builder</name></name><argument_list>()</argument_list></call>
                <operator>.</operator><call><name>add</name><argument_list>(<argument><expr><operator>new</operator> <call><name>Term</name><argument_list>(<argument><expr><literal type="string">"a"</literal></expr></argument>, <argument><expr><literal type="string">"a"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
                <operator>.</operator><call><name>add</name><argument_list>(<argument><expr><operator>new</operator> <call><name>Term</name><argument_list>(<argument><expr><literal type="string">"a"</literal></expr></argument>, <argument><expr><literal type="string">"b"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>.</operator><call><name>build</name><argument_list>()</argument_list></call></expr></argument>,
            <argument><expr><operator>new</operator> <call><name><name>BooleanQuery</name><operator>.</operator><name>Builder</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>add</name><argument_list>(<argument><expr><operator>new</operator> <call><name>TermQuery</name><argument_list>(<argument><expr><operator>new</operator> <call><name>Term</name><argument_list>(<argument><expr><literal type="string">"a"</literal></expr></argument>, <argument><expr><literal type="string">"b"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>BooleanClause</name><operator>.</operator><name>Occur</name><operator>.</operator><name>SHOULD</name></name></expr></argument>)</argument_list></call>
                <operator>.</operator><call><name>build</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>.</operator><call><name>toString</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></function>

  <function><type><specifier>public</specifier> <name>void</name></type> <name>testRewrite</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws> <block>{<block_content>
    <expr_stmt><expr><call><name><name>QueryUtils</name><operator>.</operator><name>checkEqual</name></name><argument_list>(<argument><expr><operator>new</operator> <call><name><name>BooleanQuery</name><operator>.</operator><name>Builder</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>build</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><operator>new</operator> <call><name>GraphQuery</name><argument_list>()</argument_list></call><operator>.</operator><call><name>rewrite</name><argument_list>(<argument><expr><literal type="null">null</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>QueryUtils</name><operator>.</operator><name>checkEqual</name></name><argument_list>(<argument><expr><operator>new</operator> <call><name>TermQuery</name><argument_list>(<argument><expr><operator>new</operator> <call><name>Term</name><argument_list>(<argument><expr><literal type="string">"a"</literal></expr></argument>, <argument><expr><literal type="string">"a"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
        <argument><expr><operator>new</operator> <call><name>GraphQuery</name><argument_list>(<argument><expr><operator>new</operator> <call><name>TermQuery</name><argument_list>(<argument><expr><operator>new</operator> <call><name>Term</name><argument_list>(<argument><expr><literal type="string">"a"</literal></expr></argument>, <argument><expr><literal type="string">"a"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>.</operator><call><name>rewrite</name><argument_list>(<argument><expr><literal type="null">null</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>QueryUtils</name><operator>.</operator><name>checkEqual</name></name><argument_list>(
        <argument><expr><operator>new</operator> <call><name><name>BooleanQuery</name><operator>.</operator><name>Builder</name></name><argument_list>()</argument_list></call>
            <operator>.</operator><call><name>add</name><argument_list>(<argument><expr><operator>new</operator> <call><name>TermQuery</name><argument_list>(<argument><expr><operator>new</operator> <call><name>Term</name><argument_list>(<argument><expr><literal type="string">"a"</literal></expr></argument>, <argument><expr><literal type="string">"a"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>BooleanClause</name><operator>.</operator><name>Occur</name><operator>.</operator><name>SHOULD</name></name></expr></argument>)</argument_list></call>
            <operator>.</operator><call><name>add</name><argument_list>(<argument><expr><operator>new</operator> <call><name>TermQuery</name><argument_list>(<argument><expr><operator>new</operator> <call><name>Term</name><argument_list>(<argument><expr><literal type="string">"b"</literal></expr></argument>, <argument><expr><literal type="string">"b"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>BooleanClause</name><operator>.</operator><name>Occur</name><operator>.</operator><name>SHOULD</name></name></expr></argument>)</argument_list></call><operator>.</operator><call><name>build</name><argument_list>()</argument_list></call></expr></argument>,
        <argument><expr><operator>new</operator> <call><name>GraphQuery</name><argument_list>(
            <argument><expr><operator>new</operator> <call><name>TermQuery</name><argument_list>(<argument><expr><operator>new</operator> <call><name>Term</name><argument_list>(<argument><expr><literal type="string">"a"</literal></expr></argument>, <argument><expr><literal type="string">"a"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
            <argument><expr><operator>new</operator> <call><name>TermQuery</name><argument_list>(<argument><expr><operator>new</operator> <call><name>Term</name><argument_list>(<argument><expr><literal type="string">"b"</literal></expr></argument>, <argument><expr><literal type="string">"b"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>
        )</argument_list></call><operator>.</operator><call><name>rewrite</name><argument_list>(<argument><expr><literal type="null">null</literal></expr></argument>)</argument_list></call></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></function>
}</block></class>
<expr_stmt><expr><name>diff</name> <operator>--</operator><name>git</name> <name>a</name><operator>/</operator><name>lucene</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>test</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>util</name><operator>/</operator><name><name>TestQueryBuilder</name><operator>.</operator><name>java</name></name> <name>b</name><operator>/</operator><name>lucene</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>test</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>util</name><operator>/</operator><name><name>TestQueryBuilder</name><operator>.</operator><name>java</name></name>
<name>index</name> <name>d3019e3d077</name><operator>..</operator><literal type="number">9cd839027ed</literal> <literal type="number">100644</literal>
<operator>--</operator> <name>a</name><operator>/</operator><name>lucene</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>test</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>util</name><operator>/</operator><name><name>TestQueryBuilder</name><operator>.</operator><name>java</name></name>
<operator>++</operator> <name>b</name><operator>/</operator><name>lucene</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>test</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>util</name><operator>/</operator><name><name>TestQueryBuilder</name><operator>.</operator><name>java</name></name>
@@ <operator>-</operator><literal type="number">31</literal></expr><operator>,</operator><expr><literal type="number">6</literal> <operator>+</operator><literal type="number">31</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@</expr></expr_stmt> <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>analysis</name><operator>.</operator><name>tokenattributes</name><operator>.</operator><name>PositionIncrementAttribute</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>index</name><operator>.</operator><name>Term</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>search</name><operator>.</operator><name>BooleanClause</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>search</name><operator>.</operator><name>BooleanQuery</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>search</name><operator>.</operator><name>GraphQuery</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>search</name><operator>.</operator><name>MultiPhraseQuery</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>search</name><operator>.</operator><name>PhraseQuery</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>search</name><operator>.</operator><name>Query</name></name>;</import>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">150</literal></expr><operator>,</operator><expr><literal type="number">13</literal> <operator>+</operator><literal type="number">151</literal></expr><operator>,</operator><expr><literal type="number">17</literal> @@ <specifier>public</specifier> <name>class</name> <name>TestQueryBuilder</name> extends <name>LuceneTestCase</name> <block>{
     <expr><call><name>assertEquals</name><argument_list>(<argument><expr><call><name><name>expectedBuilder</name><operator>.</operator><name>build</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>builder</name><operator>.</operator><name>createPhraseQuery</name></name><argument_list>(<argument><expr><literal type="string">"field"</literal></expr></argument>, <argument><expr><literal type="string">"old dogs"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
   }</block></expr></expr_stmt>
 
  <comment type="block" format="javadoc">/** forms multiphrase query */</comment>
  <comment type="block" format="javadoc">/** forms graph query */</comment>
   <function><type><specifier>public</specifier> <name>void</name></type> <name>testMultiWordSynonymsPhrase</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>Exception</name></expr></argument></throws> <block>{<block_content>
    <decl_stmt><decl><type><name><name>MultiPhraseQuery</name><operator>.</operator><name>Builder</name></name></type> <name>expectedBuilder</name> <init>= <expr><operator>new</operator> <call><name><name>MultiPhraseQuery</name><operator>.</operator><name>Builder</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>expectedBuilder</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><operator>new</operator> <name><name>Term</name><index>[]</index></name> <block>{ <expr><operator>new</operator> <call><name>Term</name><argument_list>(<argument><expr><literal type="string">"field"</literal></expr></argument>, <argument><expr><literal type="string">"guinea"</literal></expr></argument>)</argument_list></call></expr>, <expr><operator>new</operator> <call><name>Term</name><argument_list>(<argument><expr><literal type="string">"field"</literal></expr></argument>, <argument><expr><literal type="string">"cavy"</literal></expr></argument>)</argument_list></call></expr> }</block></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>expectedBuilder</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><operator>new</operator> <call><name>Term</name><argument_list>(<argument><expr><literal type="string">"field"</literal></expr></argument>, <argument><expr><literal type="string">"pig"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name><name>PhraseQuery</name><operator>.</operator><name>Builder</name></name></type> <name>expectedPhrase</name> <init>= <expr><operator>new</operator> <call><name><name>PhraseQuery</name><operator>.</operator><name>Builder</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>expectedPhrase</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><operator>new</operator> <call><name>Term</name><argument_list>(<argument><expr><literal type="string">"field"</literal></expr></argument>, <argument><expr><literal type="string">"guinea"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>expectedPhrase</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><operator>new</operator> <call><name>Term</name><argument_list>(<argument><expr><literal type="string">"field"</literal></expr></argument>, <argument><expr><literal type="string">"pig"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>TermQuery</name></type> <name>expectedTerm</name> <init>= <expr><operator>new</operator> <call><name>TermQuery</name><argument_list>(<argument><expr><operator>new</operator> <call><name>Term</name><argument_list>(<argument><expr><literal type="string">"field"</literal></expr></argument>, <argument><expr><literal type="string">"cavy"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

     <decl_stmt><decl><type><name>QueryBuilder</name></type> <name>queryBuilder</name> <init>= <expr><operator>new</operator> <call><name>QueryBuilder</name><argument_list>(<argument><expr><operator>new</operator> <call><name>MockSynonymAnalyzer</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><call><name><name>expectedBuilder</name><operator>.</operator><name>build</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>queryBuilder</name><operator>.</operator><name>createPhraseQuery</name></name><argument_list>(<argument><expr><literal type="string">"field"</literal></expr></argument>, <argument><expr><literal type="string">"guinea pig"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><operator>new</operator> <call><name>GraphQuery</name><argument_list>(<argument><expr><call><name><name>expectedPhrase</name><operator>.</operator><name>build</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>expectedTerm</name></expr></argument>)</argument_list></call></expr></argument>,
        <argument><expr><call><name><name>queryBuilder</name><operator>.</operator><name>createPhraseQuery</name></name><argument_list>(<argument><expr><literal type="string">"field"</literal></expr></argument>, <argument><expr><literal type="string">"guinea pig"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
   </block_content>}</block></function>
 
   <class><specifier>protected</specifier> <specifier>static</specifier> class <name>SimpleCJKTokenizer</name> <super_list><extends>extends <super><name>Tokenizer</name></super></extends></super_list> <block>{
<expr_stmt><expr><name>diff</name> <operator>--</operator><name>git</name> <name>a</name><operator>/</operator><name>lucene</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>test</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>util</name><operator>/</operator><name>graph</name><operator>/</operator><name><name>TestGraphTokenStreamFiniteStrings</name><operator>.</operator><name>java</name></name> <name>b</name><operator>/</operator><name>lucene</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>test</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>util</name><operator>/</operator><name>graph</name><operator>/</operator><name><name>TestGraphTokenStreamFiniteStrings</name><operator>.</operator><name>java</name></name>
<operator>new</operator> <name>file</name> <name>mode</name> <literal type="number">100644</literal>
<name>index</name> <literal type="number">00000000000..4e636e249dc</literal>
<operator>--</operator> <operator>/</operator><name>dev</name><operator>/</operator><literal type="null">null</literal>
<operator>++</operator> <name>b</name><operator>/</operator><name>lucene</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>test</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>util</name><operator>/</operator><name>graph</name><operator>/</operator><name><name>TestGraphTokenStreamFiniteStrings</name><operator>.</operator><name>java</name></name>
@@ <operator>-</operator><literal type="number">0</literal></expr><operator>,</operator><expr><literal type="number">0</literal> <operator>+</operator><literal type="number">1</literal></expr><operator>,</operator><expr><literal type="number">217</literal> @@</expr></expr_stmt>
<comment type="block">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</comment>
<package>package <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>util</name><operator>.</operator><name>graph</name></name>;</package>

<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>List</name></name>;</import>

<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>analysis</name><operator>.</operator><name>CannedTokenStream</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>analysis</name><operator>.</operator><name>Token</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>analysis</name><operator>.</operator><name>TokenStream</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>analysis</name><operator>.</operator><name>tokenattributes</name><operator>.</operator><name>BytesTermAttribute</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>analysis</name><operator>.</operator><name>tokenattributes</name><operator>.</operator><name>PositionIncrementAttribute</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>util</name><operator>.</operator><name>LuceneTestCase</name></name>;</import>

<comment type="block" format="javadoc">/**
 * {@link GraphTokenStreamFiniteStrings} tests.
 */</comment>
<class><specifier>public</specifier> class <name>TestGraphTokenStreamFiniteStrings</name> <super_list><extends>extends <super><name>LuceneTestCase</name></super></extends></super_list> <block>{

  <function><type><specifier>private</specifier> <specifier>static</specifier> <name>Token</name></type> <name>token</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>term</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>posInc</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>posLength</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><specifier>final</specifier> <name>Token</name></type> <name>t</name> <init>= <expr><operator>new</operator> <call><name>Token</name><argument_list>(<argument><expr><name>term</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name><name>term</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>t</name><operator>.</operator><name>setPositionIncrement</name></name><argument_list>(<argument><expr><name>posInc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>t</name><operator>.</operator><name>setPositionLength</name></name><argument_list>(<argument><expr><name>posLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>t</name></expr>;</return>
  </block_content>}</block></function>

  <function><type><specifier>private</specifier> <name>void</name></type> <name>assertTokenStream</name><parameter_list>(<parameter><decl><type><name>TokenStream</name></type> <name>ts</name></decl></parameter>, <parameter><decl><type><name><name>String</name><index>[]</index></name></type> <name>terms</name></decl></parameter>, <parameter><decl><type><name><name>int</name><index>[]</index></name></type> <name>increments</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>Exception</name></expr></argument></throws> <block>{<block_content>
    <comment type="line">// verify no nulls and arrays same length</comment>
    <expr_stmt><expr><call><name>assertNotNull</name><argument_list>(<argument><expr><name>ts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assertNotNull</name><argument_list>(<argument><expr><name>terms</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assertNotNull</name><argument_list>(<argument><expr><name>increments</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><name><name>terms</name><operator>.</operator><name>length</name></name></expr></argument>, <argument><expr><name><name>increments</name><operator>.</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>BytesTermAttribute</name></type> <name>termAtt</name> <init>= <expr><call><name><name>ts</name><operator>.</operator><name>getAttribute</name></name><argument_list>(<argument><expr><name><name>BytesTermAttribute</name><operator>.</operator><name>class</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PositionIncrementAttribute</name></type> <name>incrAtt</name> <init>= <expr><call><name><name>ts</name><operator>.</operator><name>getAttribute</name></name><argument_list>(<argument><expr><name><name>PositionIncrementAttribute</name><operator>.</operator><name>class</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>offset</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <while>while <condition>(<expr><call><name><name>ts</name><operator>.</operator><name>incrementToken</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
      <comment type="line">// verify term and increment</comment>
      <assert>assert <expr><name>offset</name> <operator>&lt;</operator> <name><name>terms</name><operator>.</operator><name>length</name></name></expr>;</assert>
      <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><name><name>terms</name><index>[<expr><name>offset</name></expr>]</index></name></expr></argument>, <argument><expr><call><name><name>termAtt</name><operator>.</operator><name>getBytesRef</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>utf8ToString</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><name><name>increments</name><index>[<expr><name>offset</name></expr>]</index></name></expr></argument>, <argument><expr><call><name><name>incrAtt</name><operator>.</operator><name>getPositionIncrement</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>offset</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></while>

    <comment type="line">// make sure we processed all items</comment>
    <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><name>offset</name></expr></argument>, <argument><expr><name><name>terms</name><operator>.</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></function>

  <function><type><specifier>public</specifier> <name>void</name></type> <name>testIllegalState</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>Exception</name></expr></argument></throws> <block>{<block_content>
    <expr_stmt><expr><call><name>expectThrows</name><argument_list>(<argument><expr><name><name>IllegalStateException</name><operator>.</operator><name>class</name></name></expr></argument>, <argument><expr><lambda><parameter_list>()</parameter_list> -&gt; <block>{<block_content>
      <decl_stmt><decl><type><name>TokenStream</name></type> <name>ts</name> <init>= <expr><operator>new</operator> <call><name>CannedTokenStream</name><argument_list>(
          <argument><expr><call><name>token</name><argument_list>(<argument><expr><literal type="string">"a"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>,
          <argument><expr><call><name>token</name><argument_list>(<argument><expr><literal type="string">"b"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>
      )</argument_list></call></expr></init></decl>;</decl_stmt>

      <expr_stmt><expr><call><name><name>GraphTokenStreamFiniteStrings</name><operator>.</operator><name>getTokenStreams</name></name><argument_list>(<argument><expr><name>ts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></lambda></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></function>

  <function><type><specifier>public</specifier> <name>void</name></type> <name>testSingleGraph</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>Exception</name></expr></argument></throws> <block>{<block_content>
    <decl_stmt><decl><type><name>TokenStream</name></type> <name>ts</name> <init>= <expr><operator>new</operator> <call><name>CannedTokenStream</name><argument_list>(
        <argument><expr><call><name>token</name><argument_list>(<argument><expr><literal type="string">"fast"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>,
        <argument><expr><call><name>token</name><argument_list>(<argument><expr><literal type="string">"wi"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>,
        <argument><expr><call><name>token</name><argument_list>(<argument><expr><literal type="string">"wifi"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>,
        <argument><expr><call><name>token</name><argument_list>(<argument><expr><literal type="string">"fi"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>,
        <argument><expr><call><name>token</name><argument_list>(<argument><expr><literal type="string">"network"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>
    )</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name>TokenStream</name></argument>&gt;</argument_list></name></type> <name>finiteTokenStreams</name> <init>= <expr><call><name><name>GraphTokenStreamFiniteStrings</name><operator>.</operator><name>getTokenStreams</name></name><argument_list>(<argument><expr><name>ts</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><call><name><name>finiteTokenStreams</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assertTokenStream</name><argument_list>(<argument><expr><call><name><name>finiteTokenStreams</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>new</operator> <name><name>String</name><index>[]</index></name><block>{<expr><literal type="string">"fast"</literal></expr>, <expr><literal type="string">"wi"</literal></expr>, <expr><literal type="string">"fi"</literal></expr>, <expr><literal type="string">"network"</literal></expr>}</block></expr></argument>, <argument><expr><operator>new</operator> <name><name>int</name><index>[]</index></name><block>{<expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>}</block></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assertTokenStream</name><argument_list>(<argument><expr><call><name><name>finiteTokenStreams</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>new</operator> <name><name>String</name><index>[]</index></name><block>{<expr><literal type="string">"fast"</literal></expr>, <expr><literal type="string">"wifi"</literal></expr>, <expr><literal type="string">"network"</literal></expr>}</block></expr></argument>, <argument><expr><operator>new</operator> <name><name>int</name><index>[]</index></name><block>{<expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>}</block></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></function>

  <function><type><specifier>public</specifier> <name>void</name></type> <name>testSingleGraphWithGap</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>Exception</name></expr></argument></throws> <block>{<block_content>
    <comment type="line">// "hey the fast wifi network", where "the" removed</comment>
    <decl_stmt><decl><type><name>TokenStream</name></type> <name>ts</name> <init>= <expr><operator>new</operator> <call><name>CannedTokenStream</name><argument_list>(
        <argument><expr><call><name>token</name><argument_list>(<argument><expr><literal type="string">"hey"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>,
        <argument><expr><call><name>token</name><argument_list>(<argument><expr><literal type="string">"fast"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>,
        <argument><expr><call><name>token</name><argument_list>(<argument><expr><literal type="string">"wi"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>,
        <argument><expr><call><name>token</name><argument_list>(<argument><expr><literal type="string">"wifi"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>,
        <argument><expr><call><name>token</name><argument_list>(<argument><expr><literal type="string">"fi"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>,
        <argument><expr><call><name>token</name><argument_list>(<argument><expr><literal type="string">"network"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>
    )</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name>TokenStream</name></argument>&gt;</argument_list></name></type> <name>finiteTokenStreams</name> <init>= <expr><call><name><name>GraphTokenStreamFiniteStrings</name><operator>.</operator><name>getTokenStreams</name></name><argument_list>(<argument><expr><name>ts</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><call><name><name>finiteTokenStreams</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assertTokenStream</name><argument_list>(<argument><expr><call><name><name>finiteTokenStreams</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>,
        <argument><expr><operator>new</operator> <name><name>String</name><index>[]</index></name><block>{<expr><literal type="string">"hey"</literal></expr>, <expr><literal type="string">"fast"</literal></expr>, <expr><literal type="string">"wi"</literal></expr>, <expr><literal type="string">"fi"</literal></expr>, <expr><literal type="string">"network"</literal></expr>}</block></expr></argument>, <argument><expr><operator>new</operator> <name><name>int</name><index>[]</index></name><block>{<expr><literal type="number">1</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>}</block></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assertTokenStream</name><argument_list>(<argument><expr><call><name><name>finiteTokenStreams</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>,
        <argument><expr><operator>new</operator> <name><name>String</name><index>[]</index></name><block>{<expr><literal type="string">"hey"</literal></expr>, <expr><literal type="string">"fast"</literal></expr>, <expr><literal type="string">"wifi"</literal></expr>, <expr><literal type="string">"network"</literal></expr>}</block></expr></argument>, <argument><expr><operator>new</operator> <name><name>int</name><index>[]</index></name><block>{<expr><literal type="number">1</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>}</block></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></function>


  <function><type><specifier>public</specifier> <name>void</name></type> <name>testGraphAndGapSameToken</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>Exception</name></expr></argument></throws> <block>{<block_content>
    <decl_stmt><decl><type><name>TokenStream</name></type> <name>ts</name> <init>= <expr><operator>new</operator> <call><name>CannedTokenStream</name><argument_list>(
        <argument><expr><call><name>token</name><argument_list>(<argument><expr><literal type="string">"fast"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>,
        <argument><expr><call><name>token</name><argument_list>(<argument><expr><literal type="string">"wi"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>,
        <argument><expr><call><name>token</name><argument_list>(<argument><expr><literal type="string">"wifi"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>,
        <argument><expr><call><name>token</name><argument_list>(<argument><expr><literal type="string">"fi"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>,
        <argument><expr><call><name>token</name><argument_list>(<argument><expr><literal type="string">"network"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>
    )</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name>TokenStream</name></argument>&gt;</argument_list></name></type> <name>finiteTokenStreams</name> <init>= <expr><call><name><name>GraphTokenStreamFiniteStrings</name><operator>.</operator><name>getTokenStreams</name></name><argument_list>(<argument><expr><name>ts</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><call><name><name>finiteTokenStreams</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assertTokenStream</name><argument_list>(<argument><expr><call><name><name>finiteTokenStreams</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>new</operator> <name><name>String</name><index>[]</index></name><block>{<expr><literal type="string">"fast"</literal></expr>, <expr><literal type="string">"wi"</literal></expr>, <expr><literal type="string">"fi"</literal></expr>, <expr><literal type="string">"network"</literal></expr>}</block></expr></argument>, <argument><expr><operator>new</operator> <name><name>int</name><index>[]</index></name><block>{<expr><literal type="number">1</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>}</block></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assertTokenStream</name><argument_list>(<argument><expr><call><name><name>finiteTokenStreams</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>new</operator> <name><name>String</name><index>[]</index></name><block>{<expr><literal type="string">"fast"</literal></expr>, <expr><literal type="string">"wifi"</literal></expr>, <expr><literal type="string">"network"</literal></expr>}</block></expr></argument>, <argument><expr><operator>new</operator> <name><name>int</name><index>[]</index></name><block>{<expr><literal type="number">1</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">1</literal></expr>}</block></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></function>

  <function><type><specifier>public</specifier> <name>void</name></type> <name>testGraphAndGapSameTokenTerm</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>Exception</name></expr></argument></throws> <block>{<block_content>
    <decl_stmt><decl><type><name>TokenStream</name></type> <name>ts</name> <init>= <expr><operator>new</operator> <call><name>CannedTokenStream</name><argument_list>(
        <argument><expr><call><name>token</name><argument_list>(<argument><expr><literal type="string">"a"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>,
        <argument><expr><call><name>token</name><argument_list>(<argument><expr><literal type="string">"b"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>,
        <argument><expr><call><name>token</name><argument_list>(<argument><expr><literal type="string">"c"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>,
        <argument><expr><call><name>token</name><argument_list>(<argument><expr><literal type="string">"a"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>,
        <argument><expr><call><name>token</name><argument_list>(<argument><expr><literal type="string">"d"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>
    )</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name>TokenStream</name></argument>&gt;</argument_list></name></type> <name>finiteTokenStreams</name> <init>= <expr><call><name><name>GraphTokenStreamFiniteStrings</name><operator>.</operator><name>getTokenStreams</name></name><argument_list>(<argument><expr><name>ts</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><call><name><name>finiteTokenStreams</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assertTokenStream</name><argument_list>(<argument><expr><call><name><name>finiteTokenStreams</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>new</operator> <name><name>String</name><index>[]</index></name><block>{<expr><literal type="string">"a"</literal></expr>, <expr><literal type="string">"b"</literal></expr>, <expr><literal type="string">"c"</literal></expr>, <expr><literal type="string">"d"</literal></expr>}</block></expr></argument>, <argument><expr><operator>new</operator> <name><name>int</name><index>[]</index></name><block>{<expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">1</literal></expr>}</block></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assertTokenStream</name><argument_list>(<argument><expr><call><name><name>finiteTokenStreams</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>new</operator> <name><name>String</name><index>[]</index></name><block>{<expr><literal type="string">"a"</literal></expr>, <expr><literal type="string">"b"</literal></expr>, <expr><literal type="string">"a"</literal></expr>}</block></expr></argument>, <argument><expr><operator>new</operator> <name><name>int</name><index>[]</index></name><block>{<expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">2</literal></expr>}</block></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></function>

  <function><type><specifier>public</specifier> <name>void</name></type> <name>testStackedGraph</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>Exception</name></expr></argument></throws> <block>{<block_content>
    <decl_stmt><decl><type><name>TokenStream</name></type> <name>ts</name> <init>= <expr><operator>new</operator> <call><name>CannedTokenStream</name><argument_list>(
        <argument><expr><call><name>token</name><argument_list>(<argument><expr><literal type="string">"fast"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>,
        <argument><expr><call><name>token</name><argument_list>(<argument><expr><literal type="string">"wi"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>,
        <argument><expr><call><name>token</name><argument_list>(<argument><expr><literal type="string">"wifi"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>,
        <argument><expr><call><name>token</name><argument_list>(<argument><expr><literal type="string">"wireless"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>,
        <argument><expr><call><name>token</name><argument_list>(<argument><expr><literal type="string">"fi"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>,
        <argument><expr><call><name>token</name><argument_list>(<argument><expr><literal type="string">"network"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>
    )</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name>TokenStream</name></argument>&gt;</argument_list></name></type> <name>finiteTokenStreams</name> <init>= <expr><call><name><name>GraphTokenStreamFiniteStrings</name><operator>.</operator><name>getTokenStreams</name></name><argument_list>(<argument><expr><name>ts</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><call><name><name>finiteTokenStreams</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assertTokenStream</name><argument_list>(<argument><expr><call><name><name>finiteTokenStreams</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>new</operator> <name><name>String</name><index>[]</index></name><block>{<expr><literal type="string">"fast"</literal></expr>, <expr><literal type="string">"wi"</literal></expr>, <expr><literal type="string">"fi"</literal></expr>, <expr><literal type="string">"network"</literal></expr>}</block></expr></argument>, <argument><expr><operator>new</operator> <name><name>int</name><index>[]</index></name><block>{<expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>}</block></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assertTokenStream</name><argument_list>(<argument><expr><call><name><name>finiteTokenStreams</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>new</operator> <name><name>String</name><index>[]</index></name><block>{<expr><literal type="string">"fast"</literal></expr>, <expr><literal type="string">"wifi"</literal></expr>, <expr><literal type="string">"network"</literal></expr>}</block></expr></argument>, <argument><expr><operator>new</operator> <name><name>int</name><index>[]</index></name><block>{<expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>}</block></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assertTokenStream</name><argument_list>(<argument><expr><call><name><name>finiteTokenStreams</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>new</operator> <name><name>String</name><index>[]</index></name><block>{<expr><literal type="string">"fast"</literal></expr>, <expr><literal type="string">"wireless"</literal></expr>, <expr><literal type="string">"network"</literal></expr>}</block></expr></argument>, <argument><expr><operator>new</operator> <name><name>int</name><index>[]</index></name><block>{<expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>}</block></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></function>

  <function><type><specifier>public</specifier> <name>void</name></type> <name>testStackedGraphWithGap</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>Exception</name></expr></argument></throws> <block>{<block_content>
    <decl_stmt><decl><type><name>TokenStream</name></type> <name>ts</name> <init>= <expr><operator>new</operator> <call><name>CannedTokenStream</name><argument_list>(
        <argument><expr><call><name>token</name><argument_list>(<argument><expr><literal type="string">"fast"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>,
        <argument><expr><call><name>token</name><argument_list>(<argument><expr><literal type="string">"wi"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>,
        <argument><expr><call><name>token</name><argument_list>(<argument><expr><literal type="string">"wifi"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>,
        <argument><expr><call><name>token</name><argument_list>(<argument><expr><literal type="string">"wireless"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>,
        <argument><expr><call><name>token</name><argument_list>(<argument><expr><literal type="string">"fi"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>,
        <argument><expr><call><name>token</name><argument_list>(<argument><expr><literal type="string">"network"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>
    )</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name>TokenStream</name></argument>&gt;</argument_list></name></type> <name>finiteTokenStreams</name> <init>= <expr><call><name><name>GraphTokenStreamFiniteStrings</name><operator>.</operator><name>getTokenStreams</name></name><argument_list>(<argument><expr><name>ts</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><call><name><name>finiteTokenStreams</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assertTokenStream</name><argument_list>(<argument><expr><call><name><name>finiteTokenStreams</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>new</operator> <name><name>String</name><index>[]</index></name><block>{<expr><literal type="string">"fast"</literal></expr>, <expr><literal type="string">"wi"</literal></expr>, <expr><literal type="string">"fi"</literal></expr>, <expr><literal type="string">"network"</literal></expr>}</block></expr></argument>, <argument><expr><operator>new</operator> <name><name>int</name><index>[]</index></name><block>{<expr><literal type="number">1</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>}</block></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assertTokenStream</name><argument_list>(<argument><expr><call><name><name>finiteTokenStreams</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>new</operator> <name><name>String</name><index>[]</index></name><block>{<expr><literal type="string">"fast"</literal></expr>, <expr><literal type="string">"wifi"</literal></expr>, <expr><literal type="string">"network"</literal></expr>}</block></expr></argument>, <argument><expr><operator>new</operator> <name><name>int</name><index>[]</index></name><block>{<expr><literal type="number">1</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">1</literal></expr>}</block></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assertTokenStream</name><argument_list>(<argument><expr><call><name><name>finiteTokenStreams</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>new</operator> <name><name>String</name><index>[]</index></name><block>{<expr><literal type="string">"fast"</literal></expr>, <expr><literal type="string">"wireless"</literal></expr>, <expr><literal type="string">"network"</literal></expr>}</block></expr></argument>, <argument><expr><operator>new</operator> <name><name>int</name><index>[]</index></name><block>{<expr><literal type="number">1</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">1</literal></expr>}</block></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></function>

  <function><type><specifier>public</specifier> <name>void</name></type> <name>testGraphWithRegularSynonym</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>Exception</name></expr></argument></throws> <block>{<block_content>
    <decl_stmt><decl><type><name>TokenStream</name></type> <name>ts</name> <init>= <expr><operator>new</operator> <call><name>CannedTokenStream</name><argument_list>(
        <argument><expr><call><name>token</name><argument_list>(<argument><expr><literal type="string">"fast"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>,
        <argument><expr><call><name>token</name><argument_list>(<argument><expr><literal type="string">"speedy"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>,
        <argument><expr><call><name>token</name><argument_list>(<argument><expr><literal type="string">"wi"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>,
        <argument><expr><call><name>token</name><argument_list>(<argument><expr><literal type="string">"wifi"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>,
        <argument><expr><call><name>token</name><argument_list>(<argument><expr><literal type="string">"fi"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>,
        <argument><expr><call><name>token</name><argument_list>(<argument><expr><literal type="string">"network"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>
    )</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name>TokenStream</name></argument>&gt;</argument_list></name></type> <name>finiteTokenStreams</name> <init>= <expr><call><name><name>GraphTokenStreamFiniteStrings</name><operator>.</operator><name>getTokenStreams</name></name><argument_list>(<argument><expr><name>ts</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><call><name><name>finiteTokenStreams</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assertTokenStream</name><argument_list>(<argument><expr><call><name><name>finiteTokenStreams</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>new</operator> <name><name>String</name><index>[]</index></name><block>{<expr><literal type="string">"fast"</literal></expr>, <expr><literal type="string">"wi"</literal></expr>, <expr><literal type="string">"fi"</literal></expr>, <expr><literal type="string">"network"</literal></expr>}</block></expr></argument>, <argument><expr><operator>new</operator> <name><name>int</name><index>[]</index></name><block>{<expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>}</block></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assertTokenStream</name><argument_list>(<argument><expr><call><name><name>finiteTokenStreams</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>new</operator> <name><name>String</name><index>[]</index></name><block>{<expr><literal type="string">"fast"</literal></expr>, <expr><literal type="string">"wifi"</literal></expr>, <expr><literal type="string">"network"</literal></expr>}</block></expr></argument>, <argument><expr><operator>new</operator> <name><name>int</name><index>[]</index></name><block>{<expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>}</block></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assertTokenStream</name><argument_list>(<argument><expr><call><name><name>finiteTokenStreams</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>new</operator> <name><name>String</name><index>[]</index></name><block>{<expr><literal type="string">"speedy"</literal></expr>, <expr><literal type="string">"wi"</literal></expr>, <expr><literal type="string">"fi"</literal></expr>, <expr><literal type="string">"network"</literal></expr>}</block></expr></argument>, <argument><expr><operator>new</operator> <name><name>int</name><index>[]</index></name><block>{<expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>}</block></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assertTokenStream</name><argument_list>(<argument><expr><call><name><name>finiteTokenStreams</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>new</operator> <name><name>String</name><index>[]</index></name><block>{<expr><literal type="string">"speedy"</literal></expr>, <expr><literal type="string">"wifi"</literal></expr>, <expr><literal type="string">"network"</literal></expr>}</block></expr></argument>, <argument><expr><operator>new</operator> <name><name>int</name><index>[]</index></name><block>{<expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>}</block></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></function>

  <function><type><specifier>public</specifier> <name>void</name></type> <name>testMultiGraph</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>Exception</name></expr></argument></throws> <block>{<block_content>
    <decl_stmt><decl><type><name>TokenStream</name></type> <name>ts</name> <init>= <expr><operator>new</operator> <call><name>CannedTokenStream</name><argument_list>(
        <argument><expr><call><name>token</name><argument_list>(<argument><expr><literal type="string">"turbo"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>,
        <argument><expr><call><name>token</name><argument_list>(<argument><expr><literal type="string">"fast"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>,
        <argument><expr><call><name>token</name><argument_list>(<argument><expr><literal type="string">"charged"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>,
        <argument><expr><call><name>token</name><argument_list>(<argument><expr><literal type="string">"wi"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>,
        <argument><expr><call><name>token</name><argument_list>(<argument><expr><literal type="string">"wifi"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>,
        <argument><expr><call><name>token</name><argument_list>(<argument><expr><literal type="string">"fi"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>,
        <argument><expr><call><name>token</name><argument_list>(<argument><expr><literal type="string">"network"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>
    )</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name>TokenStream</name></argument>&gt;</argument_list></name></type> <name>finiteTokenStreams</name> <init>= <expr><call><name><name>GraphTokenStreamFiniteStrings</name><operator>.</operator><name>getTokenStreams</name></name><argument_list>(<argument><expr><name>ts</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><call><name><name>finiteTokenStreams</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assertTokenStream</name><argument_list>(<argument><expr><call><name><name>finiteTokenStreams</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>,
        <argument><expr><operator>new</operator> <name><name>String</name><index>[]</index></name><block>{<expr><literal type="string">"turbo"</literal></expr>, <expr><literal type="string">"charged"</literal></expr>, <expr><literal type="string">"wi"</literal></expr>, <expr><literal type="string">"fi"</literal></expr>, <expr><literal type="string">"network"</literal></expr>}</block></expr></argument>, <argument><expr><operator>new</operator> <name><name>int</name><index>[]</index></name><block>{<expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>}</block></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assertTokenStream</name><argument_list>(<argument><expr><call><name><name>finiteTokenStreams</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>,
        <argument><expr><operator>new</operator> <name><name>String</name><index>[]</index></name><block>{<expr><literal type="string">"turbo"</literal></expr>, <expr><literal type="string">"charged"</literal></expr>, <expr><literal type="string">"wifi"</literal></expr>, <expr><literal type="string">"network"</literal></expr>}</block></expr></argument>, <argument><expr><operator>new</operator> <name><name>int</name><index>[]</index></name><block>{<expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>}</block></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assertTokenStream</name><argument_list>(<argument><expr><call><name><name>finiteTokenStreams</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>new</operator> <name><name>String</name><index>[]</index></name><block>{<expr><literal type="string">"fast"</literal></expr>, <expr><literal type="string">"wi"</literal></expr>, <expr><literal type="string">"fi"</literal></expr>, <expr><literal type="string">"network"</literal></expr>}</block></expr></argument>, <argument><expr><operator>new</operator> <name><name>int</name><index>[]</index></name><block>{<expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>}</block></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assertTokenStream</name><argument_list>(<argument><expr><call><name><name>finiteTokenStreams</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>new</operator> <name><name>String</name><index>[]</index></name><block>{<expr><literal type="string">"fast"</literal></expr>, <expr><literal type="string">"wifi"</literal></expr>, <expr><literal type="string">"network"</literal></expr>}</block></expr></argument>, <argument><expr><operator>new</operator> <name><name>int</name><index>[]</index></name><block>{<expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>}</block></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></function>
}</block></class>
<expr_stmt><expr><name>diff</name> <operator>--</operator><name>git</name> <name>a</name><operator>/</operator><name>lucene</name><operator>/</operator><name>queryparser</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>queryparser</name><operator>/</operator><name>classic</name><operator>/</operator><name><name>QueryParserBase</name><operator>.</operator><name>java</name></name> <name>b</name><operator>/</operator><name>lucene</name><operator>/</operator><name>queryparser</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>queryparser</name><operator>/</operator><name>classic</name><operator>/</operator><name><name>QueryParserBase</name><operator>.</operator><name>java</name></name>
<name>index</name> <literal type="number">41d3764f0ac</literal><operator>..</operator><literal type="number">9b238d87eff</literal> <literal type="number">100644</literal>
<operator>--</operator> <name>a</name><operator>/</operator><name>lucene</name><operator>/</operator><name>queryparser</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>queryparser</name><operator>/</operator><name>classic</name><operator>/</operator><name><name>QueryParserBase</name><operator>.</operator><name>java</name></name>
<operator>++</operator> <name>b</name><operator>/</operator><name>lucene</name><operator>/</operator><name>queryparser</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>queryparser</name><operator>/</operator><name>classic</name><operator>/</operator><name><name>QueryParserBase</name><operator>.</operator><name>java</name></name>
@@ <operator>-</operator><literal type="number">475</literal></expr><operator>,</operator><expr><literal type="number">8</literal> <operator>+</operator><literal type="number">475</literal></expr><operator>,</operator><expr><literal type="number">6</literal> @@ <specifier>public</specifier> <specifier>abstract</specifier> <name>class</name> <name>QueryParserBase</name> extends <name>QueryBuilder</name> implements <name>CommonQuer</name></expr></expr_stmt>
     <return>return <expr><call><name>createFieldQuery</name><argument_list>(<argument><expr><name>analyzer</name></expr></argument>, <argument><expr><name>occur</name></expr></argument>, <argument><expr><name>field</name></expr></argument>, <argument><expr><name>queryText</name></expr></argument>, <argument><expr><name>quoted</name> <operator>||</operator> <name>autoGeneratePhraseQueries</name></expr></argument>, <argument><expr><name>phraseSlop</name></expr></argument>)</argument_list></call></expr>;</return>
   }</block></class>
 


   <comment type="block" format="javadoc">/**
    * Base implementation delegates to {@link #getFieldQuery(String,String,boolean)}.
    * This method may be overridden, for example, to return
@@ -489,26 +487,48 @@ public abstract class QueryParserBase extends QueryBuilder implements CommonQuer
     Query query = getFieldQuery(field, queryText, true);
 
     if (query instanceof PhraseQuery) {
      PhraseQuery.Builder builder = new PhraseQuery.Builder();
      builder.setSlop(slop);
      PhraseQuery pq = (PhraseQuery) query;
      org.apache.lucene.index.Term[] terms = pq.getTerms();
      int[] positions = pq.getPositions();
      for (int i = 0; i &lt; terms.length; ++i) {
        builder.add(terms[i], positions[i]);
      }
      query = builder.build();
      query = addSlopToPhrase((PhraseQuery) query, slop);
     } else if (query instanceof MultiPhraseQuery) {
       MultiPhraseQuery mpq = (MultiPhraseQuery)query;
       
       if (slop != mpq.getSlop()) {
         query = new MultiPhraseQuery.Builder(mpq).setSlop(slop).build();
       }
    } else if (query instanceof GraphQuery &amp;&amp; ((GraphQuery) query).hasPhrase()) {
      // we have a graph query that has at least one phrase sub-query
      // re-build and set slop on all phrase queries
      List&lt;Query&gt; oldQueries = ((GraphQuery) query).getQueries();
      Query[] queries = new Query[oldQueries.size()];
      for (int i = 0; i &lt; queries.length; i++) {
        Query oldQuery = oldQueries.get(i);
        if (oldQuery instanceof PhraseQuery) {
          queries[i] = addSlopToPhrase((PhraseQuery) oldQuery, slop);
        } else {
          queries[i] = oldQuery;
        }
      }

      query = new GraphQuery(queries);
     }
 
     return query;
   }
 
  /**
   * Rebuild a phrase query with a slop value
   */</comment>
  <function><type><specifier>private</specifier> <name>PhraseQuery</name></type> <name>addSlopToPhrase</name><parameter_list>(<parameter><decl><type><name>PhraseQuery</name></type> <name>query</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>slop</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name><name>PhraseQuery</name><operator>.</operator><name>Builder</name></name></type> <name>builder</name> <init>= <expr><operator>new</operator> <call><name><name>PhraseQuery</name><operator>.</operator><name>Builder</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>builder</name><operator>.</operator><name>setSlop</name></name><argument_list>(<argument><expr><name>slop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>index</name><operator>.</operator><name>Term</name><index>[]</index></name></type> <name>terms</name> <init>= <expr><call><name><name>query</name><operator>.</operator><name>getTerms</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>int</name><index>[]</index></name></type> <name>positions</name> <init>= <expr><call><name><name>query</name><operator>.</operator><name>getPositions</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>terms</name><operator>.</operator><name>length</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
      <expr_stmt><expr><call><name><name>builder</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name><name>terms</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>positions</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <return>return <expr><call><name><name>builder</name><operator>.</operator><name>build</name></name><argument_list>()</argument_list></call></expr>;</return>
  </block_content>}</block></function>

   <decl_stmt><decl><type><specifier>protected</specifier> <name>Query</name></type> <name>getRangeQuery</name><argument_list>(<argument><expr><name>String</name> <name>field</name></expr></argument>,
                                 <argument><expr><name>String</name> <name>part1</name></expr></argument>,
                                 <argument><expr><name>String</name> <name>part2</name></expr></argument>,
<argument><expr><name>diff</name> <operator>--</operator><name>git</name> <name>a</name><operator>/</operator><name>lucene</name><operator>/</operator><name>queryparser</name><operator>/</operator><name>src</name><operator>/</operator><name>test</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>queryparser</name><operator>/</operator><name>classic</name><operator>/</operator><name><name>TestMultiFieldQueryParser</name><operator>.</operator><name>java</name></name> <name>b</name><operator>/</operator><name>lucene</name><operator>/</operator><name>queryparser</name><operator>/</operator><name>src</name><operator>/</operator><name>test</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>queryparser</name><operator>/</operator><name>classic</name><operator>/</operator><name><name>TestMultiFieldQueryParser</name><operator>.</operator><name>java</name></name>
<name>index</name> <name>ed76ff5009f</name><operator>..</operator><name>ae15284d45b</name> <literal type="number">100644</literal>
<operator>--</operator> <name>a</name><operator>/</operator><name>lucene</name><operator>/</operator><name>queryparser</name><operator>/</operator><name>src</name><operator>/</operator><name>test</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>queryparser</name><operator>/</operator><name>classic</name><operator>/</operator><name><name>TestMultiFieldQueryParser</name><operator>.</operator><name>java</name></name>
<operator>++</operator> <name>b</name><operator>/</operator><name>lucene</name><operator>/</operator><name>queryparser</name><operator>/</operator><name>src</name><operator>/</operator><name>test</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>queryparser</name><operator>/</operator><name>classic</name><operator>/</operator><name><name>TestMultiFieldQueryParser</name><operator>.</operator><name>java</name></name>
@@ <operator>-</operator><literal type="number">21</literal></expr></argument>,<argument><expr><literal type="number">15</literal> <operator>+</operator><literal type="number">21</literal></expr></argument>,<argument><expr><literal type="number">19</literal> @@</expr></argument></argument_list></decl></decl_stmt> <import>import <name><name>java</name><operator>.</operator><name>io</name><operator>.</operator><name>StringReader</name></name>;</import>
 <import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>HashMap</name></name>;</import>
 <import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>Map</name></name>;</import>
 
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>analysis</name><operator>.</operator><name>*</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>analysis</name><operator>.</operator><name>Analyzer</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>analysis</name><operator>.</operator><name>MockAnalyzer</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>analysis</name><operator>.</operator><name>MockSynonymFilter</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>analysis</name><operator>.</operator><name>MockTokenizer</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>analysis</name><operator>.</operator><name>Tokenizer</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>document</name><operator>.</operator><name>Document</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>document</name><operator>.</operator><name>Field</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>index</name><operator>.</operator><name>DirectoryReader</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>index</name><operator>.</operator><name>IndexReader</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>index</name><operator>.</operator><name>IndexWriter</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>index</name><operator>.</operator><name>Term</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>search</name><operator>.</operator><name>BooleanClause</name><operator>.</operator><name>Occur</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>search</name><operator>.</operator><name>BooleanClause</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>search</name><operator>.</operator><name>BooleanClause</name><operator>.</operator><name>Occur</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>search</name><operator>.</operator><name>BooleanQuery</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>search</name><operator>.</operator><name>IndexSearcher</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>search</name><operator>.</operator><name>Query</name></name>;</import>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">347</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">351</literal></expr><operator>,</operator><expr><literal type="number">8</literal> @@ <specifier>public</specifier> <name>class</name> <name>TestMultiFieldQueryParser</name> extends <name>LuceneTestCase</name> <block>{
     <expr><call><name>assertEquals</name><argument_list>(<argument><expr><literal type="string">"Synonym(b:dog b:dogs) Synonym(t:dog t:dogs)"</literal></expr></argument>, <argument><expr><call><name><name>q</name><operator>.</operator><name>toString</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
     <name>q</name> <operator>=</operator> <call><name><name>parser</name><operator>.</operator><name>parse</name></name><argument_list>(<argument><expr><literal type="string">"guinea pig"</literal></expr></argument>)</argument_list></call></block></expr>;</expr_stmt>
     <expr_stmt><expr><call><name>assertFalse</name><argument_list>(<argument><expr><call><name><name>parser</name><operator>.</operator><name>getSplitOnWhitespace</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><literal type="string">"(Synonym(b:cavy b:guinea) Synonym(t:cavy t:guinea)) (b:pig t:pig)"</literal></expr></argument>, <argument><expr><call><name><name>q</name><operator>.</operator><name>toString</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><literal type="string">"Graph(b:guinea b:pig, b:cavy, hasBoolean=true, hasPhrase=false) "</literal>
        <operator>+</operator> <literal type="string">"Graph(t:guinea t:pig, t:cavy, hasBoolean=true, hasPhrase=false)"</literal></expr></argument>, <argument><expr><call><name><name>q</name><operator>.</operator><name>toString</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
     <expr_stmt><expr><call><name><name>parser</name><operator>.</operator><name>setSplitOnWhitespace</name></name><argument_list>(<argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
     <expr_stmt><expr><name>q</name> <operator>=</operator> <call><name><name>parser</name><operator>.</operator><name>parse</name></name><argument_list>(<argument><expr><literal type="string">"guinea pig"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
     <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><literal type="string">"(b:guinea t:guinea) (b:pig t:pig)"</literal></expr></argument>, <argument><expr><call><name><name>q</name><operator>.</operator><name>toString</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>diff</name> <operator>--</operator><name>git</name> <name>a</name><operator>/</operator><name>lucene</name><operator>/</operator><name>queryparser</name><operator>/</operator><name>src</name><operator>/</operator><name>test</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>queryparser</name><operator>/</operator><name>classic</name><operator>/</operator><name><name>TestQueryParser</name><operator>.</operator><name>java</name></name> <name>b</name><operator>/</operator><name>lucene</name><operator>/</operator><name>queryparser</name><operator>/</operator><name>src</name><operator>/</operator><name>test</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>queryparser</name><operator>/</operator><name>classic</name><operator>/</operator><name><name>TestQueryParser</name><operator>.</operator><name>java</name></name>
<name>index</name> <name>bb976249bf6</name><operator>..</operator><literal type="number">87bc89fa4f7</literal> <literal type="number">100644</literal>
<operator>--</operator> <name>a</name><operator>/</operator><name>lucene</name><operator>/</operator><name>queryparser</name><operator>/</operator><name>src</name><operator>/</operator><name>test</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>queryparser</name><operator>/</operator><name>classic</name><operator>/</operator><name><name>TestQueryParser</name><operator>.</operator><name>java</name></name>
<operator>++</operator> <name>b</name><operator>/</operator><name>lucene</name><operator>/</operator><name>queryparser</name><operator>/</operator><name>src</name><operator>/</operator><name>test</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>queryparser</name><operator>/</operator><name>classic</name><operator>/</operator><name><name>TestQueryParser</name><operator>.</operator><name>java</name></name>
@@ <operator>-</operator><literal type="number">16</literal></expr><operator>,</operator><expr><literal type="number">6</literal> <operator>+</operator><literal type="number">16</literal></expr><operator>,</operator><expr><literal type="number">8</literal> @@
  <operator>*</operator><operator>/</operator></expr></expr_stmt>
 <package>package <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>queryparser</name><operator>.</operator><name>classic</name></name>;</package>
 
<import>import <name><name>java</name><operator>.</operator><name>io</name><operator>.</operator><name>IOException</name></name>;</import>

 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>analysis</name><operator>.</operator><name>Analyzer</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>analysis</name><operator>.</operator><name>MockAnalyzer</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>analysis</name><operator>.</operator><name>MockBytesAnalyzer</name></name>;</import>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">27</literal></expr><operator>,</operator><expr><literal type="number">10</literal> <operator>+</operator><literal type="number">29</literal></expr><operator>,</operator><expr><literal type="number">10</literal> @@</expr></expr_stmt> <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>analysis</name><operator>.</operator><name>TokenStream</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>analysis</name><operator>.</operator><name>Tokenizer</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>analysis</name><operator>.</operator><name>tokenattributes</name><operator>.</operator><name>CharTermAttribute</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>analysis</name><operator>.</operator><name>tokenattributes</name><operator>.</operator><name>PositionIncrementAttribute</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>document</name><operator>.</operator><name>DateTools</name><operator>.</operator><name>Resolution</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>document</name><operator>.</operator><name>Document</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>document</name><operator>.</operator><name>Field</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>document</name><operator>.</operator><name>FieldType</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>document</name><operator>.</operator><name>DateTools</name><operator>.</operator><name>Resolution</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>index</name><operator>.</operator><name>DirectoryReader</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>index</name><operator>.</operator><name>IndexOptions</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>index</name><operator>.</operator><name>RandomIndexWriter</name></name>;</import>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">41</literal></expr><operator>,</operator><expr><literal type="number">6</literal> <operator>+</operator><literal type="number">43</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@</expr></expr_stmt> <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>queryparser</name><operator>.</operator><name>util</name><operator>.</operator><name>QueryParserTestBase</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>search</name><operator>.</operator><name>BooleanClause</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>search</name><operator>.</operator><name>BooleanQuery</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>search</name><operator>.</operator><name>BoostQuery</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>search</name><operator>.</operator><name>GraphQuery</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>search</name><operator>.</operator><name>IndexSearcher</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>search</name><operator>.</operator><name>MatchAllDocsQuery</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>search</name><operator>.</operator><name>MultiPhraseQuery</name></name>;</import>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">51</literal></expr><operator>,</operator><expr><literal type="number">8</literal> <operator>+</operator><literal type="number">54</literal></expr><operator>,</operator><expr><literal type="number">6</literal> @@</expr></expr_stmt> <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>search</name><operator>.</operator><name>TermQuery</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>store</name><operator>.</operator><name>Directory</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>util</name><operator>.</operator><name>automaton</name><operator>.</operator><name>TooComplexToDeterminizeException</name></name>;</import>
 
<import>import <name><name>java</name><operator>.</operator><name>io</name><operator>.</operator><name>IOException</name></name>;</import>

 <comment type="block" format="javadoc">/**
  * Tests QueryParser.
  */</comment>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">502</literal></expr><operator>,</operator><expr><literal type="number">32</literal> <operator>+</operator><literal type="number">503</literal></expr><operator>,</operator><expr><literal type="number">34</literal> @@ <specifier>public</specifier> <name>class</name> <name>TestQueryParser</name> extends <name>QueryParserTestBase</name> <block>{
     <expr><name>QueryParser</name> <name>dumb</name> <operator>=</operator> <operator>new</operator> <call><name>QueryParser</name><argument_list>(<argument><expr><literal type="string">"field"</literal></expr></argument>, <argument><expr><operator>new</operator> <call><name>Analyzer1</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
     <call><name><name>dumb</name><operator>.</operator><name>setSplitOnWhitespace</name></name><argument_list>(<argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></block></expr>;</expr_stmt>
 
    <comment type="line">// A multi-word synonym source will form a synonym query for the same-starting-position tokens</comment>
    <decl_stmt><decl><type><name><name>BooleanQuery</name><operator>.</operator><name>Builder</name></name></type> <name>multiWordExpandedBqBuilder</name> <init>= <expr><operator>new</operator> <call><name><name>BooleanQuery</name><operator>.</operator><name>Builder</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Query</name></type> <name>multiWordSynonymQuery</name> <init>= <expr><operator>new</operator> <call><name>SynonymQuery</name><argument_list>(<argument><expr><operator>new</operator> <call><name>Term</name><argument_list>(<argument><expr><literal type="string">"field"</literal></expr></argument>, <argument><expr><literal type="string">"guinea"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>new</operator> <call><name>Term</name><argument_list>(<argument><expr><literal type="string">"field"</literal></expr></argument>, <argument><expr><literal type="string">"cavy"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>multiWordExpandedBqBuilder</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name>multiWordSynonymQuery</name></expr></argument>, <argument><expr><name><name>BooleanClause</name><operator>.</operator><name>Occur</name><operator>.</operator><name>SHOULD</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>multiWordExpandedBqBuilder</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><operator>new</operator> <call><name>TermQuery</name><argument_list>(<argument><expr><operator>new</operator> <call><name>Term</name><argument_list>(<argument><expr><literal type="string">"field"</literal></expr></argument>, <argument><expr><literal type="string">"pig"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>BooleanClause</name><operator>.</operator><name>Occur</name><operator>.</operator><name>SHOULD</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>Query</name></type> <name>multiWordExpandedBq</name> <init>= <expr><call><name><name>multiWordExpandedBqBuilder</name><operator>.</operator><name>build</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><name>multiWordExpandedBq</name></expr></argument>, <argument><expr><call><name><name>dumb</name><operator>.</operator><name>parse</name></name><argument_list>(<argument><expr><literal type="string">"guinea pig"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// With the phrase operator, a multi-word synonym source will form a multiphrase query.</comment>
    <comment type="line">// When the number of expanded term(s) is different from that of the original term(s), this is not good.</comment>
    <decl_stmt><decl><type><name><name>MultiPhraseQuery</name><operator>.</operator><name>Builder</name></name></type> <name>multiWordExpandedMpqBuilder</name> <init>= <expr><operator>new</operator> <call><name><name>MultiPhraseQuery</name><operator>.</operator><name>Builder</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>multiWordExpandedMpqBuilder</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><operator>new</operator> <name><name>Term</name><index>[]</index></name><block>{<expr><operator>new</operator> <call><name>Term</name><argument_list>(<argument><expr><literal type="string">"field"</literal></expr></argument>, <argument><expr><literal type="string">"guinea"</literal></expr></argument>)</argument_list></call></expr>, <expr><operator>new</operator> <call><name>Term</name><argument_list>(<argument><expr><literal type="string">"field"</literal></expr></argument>, <argument><expr><literal type="string">"cavy"</literal></expr></argument>)</argument_list></call></expr>}</block></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>multiWordExpandedMpqBuilder</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><operator>new</operator> <call><name>Term</name><argument_list>(<argument><expr><literal type="string">"field"</literal></expr></argument>, <argument><expr><literal type="string">"pig"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>Query</name></type> <name>multiWordExpandedMPQ</name> <init>= <expr><call><name><name>multiWordExpandedMpqBuilder</name><operator>.</operator><name>build</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><name>multiWordExpandedMPQ</name></expr></argument>, <argument><expr><call><name><name>dumb</name><operator>.</operator><name>parse</name></name><argument_list>(<argument><expr><literal type="string">"\"guinea pig\""</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>TermQuery</name></type> <name>guinea</name> <init>= <expr><operator>new</operator> <call><name>TermQuery</name><argument_list>(<argument><expr><operator>new</operator> <call><name>Term</name><argument_list>(<argument><expr><literal type="string">"field"</literal></expr></argument>, <argument><expr><literal type="string">"guinea"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TermQuery</name></type> <name>pig</name> <init>= <expr><operator>new</operator> <call><name>TermQuery</name><argument_list>(<argument><expr><operator>new</operator> <call><name>Term</name><argument_list>(<argument><expr><literal type="string">"field"</literal></expr></argument>, <argument><expr><literal type="string">"pig"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TermQuery</name></type> <name>cavy</name> <init>= <expr><operator>new</operator> <call><name>TermQuery</name><argument_list>(<argument><expr><operator>new</operator> <call><name>Term</name><argument_list>(<argument><expr><literal type="string">"field"</literal></expr></argument>, <argument><expr><literal type="string">"cavy"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="line">// A multi-word synonym source will form a graph query for synonyms that formed the graph token stream</comment>
    <decl_stmt><decl><type><name><name>BooleanQuery</name><operator>.</operator><name>Builder</name></name></type> <name>synonym</name> <init>= <expr><operator>new</operator> <call><name><name>BooleanQuery</name><operator>.</operator><name>Builder</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>synonym</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name>guinea</name></expr></argument>, <argument><expr><name><name>BooleanClause</name><operator>.</operator><name>Occur</name><operator>.</operator><name>SHOULD</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>synonym</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name>pig</name></expr></argument>, <argument><expr><name><name>BooleanClause</name><operator>.</operator><name>Occur</name><operator>.</operator><name>SHOULD</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>BooleanQuery</name></type> <name>guineaPig</name> <init>= <expr><call><name><name>synonym</name><operator>.</operator><name>build</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>GraphQuery</name></type> <name>graphQuery</name> <init>= <expr><operator>new</operator> <call><name>GraphQuery</name><argument_list>(<argument><expr><name>guineaPig</name></expr></argument>, <argument><expr><name>cavy</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><name>graphQuery</name></expr></argument>, <argument><expr><call><name><name>dumb</name><operator>.</operator><name>parse</name></name><argument_list>(<argument><expr><literal type="string">"guinea pig"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// With the phrase operator, a multi-word synonym source will form a graph query with inner phrase queries.</comment>
    <decl_stmt><decl><type><name><name>PhraseQuery</name><operator>.</operator><name>Builder</name></name></type> <name>phraseSynonym</name> <init>= <expr><operator>new</operator> <call><name><name>PhraseQuery</name><operator>.</operator><name>Builder</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>phraseSynonym</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><operator>new</operator> <call><name>Term</name><argument_list>(<argument><expr><literal type="string">"field"</literal></expr></argument>, <argument><expr><literal type="string">"guinea"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>phraseSynonym</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><operator>new</operator> <call><name>Term</name><argument_list>(<argument><expr><literal type="string">"field"</literal></expr></argument>, <argument><expr><literal type="string">"pig"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>PhraseQuery</name></type> <name>guineaPigPhrase</name> <init>= <expr><call><name><name>phraseSynonym</name><operator>.</operator><name>build</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>graphQuery</name> <operator>=</operator> <operator>new</operator> <call><name>GraphQuery</name><argument_list>(<argument><expr><name>guineaPigPhrase</name></expr></argument>, <argument><expr><name>cavy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><name>graphQuery</name></expr></argument>, <argument><expr><call><name><name>dumb</name><operator>.</operator><name>parse</name></name><argument_list>(<argument><expr><literal type="string">"\"guinea pig\""</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
 
     <comment type="line">// custom behavior, the synonyms are expanded, unless you use quote operator</comment>
     <decl_stmt><decl><type><name>QueryParser</name></type> <name>smart</name> <init>= <expr><operator>new</operator> <call><name>SmartQueryParser</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
     <expr_stmt><expr><call><name><name>smart</name><operator>.</operator><name>setSplitOnWhitespace</name></name><argument_list>(<argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><name>multiWordExpandedBq</name></expr></argument>, <argument><expr><call><name><name>smart</name><operator>.</operator><name>parse</name></name><argument_list>(<argument><expr><literal type="string">"guinea pig"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name><name>PhraseQuery</name><operator>.</operator><name>Builder</name></name></type> <name>multiWordUnexpandedPqBuilder</name> <init>= <expr><operator>new</operator> <call><name><name>PhraseQuery</name><operator>.</operator><name>Builder</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>multiWordUnexpandedPqBuilder</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><operator>new</operator> <call><name>Term</name><argument_list>(<argument><expr><literal type="string">"field"</literal></expr></argument>, <argument><expr><literal type="string">"guinea"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>multiWordUnexpandedPqBuilder</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><operator>new</operator> <call><name>Term</name><argument_list>(<argument><expr><literal type="string">"field"</literal></expr></argument>, <argument><expr><literal type="string">"pig"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>Query</name></type> <name>multiWordUnexpandedPq</name> <init>= <expr><call><name><name>multiWordUnexpandedPqBuilder</name><operator>.</operator><name>build</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><name>multiWordUnexpandedPq</name></expr></argument>, <argument><expr><call><name><name>smart</name><operator>.</operator><name>parse</name></name><argument_list>(<argument><expr><literal type="string">"\"guinea pig\""</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>graphQuery</name> <operator>=</operator> <operator>new</operator> <call><name>GraphQuery</name><argument_list>(<argument><expr><name>guineaPig</name></expr></argument>, <argument><expr><name>cavy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><name>graphQuery</name></expr></argument>, <argument><expr><call><name><name>smart</name><operator>.</operator><name>parse</name></name><argument_list>(<argument><expr><literal type="string">"guinea pig"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><name>guineaPigPhrase</name></expr></argument>, <argument><expr><call><name><name>smart</name><operator>.</operator><name>parse</name></name><argument_list>(<argument><expr><literal type="string">"\"guinea pig\""</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
   </block_content>}</block></if></if_stmt>
 
   <comment type="line">// TODO: Move to QueryParserTestBase once standard flexible parser gets this capability</comment>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">580</literal></expr><operator>,</operator><expr><literal type="number">34</literal> <operator>+</operator><literal type="number">583</literal></expr><operator>,</operator><expr><literal type="number">34</literal> @@ <specifier>public</specifier> <name>class</name> <name>TestQueryParser</name> extends <name>QueryParserTestBase</name> <block>{
     <expr><call><name>assertQueryEquals</name><argument_list>(<argument><expr><literal type="string">"guinea /pig/"</literal></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="string">"guinea /pig/"</literal></expr></argument>)</argument_list></call></expr>;
 
     <comment type="line">// Operators should not interrupt multiword analysis if not don't associate</comment>
    <expr><call><name>assertQueryEquals</name><argument_list>(<argument><expr><literal type="string">"(guinea pig)"</literal></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="string">"Synonym(cavy guinea) pig"</literal></expr></argument>)</argument_list></call></expr>;
    <expr><call><name>assertQueryEquals</name><argument_list>(<argument><expr><literal type="string">"+(guinea pig)"</literal></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="string">"+(Synonym(cavy guinea) pig)"</literal></expr></argument>)</argument_list></call></expr>;
    <expr><call><name>assertQueryEquals</name><argument_list>(<argument><expr><literal type="string">"-(guinea pig)"</literal></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="string">"-(Synonym(cavy guinea) pig)"</literal></expr></argument>)</argument_list></call></expr>;
    <expr><call><name>assertQueryEquals</name><argument_list>(<argument><expr><literal type="string">"!(guinea pig)"</literal></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="string">"-(Synonym(cavy guinea) pig)"</literal></expr></argument>)</argument_list></call></expr>;
    <expr><call><name>assertQueryEquals</name><argument_list>(<argument><expr><literal type="string">"NOT (guinea pig)"</literal></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="string">"-(Synonym(cavy guinea) pig)"</literal></expr></argument>)</argument_list></call></expr>;
    <expr><call><name>assertQueryEquals</name><argument_list>(<argument><expr><literal type="string">"(guinea pig)^2"</literal></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="string">"(Synonym(cavy guinea) pig)^2.0"</literal></expr></argument>)</argument_list></call></expr>;

    <expr><call><name>assertQueryEquals</name><argument_list>(<argument><expr><literal type="string">"field:(guinea pig)"</literal></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="string">"Synonym(cavy guinea) pig"</literal></expr></argument>)</argument_list></call></expr>;

    <expr><call><name>assertQueryEquals</name><argument_list>(<argument><expr><literal type="string">"+small guinea pig"</literal></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="string">"+small Synonym(cavy guinea) pig"</literal></expr></argument>)</argument_list></call></expr>;
    <expr><call><name>assertQueryEquals</name><argument_list>(<argument><expr><literal type="string">"-small guinea pig"</literal></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="string">"-small Synonym(cavy guinea) pig"</literal></expr></argument>)</argument_list></call></expr>;
    <expr><call><name>assertQueryEquals</name><argument_list>(<argument><expr><literal type="string">"!small guinea pig"</literal></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="string">"-small Synonym(cavy guinea) pig"</literal></expr></argument>)</argument_list></call></expr>;
    <expr><call><name>assertQueryEquals</name><argument_list>(<argument><expr><literal type="string">"NOT small guinea pig"</literal></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="string">"-small Synonym(cavy guinea) pig"</literal></expr></argument>)</argument_list></call></expr>;
    <expr><call><name>assertQueryEquals</name><argument_list>(<argument><expr><literal type="string">"small* guinea pig"</literal></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="string">"small* Synonym(cavy guinea) pig"</literal></expr></argument>)</argument_list></call></expr>;
    <expr><call><name>assertQueryEquals</name><argument_list>(<argument><expr><literal type="string">"small? guinea pig"</literal></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="string">"small? Synonym(cavy guinea) pig"</literal></expr></argument>)</argument_list></call></expr>;
    <expr><call><name>assertQueryEquals</name><argument_list>(<argument><expr><literal type="string">"\"small\" guinea pig"</literal></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="string">"small Synonym(cavy guinea) pig"</literal></expr></argument>)</argument_list></call></expr>;

    <expr><call><name>assertQueryEquals</name><argument_list>(<argument><expr><literal type="string">"guinea pig +running"</literal></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="string">"Synonym(cavy guinea) pig +running"</literal></expr></argument>)</argument_list></call></expr>;
    <expr><call><name>assertQueryEquals</name><argument_list>(<argument><expr><literal type="string">"guinea pig -running"</literal></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="string">"Synonym(cavy guinea) pig -running"</literal></expr></argument>)</argument_list></call></expr>;
    <expr><call><name>assertQueryEquals</name><argument_list>(<argument><expr><literal type="string">"guinea pig !running"</literal></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="string">"Synonym(cavy guinea) pig -running"</literal></expr></argument>)</argument_list></call></expr>;
    <expr><call><name>assertQueryEquals</name><argument_list>(<argument><expr><literal type="string">"guinea pig NOT running"</literal></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="string">"Synonym(cavy guinea) pig -running"</literal></expr></argument>)</argument_list></call></expr>;
    <expr><call><name>assertQueryEquals</name><argument_list>(<argument><expr><literal type="string">"guinea pig running*"</literal></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="string">"Synonym(cavy guinea) pig running*"</literal></expr></argument>)</argument_list></call></expr>;
    <expr><call><name>assertQueryEquals</name><argument_list>(<argument><expr><literal type="string">"guinea pig running?"</literal></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="string">"Synonym(cavy guinea) pig running?"</literal></expr></argument>)</argument_list></call></expr>;
    <expr><call><name>assertQueryEquals</name><argument_list>(<argument><expr><literal type="string">"guinea pig \"running\""</literal></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="string">"Synonym(cavy guinea) pig running"</literal></expr></argument>)</argument_list></call></expr>;

    <expr><call><name>assertQueryEquals</name><argument_list>(<argument><expr><literal type="string">"\"guinea pig\"~2"</literal></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="string">"\"(guinea cavy) pig\"~2"</literal></expr></argument>)</argument_list></call></expr>;

    <expr><call><name>assertQueryEquals</name><argument_list>(<argument><expr><literal type="string">"field:\"guinea pig\""</literal></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="string">"\"(guinea cavy) pig\""</literal></expr></argument>)</argument_list></call></expr>;
    <expr><call><name>assertQueryEquals</name><argument_list>(<argument><expr><literal type="string">"(guinea pig)"</literal></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="string">"Graph(field:guinea field:pig, field:cavy, hasBoolean=true, hasPhrase=false)"</literal></expr></argument>)</argument_list></call></expr>;
    <expr><call><name>assertQueryEquals</name><argument_list>(<argument><expr><literal type="string">"+(guinea pig)"</literal></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="string">"+Graph(field:guinea field:pig, field:cavy, hasBoolean=true, hasPhrase=false)"</literal></expr></argument>)</argument_list></call></expr>;
    <expr><call><name>assertQueryEquals</name><argument_list>(<argument><expr><literal type="string">"-(guinea pig)"</literal></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="string">"-Graph(field:guinea field:pig, field:cavy, hasBoolean=true, hasPhrase=false)"</literal></expr></argument>)</argument_list></call></expr>;
    <expr><call><name>assertQueryEquals</name><argument_list>(<argument><expr><literal type="string">"!(guinea pig)"</literal></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="string">"-Graph(field:guinea field:pig, field:cavy, hasBoolean=true, hasPhrase=false)"</literal></expr></argument>)</argument_list></call></expr>;
    <expr><call><name>assertQueryEquals</name><argument_list>(<argument><expr><literal type="string">"NOT (guinea pig)"</literal></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="string">"-Graph(field:guinea field:pig, field:cavy, hasBoolean=true, hasPhrase=false)"</literal></expr></argument>)</argument_list></call></expr>;
    <expr><call><name>assertQueryEquals</name><argument_list>(<argument><expr><literal type="string">"(guinea pig)^2"</literal></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="string">"(Graph(field:guinea field:pig, field:cavy, hasBoolean=true, hasPhrase=false))^2.0"</literal></expr></argument>)</argument_list></call></expr>;

    <expr><call><name>assertQueryEquals</name><argument_list>(<argument><expr><literal type="string">"field:(guinea pig)"</literal></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="string">"Graph(field:guinea field:pig, field:cavy, hasBoolean=true, hasPhrase=false)"</literal></expr></argument>)</argument_list></call></expr>;

    <expr><call><name>assertQueryEquals</name><argument_list>(<argument><expr><literal type="string">"+small guinea pig"</literal></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="string">"+small Graph(field:guinea field:pig, field:cavy, hasBoolean=true, hasPhrase=false)"</literal></expr></argument>)</argument_list></call></expr>;
    <expr><call><name>assertQueryEquals</name><argument_list>(<argument><expr><literal type="string">"-small guinea pig"</literal></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="string">"-small Graph(field:guinea field:pig, field:cavy, hasBoolean=true, hasPhrase=false)"</literal></expr></argument>)</argument_list></call></expr>;
    <expr><call><name>assertQueryEquals</name><argument_list>(<argument><expr><literal type="string">"!small guinea pig"</literal></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="string">"-small Graph(field:guinea field:pig, field:cavy, hasBoolean=true, hasPhrase=false)"</literal></expr></argument>)</argument_list></call></expr>;
    <expr><call><name>assertQueryEquals</name><argument_list>(<argument><expr><literal type="string">"NOT small guinea pig"</literal></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="string">"-small Graph(field:guinea field:pig, field:cavy, hasBoolean=true, hasPhrase=false)"</literal></expr></argument>)</argument_list></call></expr>;
    <expr><call><name>assertQueryEquals</name><argument_list>(<argument><expr><literal type="string">"small* guinea pig"</literal></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="string">"small* Graph(field:guinea field:pig, field:cavy, hasBoolean=true, hasPhrase=false)"</literal></expr></argument>)</argument_list></call></expr>;
    <expr><call><name>assertQueryEquals</name><argument_list>(<argument><expr><literal type="string">"small? guinea pig"</literal></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="string">"small? Graph(field:guinea field:pig, field:cavy, hasBoolean=true, hasPhrase=false)"</literal></expr></argument>)</argument_list></call></expr>;
    <expr><call><name>assertQueryEquals</name><argument_list>(<argument><expr><literal type="string">"\"small\" guinea pig"</literal></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="string">"small Graph(field:guinea field:pig, field:cavy, hasBoolean=true, hasPhrase=false)"</literal></expr></argument>)</argument_list></call></expr>;

    <expr><call><name>assertQueryEquals</name><argument_list>(<argument><expr><literal type="string">"guinea pig +running"</literal></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="string">"Graph(field:guinea field:pig, field:cavy, hasBoolean=true, hasPhrase=false) +running"</literal></expr></argument>)</argument_list></call></expr>;
    <expr><call><name>assertQueryEquals</name><argument_list>(<argument><expr><literal type="string">"guinea pig -running"</literal></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="string">"Graph(field:guinea field:pig, field:cavy, hasBoolean=true, hasPhrase=false) -running"</literal></expr></argument>)</argument_list></call></expr>;
    <expr><call><name>assertQueryEquals</name><argument_list>(<argument><expr><literal type="string">"guinea pig !running"</literal></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="string">"Graph(field:guinea field:pig, field:cavy, hasBoolean=true, hasPhrase=false) -running"</literal></expr></argument>)</argument_list></call></expr>;
    <expr><call><name>assertQueryEquals</name><argument_list>(<argument><expr><literal type="string">"guinea pig NOT running"</literal></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="string">"Graph(field:guinea field:pig, field:cavy, hasBoolean=true, hasPhrase=false) -running"</literal></expr></argument>)</argument_list></call></expr>;
    <expr><call><name>assertQueryEquals</name><argument_list>(<argument><expr><literal type="string">"guinea pig running*"</literal></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="string">"Graph(field:guinea field:pig, field:cavy, hasBoolean=true, hasPhrase=false) running*"</literal></expr></argument>)</argument_list></call></expr>;
    <expr><call><name>assertQueryEquals</name><argument_list>(<argument><expr><literal type="string">"guinea pig running?"</literal></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="string">"Graph(field:guinea field:pig, field:cavy, hasBoolean=true, hasPhrase=false) running?"</literal></expr></argument>)</argument_list></call></expr>;
    <expr><call><name>assertQueryEquals</name><argument_list>(<argument><expr><literal type="string">"guinea pig \"running\""</literal></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="string">"Graph(field:guinea field:pig, field:cavy, hasBoolean=true, hasPhrase=false) running"</literal></expr></argument>)</argument_list></call></expr>;

    <expr><call><name>assertQueryEquals</name><argument_list>(<argument><expr><literal type="string">"\"guinea pig\"~2"</literal></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="string">"Graph(field:\"guinea pig\"~2, field:cavy, hasBoolean=false, hasPhrase=true)"</literal></expr></argument>)</argument_list></call></expr>;

    <expr><call><name>assertQueryEquals</name><argument_list>(<argument><expr><literal type="string">"field:\"guinea pig\""</literal></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="string">"Graph(field:\"guinea pig\", field:cavy, hasBoolean=false, hasPhrase=true)"</literal></expr></argument>)</argument_list></call></expr>;
 
     <expr><name>splitOnWhitespace</name> <operator>=</operator> <name>oldSplitOnWhitespace</name></expr>;
   }</block>
@@ <operator>-</operator><literal type="number">684</literal></expr><operator>,</operator><expr><literal type="number">9</literal> <operator>+</operator><literal type="number">687</literal></expr><operator>,</operator><expr><literal type="number">9</literal> @@ <specifier>public</specifier> <name>class</name> <name>TestQueryParser</name> extends <name>QueryParserTestBase</name> <block>{
     <expr><call><name>assertQueryEquals</name><argument_list>(<argument><expr><literal type="string">"guinea pig running?"</literal></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="string">"guinea pig running?"</literal></expr></argument>)</argument_list></call></expr>;
     <expr><call><name>assertQueryEquals</name><argument_list>(<argument><expr><literal type="string">"guinea pig \"running\""</literal></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="string">"guinea pig running"</literal></expr></argument>)</argument_list></call></expr>;
 
    <expr><call><name>assertQueryEquals</name><argument_list>(<argument><expr><literal type="string">"\"guinea pig\"~2"</literal></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="string">"\"(guinea cavy) pig\"~2"</literal></expr></argument>)</argument_list></call></expr>;
    <expr><call><name>assertQueryEquals</name><argument_list>(<argument><expr><literal type="string">"\"guinea pig\"~2"</literal></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="string">"Graph(field:\"guinea pig\"~2, field:cavy, hasBoolean=false, hasPhrase=true)"</literal></expr></argument>)</argument_list></call></expr>;
 
    <expr><call><name>assertQueryEquals</name><argument_list>(<argument><expr><literal type="string">"field:\"guinea pig\""</literal></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="string">"\"(guinea cavy) pig\""</literal></expr></argument>)</argument_list></call></expr>;
    <expr><call><name>assertQueryEquals</name><argument_list>(<argument><expr><literal type="string">"field:\"guinea pig\""</literal></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="string">"Graph(field:\"guinea pig\", field:cavy, hasBoolean=false, hasPhrase=true)"</literal></expr></argument>)</argument_list></call></expr>;
 
     <expr><name>splitOnWhitespace</name> <operator>=</operator> <name>oldSplitOnWhitespace</name></expr>;
   }</block>
@@ <operator>-</operator><literal type="number">697</literal></expr><operator>,</operator><expr><literal type="number">14</literal> <operator>+</operator><literal type="number">700</literal></expr><operator>,</operator><expr><literal type="number">22</literal> @@ <specifier>public</specifier> <name>class</name> <name>TestQueryParser</name> extends <name>QueryParserTestBase</name> <block>{
     <expr><call><name>assertFalse</name><argument_list>(<argument><expr><call><name><name>parser</name><operator>.</operator><name>getSplitOnWhitespace</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>; <comment type="line">// default is false</comment>
 
     <comment type="line">// A multi-word synonym source will form a synonym query for the same-starting-position tokens</comment>
    <expr><name><name>BooleanQuery</name><operator>.</operator><name>Builder</name></name> <name>bqBuilder</name> <operator>=</operator> <operator>new</operator> <call><name><name>BooleanQuery</name><operator>.</operator><name>Builder</name></name><argument_list>()</argument_list></call></expr>;
    <expr><call><name><name>bqBuilder</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><operator>new</operator> <call><name>SynonymQuery</name><argument_list>(<argument><expr><operator>new</operator> <call><name>Term</name><argument_list>(<argument><expr><literal type="string">"field"</literal></expr></argument>, <argument><expr><literal type="string">"guinea"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>new</operator> <call><name>Term</name><argument_list>(<argument><expr><literal type="string">"field"</literal></expr></argument>, <argument><expr><literal type="string">"cavy"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>BooleanClause</name><operator>.</operator><name>Occur</name><operator>.</operator><name>SHOULD</name></name></expr></argument>)</argument_list></call></expr>;
    <expr><call><name><name>bqBuilder</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><operator>new</operator> <call><name>TermQuery</name><argument_list>(<argument><expr><operator>new</operator> <call><name>Term</name><argument_list>(<argument><expr><literal type="string">"field"</literal></expr></argument>, <argument><expr><literal type="string">"pig"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>BooleanClause</name><operator>.</operator><name>Occur</name><operator>.</operator><name>SHOULD</name></name></expr></argument>)</argument_list></call></expr>;
    <expr><call><name>assertEquals</name><argument_list>(<argument><expr><call><name><name>bqBuilder</name><operator>.</operator><name>build</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>parser</name><operator>.</operator><name>parse</name></name><argument_list>(<argument><expr><literal type="string">"guinea pig"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
    <expr><name>TermQuery</name> <name>guinea</name> <operator>=</operator> <operator>new</operator> <call><name>TermQuery</name><argument_list>(<argument><expr><operator>new</operator> <call><name>Term</name><argument_list>(<argument><expr><literal type="string">"field"</literal></expr></argument>, <argument><expr><literal type="string">"guinea"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
    <expr><name>TermQuery</name> <name>pig</name> <operator>=</operator> <operator>new</operator> <call><name>TermQuery</name><argument_list>(<argument><expr><operator>new</operator> <call><name>Term</name><argument_list>(<argument><expr><literal type="string">"field"</literal></expr></argument>, <argument><expr><literal type="string">"pig"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
    <expr><name>TermQuery</name> <name>cavy</name> <operator>=</operator> <operator>new</operator> <call><name>TermQuery</name><argument_list>(<argument><expr><operator>new</operator> <call><name>Term</name><argument_list>(<argument><expr><literal type="string">"field"</literal></expr></argument>, <argument><expr><literal type="string">"cavy"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;

    <comment type="line">// A multi-word synonym source will form a graph query for synonyms that formed the graph token stream</comment>
    <expr><name><name>BooleanQuery</name><operator>.</operator><name>Builder</name></name> <name>synonym</name> <operator>=</operator> <operator>new</operator> <call><name><name>BooleanQuery</name><operator>.</operator><name>Builder</name></name><argument_list>()</argument_list></call></expr>;
    <expr><call><name><name>synonym</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name>guinea</name></expr></argument>, <argument><expr><name><name>BooleanClause</name><operator>.</operator><name>Occur</name><operator>.</operator><name>SHOULD</name></name></expr></argument>)</argument_list></call></expr>;
    <expr><call><name><name>synonym</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name>pig</name></expr></argument>, <argument><expr><name><name>BooleanClause</name><operator>.</operator><name>Occur</name><operator>.</operator><name>SHOULD</name></name></expr></argument>)</argument_list></call></expr>;
    <expr><name>BooleanQuery</name> <name>guineaPig</name> <operator>=</operator> <call><name><name>synonym</name><operator>.</operator><name>build</name></name><argument_list>()</argument_list></call></expr>;

    <expr><name>GraphQuery</name> <name>graphQuery</name> <operator>=</operator> <operator>new</operator> <call><name>GraphQuery</name><argument_list>(<argument><expr><name>guineaPig</name></expr></argument>, <argument><expr><name>cavy</name></expr></argument>)</argument_list></call></expr>;
    <expr><call><name>assertEquals</name><argument_list>(<argument><expr><name>graphQuery</name></expr></argument>, <argument><expr><call><name><name>parser</name><operator>.</operator><name>parse</name></name><argument_list>(<argument><expr><literal type="string">"guinea pig"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
 
     <expr><name>boolean</name> <name>oldSplitOnWhitespace</name> <operator>=</operator> <name>splitOnWhitespace</name></expr>;
     <expr><name>splitOnWhitespace</name> <operator>=</operator> <name><name>QueryParser</name><operator>.</operator><name>DEFAULT_SPLIT_ON_WHITESPACE</name></name></expr>;
    <expr><call><name>assertQueryEquals</name><argument_list>(<argument><expr><literal type="string">"guinea pig"</literal></expr></argument>, <argument><expr><operator>new</operator> <call><name>MockSynonymAnalyzer</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="string">"Synonym(cavy guinea) pig"</literal></expr></argument>)</argument_list></call></expr>;
    <expr><call><name>assertQueryEquals</name><argument_list>(<argument><expr><literal type="string">"guinea pig"</literal></expr></argument>, <argument><expr><operator>new</operator> <call><name>MockSynonymAnalyzer</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="string">"Graph(field:guinea field:pig, field:cavy, hasBoolean=true, hasPhrase=false)"</literal></expr></argument>)</argument_list></call></expr>;
     <expr><name>splitOnWhitespace</name> <operator>=</operator> <name>oldSplitOnWhitespace</name></expr>;
   }</block>
    
<operator>-</operator> 
<literal type="number">2.19.1.windows</literal><literal type="number">.1</literal></expr></expr_stmt></block_content></block></function></block_content></block></function>

</unit>
