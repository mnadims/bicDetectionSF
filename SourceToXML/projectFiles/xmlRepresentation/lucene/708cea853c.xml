<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" revision="1.0.0" language="Java" filename="E:/01Courses@USASK/CMPT898-HumanDrivenSoftwareEngineeringForScientificResearch/ProjectProgress/data_files/final_dataset/gen_patch_codes/filtered/lucene/708cea853c.java"><expr_stmt><expr><name>From</name> <literal type="number">708cea853c8b8de1556209837e5f926c019c41df</literal> <name>Mon</name> <name>Sep</name> <literal type="number">17</literal> <literal type="number">00</literal><operator>:</operator><literal type="number">00</literal><operator>:</operator><literal type="number">00</literal> <literal type="number">2001</literal>
<name>From</name><operator>:</operator> <name>Yonik</name> <name><name>Seeley</name> <argument_list type="generic">&lt;<argument><name>yonik</name><annotation>@<name><name>apache</name><operator>.</operator><name>org</name></name></annotation></argument>&gt;</argument_list></name>
<name>Date</name><operator>:</operator> <name>Thu</name></expr><operator>,</operator> <expr><literal type="number">30</literal> <name>Sep</name> <literal type="number">2010</literal> <literal type="number">15</literal><operator>:</operator><literal type="number">35</literal><operator>:</operator><literal type="number">18</literal> <operator>+</operator><literal type="number">0000</literal>
<name>Subject</name><operator>:</operator> <index>[<expr><name>PATCH</name></expr>]</index> <name>SOLR</name><operator>-</operator><literal type="number">1297</literal><operator>:</operator> <name>fix</name> <name>sort</name> <name>by</name> <name>function</name> <name>parsing</name>

<name>git</name><operator>-</operator><name>svn</name><operator>-</operator><name>id</name><operator>:</operator> <name>https</name><operator>:</operator><comment type="line">//svn.apache.org/repos/asf/lucene/dev/trunk@1003107 13f79535-47bb-0310-9956-ffa450edef68</comment>
<operator>--</operator>
 <name>solr</name><operator>/</operator><name><name>CHANGES</name><operator>.</operator><name>txt</name></name>                              <operator>|</operator>   <literal type="number">2</literal> <operator>+</operator><operator>-</operator>
 <operator>...</operator><operator>/</operator><name>handler</name><operator>/</operator><name>component</name><operator>/</operator><name><name>QueryComponent</name><operator>.</operator><name>java</name></name>     <operator>|</operator>   <literal type="number">4</literal> <operator>+</operator><operator>-</operator>
 <operator>...</operator><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>search</name><operator>/</operator><name><name>FunctionQParser</name><operator>.</operator><name>java</name></name>   <operator>|</operator>   <literal type="number">2</literal> <operator>+</operator><operator>-</operator>
 <operator>...</operator><operator>/</operator><name>solr</name><operator>/</operator><name>search</name><operator>/</operator><name><name>LuceneQParserPlugin</name><operator>.</operator><name>java</name></name>      <operator>|</operator>   <literal type="number">2</literal> <operator>+</operator><operator>-</operator>
 <operator>...</operator><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>search</name><operator>/</operator><name><name>QParser</name><operator>.</operator><name>java</name></name>  <operator>|</operator>  <literal type="number">43</literal> <operator>++</operator><operator>-</operator>
 <operator>...</operator><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>search</name><operator>/</operator><name><name>QueryParsing</name><operator>.</operator><name>java</name></name>  <operator>|</operator> <literal type="number">271</literal> <operator>++</operator><operator>++</operator><operator>++</operator><operator>++</operator><operator>+</operator><operator>--</operator><operator>--</operator><operator>--</operator><operator>--</operator><operator>-</operator>
 <operator>...</operator><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>tst</name><operator>/</operator><name><name>OldRequestHandler</name><operator>.</operator><name>java</name></name>    <operator>|</operator>   <literal type="number">2</literal> <operator>+</operator><operator>-</operator>
 <operator>...</operator><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>tst</name><operator>/</operator><name><name>TestRequestHandler</name><operator>.</operator><name>java</name></name>   <operator>|</operator>   <literal type="number">2</literal> <operator>+</operator><operator>-</operator>
 <operator>...</operator><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>util</name><operator>/</operator><name><name>SolrPluginUtils</name><operator>.</operator><name>java</name></name> <operator>|</operator>  <literal type="number">20</literal> <operator>+</operator><operator>-</operator>
 <operator>...</operator><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>search</name><operator>/</operator><name><name>QueryParsingTest</name><operator>.</operator><name>java</name></name>  <operator>|</operator>  <literal type="number">45</literal> <operator>+</operator><operator>--</operator>
 <operator>...</operator><operator>/</operator><name>search</name><operator>/</operator><name>function</name><operator>/</operator><name><name>TestFunctionQuery</name><operator>.</operator><name>java</name></name>    <operator>|</operator>  <literal type="number">46</literal> <operator>++</operator><operator>+</operator>
 <literal type="number">11</literal> <name>files</name> <name>changed</name></expr><operator>,</operator> <expr><literal type="number">262</literal> <call><name>insertions</name><argument_list>(<argument><expr><operator>+</operator></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><literal type="number">177</literal> <call><name>deletions</name><argument_list>(<argument><expr><operator>-</operator></expr></argument>)</argument_list></call>

<name>diff</name> <operator>--</operator><name>git</name> <name>a</name><operator>/</operator><name>solr</name><operator>/</operator><name><name>CHANGES</name><operator>.</operator><name>txt</name></name> <name>b</name><operator>/</operator><name>solr</name><operator>/</operator><name><name>CHANGES</name><operator>.</operator><name>txt</name></name>
<name>index</name> <name>c67e2fbfe40</name><operator>..</operator><name>a6ae2419f39</name> <literal type="number">100644</literal>
<operator>--</operator> <name>a</name><operator>/</operator><name>solr</name><operator>/</operator><name><name>CHANGES</name><operator>.</operator><name>txt</name></name>
<operator>++</operator> <name>b</name><operator>/</operator><name>solr</name><operator>/</operator><name><name>CHANGES</name><operator>.</operator><name>txt</name></name>
@@ <operator>-</operator><literal type="number">118</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">118</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@ <name>New</name> <name>Features</name>
 
 <operator>*</operator> <name>SOLR</name><operator>-</operator><literal type="number">1625</literal><operator>:</operator> <name>Add</name> <name>regexp</name> <name>support</name></expr></expr_stmt> <for>for TermsComponent <control>(<init><expr><name>Uri</name> <name>Boness</name> <name>via</name> <name>noble</name></expr></init>)</control><block type="pseudo"><block_content>
 
<expr_stmt><expr><operator>*</operator> <name>SOLR</name><operator>-</operator><literal type="number">1297</literal><operator>:</operator> <name>Add</name> <name>sort</name> <name>by</name> <name>Function</name> <call><name>capability</name> <argument_list>(<argument><expr><name>gsingers</name></expr></argument>)</argument_list></call>
<operator>*</operator> <name>SOLR</name><operator>-</operator><literal type="number">1297</literal><operator>:</operator> <name>Add</name> <name>sort</name> <name>by</name> <name>Function</name> <call><name>capability</name> <argument_list>(<argument><expr><name>gsingers</name></expr></argument>, <argument><expr><name>yonik</name></expr></argument>)</argument_list></call>
 
 <operator>*</operator> <name>SOLR</name><operator>-</operator><literal type="number">1139</literal><operator>:</operator> <name>Add</name> <name>TermsComponent</name> <name>Query</name> <name>and</name> <name>Response</name> <name>Support</name> <name>in</name> <call><name>SolrJ</name> <argument_list>(<argument><expr><name>Matt</name> <name>Weber</name> <name>via</name> <name>shalin</name></expr></argument>)</argument_list></call>
 
<name>diff</name> <operator>--</operator><name>git</name> <name>a</name><operator>/</operator><name>solr</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>handler</name><operator>/</operator><name>component</name><operator>/</operator><name><name>QueryComponent</name><operator>.</operator><name>java</name></name> <name>b</name><operator>/</operator><name>solr</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>handler</name><operator>/</operator><name>component</name><operator>/</operator><name><name>QueryComponent</name><operator>.</operator><name>java</name></name>
<name>index</name> <literal type="number">9fe18f5e5be</literal><operator>..</operator><name>c32eb1bafd7</name> <literal type="number">100644</literal>
<operator>--</operator> <name>a</name><operator>/</operator><name>solr</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>handler</name><operator>/</operator><name>component</name><operator>/</operator><name><name>QueryComponent</name><operator>.</operator><name>java</name></name>
<operator>++</operator> <name>b</name><operator>/</operator><name>solr</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>handler</name><operator>/</operator><name>component</name><operator>/</operator><name><name>QueryComponent</name><operator>.</operator><name>java</name></name>
@@ <operator>-</operator><literal type="number">194</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">194</literal></expr><operator>,</operator><expr><literal type="number">9</literal> @@ <specifier>public</specifier> <name>class</name> <name>QueryComponent</name> extends <name>SearchComponent</name>
         <name><name>String</name><index>[]</index></name> <name>funcs</name> <operator>=</operator> <call><name><name>params</name><operator>.</operator><name>getParams</name></name><argument_list>(<argument><expr><name><name>GroupParams</name><operator>.</operator><name>GROUP_FUNC</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
         <decl_stmt><decl><type><name><name>String</name><index>[]</index></name></type> <name>queries</name> <init>= <expr><call><name><name>params</name><operator>.</operator><name>getParams</name></name><argument_list>(<argument><expr><name><name>GroupParams</name><operator>.</operator><name>GROUP_QUERY</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
         <decl_stmt><decl><type><name>String</name></type> <name>groupSortStr</name> <init>= <expr><call><name><name>params</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name><name>GroupParams</name><operator>.</operator><name>GROUP_SORT</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Sort</name></type> <name>groupSort</name> <init>= <expr><ternary><condition><expr><name>groupSortStr</name> <operator>!=</operator> <literal type="null">null</literal></expr> ?</condition><then> <expr><call><name><name>QueryParsing</name><operator>.</operator><name>parseSort</name></name><argument_list>(<argument><expr><name>groupSortStr</name></expr></argument>, <argument><expr><call><name><name>req</name><operator>.</operator><name>getSchema</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="null">null</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

        <comment type="line">// TODO: don't use groupSort==null to test for the presense of a sort since "score desc" will normalize to null</comment>
        <decl_stmt><decl><type><name>Sort</name></type> <name>groupSort</name> <init>= <expr><ternary><condition><expr><name>groupSortStr</name> <operator>!=</operator> <literal type="null">null</literal></expr> ?</condition><then> <expr><call><name><name>QueryParsing</name><operator>.</operator><name>parseSort</name></name><argument_list>(<argument><expr><name>groupSortStr</name></expr></argument>, <argument><expr><name>req</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="null">null</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
 
         <decl_stmt><decl><type><name>int</name></type> <name>limitDefault</name> <init>= <expr><call><name><name>cmd</name><operator>.</operator><name>getLen</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt> <comment type="line">// this is normally from "rows"</comment>
         <decl_stmt><decl><type><name>int</name></type> <name>docsPerGroupDefault</name> <init>= <expr><call><name><name>params</name><operator>.</operator><name>getInt</name></name><argument_list>(<argument><expr><name><name>GroupParams</name><operator>.</operator><name>GROUP_LIMIT</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>diff</name> <operator>--</operator><name>git</name> <name>a</name><operator>/</operator><name>solr</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>search</name><operator>/</operator><name><name>FunctionQParser</name><operator>.</operator><name>java</name></name> <name>b</name><operator>/</operator><name>solr</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>search</name><operator>/</operator><name><name>FunctionQParser</name><operator>.</operator><name>java</name></name>
<name>index</name> <name>a2312e1ab6d</name><operator>..</operator><name>c5e710acd54</name> <literal type="number">100755</literal>
<operator>--</operator> <name>a</name><operator>/</operator><name>solr</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>search</name><operator>/</operator><name><name>FunctionQParser</name><operator>.</operator><name>java</name></name>
<operator>++</operator> <name>b</name><operator>/</operator><name>solr</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>search</name><operator>/</operator><name><name>FunctionQParser</name><operator>.</operator><name>java</name></name>
@@ <operator>-</operator><literal type="number">48</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">48</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@ <specifier>public</specifier> <name>class</name> <name>FunctionQParser</name> extends <name>QParser</name> <block>{
   }</block>
 
   <specifier>public</specifier> <name>void</name> <call><name>setParseToEnd</name><argument_list>(<argument><expr><name>boolean</name> <name>parseToEnd</name></expr></argument>)</argument_list></call> <block>{
    <expr><name><name>this</name><operator>.</operator><name>parseMultipleSources</name></name> <operator>=</operator> <name>parseMultipleSources</name></expr>;
    <expr><name><name>this</name><operator>.</operator><name>parseToEnd</name></name> <operator>=</operator> <name>parseToEnd</name></expr>;
   }</block>
 
   <comment type="block" format="javadoc">/** throw exception if there is extra stuff at the end of the parsed valuesource(s). */</comment>
<name>diff</name> <operator>--</operator><name>git</name> <name>a</name><operator>/</operator><name>solr</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>search</name><operator>/</operator><name><name>LuceneQParserPlugin</name><operator>.</operator><name>java</name></name> <name>b</name><operator>/</operator><name>solr</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>search</name><operator>/</operator><name><name>LuceneQParserPlugin</name><operator>.</operator><name>java</name></name>
<name>index</name> <literal type="number">1c2e8dadcc3</literal><operator>..</operator><literal type="number">0c8d1a16e4a</literal> <literal type="number">100755</literal>
<operator>--</operator> <name>a</name><operator>/</operator><name>solr</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>search</name><operator>/</operator><name><name>LuceneQParserPlugin</name><operator>.</operator><name>java</name></name>
<operator>++</operator> <name>b</name><operator>/</operator><name>solr</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>search</name><operator>/</operator><name><name>LuceneQParserPlugin</name><operator>.</operator><name>java</name></name>
@@ <operator>-</operator><literal type="number">117</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">117</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@ <name>class</name> <name>OldLuceneQParser</name> extends <name>LuceneQParser</name> <block>{
   <expr><specifier>public</specifier> <name>SortSpec</name> <call><name>getSort</name><argument_list>(<argument><expr><name>boolean</name> <name>useGlobal</name></expr></argument>)</argument_list></call> <throws>throws <argument><expr><name>ParseException</name> <block>{
     <expr><name>SortSpec</name> <name>sort</name> <operator>=</operator> <call><name><name>super</name><operator>.</operator><name>getSort</name></name><argument_list>(<argument><expr><name>useGlobal</name></expr></argument>)</argument_list></call></expr></block></expr></argument></throws></expr>;
     <if_stmt><if>if <condition>(<expr><name>sortStr</name> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <call><name><name>sortStr</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name><name>sort</name><operator>.</operator><name>getSort</name></name><argument_list>()</argument_list></call><operator>==</operator><literal type="null">null</literal></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>Sort</name></type> <name>oldSort</name> <init>= <expr><call><name><name>QueryParsing</name><operator>.</operator><name>parseSort</name></name><argument_list>(<argument><expr><name>sortStr</name></expr></argument>, <argument><expr><call><name>getReq</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSchema</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>Sort</name></type> <name>oldSort</name> <init>= <expr><call><name><name>QueryParsing</name><operator>.</operator><name>parseSort</name></name><argument_list>(<argument><expr><name>sortStr</name></expr></argument>, <argument><expr><call><name>getReq</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
       <if_stmt><if>if<condition>( <expr><name>oldSort</name> <operator>!=</operator> <literal type="null">null</literal></expr> )</condition> <block>{<block_content>
         <expr_stmt><expr><name><name>sort</name><operator>.</operator><name>sort</name></name> <operator>=</operator> <name>oldSort</name></expr>;</expr_stmt>
       <expr_stmt/></block_content></block></if></if_stmt></block_content></block></if></if_stmt>}</block>
<name>diff</name> <operator>--</operator><name>git</name> <name>a</name><operator>/</operator><name>solr</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>search</name><operator>/</operator><name><name>QParser</name><operator>.</operator><name>java</name></name> <name>b</name><operator>/</operator><name>solr</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>search</name><operator>/</operator><name><name>QParser</name><operator>.</operator><name>java</name></name>
<name>index</name> <name>c942ef57c88</name><operator>..</operator><literal type="number">52254858d17</literal> <literal type="number">100755</literal>
<operator>--</operator> <name>a</name><operator>/</operator><name>solr</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>search</name><operator>/</operator><name><name>QParser</name><operator>.</operator><name>java</name></name>
<operator>++</operator> <name>b</name><operator>/</operator><name>solr</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>search</name><operator>/</operator><name><name>QParser</name><operator>.</operator><name>java</name></name>
@@ <operator>-</operator><literal type="number">20</literal></expr><operator>,</operator><expr><literal type="number">6</literal> <operator>+</operator><literal type="number">20</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@</expr></expr_stmt> <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>queryParser</name><operator>.</operator><name>ParseException</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>search</name><operator>.</operator><name>Query</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>search</name><operator>.</operator><name>Sort</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>common</name><operator>.</operator><name>params</name><operator>.</operator><name>CommonParams</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>common</name><operator>.</operator><name>params</name><operator>.</operator><name>MapSolrParams</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>common</name><operator>.</operator><name>params</name><operator>.</operator><name>SolrParams</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>common</name><operator>.</operator><name>util</name><operator>.</operator><name>NamedList</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>common</name><operator>.</operator><name>util</name><operator>.</operator><name>StrUtils</name></name>;</import>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">41</literal></expr><operator>,</operator><expr><literal type="number">6</literal> <operator>+</operator><literal type="number">42</literal></expr><operator>,</operator><expr><literal type="number">10</literal> @@ <specifier>public</specifier> <specifier>abstract</specifier> <name>class</name> <name>QParser</name> <block>{
 
   <expr><specifier>protected</specifier> <name>Query</name> <name>query</name></expr>;
 
  <expr><specifier>protected</specifier> <name>String</name> <name>stringIncludingLocalParams</name></expr>;   <comment type="line">// the original query string including any local params</comment>
  <expr><specifier>protected</specifier> <name>boolean</name> <name>valFollowedParams</name></expr>;           <comment type="line">// true if the value "qstr" followed the localParams</comment>
  <expr><specifier>protected</specifier> <name>int</name> <name>localParamsEnd</name></expr>;                  <comment type="line">// the position one past where the localParams ended </comment>

   <comment type="block" format="javadoc">/**
    * Constructor for the QParser
    * @param qstr The part of the query string specific to this parser
@@ -214,7 +219,7 @@ public abstract class QParser {
 
     Sort sort = null;
     if( sortStr != null ) {
      sort = QueryParsing.parseSort(sortStr, req.getSchema());
      sort = QueryParsing.parseSort(sortStr, req);
     }
     return new SortSpec( sort, start, rows );
   }
@@ -241,7 +246,32 @@ public abstract class QParser {
    * then the prefix query parser will be used.
    */</comment>
   <expr><specifier>public</specifier> <specifier>static</specifier> <name>QParser</name> <call><name>getParser</name><argument_list>(<argument><expr><name>String</name> <name>qstr</name></expr></argument>, <argument><expr><name>String</name> <name>defaultType</name></expr></argument>, <argument><expr><name>SolrQueryRequest</name> <name>req</name></expr></argument>)</argument_list></call> <throws>throws <argument><expr><name>ParseException</name> <block>{
    <expr><name>SolrParams</name> <name>localParams</name> <operator>=</operator> <call><name><name>QueryParsing</name><operator>.</operator><name>getLocalParams</name></name><argument_list>(<argument><expr><name>qstr</name></expr></argument>, <argument><expr><call><name><name>req</name><operator>.</operator><name>getParams</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></block></expr></argument></throws></expr>;
    <comment type="line">// SolrParams localParams = QueryParsing.getLocalParams(qstr, req.getParams());</comment>

    <expr><name>String</name> <name>stringIncludingLocalParams</name> <operator>=</operator> <name>qstr</name></expr>;
    <expr><name>SolrParams</name> <name>localParams</name> <operator>=</operator> <literal type="null">null</literal></expr>;
    <expr><name>SolrParams</name> <name>globalParams</name> <operator>=</operator> <call><name><name>req</name><operator>.</operator><name>getParams</name></name><argument_list>()</argument_list></call></expr>;
    <expr><name>boolean</name> <name>valFollowedParams</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;
    <expr><name>int</name> <name>localParamsEnd</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;

    <if_stmt><if>if <condition>(<expr><name>qstr</name> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <call><name><name>qstr</name><operator>.</operator><name>startsWith</name></name><argument_list>(<argument><expr><name><name>QueryParsing</name><operator>.</operator><name>LOCALPARAM_START</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name><name>Map</name><argument_list type="generic">&lt;<argument><name>String</name></argument>, <argument><name>String</name></argument>&gt;</argument_list></name></type> <name>localMap</name> <init>= <expr><operator>new</operator> <call><name><name>HashMap</name><argument_list type="generic">&lt;<argument><name>String</name></argument>, <argument><name>String</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>localParamsEnd</name> <operator>=</operator> <call><name><name>QueryParsing</name><operator>.</operator><name>parseLocalParams</name></name><argument_list>(<argument><expr><name>qstr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>localMap</name></expr></argument>, <argument><expr><name>globalParams</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <decl_stmt><decl><type><name>String</name></type> <name>val</name> <init>= <expr><call><name><name>localMap</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name><name>QueryParsing</name><operator>.</operator><name>V</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><name>val</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
        <comment type="line">// val was directly specified in localParams via v=&lt;something&gt; or v=$arg</comment>
        <expr_stmt><expr><name>valFollowedParams</name> <operator>=</operator> <literal type="boolean">false</literal></expr>;</expr_stmt>
      <expr_stmt/></block_content></block></if></if_stmt></block_content></block></if></if_stmt>}</block></expr></expr_stmt> <if_stmt><else>else <block>{<block_content>
        <comment type="line">// use the remainder of the string as the value</comment>
        <expr_stmt><expr><name>valFollowedParams</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>val</name> <operator>=</operator> <call><name><name>qstr</name><operator>.</operator><name>substring</name></name><argument_list>(<argument><expr><name>localParamsEnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>localMap</name><operator>.</operator><name>put</name></name><argument_list>(<argument><expr><name><name>QueryParsing</name><operator>.</operator><name>V</name></name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><name>localParams</name> <operator>=</operator> <operator>new</operator> <call><name>MapSolrParams</name><argument_list>(<argument><expr><name>localMap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }


     String <expr_stmt><expr><name>type</name></expr>;</expr_stmt>
     
     <if_stmt><if>if <condition>(<expr><name>localParams</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">254</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">284</literal></expr><operator>,</operator><expr><literal type="number">12</literal> @@ <specifier>public</specifier> <specifier>abstract</specifier> <name>class</name> <name>QParser</name> <block>{
     <expr><name>type</name> <operator>=</operator> <name>type</name><operator>==</operator><literal type="null">null</literal> <operator>?</operator> <name><name>QParserPlugin</name><operator>.</operator><name>DEFAULT_QTYPE</name></name> <operator>:</operator> <name>type</name></expr>;
 
     <name>QParserPlugin</name> <name>qplug</name> <operator>=</operator> <call><name><name>req</name><operator>.</operator><name>getCore</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getQueryPlugin</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></block></expr>;</expr_stmt>
    <return>return <expr><call><name><name>qplug</name><operator>.</operator><name>createParser</name></name><argument_list>(<argument><expr><name>qstr</name></expr></argument>, <argument><expr><name>localParams</name></expr></argument>, <argument><expr><call><name><name>req</name><operator>.</operator><name>getParams</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>req</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if></if_stmt>                            
    <decl_stmt><decl><type><name>QParser</name></type> <name>parser</name> <init>=  <expr><call><name><name>qplug</name><operator>.</operator><name>createParser</name></name><argument_list>(<argument><expr><name>qstr</name></expr></argument>, <argument><expr><name>localParams</name></expr></argument>, <argument><expr><call><name><name>req</name><operator>.</operator><name>getParams</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>req</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>parser</name><operator>.</operator><name>stringIncludingLocalParams</name></name> <operator>=</operator> <name>stringIncludingLocalParams</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>parser</name><operator>.</operator><name>valFollowedParams</name></name> <operator>=</operator> <name>valFollowedParams</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>parser</name><operator>.</operator><name>localParamsEnd</name></name> <operator>=</operator> <name>localParamsEnd</name></expr>;</expr_stmt>
    <return>return <expr><name>parser</name></expr>;</return>
  }
 
 }
<expr_stmt><expr><name>diff</name> <operator>--</operator><name>git</name> <name>a</name><operator>/</operator><name>solr</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>search</name><operator>/</operator><name><name>QueryParsing</name><operator>.</operator><name>java</name></name> <name>b</name><operator>/</operator><name>solr</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>search</name><operator>/</operator><name><name>QueryParsing</name><operator>.</operator><name>java</name></name>
<name>index</name> <literal type="number">973e4ca1df8</literal><operator>..</operator><literal type="number">62f538e0957</literal> <literal type="number">100644</literal>
<operator>--</operator> <name>a</name><operator>/</operator><name>solr</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>search</name><operator>/</operator><name><name>QueryParsing</name><operator>.</operator><name>java</name></name>
<operator>++</operator> <name>b</name><operator>/</operator><name>solr</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>search</name><operator>/</operator><name><name>QueryParsing</name><operator>.</operator><name>java</name></name>
@@ <operator>-</operator><literal type="number">38</literal></expr><operator>,</operator><expr><literal type="number">10</literal> <operator>+</operator><literal type="number">38</literal></expr><operator>,</operator><expr><literal type="number">12</literal> @@</expr></expr_stmt> <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>common</name><operator>.</operator><name>params</name><operator>.</operator><name>MapSolrParams</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>common</name><operator>.</operator><name>params</name><operator>.</operator><name>SolrParams</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>core</name><operator>.</operator><name>SolrCore</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>request</name><operator>.</operator><name>LocalSolrQueryRequest</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>request</name><operator>.</operator><name>SolrQueryRequest</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>schema</name><operator>.</operator><name>FieldType</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>schema</name><operator>.</operator><name>IndexSchema</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>schema</name><operator>.</operator><name>SchemaField</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>search</name><operator>.</operator><name>function</name><operator>.</operator><name>FunctionQuery</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>search</name><operator>.</operator><name>function</name><operator>.</operator><name>QueryValueSource</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>search</name><operator>.</operator><name>function</name><operator>.</operator><name>ValueSource</name></name>;</import>
 
 <import>import <name><name>java</name><operator>.</operator><name>io</name><operator>.</operator><name>IOException</name></name>;</import>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">66</literal></expr><operator>,</operator><expr><literal type="number">6</literal> <operator>+</operator><literal type="number">68</literal></expr><operator>,</operator><expr><literal type="number">10</literal> @@ <specifier>public</specifier> <name>class</name> <name>QueryParsing</name> <block>{
   <expr><specifier>public</specifier> <specifier>static</specifier> <name>final</name> <name>char</name> <name>LOCALPARAM_END</name> <operator>=</operator> <literal type="char">'}'</literal></expr>;
   <expr><specifier>public</specifier> <specifier>static</specifier> <name>final</name> <name>String</name> <name>DOCID</name> <operator>=</operator> <literal type="string">"_docid_"</literal></expr>;
 
  <comment type="line">// true if the value was specified by the "v" param (i.e. v=myval, or v=$param)</comment>
  <expr><specifier>public</specifier> <specifier>static</specifier> <name>final</name> <name>String</name> <name>VAL_EXPLICIT</name> <operator>=</operator> <literal type="string">"__VAL_EXPLICIT__"</literal></expr>;


   <comment type="block" format="javadoc">/**
    * Returns the "prefered" default operator for use by Query Parsers, 
    * based on the settings in the IndexSchema which may be overridden using 
@@ -253,20 +259,17 @@ public class QueryParsing {
     Map&lt;String, String&gt; localParams = new HashMap&lt;String, String&gt;();
     int start = QueryParsing.parseLocalParams(txt, 0, localParams, params);
 
    String val;
    if (start &gt;= txt.length()) {
      // if the rest of the string is empty, check for "v" to provide the value
      val = localParams.get(V);
      val = val == null ? "" : val;
    } else {
    String val = localParams.get(V);
    if (val == null) {
       val = txt.substring(start);
      localParams.put(V, val);
    } else {
      // localParams.put(VAL_EXPLICIT, "true");
     }
    localParams.put(V, val);
     return new MapSolrParams(localParams);
   }
 
 

   /**
    * Returns null if the sortSpec is the standard sort desc.
    * &lt;p/&gt;
@@ -287,150 +290,129 @@ public class QueryParsing {
    *   height desc,weight asc   #sort by height descending, using weight ascending as a tiebreaker
    * &lt;/pre&gt;
    */</comment>
  <expr><specifier>public</specifier> <specifier>static</specifier> <name>Sort</name> <call><name>parseSort</name><argument_list>(<argument><expr><name>String</name> <name>sortSpec</name></expr></argument>, <argument><expr><name>IndexSchema</name> <name>schema</name></expr></argument>)</argument_list></call> <block>{
  <expr><specifier>public</specifier> <specifier>static</specifier> <name>Sort</name> <call><name>parseSort</name><argument_list>(<argument><expr><name>String</name> <name>sortSpec</name></expr></argument>, <argument><expr><name>SolrQueryRequest</name> <name>req</name></expr></argument>)</argument_list></call> <block>{
     <if_stmt><if>if <condition>(<expr><name>sortSpec</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <call><name><name>sortSpec</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="null">null</literal></expr>;</return></block_content></block></if></if_stmt>
    <name><name>char</name><index>[]</index></name> <name>chars</name> <operator>=</operator> <call><name><name>sortSpec</name><operator>.</operator><name>toCharArray</name></name><argument_list>()</argument_list></call></block></expr>;
    <expr><name>int</name> <name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;
    <expr><name>StringBuilder</name> <name>buffer</name> <operator>=</operator> <operator>new</operator> <call><name>StringBuilder</name><argument_list>(<argument><expr><call><name><name>sortSpec</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
    <expr><name>String</name> <name>sort</name> <operator>=</operator> <literal type="null">null</literal></expr>;
    <expr><name>String</name> <name>order</name> <operator>=</operator> <literal type="null">null</literal></expr>;
    <expr><name>int</name> <name>functionDepth</name> <operator>=</operator> <literal type="number">0</literal></expr>;
    <expr><name>boolean</name> <name>score</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;
    <expr><name><name>List</name><argument_list type="generic">&lt;<argument><name>SortField</name></argument>&gt;</argument_list></name> <name>lst</name> <operator>=</operator> <operator>new</operator> <call><name><name>ArrayList</name><argument_list type="generic">&lt;<argument><name>SortField</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;
    <expr><name>boolean</name> <name>needOrder</name> <operator>=</operator> <literal type="boolean">false</literal></expr>;
    <while>while <condition>(<expr><name>i</name> <operator>&lt;</operator> <name><name>chars</name><operator>.</operator><name>length</name></name></expr>)</condition> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><call><name><name>Character</name><operator>.</operator><name>isWhitespace</name></name><argument_list>(<argument><expr><name><name>chars</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>functionDepth</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name><name>buffer</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
          <comment type="line">//do nothing</comment>
        <expr_stmt/></block_content></block></if></if_stmt></block_content></block></if></if_stmt></block_content></block></while>}</block></expr> <if_stmt><else>else <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><name>needOrder</name> <operator>==</operator> <literal type="boolean">false</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>sort</name> <operator>=</operator> <call><name><name>buffer</name><operator>.</operator><name>toString</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>trim</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>buffer</name><operator>.</operator><name>setLength</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>needOrder</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
    <decl_stmt><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name>SortField</name></argument>&gt;</argument_list></name></type> <name>lst</name> <init>= <expr><operator>new</operator> <call><name><name>ArrayList</name><argument_list type="generic">&lt;<argument><name>SortField</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <try>try <block>{<block_content>

      <decl_stmt><decl><type><name>StrParser</name></type> <name>sp</name> <init>= <expr><operator>new</operator> <call><name>StrParser</name><argument_list>(<argument><expr><name>sortSpec</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <while>while <condition>(<expr><name><name>sp</name><operator>.</operator><name>pos</name></name> <operator>&lt;</operator> <name><name>sp</name><operator>.</operator><name>end</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name><name>sp</name><operator>.</operator><name>eatws</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <decl_stmt><decl><type><name>int</name></type> <name>start</name> <init>= <expr><name><name>sp</name><operator>.</operator><name>pos</name></name></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>String</name></type> <name>field</name> <init>= <expr><call><name><name>sp</name><operator>.</operator><name>getId</name></name><argument_list>(<argument><expr><literal type="null">null</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ValueSource</name></type> <name>vs</name> <init>= <expr><literal type="null">null</literal></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>field</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <call><name><name>sp</name><operator>.</operator><name>ch</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <literal type="char">' '</literal></expr>)</condition> <block>{<block_content>
          <comment type="line">// let's try it as a function instead</comment>
          <decl_stmt><decl><type><name>String</name></type> <name>funcStr</name> <init>= <expr><call><name><name>sp</name><operator>.</operator><name>val</name><operator>.</operator><name>substring</name></name><argument_list>(<argument><expr><name>start</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

          <decl_stmt><decl><type><name>QParser</name></type> <name>parser</name> <init>= <expr><call><name><name>QParser</name><operator>.</operator><name>getParser</name></name><argument_list>(<argument><expr><name>funcStr</name></expr></argument>, <argument><expr><name><name>FunctionQParserPlugin</name><operator>.</operator><name>NAME</name></name></expr></argument>, <argument><expr><name>req</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>Query</name></type> <name>q</name> <init>= <expr><literal type="null">null</literal></expr></init></decl>;</decl_stmt>
          <if_stmt><if>if <condition>(<expr><name>parser</name> <operator>instanceof</operator> <name>FunctionQParser</name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>FunctionQParser</name></type> <name>fparser</name> <init>= <expr><operator>(</operator><name>FunctionQParser</name><operator>)</operator><name>parser</name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>fparser</name><operator>.</operator><name>setParseMultipleSources</name></name><argument_list>(<argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>fparser</name><operator>.</operator><name>setParseToEnd</name></name><argument_list>(<argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>q</name> <operator>=</operator> <call><name><name>fparser</name><operator>.</operator><name>getQuery</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>fparser</name><operator>.</operator><name>localParams</name></name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
              <if_stmt><if>if <condition>(<expr><name><name>fparser</name><operator>.</operator><name>valFollowedParams</name></name></expr>)</condition> <block>{<block_content>
                <comment type="line">// need to find the end of the function query via the string parser</comment>
                <decl_stmt><decl><type><name>int</name></type> <name>leftOver</name> <init>= <expr><name><name>fparser</name><operator>.</operator><name>sp</name><operator>.</operator><name>end</name></name> <operator>-</operator> <name><name>fparser</name><operator>.</operator><name>sp</name><operator>.</operator><name>pos</name></name></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><name><name>sp</name><operator>.</operator><name>pos</name></name> <operator>=</operator> <name><name>sp</name><operator>.</operator><name>end</name></name> <operator>-</operator> <name>leftOver</name></expr>;</expr_stmt>   <comment type="line">// reset our parser to the same amount of leftover</comment>
              <expr_stmt/></block_content></block></if></if_stmt></block_content></block></if></if_stmt></block_content></block></if></if_stmt></block_content></block></if></if_stmt></block_content></block></while></block_content></block></try></block_content></block></if></if_stmt></block_content></block></else></if_stmt>}</block></expr></expr_stmt> <if_stmt><else>else <block>{<block_content>
                <comment type="line">// the value was via the "v" param in localParams, so we need to find</comment>
                <comment type="line">// the end of the local params themselves to pick up where we left off</comment>
                <expr_stmt><expr><name><name>sp</name><operator>.</operator><name>pos</name></name> <operator>=</operator> <name>start</name> <operator>+</operator> <name><name>fparser</name><operator>.</operator><name>localParamsEnd</name></name></expr>;</expr_stmt>
              </block_content>}</block></else></if_stmt>
            } else <block>{<block_content>
              <comment type="line">// need to find the end of the function query via the string parser</comment>
              <decl_stmt><decl><type><name>int</name></type> <name>leftOver</name> <init>= <expr><name><name>fparser</name><operator>.</operator><name>sp</name><operator>.</operator><name>end</name></name> <operator>-</operator> <name><name>fparser</name><operator>.</operator><name>sp</name><operator>.</operator><name>pos</name></name></expr></init></decl>;</decl_stmt>
              <expr_stmt><expr><name><name>sp</name><operator>.</operator><name>pos</name></name> <operator>=</operator> <name><name>sp</name><operator>.</operator><name>end</name></name> <operator>-</operator> <name>leftOver</name></expr>;</expr_stmt>   <comment type="line">// reset our parser to the same amount of leftover</comment>
            </block_content>}</block>
           } else <block>{<block_content>
            <expr_stmt><expr><name>order</name> <operator>=</operator> <call><name><name>buffer</name><operator>.</operator><name>toString</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>trim</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>buffer</name><operator>.</operator><name>setLength</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>needOrder</name> <operator>=</operator> <literal type="boolean">false</literal></expr>;</expr_stmt>
            <comment type="line">// A QParser that's not for function queries.</comment>
            <comment type="line">// It must have been specified via local params.</comment>
            <expr_stmt><expr><name>q</name> <operator>=</operator> <call><name><name>parser</name><operator>.</operator><name>getQuery</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

            <assert>assert <expr><call><name><name>parser</name><operator>.</operator><name>getLocalParams</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <literal type="null">null</literal></expr>;</assert>
            <expr_stmt><expr><name><name>sp</name><operator>.</operator><name>pos</name></name> <operator>=</operator> <name>start</name> <operator>+</operator> <name><name>parser</name><operator>.</operator><name>localParamsEnd</name></name></expr>;</expr_stmt>
           </block_content>}</block>
        }
      } <if_stmt><if type="elseif">else if <condition>(<expr><name><name>chars</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="char">'('</literal> <operator>&amp;&amp;</operator> <name>functionDepth</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name><name>buffer</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name><name>chars</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>functionDepth</name><operator>++</operator></expr>;</expr_stmt>
      </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>chars</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="char">')'</literal> <operator>&amp;&amp;</operator> <name>functionDepth</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name><name>buffer</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name><name>chars</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>functionDepth</name><operator>--</operator></expr>;</expr_stmt><comment type="line">//close up one layer</comment>
      </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>chars</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="char">','</literal> <operator>&amp;&amp;</operator> <name>functionDepth</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content><comment type="line">//can either be a separator of sort declarations, or a separator in a function</comment>
        <comment type="line">//we have a separator between sort declarations,</comment>
        <comment type="line">// We may need an order still, but then evaluate it, as we should have everything we need</comment>
        <if_stmt><if>if <condition>(<expr><name>needOrder</name> <operator>==</operator> <literal type="boolean">true</literal> <operator>&amp;&amp;</operator> <call><name><name>buffer</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block>{<block_content>
          <expr_stmt><expr><name>order</name> <operator>=</operator> <call><name><name>buffer</name><operator>.</operator><name>toString</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>trim</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name><name>buffer</name><operator>.</operator><name>setLength</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>needOrder</name> <operator>=</operator> <literal type="boolean">false</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>score</name> <operator>=</operator> <call><name>processSort</name><argument_list>(<argument><expr><name>schema</name></expr></argument>, <argument><expr><name>sort</name></expr></argument>, <argument><expr><name>order</name></expr></argument>, <argument><expr><name>lst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>sort</name> <operator>=</operator> <literal type="null">null</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>order</name> <operator>=</operator> <literal type="null">null</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>buffer</name><operator>.</operator><name>setLength</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt><comment type="line">//get ready for the next one, if there is one</comment>
      </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>chars</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="char">','</literal> <operator>&amp;&amp;</operator> <name>functionDepth</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <comment type="line">//we are in a function</comment>
        <expr_stmt><expr><call><name><name>buffer</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name><name>chars</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if> <else>else <block>{<block_content>
        <comment type="line">//just a regular old char, add it to the buffer</comment>
        <expr_stmt><expr><call><name><name>buffer</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name><name>chars</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
    }
    if <expr_stmt><expr><operator>(</operator><call><name><name>buffer</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>needOrder</name><operator>)</operator><block>{<comment type="line">//see if we have anything left, at most it should be an order</comment>
      <expr><name>order</name> <operator>=</operator> <call><name><name>buffer</name><operator>.</operator><name>toString</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>trim</name><argument_list>()</argument_list></call></expr>;
      <expr><call><name><name>buffer</name><operator>.</operator><name>setLength</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;
      <expr><name>needOrder</name> <operator>=</operator> <literal type="boolean">false</literal></expr>;
    }</block></expr></expr_stmt>
 
    <comment type="line">//do some sanity checks</comment>
    <if_stmt><if>if <condition>(<expr><name>functionDepth</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block>{<block_content>
      <throw>throw <expr><operator>new</operator> <call><name>SolrException</name><argument_list>(<argument><expr><name><name>SolrException</name><operator>.</operator><name>ErrorCode</name><operator>.</operator><name>BAD_REQUEST</name></name></expr></argument>, <argument><expr><literal type="string">"Unable to parse sort spec, mismatched parentheses: "</literal> <operator>+</operator> <name>sortSpec</name></expr></argument>)</argument_list></call></expr>;</throw>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name><name>buffer</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block>{<block_content><comment type="line">//there's something wrong, as everything should have been parsed by now</comment>
      <throw>throw <expr><operator>new</operator> <call><name>SolrException</name><argument_list>(<argument><expr><name><name>SolrException</name><operator>.</operator><name>ErrorCode</name><operator>.</operator><name>BAD_REQUEST</name></name></expr></argument>, <argument><expr><literal type="string">"Unable to parse sort spec: "</literal> <operator>+</operator> <name>sortSpec</name></expr></argument>)</argument_list></call></expr>;</throw>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>needOrder</name> <operator>==</operator> <literal type="boolean">false</literal> <operator>&amp;&amp;</operator> <name>sort</name> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <call><name><name>sort</name><operator>.</operator><name>equals</name></name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="boolean">false</literal> <operator>&amp;&amp;</operator> <name>order</name> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <call><name><name>order</name><operator>.</operator><name>equals</name></name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="boolean">false</literal></expr>)</condition><block>{<block_content><comment type="line">//handle the last declaration</comment>
      <expr_stmt><expr><name>score</name> <operator>=</operator> <call><name>processSort</name><argument_list>(<argument><expr><name>schema</name></expr></argument>, <argument><expr><name>sort</name></expr></argument>, <argument><expr><name>order</name></expr></argument>, <argument><expr><name>lst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <comment type="line">//If the normal case (by score desc) do nothing</comment>
    <if_stmt><if>if <condition>(<expr><call><name><name>lst</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>score</name> <operator>==</operator> <literal type="boolean">true</literal> <operator>&amp;&amp;</operator> <call><name><name>lst</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>.</operator><call><name>getReverse</name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="boolean">false</literal></expr>)</condition> <block>{<block_content>
      <return>return <expr><literal type="null">null</literal></expr>;</return> <comment type="line">// do normal scoring...</comment>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><operator>new</operator> <call><name>Sort</name><argument_list>(<argument><expr><operator>(</operator><name><name>SortField</name><index>[]</index></name><operator>)</operator> <call><name><name>lst</name><operator>.</operator><name>toArray</name></name><argument_list>(<argument><expr><operator>new</operator> <name><name>SortField</name><index>[<expr><call><name><name>lst</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
  }
          <comment type="line">// OK, now we have our query.</comment>
          if <expr_stmt><expr><operator>(</operator><name>q</name> <operator>instanceof</operator> <name>FunctionQuery</name><operator>)</operator> <block>{
            <expr><name>vs</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>FunctionQuery</name><operator>)</operator><name>q</name><operator>)</operator><operator>.</operator><call><name>getValueSource</name><argument_list>()</argument_list></call></expr>;
          }</block></expr></expr_stmt> <if_stmt><else>else <block>{<block_content>
            <expr_stmt><expr><name>vs</name> <operator>=</operator> <operator>new</operator> <call><name>QueryValueSource</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="number">0.0f</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></else></if_stmt>
        }
 
  private <function><type><specifier>static</specifier> <name>boolean</name></type> <name>processSort</name><parameter_list>(<parameter><decl><type><name>IndexSchema</name></type> <name>schema</name></decl></parameter>, <parameter><decl><type><name>String</name></type> <name>sort</name></decl></parameter>, <parameter><decl><type><name>String</name></type> <name>order</name></decl></parameter>, <parameter><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name>SortField</name></argument>&gt;</argument_list></name></type> <name>lst</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>boolean</name></type> <name>score</name> <init>= <expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>sort</name> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <name>order</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>boolean</name></type> <name>top</name> <init>= <expr><literal type="boolean">true</literal></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><literal type="string">"desc"</literal><operator>.</operator><call><name>equals</name><argument_list>(<argument><expr><name>order</name></expr></argument>)</argument_list></call> <operator>||</operator> <literal type="string">"top"</literal><operator>.</operator><call><name>equals</name><argument_list>(<argument><expr><name>order</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>top</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
      </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><literal type="string">"asc"</literal><operator>.</operator><call><name>equals</name><argument_list>(<argument><expr><name>order</name></expr></argument>)</argument_list></call> <operator>||</operator> <literal type="string">"bottom"</literal><operator>.</operator><call><name>equals</name><argument_list>(<argument><expr><name>order</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>top</name> <operator>=</operator> <literal type="boolean">false</literal></expr>;</expr_stmt>
      </block_content>}</block></if> <else>else <block>{<block_content>
        <throw>throw <expr><operator>new</operator> <call><name>SolrException</name><argument_list>(<argument><expr><name><name>SolrException</name><operator>.</operator><name>ErrorCode</name><operator>.</operator><name>BAD_REQUEST</name></name></expr></argument>, <argument><expr><literal type="string">"Unknown sort order: "</literal> <operator>+</operator> <name>order</name></expr></argument>)</argument_list></call></expr>;</throw>
      </block_content>}</block></else></if_stmt>
      <comment type="line">//we got the order, now deal with the sort</comment>
      <if_stmt><if>if <condition>(<expr><literal type="string">"score"</literal><operator>.</operator><call><name>equals</name><argument_list>(<argument><expr><name>sort</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>score</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>top</name></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><call><name><name>lst</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name><name>SortField</name><operator>.</operator><name>FIELD_SCORE</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="line">// now we have our field or value source, so find the sort order</comment>
        <decl_stmt><decl><type><name>String</name></type> <name>order</name> <init>= <expr><call><name><name>sp</name><operator>.</operator><name>getId</name></name><argument_list>(<argument><expr><literal type="string">"Expected sort order asc/desc"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>boolean</name></type> <name>top</name></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><literal type="string">"desc"</literal><operator>.</operator><call><name>equals</name><argument_list>(<argument><expr><name>order</name></expr></argument>)</argument_list></call> <operator>||</operator> <literal type="string">"top"</literal><operator>.</operator><call><name>equals</name><argument_list>(<argument><expr><name>order</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><name>top</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><literal type="string">"asc"</literal><operator>.</operator><call><name>equals</name><argument_list>(<argument><expr><name>order</name></expr></argument>)</argument_list></call> <operator>||</operator> <literal type="string">"bottom"</literal><operator>.</operator><call><name>equals</name><argument_list>(<argument><expr><name>order</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><name>top</name> <operator>=</operator> <literal type="boolean">false</literal></expr>;</expr_stmt>
         </block_content>}</block></if> <else>else <block>{<block_content>
          <expr_stmt><expr><call><name><name>lst</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><operator>new</operator> <call><name>SortField</name><argument_list>(<argument><expr><literal type="null">null</literal></expr></argument>, <argument><expr><name><name>SortField</name><operator>.</operator><name>SCORE</name></name></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name><name>DOCID</name><operator>.</operator><name>equals</name></name><argument_list>(<argument><expr><name>sort</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name><name>lst</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><operator>new</operator> <call><name>SortField</name><argument_list>(<argument><expr><literal type="null">null</literal></expr></argument>, <argument><expr><name><name>SortField</name><operator>.</operator><name>DOC</name></name></expr></argument>, <argument><expr><name>top</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if> <else>else <block>{<block_content>
        <comment type="line">//See if we have a Field first, then see if it is a function, then throw an exception</comment>
        <comment type="line">// getField could throw an exception if the name isn't found</comment>
        <decl_stmt><decl><type><name>SchemaField</name></type> <name>f</name> <init>= <expr><literal type="null">null</literal></expr></init></decl>;</decl_stmt>
        <try>try <block>{<block_content>
          <expr_stmt><expr><name>f</name> <operator>=</operator> <call><name><name>schema</name><operator>.</operator><name>getField</name></name><argument_list>(<argument><expr><name>sort</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
        <catch>catch <parameter_list>(<parameter><decl><type><name>SolrException</name></type> <name>e</name></decl></parameter>)</parameter_list> <block>{<block_content>
          <comment type="line">//Not an error just yet</comment>
          <throw>throw <expr><operator>new</operator> <call><name>SolrException</name><argument_list>(<argument><expr><name><name>SolrException</name><operator>.</operator><name>ErrorCode</name><operator>.</operator><name>BAD_REQUEST</name></name></expr></argument>, <argument><expr><literal type="string">"Unknown sort order: "</literal> <operator>+</operator> <name>order</name></expr></argument>)</argument_list></call></expr>;</throw>
         </block_content>}</block></catch></try>
        <if_stmt><if>if <condition>(<expr><name>f</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><name>f</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <operator>!</operator><call><name><name>f</name><operator>.</operator><name>indexed</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
            <throw>throw <expr><operator>new</operator> <call><name>SolrException</name><argument_list>(<argument><expr><name><name>SolrException</name><operator>.</operator><name>ErrorCode</name><operator>.</operator><name>BAD_REQUEST</name></name></expr></argument>, <argument><expr><literal type="string">"can not sort on unindexed field: "</literal> <operator>+</operator> <name>sort</name></expr></argument>)</argument_list></call></expr>;</throw>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><call><name><name>lst</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><call><name><name>f</name><operator>.</operator><name>getType</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSortField</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>top</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
          <comment type="line">//See if we have a function:</comment>
          <decl_stmt><decl><type><name>FunctionQuery</name></type> <name>query</name> <init>= <expr><literal type="null">null</literal></expr></init></decl>;</decl_stmt>
          <try>try <block>{<block_content>
            <expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>parseFunction</name><argument_list>(<argument><expr><name>sort</name></expr></argument>, <argument><expr><name>schema</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>query</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
              <decl_stmt><decl><type><name>ValueSource</name></type> <name>valueSource</name> <init>= <expr><call><name><name>query</name><operator>.</operator><name>getValueSource</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
              <comment type="line">//We have a function query</comment>
              <try>try <block>{<block_content>
                <expr_stmt><expr><call><name><name>lst</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><call><name><name>valueSource</name><operator>.</operator><name>getSortField</name></name><argument_list>(<argument><expr><name>top</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              </block_content>}</block> <catch>catch <parameter_list>(<parameter><decl><type><name>IOException</name></type> <name>e</name></decl></parameter>)</parameter_list> <block>{<block_content>
                <throw>throw <expr><operator>new</operator> <call><name>SolrException</name><argument_list>(<argument><expr><name><name>SolrException</name><operator>.</operator><name>ErrorCode</name><operator>.</operator><name>BAD_REQUEST</name></name></expr></argument>, <argument><expr><literal type="string">"error getting the sort for this function: "</literal> <operator>+</operator> <name>sort</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</throw>
              </block_content>}</block></catch></try>

        <if_stmt><if>if <condition>(<expr><name>vs</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
          <comment type="line">//we got the order, now deal with the sort</comment>
          <if_stmt><if>if <condition>(<expr><literal type="string">"score"</literal><operator>.</operator><call><name>equals</name><argument_list>(<argument><expr><name>field</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>top</name></expr>)</condition> <block>{<block_content>
              <expr_stmt><expr><call><name><name>lst</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name><name>SortField</name><operator>.</operator><name>FIELD_SCORE</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
             </block_content>}</block></if> <else>else <block>{<block_content>
              <throw>throw <expr><operator>new</operator> <call><name>SolrException</name><argument_list>(<argument><expr><name><name>SolrException</name><operator>.</operator><name>ErrorCode</name><operator>.</operator><name>BAD_REQUEST</name></name></expr></argument>, <argument><expr><literal type="string">"can not sort on undefined function: "</literal> <operator>+</operator> <name>sort</name></expr></argument>)</argument_list></call></expr>;</throw>
              <expr_stmt><expr><call><name><name>lst</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><operator>new</operator> <call><name>SortField</name><argument_list>(<argument><expr><literal type="null">null</literal></expr></argument>, <argument><expr><name><name>SortField</name><operator>.</operator><name>SCORE</name></name></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
          </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name><name>DOCID</name><operator>.</operator><name>equals</name></name><argument_list>(<argument><expr><name>field</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name><name>lst</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><operator>new</operator> <call><name>SortField</name><argument_list>(<argument><expr><literal type="null">null</literal></expr></argument>, <argument><expr><name><name>SortField</name><operator>.</operator><name>DOC</name></name></expr></argument>, <argument><expr><name>top</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if> <else>else <block>{<block_content>
            <comment type="line">//See if we have a Field first, then see if it is a function, then throw an exception</comment>
            <comment type="line">// getField could throw an exception if the name isn't found</comment>
            <decl_stmt><decl><type><name>SchemaField</name></type> <name>sf</name> <init>= <expr><call><name><name>req</name><operator>.</operator><name>getSchema</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getField</name><argument_list>(<argument><expr><name>field</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="line">// TODO: remove this - it should be up to the FieldType</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>sf</name><operator>.</operator><name>indexed</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
              <throw>throw <expr><operator>new</operator> <call><name>SolrException</name><argument_list>(<argument><expr><name><name>SolrException</name><operator>.</operator><name>ErrorCode</name><operator>.</operator><name>BAD_REQUEST</name></name></expr></argument>, <argument><expr><literal type="string">"can not sort on unindexed field: "</literal> <operator>+</operator> <name>field</name></expr></argument>)</argument_list></call></expr>;</throw>
             </block_content>}</block></if></if_stmt>
          </block_content>}</block></else></if_stmt> <catch>catch <parameter_list>(<parameter><decl><type><name>ParseException</name></type> <name>e</name></decl></parameter>)</parameter_list> <block>{<block_content>
            <throw>throw <expr><operator>new</operator> <call><name>SolrException</name><argument_list>(<argument><expr><name><name>SolrException</name><operator>.</operator><name>ErrorCode</name><operator>.</operator><name>BAD_REQUEST</name></name></expr></argument>, <argument><expr><literal type="string">"can not sort on undefined field or function: "</literal> <operator>+</operator> <name>sort</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</throw>

            <expr_stmt><expr><call><name><name>lst</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><call><name><name>sf</name><operator>.</operator><name>getType</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSortField</name><argument_list>(<argument><expr><name>sf</name></expr></argument>, <argument><expr><name>top</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>


           </block_content>}</block></catch>
        </block_content>}</block></if> <else>else <block>{<block_content>
          <expr_stmt><expr><call><name><name>lst</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><call><name><name>vs</name><operator>.</operator><name>getSortField</name></name><argument_list>(<argument><expr><name>top</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
 
        <expr_stmt><expr><call><name><name>sp</name><operator>.</operator><name>eatws</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>sp</name><operator>.</operator><name>pos</name></name> <operator>&lt;</operator> <name><name>sp</name><operator>.</operator><name>end</name></name></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><call><name><name>sp</name><operator>.</operator><name>expect</name></name><argument_list>(<argument><expr><literal type="string">","</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
         </block_content>}</block></if></if_stmt>

       </block_content>}</block></if></if_stmt>
    </block_content>}</block></try> <if_stmt><if type="elseif">else if <condition>(<expr><name>sort</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content><comment type="line">//no sort value</comment>
      <throw>throw <expr><operator>new</operator> <call><name>SolrException</name><argument_list>(<argument><expr><name><name>SolrException</name><operator>.</operator><name>ErrorCode</name><operator>.</operator><name>BAD_REQUEST</name></name></expr></argument>,
              <argument><expr><literal type="string">"Must declare sort field or function"</literal></expr></argument>)</argument_list></call></expr>;</throw>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>order</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
      <throw>throw <expr><operator>new</operator> <call><name>SolrException</name><argument_list>(<argument><expr><name><name>SolrException</name><operator>.</operator><name>ErrorCode</name><operator>.</operator><name>BAD_REQUEST</name></name></expr></argument>, <argument><expr><literal type="string">"Missing sort order: "</literal></expr></argument>)</argument_list></call></expr>;</throw>

    </block_content>}</block></if></if_stmt> <catch>catch <parameter_list>(<parameter><decl><type><name>ParseException</name></type> <name>e</name></decl></parameter>)</parameter_list> <block>{<block_content>
      <throw>throw <expr><operator>new</operator> <call><name>SolrException</name><argument_list>(<argument><expr><name><name>SolrException</name><operator>.</operator><name>ErrorCode</name><operator>.</operator><name>BAD_REQUEST</name></name></expr></argument>, <argument><expr><literal type="string">"error in sort: "</literal> <operator>+</operator> <name>sortSpec</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</throw>
    </block_content>}</block></catch> <catch>catch <parameter_list>(<parameter><decl><type><name>IOException</name></type> <name>e</name></decl></parameter>)</parameter_list> <block>{<block_content>
      <throw>throw <expr><operator>new</operator> <call><name>SolrException</name><argument_list>(<argument><expr><name><name>SolrException</name><operator>.</operator><name>ErrorCode</name><operator>.</operator><name>BAD_REQUEST</name></name></expr></argument>, <argument><expr><literal type="string">"error in sort: "</literal> <operator>+</operator> <name>sortSpec</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</throw>
     </block_content>}</block></catch>
    <return>return <expr><name>score</name></expr>;</return>


    <comment type="line">// normalize a sort on score desc to null</comment>
    <if_stmt><if>if <condition>(<expr><call><name><name>lst</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call><operator>==</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <call><name><name>lst</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name><name>SortField</name><operator>.</operator><name>FIELD_SCORE</name></name></expr>)</condition> <block>{<block_content>
      <return>return <expr><literal type="null">null</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><operator>new</operator> <call><name>Sort</name><argument_list>(<argument><expr><operator>(</operator><name><name>SortField</name><index>[]</index></name><operator>)</operator> <call><name><name>lst</name><operator>.</operator><name>toArray</name></name><argument_list>(<argument><expr><operator>new</operator> <name><name>SortField</name><index>[<expr><call><name><name>lst</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
   </block_content>}</block></else></if_stmt>
 
 

   <comment type="line" format="doxygen">///////////////////////////</comment>
   <comment type="line" format="doxygen">///////////////////////////</comment>
   <comment type="line" format="doxygen">///////////////////////////</comment>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">640</literal></expr><operator>,</operator><expr><literal type="number">6</literal> <operator>+</operator><literal type="number">622</literal></expr><operator>,</operator><expr><literal type="number">10</literal> @@ <specifier>public</specifier> <name>class</name> <name>QueryParsing</name> <block>{
       <while>while <condition>(<expr><name>pos</name> <operator>&lt;</operator> <name>end</name> <operator>&amp;&amp;</operator> <call><name><name>Character</name><operator>.</operator><name>isWhitespace</name></name><argument_list>(<argument><expr><call><name><name>val</name><operator>.</operator><name>charAt</name></name><argument_list>(<argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>pos</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
     }</block></expr></expr_stmt>
 
    <function><type><name>char</name></type> <name>ch</name><parameter_list>()</parameter_list> <block>{<block_content>
      <return>return <expr><ternary><condition><expr><name>pos</name> <operator>&lt;</operator> <name>end</name></expr> ?</condition><then> <expr><call><name><name>val</name><operator>.</operator><name>charAt</name></name><argument_list>(<argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</return>
    </block_content>}</block></function>

     <function><type><name>void</name></type> <name>skip</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>nChars</name></decl></parameter>)</parameter_list> <block>{<block_content>
       <expr_stmt><expr><name>pos</name> <operator>=</operator> <call><name><name>Math</name><operator>.</operator><name>max</name></name><argument_list>(<argument><expr><name>pos</name> <operator>+</operator> <name>nChars</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
     </block_content>}</block></function>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">756</literal></expr><operator>,</operator><expr><literal type="number">12</literal> <operator>+</operator><literal type="number">742</literal></expr><operator>,</operator><expr><literal type="number">17</literal> @@ <specifier>public</specifier> <name>class</name> <name>QueryParsing</name> <block>{
 
 
     <expr><name>String</name> <call><name>getId</name><argument_list>()</argument_list></call> <throws>throws <argument><expr><name>ParseException</name> <block>{</block></expr></argument></throws></expr>
      <return>return <expr><call><name>getId</name><argument_list>(<argument><expr><literal type="string">"Expected identifier"</literal></expr></argument>)</argument_list></call></expr>;</return>
    }</block></expr></expr_stmt>

    <function><type><name>String</name></type> <name>getId</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>errMessage</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>ParseException</name></expr></argument></throws> <block>{<block_content>
       <expr_stmt><expr><call><name>eatws</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
       <decl_stmt><decl><type><name>int</name></type> <name>id_start</name> <init>= <expr><name>pos</name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><name>pos</name> <operator>&lt;</operator> <name>end</name> <operator>&amp;&amp;</operator> <call><name><name>Character</name><operator>.</operator><name>isJavaIdentifierStart</name></name><argument_list>(<argument><expr><call><name><name>val</name><operator>.</operator><name>charAt</name></name><argument_list>(<argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>char</name></type> <name>ch</name></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><name>pos</name> <operator>&lt;</operator> <name>end</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>ch</name> <operator>=</operator> <call><name><name>val</name><operator>.</operator><name>charAt</name></name><argument_list>(<argument><expr><name>pos</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <literal type="char">'$'</literal> <operator>&amp;&amp;</operator> <call><name><name>Character</name><operator>.</operator><name>isJavaIdentifierStart</name></name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
         <expr_stmt><expr><name>pos</name><operator>++</operator></expr>;</expr_stmt>
         <while>while <condition>(<expr><name>pos</name> <operator>&lt;</operator> <name>end</name></expr>)</condition> <block>{<block_content>
          <decl_stmt><decl><type><name>char</name></type> <name>ch</name> <init>= <expr><call><name><name>val</name><operator>.</operator><name>charAt</name></name><argument_list>(<argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><name>ch</name> <operator>=</operator> <call><name><name>val</name><operator>.</operator><name>charAt</name></name><argument_list>(<argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
           <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>Character</name><operator>.</operator><name>isJavaIdentifierPart</name></name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>ch</name> <operator>!=</operator> <literal type="char">'.'</literal></expr>)</condition> <block>{<block_content>
             <break>break;</break>
           </block_content>}</block></if></if_stmt>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">769</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">760</literal></expr><operator>,</operator><expr><literal type="number">11</literal> @@ <specifier>public</specifier> <name>class</name> <name>QueryParsing</name> <block>{
         }</block></expr></expr_stmt>
         <return>return <expr><call><name><name>val</name><operator>.</operator><name>substring</name></name><argument_list>(<argument><expr><name>id_start</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</return>
       </block_content>}</block></while>
      <throw>throw <expr><operator>new</operator> <call><name>ParseException</name><argument_list>(<argument><expr><literal type="string">"Expected identifier at pos "</literal> <operator>+</operator> <name>pos</name> <operator>+</operator> <literal type="string">" str='"</literal> <operator>+</operator> <name>val</name> <operator>+</operator> <literal type="string">"'"</literal></expr></argument>)</argument_list></call></expr>;</throw>

      <if_stmt><if>if <condition>(<expr><name>errMessage</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
        <throw>throw <expr><operator>new</operator> <call><name>ParseException</name><argument_list>(<argument><expr><name>errMessage</name> <operator>+</operator> <literal type="string">" at pos "</literal> <operator>+</operator> <name>pos</name> <operator>+</operator> <literal type="string">" str='"</literal> <operator>+</operator> <name>val</name> <operator>+</operator> <literal type="string">"'"</literal></expr></argument>)</argument_list></call></expr>;</throw>
      </block_content>}</block></if></if_stmt>
      <return>return <expr><literal type="null">null</literal></expr>;</return>
     </block_content>}</block></if></if_stmt>
 
     <comment type="line">// return null if not a string</comment>
<expr_stmt><expr><name>diff</name> <operator>--</operator><name>git</name> <name>a</name><operator>/</operator><name>solr</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>tst</name><operator>/</operator><name><name>OldRequestHandler</name><operator>.</operator><name>java</name></name> <name>b</name><operator>/</operator><name>solr</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>tst</name><operator>/</operator><name><name>OldRequestHandler</name><operator>.</operator><name>java</name></name>
<name>index</name> <name>a42461f4f12</name><operator>..</operator><literal type="number">13183e3ed2d</literal> <literal type="number">100644</literal>
<operator>--</operator> <name>a</name><operator>/</operator><name>solr</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>tst</name><operator>/</operator><name><name>OldRequestHandler</name><operator>.</operator><name>java</name></name>
<operator>++</operator> <name>b</name><operator>/</operator><name>solr</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>tst</name><operator>/</operator><name><name>OldRequestHandler</name><operator>.</operator><name>java</name></name>
@@ <operator>-</operator><literal type="number">63</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">63</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@ <specifier>public</specifier> <name>class</name> <name>OldRequestHandler</name> implements <name>SolrRequestHandler</name> <block>{
     <comment type="line">// we can use the Lucene sort ability.</comment>
     <expr><name>Sort</name> <name>sort</name> <operator>=</operator> <literal type="null">null</literal></expr>;</block></expr></expr_stmt>
     <if_stmt><if>if <condition>(<expr><call><name><name>commands</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&gt;=</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>sort</name> <operator>=</operator> <call><name><name>QueryParsing</name><operator>.</operator><name>parseSort</name></name><argument_list>(<argument><expr><call><name><name>commands</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>req</name><operator>.</operator><name>getSchema</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>sort</name> <operator>=</operator> <call><name><name>QueryParsing</name><operator>.</operator><name>parseSort</name></name><argument_list>(<argument><expr><call><name><name>commands</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>req</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
     </block_content>}</block></if></if_stmt>
 
 
<expr_stmt><expr><name>diff</name> <operator>--</operator><name>git</name> <name>a</name><operator>/</operator><name>solr</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>tst</name><operator>/</operator><name><name>TestRequestHandler</name><operator>.</operator><name>java</name></name> <name>b</name><operator>/</operator><name>solr</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>tst</name><operator>/</operator><name><name>TestRequestHandler</name><operator>.</operator><name>java</name></name>
<name>index</name> <name>edabc056ab1</name><operator>..</operator><name>c17942aca0e</name> <literal type="number">100644</literal>
<operator>--</operator> <name>a</name><operator>/</operator><name>solr</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>tst</name><operator>/</operator><name><name>TestRequestHandler</name><operator>.</operator><name>java</name></name>
<operator>++</operator> <name>b</name><operator>/</operator><name>solr</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>tst</name><operator>/</operator><name><name>TestRequestHandler</name><operator>.</operator><name>java</name></name>
@@ <operator>-</operator><literal type="number">105</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">105</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@ <specifier>public</specifier> <name>class</name> <name>TestRequestHandler</name> implements <name>SolrRequestHandler</name> <block>{
       <comment type="line">// we can use the Lucene sort ability.</comment>
       <expr><name>Sort</name> <name>sort</name> <operator>=</operator> <literal type="null">null</literal></expr>;</block></expr></expr_stmt>
       <if_stmt><if>if <condition>(<expr><call><name><name>commands</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&gt;=</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>sort</name> <operator>=</operator> <call><name><name>QueryParsing</name><operator>.</operator><name>parseSort</name></name><argument_list>(<argument><expr><call><name><name>commands</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>req</name><operator>.</operator><name>getSchema</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>sort</name> <operator>=</operator> <call><name><name>QueryParsing</name><operator>.</operator><name>parseSort</name></name><argument_list>(<argument><expr><call><name><name>commands</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>req</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
       </block_content>}</block></if></if_stmt>
 
       <decl_stmt><decl><type><name>SolrIndexSearcher</name></type> <name>searcher</name> <init>= <expr><call><name><name>req</name><operator>.</operator><name>getSearcher</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>diff</name> <operator>--</operator><name>git</name> <name>a</name><operator>/</operator><name>solr</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>util</name><operator>/</operator><name><name>SolrPluginUtils</name><operator>.</operator><name>java</name></name> <name>b</name><operator>/</operator><name>solr</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>util</name><operator>/</operator><name><name>SolrPluginUtils</name><operator>.</operator><name>java</name></name>
<name>index</name> <literal type="number">03507a0301c</literal><operator>..</operator><name>b7ce01cbbdf</name> <literal type="number">100644</literal>
<operator>--</operator> <name>a</name><operator>/</operator><name>solr</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>util</name><operator>/</operator><name><name>SolrPluginUtils</name><operator>.</operator><name>java</name></name>
<operator>++</operator> <name>b</name><operator>/</operator><name>solr</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>util</name><operator>/</operator><name><name>SolrPluginUtils</name><operator>.</operator><name>java</name></name>
@@ <operator>-</operator><literal type="number">366</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">366</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@ <specifier>public</specifier> <name>class</name> <name>SolrPluginUtils</name> <block>{
       <expr><name>String</name> <name>otherQueryS</name> <operator>=</operator> <call><name><name>req</name><operator>.</operator><name>getParams</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>get</name><argument_list>(<argument><expr><name><name>CommonParams</name><operator>.</operator><name>EXPLAIN_OTHER</name></name></expr></argument>)</argument_list></call></expr>;</block></expr></expr_stmt>
       <if_stmt><if>if <condition>(<expr><name>otherQueryS</name> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <call><name><name>otherQueryS</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
         <decl_stmt><decl><type><name>DocList</name></type> <name>otherResults</name> <init>= <expr><call><name>doSimpleQuery</name>
                <argument_list>(<argument><expr><name>otherQueryS</name></expr></argument>, <argument><expr><call><name><name>req</name><operator>.</operator><name>getSearcher</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>req</name><operator>.</operator><name>getSchema</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><operator>(</operator><name>otherQueryS</name><operator>,</operator> <name>req</name><operator>,</operator> <literal type="number">0</literal><operator>,</operator> <literal type="number">10</literal><operator>)</operator></expr>;</expr_stmt>
         <expr_stmt><expr><call><name><name>dbg</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><literal type="string">"otherQuery"</literal></expr></argument>, <argument><expr><name>otherQueryS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
         <decl_stmt><decl><type><name><name>NamedList</name><argument_list type="generic">&lt;<argument><name>Explanation</name></argument>&gt;</argument_list></name></type> <name>explainO</name>
                 <init>= <expr><call><name>getExplanations</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>otherResults</name></expr></argument>, <argument><expr><name>searcher</name></expr></argument>, <argument><expr><name>schema</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">467</literal></expr><operator>,</operator><expr><literal type="number">26</literal> <operator>+</operator><literal type="number">467</literal></expr><operator>,</operator><expr><literal type="number">30</literal> @@ <specifier>public</specifier> <name>class</name> <name>SolrPluginUtils</name> <block>{
   }</block>
 
   <comment type="block" format="javadoc">/**
   * Executes a basic query in lucene syntax
   * Executes a basic query
    */</comment>
   <specifier>public</specifier> <specifier>static</specifier> <name>DocList</name> <call><name>doSimpleQuery</name><argument_list>(<argument><expr><name>String</name> <name>sreq</name></expr></argument>,
                                      <argument><expr><name>SolrIndexSearcher</name> <name>searcher</name></expr></argument>,
                                      <argument><expr><name>IndexSchema</name> <name>schema</name></expr></argument>,
                                      <argument><expr><name>SolrQueryRequest</name> <name>req</name></expr></argument>,
                                       <argument><expr><name>int</name> <name>start</name></expr></argument>, <argument><expr><name>int</name> <name>limit</name></expr></argument>)</argument_list></call> <throws>throws <argument><expr><name>IOException</name> <block>{
     <expr><name><name>List</name><argument_list type="generic">&lt;<argument><name>String</name></argument>&gt;</argument_list></name> <name>commands</name> <operator>=</operator> <call><name><name>StrUtils</name><operator>.</operator><name>splitSmart</name></name><argument_list>(<argument><expr><name>sreq</name></expr></argument>,<argument><expr><literal type="char">';'</literal></expr></argument>)</argument_list></call></expr></block></expr></argument></throws></expr>;</expr_stmt>
 
     <decl_stmt><decl><type><name>String</name></type> <name>qs</name> <init>= <expr><ternary><condition><expr><call><name><name>commands</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&gt;=</operator> <literal type="number">1</literal></expr> ?</condition><then> <expr><call><name><name>commands</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Query</name></type> <name>query</name> <init>= <expr><call><name><name>QueryParsing</name><operator>.</operator><name>parseQuery</name></name><argument_list>(<argument><expr><name>qs</name></expr></argument>, <argument><expr><name>schema</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <try>try <block>{<block_content>
    <decl_stmt><decl><type><name>Query</name></type> <name>query</name> <init>= <expr><call><name><name>QParser</name><operator>.</operator><name>getParser</name></name><argument_list>(<argument><expr><name>qs</name></expr></argument>, <argument><expr><literal type="null">null</literal></expr></argument>, <argument><expr><name>req</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>getQuery</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
 
     <comment type="line">// If the first non-query, non-filter command is a simple sort on an indexed field, then</comment>
     <comment type="line">// we can use the Lucene sort ability.</comment>
     <decl_stmt><decl><type><name>Sort</name></type> <name>sort</name> <init>= <expr><literal type="null">null</literal></expr></init></decl>;</decl_stmt>
     <if_stmt><if>if <condition>(<expr><call><name><name>commands</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&gt;=</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>sort</name> <operator>=</operator> <call><name><name>QueryParsing</name><operator>.</operator><name>parseSort</name></name><argument_list>(<argument><expr><call><name><name>commands</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>schema</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>sort</name> <operator>=</operator> <call><name><name>QueryParsing</name><operator>.</operator><name>parseSort</name></name><argument_list>(<argument><expr><call><name><name>commands</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>req</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
     </block_content>}</block></if></if_stmt>
 
    <decl_stmt><decl><type><name>DocList</name></type> <name>results</name> <init>= <expr><call><name><name>searcher</name><operator>.</operator><name>getDocList</name></name><argument_list>(<argument><expr><name>query</name></expr></argument>,<argument><expr><operator>(</operator><name>DocSet</name><operator>)</operator><literal type="null">null</literal></expr></argument>, <argument><expr><name>sort</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>limit</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>DocList</name></type> <name>results</name> <init>= <expr><call><name><name>req</name><operator>.</operator><name>getSearcher</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getDocList</name><argument_list>(<argument><expr><name>query</name></expr></argument>,<argument><expr><operator>(</operator><name>DocSet</name><operator>)</operator><literal type="null">null</literal></expr></argument>, <argument><expr><name>sort</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>limit</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
     <return>return <expr><name>results</name></expr>;</return>
    </block_content>}</block> <catch>catch <parameter_list>(<parameter><decl><type><name>ParseException</name></type> <name>e</name></decl></parameter>)</parameter_list> <block>{<block_content>
      <throw>throw <expr><operator>new</operator> <call><name>SolrException</name><argument_list>(<argument><expr><name><name>SolrException</name><operator>.</operator><name>ErrorCode</name><operator>.</operator><name>BAD_REQUEST</name></name></expr></argument>, <argument><expr><literal type="string">"Error parsing query: "</literal> <operator>+</operator> <name>qs</name></expr></argument>)</argument_list></call></expr>;</throw>
    </block_content>}</block></catch></try>

   </block_content>}</block></if></if_stmt></block_content></block></if></if_stmt></block_content></block></function></block_content></block></else></if_stmt></block_content></block></if></if_stmt></block_content></block></if></if_stmt></block_content></block></function>
 
   <comment type="block" format="javadoc">/**
@@ -855,7 +859,7 @@ public class SolrPluginUtils {
     SolrException sortE = null;
     Sort ss = null;
     try {
      ss = QueryParsing.parseSort(sort, req.getSchema());
      ss = QueryParsing.parseSort(sort, req);
     } catch (SolrException e) {
       sortE = e;
     }
diff --git a/solr/src/test/org/apache/solr/search/QueryParsingTest.java b/solr/src/test/org/apache/solr/search/QueryParsingTest.java
index 559c001cb8d..95087bc3bb7 100644
-- a/solr/src/test/org/apache/solr/search/QueryParsingTest.java
++ b/solr/src/test/org/apache/solr/search/QueryParsingTest.java
@@ -20,6 +20,7 @@ import org.apache.lucene.search.Sort;
 import org.apache.lucene.search.SortField;
 import org.apache.solr.SolrTestCaseJ4;
 import org.apache.solr.common.SolrException;
import org.apache.solr.request.SolrQueryRequest;
 import org.apache.solr.schema.IndexSchema;
 import org.junit.BeforeClass;
 import org.junit.Test;
@@ -39,22 +40,23 @@ public class QueryParsingTest extends SolrTestCaseJ4 {
   @Test
   public void testSort() throws Exception {
     Sort sort;
    SolrQueryRequest req = req();
 
     IndexSchema schema = h.getCore().getSchema();
    sort = QueryParsing.parseSort("score desc", schema);
    sort = QueryParsing.parseSort("score desc", req);
     assertNull("sort", sort);//only 1 thing in the list, no Sort specified
 
    sort = QueryParsing.parseSort("score asc", schema);
    sort = QueryParsing.parseSort("score asc", req);
     SortField[] flds = sort.getSort();
     assertEquals(flds[0].getType(), SortField.SCORE);
     assertTrue(flds[0].getReverse());
 
    sort = QueryParsing.parseSort("weight desc", schema);
    sort = QueryParsing.parseSort("weight desc", req);
     flds = sort.getSort();
     assertEquals(flds[0].getType(), SortField.FLOAT);
     assertEquals(flds[0].getField(), "weight");
     assertEquals(flds[0].getReverse(), true);
    sort = QueryParsing.parseSort("weight desc,bday asc", schema);
    sort = QueryParsing.parseSort("weight desc,bday asc", req);
     flds = sort.getSort();
     assertEquals(flds[0].getType(), SortField.FLOAT);
     assertEquals(flds[0].getField(), "weight");
@@ -63,7 +65,7 @@ public class QueryParsingTest extends SolrTestCaseJ4 {
     assertEquals(flds[1].getField(), "bday");
     assertEquals(flds[1].getReverse(), false);
     //order aliases
    sort = QueryParsing.parseSort("weight top,bday asc", schema);
    sort = QueryParsing.parseSort("weight top,bday asc", req);
     flds = sort.getSort();
     assertEquals(flds[0].getType(), SortField.FLOAT);
     assertEquals(flds[0].getField(), "weight");
@@ -71,7 +73,7 @@ public class QueryParsingTest extends SolrTestCaseJ4 {
     assertEquals(flds[1].getType(), SortField.LONG);
     assertEquals(flds[1].getField(), "bday");
     assertEquals(flds[1].getReverse(), false);
    sort = QueryParsing.parseSort("weight top,bday bottom", schema);
    sort = QueryParsing.parseSort("weight top,bday bottom", req);
     flds = sort.getSort();
     assertEquals(flds[0].getType(), SortField.FLOAT);
     assertEquals(flds[0].getField(), "weight");
@@ -81,20 +83,20 @@ public class QueryParsingTest extends SolrTestCaseJ4 {
     assertEquals(flds[1].getReverse(), false);
 
     //test weird spacing
    sort = QueryParsing.parseSort("weight         desc,            bday         asc", schema);
    sort = QueryParsing.parseSort("weight         desc,            bday         asc", req);
     flds = sort.getSort();
     assertEquals(flds[0].getType(), SortField.FLOAT);
     assertEquals(flds[0].getField(), "weight");
     assertEquals(flds[1].getField(), "bday");
     assertEquals(flds[1].getType(), SortField.LONG);
     //handles trailing commas
    sort = QueryParsing.parseSort("weight desc,", schema);
    sort = QueryParsing.parseSort("weight desc,", req);
     flds = sort.getSort();
     assertEquals(flds[0].getType(), SortField.FLOAT);
     assertEquals(flds[0].getField(), "weight");
 
     //test functions
    sort = QueryParsing.parseSort("pow(weight, 2) desc", schema);
    sort = QueryParsing.parseSort("pow(weight, 2) desc", req);
     flds = sort.getSort();
     assertEquals(flds[0].getType(), SortField.CUSTOM);
     //Not thrilled about the fragility of string matching here, but...
@@ -102,12 +104,12 @@ public class QueryParsingTest extends SolrTestCaseJ4 {
     assertEquals(flds[0].getField(), "pow(float(weight),const(2.0))");
     
     //test functions (more deep)
    sort = QueryParsing.parseSort("sum(product(r_f,sum(d_f,t_f,1)),a_f) asc", schema);
    sort = QueryParsing.parseSort("sum(product(r_f,sum(d_f,t_f,1)),a_f) asc", req);
     flds = sort.getSort();
     assertEquals(flds[0].getType(), SortField.CUSTOM);
     assertEquals(flds[0].getField(), "sum(product(float(r_f),sum(float(d_f),float(t_f),const(1.0))),float(a_f))");
 
    sort = QueryParsing.parseSort("pow(weight,                 2)         desc", schema);
    sort = QueryParsing.parseSort("pow(weight,                 2)         desc", req);
     flds = sort.getSort();
     assertEquals(flds[0].getType(), SortField.CUSTOM);
     //Not thrilled about the fragility of string matching here, but...
@@ -115,7 +117,7 @@ public class QueryParsingTest extends SolrTestCaseJ4 {
     assertEquals(flds[0].getField(), "pow(float(weight),const(2.0))");
 
 
    sort = QueryParsing.parseSort("pow(weight, 2) desc, weight    desc,   bday    asc", schema);
    sort = QueryParsing.parseSort("pow(weight, 2) desc, weight    desc,   bday    asc", req);
     flds = sort.getSort();
     assertEquals(flds[0].getType(), SortField.CUSTOM);
 
@@ -129,19 +131,19 @@ public class QueryParsingTest extends SolrTestCaseJ4 {
     assertEquals(flds[2].getType(), SortField.LONG);
     
     //handles trailing commas
    sort = QueryParsing.parseSort("weight desc,", schema);
    sort = QueryParsing.parseSort("weight desc,", req);
     flds = sort.getSort();
     assertEquals(flds[0].getType(), SortField.FLOAT);
     assertEquals(flds[0].getField(), "weight");
 
     //Test literals in functions
    sort = QueryParsing.parseSort("strdist(foo_s, \"junk\", jw) desc", schema);
    sort = QueryParsing.parseSort("strdist(foo_s, \"junk\", jw) desc", req);
     flds = sort.getSort();
     assertEquals(flds[0].getType(), SortField.CUSTOM);
     //the value sources get wrapped, so the out field is different than the input
     assertEquals(flds[0].getField(), "strdist(str(foo_s),literal(junk), dist=org.apache.lucene.search.spell.JaroWinklerDistance)");
 
    sort = QueryParsing.parseSort("", schema);
    sort = QueryParsing.parseSort("", req);
     assertNull(sort);
 
   }
@@ -149,44 +151,45 @@ public class QueryParsingTest extends SolrTestCaseJ4 {
   @Test
   public void testBad() throws Exception {
     Sort sort;
    SolrQueryRequest req = req();
 
     IndexSchema schema = h.getCore().getSchema();
     //test some bad vals
     try {
      sort = QueryParsing.parseSort("weight, desc", schema);
      sort = QueryParsing.parseSort("weight, desc", req);
       assertTrue(false);
     } catch (SolrException e) {
       //expected
     }
     try {
      sort = QueryParsing.parseSort("w", schema);
      sort = QueryParsing.parseSort("w", req);
       assertTrue(false);
     } catch (SolrException e) {
       //expected
     }
     try {
      sort = QueryParsing.parseSort("weight desc, bday", schema);
      sort = QueryParsing.parseSort("weight desc, bday", req);
       assertTrue(false);
     } catch (SolrException e) {
     }
 
     try {
       //bad number of commas
      sort = QueryParsing.parseSort("pow(weight,,2) desc, bday asc", schema);
      sort = QueryParsing.parseSort("pow(weight,,2) desc, bday asc", req);
       assertTrue(false);
     } catch (SolrException e) {
     }
 
     try {
       //bad function
      sort = QueryParsing.parseSort("pow() desc, bday asc", schema);
      sort = QueryParsing.parseSort("pow() desc, bday asc", req);
       assertTrue(false);
     } catch (SolrException e) {
     }
 
     try {
       //bad number of parens
      sort = QueryParsing.parseSort("pow((weight,2) desc, bday asc", schema);
      sort = QueryParsing.parseSort("pow((weight,2) desc, bday asc", req);
       assertTrue(false);
     } catch (SolrException e) {
     }
diff --git a/solr/src/test/org/apache/solr/search/function/TestFunctionQuery.java b/solr/src/test/org/apache/solr/search/function/TestFunctionQuery.java
index 7f2025f3d70..91d458885a1 100755
-- a/solr/src/test/org/apache/solr/search/function/TestFunctionQuery.java
++ b/solr/src/test/org/apache/solr/search/function/TestFunctionQuery.java
@@ -359,6 +359,52 @@ public class TestFunctionQuery extends SolrTestCaseJ4 {
     purgeFieldCache(FieldCache.DEFAULT);   // avoid FC insanity
   }
 
  @Test
  public void testSortByFunc() throws Exception {
    assertU(adoc("id", "1", "x_i", "100"));
    assertU(adoc("id", "2", "x_i", "300"));
    assertU(adoc("id", "3", "x_i", "200"));
    assertU(commit());

    String desc = "/response/docs==[{'x_i':300},{'x_i':200},{'x_i':100}]";
    String asc =  "/response/docs==[{'x_i':100},{'x_i':200},{'x_i':300}]";

    String q = "id:[1 TO 3]";
    assertJQ(req("q",q,  "fl","x_i", "sort","add(x_i,x_i) desc")
      ,desc
    );

    // param sub of entire function
    assertJQ(req("q",q,  "fl","x_i", "sort", "$x asc", "x","add(x_i,x_i)")
      ,asc
    );

    // multiple functions
    assertJQ(req("q",q,  "fl","x_i", "sort", "$x asc, $y desc", "x", "5", "y","add(x_i,x_i)")
      ,desc
    );

    // multiple functions inline
    assertJQ(req("q",q,  "fl","x_i", "sort", "add( 10 , 10 ) asc, add(x_i , $const) desc", "const","50")
      ,desc
    );

    // test function w/ local params + func inline
     assertJQ(req("q",q,  "fl","x_i", "sort", "{!key=foo}add(x_i,x_i) desc")
      ,desc
    );

    // test multiple functions w/ local params + func inline
    assertJQ(req("q",q,  "fl","x_i", "sort", "{!key=bar}add(10,20) asc, {!key=foo}add(x_i,x_i) desc")
      ,desc
    );

    // test multiple functions w/ local param value not inlined
    assertJQ(req("q",q,  "fl","x_i", "sort", "{!key=bar v=$s1} asc, {!key=foo v=$s2} desc", "s1","add(3,4)", "s2","add(x_i,5)")
      ,desc
    );
  }

   @Test
   public void testDegreeRads() throws Exception {    
     assertU(adoc("id", "1", "x_td", "0", "y_td", "0"));
- 
2.19.1.windows.1

</comment></unit>
