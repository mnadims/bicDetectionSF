<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" revision="1.0.0" language="Java" filename="E:/01Courses@USASK/CMPT898-HumanDrivenSoftwareEngineeringForScientificResearch/ProjectProgress/data_files/final_dataset/gen_patch_codes/filtered/lucene/57b47fed01.java"><expr><name>From</name> <literal type="number">57b47fed018c1e77cabd3d31a0fc7965a3badf16</literal> <name>Mon</name> <name>Sep</name> <literal type="number">17</literal> <literal type="number">00</literal><operator>:</operator><literal type="number">00</literal><operator>:</operator><literal type="number">00</literal> <literal type="number">2001</literal>
<name>From</name><operator>:</operator> <name>Mark</name> <name>Robert</name> <name><name>Miller</name> <argument_list type="generic">&lt;<argument><name>markrmiller</name><annotation>@<name><name>apache</name><operator>.</operator><name>org</name></name></annotation></argument>&gt;</argument_list></name>
<name>Date</name><operator>:</operator> <name>Tue</name></expr><operator>,</operator> <expr><literal type="number">24</literal> <name>Mar</name> <literal type="number">2015</literal> <literal type="number">03</literal><operator>:</operator><literal type="number">19</literal><operator>:</operator><literal type="number">37</literal> <operator>+</operator><literal type="number">0000</literal>
<name>Subject</name><operator>:</operator> <index>[<expr><name>PATCH</name></expr>]</index> <name>SOLR</name><operator>-</operator><literal type="number">7134</literal><operator>:</operator> <name>Replication</name> <name>can</name> <name>still</name> <name>cause</name> <name>index</name> <name><name>corruption</name><operator>.</operator>

<name>git</name></name><operator>-</operator><name>svn</name><operator>-</operator><name>id</name><operator>:</operator> <name>https</name><operator>:</operator><comment type="line">//svn.apache.org/repos/asf/lucene/dev/trunk@1668779 13f79535-47bb-0310-9956-ffa450edef68</comment>
<operator>--</operator>
 <name>solr</name><operator>/</operator><name><name>CHANGES</name><operator>.</operator><name>txt</name></name>                              <operator>|</operator>   <literal type="number">2</literal> <operator>+</operator>
 <operator>...</operator><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>cloud</name><operator>/</operator><name><name>ElectionContext</name><operator>.</operator><name>java</name></name>    <operator>|</operator>   <literal type="number">2</literal> <operator>+</operator><operator>-</operator>
 <operator>...</operator><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>cloud</name><operator>/</operator><name><name>RecoveryStrategy</name><operator>.</operator><name>java</name></name>   <operator>|</operator>  <literal type="number">11</literal> <operator>+</operator><operator>-</operator>
 <operator>...</operator><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>handler</name><operator>/</operator><name><name>IndexFetcher</name><operator>.</operator><name>java</name></name> <operator>|</operator> <literal type="number">107</literal> <operator>++</operator><operator>++</operator><operator>++</operator><operator>++</operator><operator>++</operator><operator>++</operator><operator>--</operator><operator>--</operator><operator>--</operator>
 <operator>...</operator><operator>/</operator><name>solr</name><operator>/</operator><name>handler</name><operator>/</operator><name>admin</name><operator>/</operator><name><name>CoreAdminHandler</name><operator>.</operator><name>java</name></name>  <operator>|</operator>   <literal type="number">4</literal> <operator>+</operator><operator>-</operator>
 <operator>...</operator><operator>/</operator><name>component</name><operator>/</operator><name><name>RealTimeGetComponent</name><operator>.</operator><name>java</name></name>       <operator>|</operator>  <literal type="number">20</literal> <operator>++</operator><operator>++</operator>
 <operator>...</operator><operator>/</operator><name>solr</name><operator>/</operator><name>update</name><operator>/</operator><name><name>DefaultSolrCoreState</name><operator>.</operator><name>java</name></name>     <operator>|</operator>  <literal type="number">10</literal> <operator>++</operator>
 <operator>...</operator><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>update</name><operator>/</operator><name><name>PeerSync</name><operator>.</operator><name>java</name></name> <operator>|</operator>   <literal type="number">4</literal> <operator>+</operator><operator>-</operator>
 <operator>...</operator><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>update</name><operator>/</operator><name><name>SolrCoreState</name><operator>.</operator><name>java</name></name> <operator>|</operator>   <literal type="number">3</literal> <operator>+</operator>
 <operator>...</operator><operator>/</operator><name>processor</name><operator>/</operator><name><name>DistributedUpdateProcessor</name><operator>.</operator><name>java</name></name> <operator>|</operator>   <literal type="number">2</literal> <operator>+</operator>
 <operator>...</operator><operator>/</operator><name>solr</name><operator>/</operator><name>cloud</name><operator>/</operator><name><name>ChaosMonkeySafeLeaderTest</name><operator>.</operator><name>java</name></name> <operator>|</operator>  <literal type="number">17</literal> <operator>++</operator><operator>-</operator>
 <operator>...</operator><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>cloud</name><operator>/</operator><name><name>RecoveryZkTest</name><operator>.</operator><name>java</name></name> <operator>|</operator>   <literal type="number">4</literal> <operator>+</operator><operator>-</operator>
 <operator>...</operator><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>cloud</name><operator>/</operator><name>hdfs</name><operator>/</operator><name><name>HdfsTestUtil</name><operator>.</operator><name>java</name></name>  <operator>|</operator>  <literal type="number">13</literal> <operator>++</operator><operator>-</operator>
 <operator>...</operator><operator>/</operator><name><name>HdfsWriteToMultipleCollectionsTest</name><operator>.</operator><name>java</name></name>   <operator>|</operator>   <literal type="number">2</literal> <operator>+</operator><operator>-</operator>
 <operator>...</operator><operator>/</operator><name>solr</name><operator>/</operator><name>handler</name><operator>/</operator><name><name>TestReplicationHandler</name><operator>.</operator><name>java</name></name>  <operator>|</operator>   <literal type="number">5</literal> <operator>+</operator><operator>-</operator>
 <operator>...</operator><operator>/</operator><name>solr</name><operator>/</operator><name>cloud</name><operator>/</operator><name><name>StopableIndexingThread</name><operator>.</operator><name>java</name></name>    <operator>|</operator>  <literal type="number">46</literal> <operator>++</operator><operator>++</operator><operator>--</operator><operator>--</operator>
 <literal type="number">16</literal> <name>files</name> <name>changed</name></expr><operator>,</operator> <expr><literal type="number">177</literal> <call><name>insertions</name><argument_list>(<argument><expr><operator>+</operator></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><literal type="number">75</literal> <call><name>deletions</name><argument_list>(<argument><expr><operator>-</operator></expr></argument>)</argument_list></call>

<name>diff</name> <operator>--</operator><name>git</name> <name>a</name><operator>/</operator><name>solr</name><operator>/</operator><name><name>CHANGES</name><operator>.</operator><name>txt</name></name> <name>b</name><operator>/</operator><name>solr</name><operator>/</operator><name><name>CHANGES</name><operator>.</operator><name>txt</name></name>
<name>index</name> <literal type="number">92a2ebd7a11</literal><operator>..</operator><literal type="number">1f2d0f2f620</literal> <literal type="number">100644</literal>
<operator>--</operator> <name>a</name><operator>/</operator><name>solr</name><operator>/</operator><name><name>CHANGES</name><operator>.</operator><name>txt</name></name>
<operator>++</operator> <name>b</name><operator>/</operator><name>solr</name><operator>/</operator><name><name>CHANGES</name><operator>.</operator><name>txt</name></name>
@@ <operator>-</operator><literal type="number">282</literal></expr><operator>,</operator><expr><literal type="number">6</literal> <operator>+</operator><literal type="number">282</literal></expr><operator>,</operator><expr><literal type="number">8</literal> @@ <name>Bug</name> <name>Fixes</name>
 <operator>*</operator> <name>SOLR</name><operator>-</operator><literal type="number">7286</literal><operator>:</operator> <name>Using</name> <name>HDFS</name><literal type="char">'s FileSystem.newInstance does not guarantee a new instance.
   (Mark Miller)
 
* SOLR-7134: Replication can still cause index corruption. (Mark Miller, shalin, Mike Drob)

 Optimizations
 ----------------------
 
diff --git a/solr/core/src/java/org/apache/solr/cloud/ElectionContext.java b/solr/core/src/java/org/apache/solr/cloud/ElectionContext.java
index 912116bc407..2c12ebb0363 100644
-- a/solr/core/src/java/org/apache/solr/cloud/ElectionContext.java
++ b/solr/core/src/java/org/apache/solr/cloud/ElectionContext.java
@@ -305,7 +305,7 @@ final class ShardLeaderElectionContext extends ShardLeaderElectionContextBase {
             searchHolder.decref();
           }
         } catch (Exception e) {
          throw new SolrException(ErrorCode.SERVER_ERROR, null, e);
          log.error("Error in solrcloud_debug block", e);
         }
       }
       if (!success) {
diff --git a/solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy.java b/solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy.java
index 7d5836385fd..1b8fafb6663 100644
-- a/solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy.java
++ b/solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy.java
@@ -160,8 +160,7 @@ public class RecoveryStrategy extends Thread implements ClosableThread {
     boolean success = replicationHandler.doFetch(solrParams, false);
     
     if (!success) {
      throw new SolrException(ErrorCode.SERVER_ERROR,
          "Replication for recovery failed.");
      throw new SolrException(ErrorCode.SERVER_ERROR, "Replication for recovery failed.");
     }
     
     // solrcloud_debug
@@ -179,7 +178,7 @@ public class RecoveryStrategy extends Thread implements ClosableThread {
               + " from "
               + leaderUrl
               + " gen:"
              + core.getDeletionPolicy().getLatestCommit().getGeneration()
              + core.getDeletionPolicy().getLatestCommit() != null ? "null" : core.getDeletionPolicy().getLatestCommit().getGeneration()
               + " data:" + core.getDataDir()
               + " index:" + core.getIndexDir()
               + " newIndex:" + core.getNewIndexDir()
@@ -189,7 +188,7 @@ public class RecoveryStrategy extends Thread implements ClosableThread {
           searchHolder.decref();
         }
       } catch (Exception e) {
        throw new SolrException(ErrorCode.SERVER_ERROR, null, e);
        log.debug("Error in solrcloud_debug block", e);
       }
     }
 
@@ -409,7 +408,7 @@ public class RecoveryStrategy extends Thread implements ClosableThread {
                   searchHolder.decref();
                 }
               } catch (Exception e) {
                throw new SolrException(ErrorCode.SERVER_ERROR, null, e);
                log.debug("Error in solrcloud_debug block", e);
               }
             }
 
@@ -557,7 +556,7 @@ public class RecoveryStrategy extends Thread implements ClosableThread {
           searchHolder.decref();
         }
       } catch (Exception e) {
        throw new SolrException(ErrorCode.SERVER_ERROR, null, e);
        log.debug("Error in solrcloud_debug block", e);
       }
     }
     
diff --git a/solr/core/src/java/org/apache/solr/handler/IndexFetcher.java b/solr/core/src/java/org/apache/solr/handler/IndexFetcher.java
index 3cda5ef61f3..cbe07df7284 100644
-- a/solr/core/src/java/org/apache/solr/handler/IndexFetcher.java
++ b/solr/core/src/java/org/apache/solr/handler/IndexFetcher.java
@@ -245,25 +245,37 @@ public class IndexFetcher {
     }
   }
 
  private boolean successfulInstall = false;

  boolean fetchLatestIndex(final SolrCore core, boolean forceReplication) throws IOException, InterruptedException {
    return fetchLatestIndex(core, forceReplication, false);
  }
  
   /**
    * This command downloads all the necessary files from master to install a index commit point. Only changed files are
    * downloaded. It also downloads the conf files (if they are modified).
    *
    * @param core the SolrCore
    * @param forceReplication force a replication in all cases 
   * @param forceCoreReload force a core reload in all cases
    * @return true on success, false if slave is already in sync
    * @throws IOException if an exception occurs
    */
  boolean fetchLatestIndex(final SolrCore core, boolean forceReplication) throws IOException, InterruptedException {
    successfulInstall = false;
   boolean fetchLatestIndex(final SolrCore core, boolean forceReplication, boolean forceCoreReload) throws IOException, InterruptedException {
    boolean cleanupDone = false;
    boolean successfulInstall = false;
     replicationStartTime = System.currentTimeMillis();
     Directory tmpIndexDir = null;
     String tmpIndex = null;
     Directory indexDir = null;
     String indexDirPath = null;
     boolean deleteTmpIdxDir = true;
    
    if (!core.getSolrCoreState().getLastReplicateIndexSuccess()) {
      // if the last replication was not a success, we force a full replication
      // when we are a bit more confident we may want to try a partial replication
      // if the error is connection related or something, but we have to be careful
      forceReplication = true;
    }
    
     try {
       //get the current '</literal><name>replicateable</name><literal type="char">'</literal></expr> index version in the master
       NamedList response = null;
@@ -404,6 +416,7 @@ public class IndexFetcher {
               + " secs");
           Collection&lt;Map&lt;String,Object&gt;&gt; modifiedConfFiles = getModifiedConfFiles(confFilesToDownload);
           if (!modifiedConfFiles.isEmpty()) {
            reloadCore = true;
             downloadConfFiles(confFilesToDownload, latestGeneration);
             if (isFullCopyNeeded) {
               successfulInstall = modifyIndexProps(tmpIdxDirName);
@@ -426,7 +439,6 @@ public class IndexFetcher {
               logReplicationTimeAndConfFiles(modifiedConfFiles,
                   successfulInstall);// write to a file time of replication and
                                      // conf files.
              reloadCore = true;
             }
           } else {
             terminateAndWaitFsyncService();
@@ -448,7 +460,8 @@ public class IndexFetcher {
         }
         
         // we must reload the core after we open the IW back up
        if (reloadCore) {
       if (successfulInstall &amp;&amp; (reloadCore || forceCoreReload)) {
          LOG.info("Reloading SolrCore {}", core.getName());
           reloadCore();
         }
 
@@ -469,6 +482,16 @@ public class IndexFetcher {
           openNewSearcherAndUpdateCommitPoint();
         }
         
        if (!isFullCopyNeeded &amp;&amp; !forceReplication &amp;&amp; !successfulInstall) {
          cleanup(core, tmpIndexDir, indexDir, deleteTmpIdxDir, successfulInstall);
          cleanupDone = true;
          // we try with a full copy of the index
          LOG.warn(
              "Replication attempt was not successful - trying a full index replication reloadCore={}",
              reloadCore);
          successfulInstall = fetchLatestIndex(core, true, reloadCore);
        }
        
         replicationStartTime = 0;
         return successfulInstall;
       } catch (ReplicationHandlerException e) {
@@ -482,41 +505,51 @@ public class IndexFetcher {
         throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, "Index fetch failed : ", e);
       }
     } finally {
      try {
        if (!successfulInstall) {
          try {
            logReplicationTimeAndConfFiles(null, successfulInstall);
          } catch(Exception e) {
            LOG.error("caught", e);
          }
        }
        filesToDownload = filesDownloaded = confFilesDownloaded = confFilesToDownload = null;
        replicationStartTime = 0;
        dirFileFetcher = null;
        localFileFetcher = null;
        if (fsyncService != null &amp;&amp; !fsyncService.isShutdown()) fsyncService
            .shutdownNow();
        fsyncService = null;
        stop = false;
        fsyncException = null;
      } finally {
        if (deleteTmpIdxDir &amp;&amp; tmpIndexDir != null) {
          try {
            core.getDirectoryFactory().doneWithDirectory(tmpIndexDir);
            core.getDirectoryFactory().remove(tmpIndexDir);
          } catch (IOException e) {
            SolrException.log(LOG, "Error removing directory " + tmpIndexDir, e);
          }
        }
      if (!cleanupDone) {
        cleanup(core, tmpIndexDir, indexDir, deleteTmpIdxDir, successfulInstall);
      }
    }
  }
         
        if (tmpIndexDir != null) {
          core.getDirectoryFactory().release(tmpIndexDir);
  private void cleanup(final SolrCore core, Directory tmpIndexDir,
      Directory indexDir, boolean deleteTmpIdxDir, boolean successfulInstall) throws IOException {
    try {
      if (!successfulInstall) {
        try {
          logReplicationTimeAndConfFiles(null, successfulInstall);
        } catch (Exception e) {
          LOG.error("caught", e);
         }
        
        if (indexDir != null) {
          core.getDirectoryFactory().release(indexDir);
      }
      
      core.getUpdateHandler().getSolrCoreState().setLastReplicateIndexSuccess(successfulInstall);
      
      filesToDownload = filesDownloaded = confFilesDownloaded = confFilesToDownload = null;
      replicationStartTime = 0;
      dirFileFetcher = null;
      localFileFetcher = null;
      if (fsyncService != null &amp;&amp; !fsyncService.isShutdown()) fsyncService
          .shutdownNow();
      fsyncService = null;
      stop = false;
      fsyncException = null;
    } finally {
      if (deleteTmpIdxDir &amp;&amp; tmpIndexDir != null) {
        try {
          core.getDirectoryFactory().doneWithDirectory(tmpIndexDir);
          core.getDirectoryFactory().remove(tmpIndexDir);
        } catch (IOException e) {
          SolrException.log(LOG, "Error removing directory " + tmpIndexDir, e);
         }
       }
      
      if (tmpIndexDir != null) {
        core.getDirectoryFactory().release(tmpIndexDir);
      }
      
      if (indexDir != null) {
        core.getDirectoryFactory().release(indexDir);
      }
     }
   }
 
diff --git a/solr/core/src/java/org/apache/solr/handler/admin/CoreAdminHandler.java b/solr/core/src/java/org/apache/solr/handler/admin/CoreAdminHandler.java
index f32901a6232..30b03564391 100644
-- a/solr/core/src/java/org/apache/solr/handler/admin/CoreAdminHandler.java
++ b/solr/core/src/java/org/apache/solr/handler/admin/CoreAdminHandler.java
@@ -832,7 +832,7 @@ public class CoreAdminHandler extends RequestHandlerBase {
               searchHolder.decref();
             }
           } catch (Exception e) {
            throw new SolrException(ErrorCode.SERVER_ERROR, null, e);
            log.debug("Error in solrcloud_debug block", e);
           }
         }
         if (!success) {
@@ -1011,7 +1011,7 @@ public class CoreAdminHandler extends RequestHandlerBase {
               searchHolder.decref();
             }
           } catch (Exception e) {
            throw new SolrException(ErrorCode.SERVER_ERROR, null, e);
            log.debug("Error in solrcloud_debug block", e);
           }
         }
       }
diff --git a/solr/core/src/java/org/apache/solr/handler/component/RealTimeGetComponent.java b/solr/core/src/java/org/apache/solr/handler/component/RealTimeGetComponent.java
index a8ae0896676..6757f3e732e 100644
-- a/solr/core/src/java/org/apache/solr/handler/component/RealTimeGetComponent.java
++ b/solr/core/src/java/org/apache/solr/handler/component/RealTimeGetComponent.java
@@ -29,6 +29,7 @@ import org.apache.lucene.index.IndexableField;
 import org.apache.lucene.index.StorableField;
 import org.apache.lucene.index.StoredDocument;
 import org.apache.lucene.index.Term;
import org.apache.lucene.search.MatchAllDocsQuery;
 import org.apache.lucene.util.BytesRef;
 import org.apache.lucene.util.BytesRefBuilder;
 import org.apache.solr.client.solrj.SolrResponse;
@@ -98,6 +99,25 @@ public class RealTimeGetComponent extends SearchComponent
 
     val = params.get("getUpdates");
     if (val != null) {
      // solrcloud_debug
      if (log.isDebugEnabled()) {
        try {
          RefCounted&lt;SolrIndexSearcher&gt; searchHolder = req.getCore()
              .getNewestSearcher(false);
          SolrIndexSearcher searcher = searchHolder.get();
          try {
            log.debug(req.getCore().getCoreDescriptor()
                .getCoreContainer().getZkController().getNodeName()
                + " min count to sync to (from most recent searcher view) "
                + searcher.search(new MatchAllDocsQuery(), 1).totalHits);
          } finally {
            searchHolder.decref();
          }
        } catch (Exception e) {
          log.debug("Error in solrcloud_debug block", e);
        }
      }
      
       processGetUpdates(rb);
       return;
     }
diff --git a/solr/core/src/java/org/apache/solr/update/DefaultSolrCoreState.java b/solr/core/src/java/org/apache/solr/update/DefaultSolrCoreState.java
index 0e6ce14dc34..d38fc6b3ad8 100644
-- a/solr/core/src/java/org/apache/solr/update/DefaultSolrCoreState.java
++ b/solr/core/src/java/org/apache/solr/update/DefaultSolrCoreState.java
@@ -53,6 +53,7 @@ public final class DefaultSolrCoreState extends SolrCoreState implements Recover
 
   private volatile boolean recoveryRunning;
   private RecoveryStrategy recoveryStrat;
  private volatile boolean lastReplicationSuccess = true;
 
   private RefCounted&lt;IndexWriter&gt; refCntWriter;
 
@@ -377,5 +378,14 @@ public final class DefaultSolrCoreState extends SolrCoreState implements Recover
     return leaderThrottle;
   }
   
  @Override
  public boolean getLastReplicateIndexSuccess() {
    return lastReplicationSuccess;
  }

  @Override
  public void setLastReplicateIndexSuccess(boolean success) {
    this.lastReplicationSuccess = success;
  }
   
 }
diff --git a/solr/core/src/java/org/apache/solr/update/PeerSync.java b/solr/core/src/java/org/apache/solr/update/PeerSync.java
index 77b26a9fb40..1b3bf96353b 100644
-- a/solr/core/src/java/org/apache/solr/update/PeerSync.java
++ b/solr/core/src/java/org/apache/solr/update/PeerSync.java
@@ -495,7 +495,7 @@ public class PeerSync  {
             cmd.setVersion(version);
             cmd.setFlags(UpdateCommand.PEER_SYNC | UpdateCommand.IGNORE_AUTOCOMMIT);
             if (debug) {
              log.debug(msg() + "add " + cmd);
              log.debug(msg() + "add " + cmd + " id " + sdoc.getField("id"));
             }
             proc.processAdd(cmd);
             break;
@@ -508,7 +508,7 @@ public class PeerSync  {
             cmd.setVersion(version);
             cmd.setFlags(UpdateCommand.PEER_SYNC | UpdateCommand.IGNORE_AUTOCOMMIT);
             if (debug) {
              log.debug(msg() + "delete " + cmd);
              log.debug(msg() + "delete " + cmd + " " + new BytesRef(idBytes).utf8ToString());
             }
             proc.processDelete(cmd);
             break;
diff --git a/solr/core/src/java/org/apache/solr/update/SolrCoreState.java b/solr/core/src/java/org/apache/solr/update/SolrCoreState.java
index e7467a0ea06..b14b5ac483a 100644
-- a/solr/core/src/java/org/apache/solr/update/SolrCoreState.java
++ b/solr/core/src/java/org/apache/solr/update/SolrCoreState.java
@@ -146,4 +146,7 @@ public abstract class SolrCoreState {
    */
   public abstract ActionThrottle getLeaderThrottle();
 
  public abstract boolean getLastReplicateIndexSuccess();

  public abstract void setLastReplicateIndexSuccess(boolean success);
 }
diff --git a/solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor.java b/solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor.java
index 3c201ad9152..b47c4ace655 100644
-- a/solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor.java
++ b/solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor.java
@@ -1081,6 +1081,7 @@ public class DistributedUpdateProcessor extends UpdateRequestProcessor {
               Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());
               if (lastVersion != null &amp;&amp; Math.abs(lastVersion) &gt;= versionOnUpdate) {
                 // This update is a repeat, or was reordered.  We need to drop this update.
                log.debug("Dropping add update due to version {}", idBytes.utf8ToString());
                 return true;
               }
 
@@ -1568,6 +1569,7 @@ public class DistributedUpdateProcessor extends UpdateRequestProcessor {
               Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());
               if (lastVersion != null &amp;&amp; Math.abs(lastVersion) &gt;= versionOnUpdate) {
                 // This update is a repeat, or was reordered.  We need to drop this update.
                log.debug("Dropping delete update due to version {}", idBytes.utf8ToString());
                 return true;
               }
             }
diff --git a/solr/core/src/test/org/apache/solr/cloud/ChaosMonkeySafeLeaderTest.java b/solr/core/src/test/org/apache/solr/cloud/ChaosMonkeySafeLeaderTest.java
index b7d815cb297..d9e835709b6 100644
-- a/solr/core/src/test/org/apache/solr/cloud/ChaosMonkeySafeLeaderTest.java
++ b/solr/core/src/test/org/apache/solr/cloud/ChaosMonkeySafeLeaderTest.java
@@ -112,8 +112,21 @@ public class ChaosMonkeySafeLeaderTest extends AbstractFullDistribZkTestBase {
     
     List&lt;StopableIndexingThread&gt; threads = new ArrayList&lt;&gt;();
     int threadCount = 2;
    int batchSize = 1;
    if (random().nextBoolean()) {
      batchSize = random().nextInt(98) + 2;
    }
    
    boolean pauseBetweenUpdates = TEST_NIGHTLY ? random().nextBoolean() : true;
    int maxUpdates = -1;
    if (!pauseBetweenUpdates) {
      maxUpdates = 1000 + random().nextInt(1000);
    } else {
      maxUpdates = 15000;
    }
    
     for (int i = 0; i &lt; threadCount; i++) {
      StopableIndexingThread indexThread = new StopableIndexingThread(controlClient, cloudClient, Integer.toString(i), true);
      StopableIndexingThread indexThread = new StopableIndexingThread(controlClient, cloudClient, Integer.toString(i), true, maxUpdates, batchSize, pauseBetweenUpdates); // random().nextInt(999) + 1
       threads.add(indexThread);
       indexThread.start();
     }
@@ -158,7 +171,7 @@ public class ChaosMonkeySafeLeaderTest extends AbstractFullDistribZkTestBase {
 
     waitForThingsToLevelOut(180000);
 
    checkShardConsistency(true, true);
    checkShardConsistency(batchSize == 1, true);
     
     if (VERBOSE) System.out.println("control docs:" + controlClient.query(new SolrQuery("*:*")).getResults().getNumFound() + "\n\n");
     
diff --git a/solr/core/src/test/org/apache/solr/cloud/RecoveryZkTest.java b/solr/core/src/test/org/apache/solr/cloud/RecoveryZkTest.java
index 9966178138a..f828b933d37 100644
-- a/solr/core/src/test/org/apache/solr/cloud/RecoveryZkTest.java
++ b/solr/core/src/test/org/apache/solr/cloud/RecoveryZkTest.java
@@ -72,10 +72,10 @@ public class RecoveryZkTest extends AbstractFullDistribZkTestBase {
       maxDoc = maxDocNightlyList[random().nextInt(maxDocList.length - 1)];
     }
     
    indexThread = new StopableIndexingThread(controlClient, cloudClient, "1", true, maxDoc);
    indexThread = new StopableIndexingThread(controlClient, cloudClient, "1", true, maxDoc, 1, true);
     indexThread.start();
     
    indexThread2 = new StopableIndexingThread(controlClient, cloudClient, "2", true, maxDoc);
    indexThread2 = new StopableIndexingThread(controlClient, cloudClient, "2", true, maxDoc, 1, true);
     
     indexThread2.start();
 
diff --git a/solr/core/src/test/org/apache/solr/cloud/hdfs/HdfsTestUtil.java b/solr/core/src/test/org/apache/solr/cloud/hdfs/HdfsTestUtil.java
index 5f02a6876ca..69e035f4b63 100644
-- a/solr/core/src/test/org/apache/solr/cloud/hdfs/HdfsTestUtil.java
++ b/solr/core/src/test/org/apache/solr/cloud/hdfs/HdfsTestUtil.java
@@ -18,6 +18,8 @@ import org.apache.hadoop.hdfs.server.namenode.NameNodeAdapter;
 import org.apache.lucene.util.LuceneTestCase;
 import org.apache.solr.SolrTestCaseJ4;
 import org.apache.solr.common.util.IOUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
 
 /*
  * Licensed to the Apache Software Foundation (ASF) under one or more
@@ -37,6 +39,7 @@ import org.apache.solr.common.util.IOUtils;
  */
 
 public class HdfsTestUtil {
  private static Logger log = LoggerFactory.getLogger(HdfsTestUtil.class);
   
   private static Locale savedLocale;
   
@@ -131,7 +134,15 @@ public class HdfsTestUtil {
       if (timer != null) {
         timer.cancel();
       }
      dfsCluster.shutdown();
      try {
        dfsCluster.shutdown();
      } catch (Error e) {
        // Added in SOLR-7134
        // Rarely, this can fail to either a NullPointerException
        // or a class not found exception. The later may fixable
        // by adding test dependencies.
        log.warn("Exception shutting down dfsCluster", e);
      }
     }
     
     // TODO: we HACK around HADOOP-9643
diff --git a/solr/core/src/test/org/apache/solr/cloud/hdfs/HdfsWriteToMultipleCollectionsTest.java b/solr/core/src/test/org/apache/solr/cloud/hdfs/HdfsWriteToMultipleCollectionsTest.java
index ba198cee107..45946e4887e 100644
-- a/solr/core/src/test/org/apache/solr/cloud/hdfs/HdfsWriteToMultipleCollectionsTest.java
++ b/solr/core/src/test/org/apache/solr/cloud/hdfs/HdfsWriteToMultipleCollectionsTest.java
@@ -105,7 +105,7 @@ public class HdfsWriteToMultipleCollectionsTest extends BasicDistributedZkTest {
       CloudSolrClient client = new CloudSolrClient(zkServer.getZkAddress());
       client.setDefaultCollection(ACOLLECTION + i);
       cloudClients.add(client);
      StopableIndexingThread indexThread = new StopableIndexingThread(null, client, "1", true, docCount);
      StopableIndexingThread indexThread = new StopableIndexingThread(null, client, "1", true, docCount, 1, true);
       threads.add(indexThread);
       indexThread.start();
     }
diff --git a/solr/core/src/test/org/apache/solr/handler/TestReplicationHandler.java b/solr/core/src/test/org/apache/solr/handler/TestReplicationHandler.java
index c0b80c03b38..feed24acbe1 100644
-- a/solr/core/src/test/org/apache/solr/handler/TestReplicationHandler.java
++ b/solr/core/src/test/org/apache/solr/handler/TestReplicationHandler.java
@@ -301,8 +301,9 @@ public class TestReplicationHandler extends SolrTestCaseJ4 {
                     details.get("slave"));
       // SOLR-2677: assert not false negatives
       Object timesFailed = ((NamedList)details.get("slave")).get(IndexFetcher.TIMES_FAILED);
      assertEquals("slave has fetch error count",
                   null, timesFailed);
      // SOLR-7134: we can have a fail because some mock index files have no checksum, will
      // always be downloaded, and may not be able to be moved into the existing index
      assertTrue("slave has fetch error count: " + (String)timesFailed, timesFailed == null || ((String) timesFailed).equals("1"));
 
       if (3 != i) {
         // index &amp; fetch
diff --git a/solr/test-framework/src/java/org/apache/solr/cloud/StopableIndexingThread.java b/solr/test-framework/src/java/org/apache/solr/cloud/StopableIndexingThread.java
index 3f04d7050a0..f6832112477 100644
-- a/solr/test-framework/src/java/org/apache/solr/cloud/StopableIndexingThread.java
++ b/solr/test-framework/src/java/org/apache/solr/cloud/StopableIndexingThread.java
@@ -42,18 +42,23 @@ public class StopableIndexingThread extends AbstractFullDistribZkTestBase.Stopab
   private SolrClient cloudClient;
   private int numDeletes;
   private int numAdds;

  private List&lt;SolrInputDocument&gt; docs = new ArrayList&lt;SolrInputDocument&gt;();
  private int batchSize;
  private boolean pauseBetweenUpdates;
  
   public StopableIndexingThread(SolrClient controlClient, SolrClient cloudClient, String id, boolean doDeletes) {
    this(controlClient, cloudClient, id, doDeletes, -1);
    this(controlClient, cloudClient, id, doDeletes, -1, 1, true);
   }
   
  public StopableIndexingThread(SolrClient controlClient, SolrClient cloudClient, String id, boolean doDeletes, int numCycles) {
  public StopableIndexingThread(SolrClient controlClient, SolrClient cloudClient, String id, boolean doDeletes, int numCycles, int batchSize, boolean pauseBetweenUpdates) {
     super("StopableIndexingThread");
     this.controlClient = controlClient;
     this.cloudClient = cloudClient;
     this.id = id;
     this.doDeletes = doDeletes;
     this.numCycles = numCycles;
    this.batchSize = batchSize;
    this.pauseBetweenUpdates = pauseBetweenUpdates;
     setDaemon(true);
   }
   
@@ -100,8 +105,17 @@ public class StopableIndexingThread extends AbstractFullDistribZkTestBase.Stopab
       
       try {
         numAdds++;
        indexr("id", id, i1, 50, t1,
        SolrInputDocument doc = new SolrInputDocument();
        addFields(doc, "id", id, i1, 50, t1,
             "to come to the aid of their country.");
        addFields(doc, "rnd_b", true);
        
        docs.add(doc);
        
        if (docs.size() &gt;= batchSize)  {
          indexDocs(docs);
          docs.clear();
        }
       } catch (Exception e) {
         addFailed = true;
         System.err.println("REQUEST FAILED for id=" + id);
@@ -117,10 +131,12 @@ public class StopableIndexingThread extends AbstractFullDistribZkTestBase.Stopab
         deletes.add(id);
       }
       
      try {
        Thread.currentThread().sleep(AbstractFullDistribZkTestBase.random().nextInt(100));
      } catch (InterruptedException e) {
        Thread.currentThread().interrupt();
      if (docs.size() &gt; 0 &amp;&amp; pauseBetweenUpdates) {
        try {
          Thread.currentThread().sleep(AbstractFullDistribZkTestBase.random().nextInt(500) + 50);
        } catch (InterruptedException e) {
          Thread.currentThread().interrupt();
        }
       }
     }
     
@@ -151,26 +167,18 @@ public class StopableIndexingThread extends AbstractFullDistribZkTestBase.Stopab
     }
   }
   
  protected void indexr(Object... fields) throws Exception {
    SolrInputDocument doc = new SolrInputDocument();
    addFields(doc, fields);
    addFields(doc, "rnd_b", true);
    indexDoc(doc);
  }
  
  protected void indexDoc(SolrInputDocument doc) throws IOException,
  protected void indexDocs(List&lt;SolrInputDocument&gt; docs) throws IOException,
       SolrServerException {
     
     if (controlClient != null) {
       UpdateRequest req = new UpdateRequest();
      req.add(doc);
      req.add(docs);
       req.setParam("CONTROL", "TRUE");
       req.process(controlClient);
     }

     
     UpdateRequest ureq = new UpdateRequest();
    ureq.add(doc);
    ureq.add(docs);
     ureq.process(cloudClient);
   }
   
- 
2.19.1.windows.1

</unit>
