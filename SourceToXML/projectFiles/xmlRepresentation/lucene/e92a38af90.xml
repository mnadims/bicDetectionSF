<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" revision="1.0.0" language="Java" filename="E:/01Courses@USASK/CMPT898-HumanDrivenSoftwareEngineeringForScientificResearch/ProjectProgress/data_files/final_dataset/gen_patch_codes/filtered/lucene/e92a38af90.java"><expr><name>From</name> <name>e92a38af90d12e51390b4307ccbe0c24ac7b6b4e</name> <name>Mon</name> <name>Sep</name> <literal type="number">17</literal> <literal type="number">00</literal><operator>:</operator><literal type="number">00</literal><operator>:</operator><literal type="number">00</literal> <literal type="number">2001</literal>
<name>From</name><operator>:</operator> <name>Adrien</name> <name><name>Grand</name> <argument_list type="generic">&lt;<argument><name>jpountz</name><annotation>@<name><name>gmail</name><operator>.</operator><name>com</name></name></annotation></argument>&gt;</argument_list></name>
<name>Date</name><operator>:</operator> <name>Tue</name></expr><operator>,</operator> <expr><literal type="number">28</literal> <name>Jun</name> <literal type="number">2016</literal> <literal type="number">18</literal><operator>:</operator><literal type="number">23</literal><operator>:</operator><literal type="number">11</literal> <operator>+</operator><literal type="number">0200</literal>
<name>Subject</name><operator>:</operator> <index>[<expr><name>PATCH</name></expr>]</index> <name>LUCENE</name><operator>-</operator><literal type="number">7355</literal><operator>:</operator> <name>Add</name> <name>Analyzer</name><operator>#</operator><call><name>normalize</name><argument_list>()</argument_list></call> <name>and</name> <name>use</name> <name>it</name> <name>in</name> <name>query</name>
 <name><name>parsers</name><operator>.</operator></name>

--
 <name>lucene</name><operator>/</operator><name><name>CHANGES</name><operator>.</operator><name>txt</name></name>                            <operator>|</operator>  <literal type="number">10</literal> <operator>+</operator>
 <name>lucene</name><operator>/</operator><name><name>MIGRATE</name><operator>.</operator><name>txt</name></name>                            <operator>|</operator>  <literal type="number">11</literal> <operator>+</operator>
 <operator>...</operator><operator>/</operator><name>lucene</name><operator>/</operator><name>analysis</name><operator>/</operator><name>ar</name><operator>/</operator><name><name>ArabicAnalyzer</name><operator>.</operator><name>java</name></name>    <operator>|</operator>   <literal type="number">8</literal> <operator>+</operator>
 <operator>...</operator><operator>/</operator><name>lucene</name><operator>/</operator><name>analysis</name><operator>/</operator><name>bg</name><operator>/</operator><name><name>BulgarianAnalyzer</name><operator>.</operator><name>java</name></name> <operator>|</operator>   <literal type="number">7</literal> <operator>+</operator>
 <operator>...</operator><operator>/</operator><name>lucene</name><operator>/</operator><name>analysis</name><operator>/</operator><name>br</name><operator>/</operator><name><name>BrazilianAnalyzer</name><operator>.</operator><name>java</name></name> <operator>|</operator>   <literal type="number">7</literal> <operator>+</operator>
 <operator>...</operator><operator>/</operator><name>lucene</name><operator>/</operator><name>analysis</name><operator>/</operator><name>ca</name><operator>/</operator><name><name>CatalanAnalyzer</name><operator>.</operator><name>java</name></name>   <operator>|</operator>   <literal type="number">8</literal> <operator>+</operator>
 <operator>...</operator><operator>/</operator><name>lucene</name><operator>/</operator><name>analysis</name><operator>/</operator><name>cjk</name><operator>/</operator><name><name>CJKAnalyzer</name><operator>.</operator><name>java</name></name>      <operator>|</operator>   <literal type="number">7</literal> <operator>+</operator>
 <operator>...</operator><operator>/</operator><name>lucene</name><operator>/</operator><name>analysis</name><operator>/</operator><name>ckb</name><operator>/</operator><name><name>SoraniAnalyzer</name><operator>.</operator><name>java</name></name>   <operator>|</operator>   <literal type="number">9</literal> <operator>+</operator>
 <operator>...</operator><operator>/</operator><name>lucene</name><operator>/</operator><name>analysis</name><operator>/</operator><name>core</name><operator>/</operator><name><name>SimpleAnalyzer</name><operator>.</operator><name>java</name></name>  <operator>|</operator>   <literal type="number">6</literal> <operator>+</operator>
 <operator>...</operator><operator>/</operator><name>lucene</name><operator>/</operator><name>analysis</name><operator>/</operator><name>core</name><operator>/</operator><name><name>StopAnalyzer</name><operator>.</operator><name>java</name></name>    <operator>|</operator>   <literal type="number">6</literal> <operator>+</operator>
 <operator>...</operator><operator>/</operator><name>analysis</name><operator>/</operator><name>custom</name><operator>/</operator><name><name>CustomAnalyzer</name><operator>.</operator><name>java</name></name>       <operator>|</operator>  <literal type="number">28</literal> <operator>+</operator><operator>-</operator>
 <operator>...</operator><operator>/</operator><name>lucene</name><operator>/</operator><name>analysis</name><operator>/</operator><name>cz</name><operator>/</operator><name><name>CzechAnalyzer</name><operator>.</operator><name>java</name></name>     <operator>|</operator>   <literal type="number">7</literal> <operator>+</operator>
 <operator>...</operator><operator>/</operator><name>lucene</name><operator>/</operator><name>analysis</name><operator>/</operator><name>da</name><operator>/</operator><name><name>DanishAnalyzer</name><operator>.</operator><name>java</name></name>    <operator>|</operator>   <literal type="number">7</literal> <operator>+</operator>
 <operator>...</operator><operator>/</operator><name>lucene</name><operator>/</operator><name>analysis</name><operator>/</operator><name>de</name><operator>/</operator><name><name>GermanAnalyzer</name><operator>.</operator><name>java</name></name>    <operator>|</operator>   <literal type="number">8</literal> <operator>+</operator>
 <operator>...</operator><operator>/</operator><name>lucene</name><operator>/</operator><name>analysis</name><operator>/</operator><name>el</name><operator>/</operator><name><name>GreekAnalyzer</name><operator>.</operator><name>java</name></name>     <operator>|</operator>   <literal type="number">7</literal> <operator>+</operator>
 <operator>...</operator><operator>/</operator><name>lucene</name><operator>/</operator><name>analysis</name><operator>/</operator><name>en</name><operator>/</operator><name><name>EnglishAnalyzer</name><operator>.</operator><name>java</name></name>   <operator>|</operator>   <literal type="number">7</literal> <operator>+</operator>
 <operator>...</operator><operator>/</operator><name>lucene</name><operator>/</operator><name>analysis</name><operator>/</operator><name>es</name><operator>/</operator><name><name>SpanishAnalyzer</name><operator>.</operator><name>java</name></name>   <operator>|</operator>   <literal type="number">7</literal> <operator>+</operator>
 <operator>...</operator><operator>/</operator><name>lucene</name><operator>/</operator><name>analysis</name><operator>/</operator><name>eu</name><operator>/</operator><name><name>BasqueAnalyzer</name><operator>.</operator><name>java</name></name>    <operator>|</operator>   <literal type="number">7</literal> <operator>+</operator>
 <operator>...</operator><operator>/</operator><name>lucene</name><operator>/</operator><name>analysis</name><operator>/</operator><name>fa</name><operator>/</operator><name><name>PersianAnalyzer</name><operator>.</operator><name>java</name></name>   <operator>|</operator>  <literal type="number">14</literal> <operator>+</operator><operator>-</operator>
 <operator>...</operator><operator>/</operator><name>lucene</name><operator>/</operator><name>analysis</name><operator>/</operator><name>fi</name><operator>/</operator><name><name>FinnishAnalyzer</name><operator>.</operator><name>java</name></name>   <operator>|</operator>   <literal type="number">7</literal> <operator>+</operator>
 <operator>...</operator><operator>/</operator><name>lucene</name><operator>/</operator><name>analysis</name><operator>/</operator><name>fr</name><operator>/</operator><name><name>FrenchAnalyzer</name><operator>.</operator><name>java</name></name>    <operator>|</operator>   <literal type="number">8</literal> <operator>+</operator>
 <operator>...</operator><operator>/</operator><name>lucene</name><operator>/</operator><name>analysis</name><operator>/</operator><name>ga</name><operator>/</operator><name><name>IrishAnalyzer</name><operator>.</operator><name>java</name></name>     <operator>|</operator>   <literal type="number">8</literal> <operator>+</operator>
 <operator>...</operator><operator>/</operator><name>lucene</name><operator>/</operator><name>analysis</name><operator>/</operator><name>gl</name><operator>/</operator><name><name>GalicianAnalyzer</name><operator>.</operator><name>java</name></name>  <operator>|</operator>   <literal type="number">7</literal> <operator>+</operator>
 <operator>...</operator><operator>/</operator><name>lucene</name><operator>/</operator><name>analysis</name><operator>/</operator><name>hi</name><operator>/</operator><name><name>HindiAnalyzer</name><operator>.</operator><name>java</name></name>     <operator>|</operator>  <literal type="number">11</literal> <operator>+</operator>
 <operator>...</operator><operator>/</operator><name>lucene</name><operator>/</operator><name>analysis</name><operator>/</operator><name>hu</name><operator>/</operator><name><name>HungarianAnalyzer</name><operator>.</operator><name>java</name></name> <operator>|</operator>   <literal type="number">7</literal> <operator>+</operator>
 <operator>...</operator><operator>/</operator><name>lucene</name><operator>/</operator><name>analysis</name><operator>/</operator><name>hy</name><operator>/</operator><name><name>ArmenianAnalyzer</name><operator>.</operator><name>java</name></name>  <operator>|</operator>   <literal type="number">7</literal> <operator>+</operator>
 <operator>...</operator><operator>/</operator><name>analysis</name><operator>/</operator><name>id</name><operator>/</operator><name><name>IndonesianAnalyzer</name><operator>.</operator><name>java</name></name>       <operator>|</operator>   <literal type="number">7</literal> <operator>+</operator>
 <operator>...</operator><operator>/</operator><name>lucene</name><operator>/</operator><name>analysis</name><operator>/</operator><name>it</name><operator>/</operator><name><name>ItalianAnalyzer</name><operator>.</operator><name>java</name></name>   <operator>|</operator>   <literal type="number">8</literal> <operator>+</operator>
 <operator>...</operator><operator>/</operator><name>analysis</name><operator>/</operator><name>lt</name><operator>/</operator><name><name>LithuanianAnalyzer</name><operator>.</operator><name>java</name></name>       <operator>|</operator>   <literal type="number">7</literal> <operator>+</operator>
 <operator>...</operator><operator>/</operator><name>lucene</name><operator>/</operator><name>analysis</name><operator>/</operator><name>lv</name><operator>/</operator><name><name>LatvianAnalyzer</name><operator>.</operator><name>java</name></name>   <operator>|</operator>   <literal type="number">7</literal> <operator>+</operator>
 <operator>...</operator><operator>/</operator><name>lucene</name><operator>/</operator><name>analysis</name><operator>/</operator><name>nl</name><operator>/</operator><name><name>DutchAnalyzer</name><operator>.</operator><name>java</name></name>     <operator>|</operator>   <literal type="number">7</literal> <operator>+</operator>
 <operator>...</operator><operator>/</operator><name>lucene</name><operator>/</operator><name>analysis</name><operator>/</operator><name>no</name><operator>/</operator><name><name>NorwegianAnalyzer</name><operator>.</operator><name>java</name></name> <operator>|</operator>   <literal type="number">7</literal> <operator>+</operator>
 <operator>...</operator><operator>/</operator><name>analysis</name><operator>/</operator><name>pt</name><operator>/</operator><name><name>PortugueseAnalyzer</name><operator>.</operator><name>java</name></name>       <operator>|</operator>   <literal type="number">7</literal> <operator>+</operator>
 <operator>...</operator><operator>/</operator><name>lucene</name><operator>/</operator><name>analysis</name><operator>/</operator><name>ro</name><operator>/</operator><name><name>RomanianAnalyzer</name><operator>.</operator><name>java</name></name>  <operator>|</operator>   <literal type="number">7</literal> <operator>+</operator>
 <operator>...</operator><operator>/</operator><name>lucene</name><operator>/</operator><name>analysis</name><operator>/</operator><name>ru</name><operator>/</operator><name><name>RussianAnalyzer</name><operator>.</operator><name>java</name></name>   <operator>|</operator>   <literal type="number">7</literal> <operator>+</operator>
 <operator>...</operator><operator>/</operator><name>analysis</name><operator>/</operator><name>standard</name><operator>/</operator><name><name>ClassicAnalyzer</name><operator>.</operator><name>java</name></name>    <operator>|</operator>   <literal type="number">5</literal> <operator>+</operator>
 <operator>...</operator><operator>/</operator><name>standard</name><operator>/</operator><name><name>UAX29URLEmailAnalyzer</name><operator>.</operator><name>java</name></name>       <operator>|</operator>   <literal type="number">5</literal> <operator>+</operator>
 <operator>...</operator><operator>/</operator><name>lucene</name><operator>/</operator><name>analysis</name><operator>/</operator><name>sv</name><operator>/</operator><name><name>SwedishAnalyzer</name><operator>.</operator><name>java</name></name>   <operator>|</operator>   <literal type="number">7</literal> <operator>+</operator>
 <operator>...</operator><operator>/</operator><name>lucene</name><operator>/</operator><name>analysis</name><operator>/</operator><name>th</name><operator>/</operator><name><name>ThaiAnalyzer</name><operator>.</operator><name>java</name></name>      <operator>|</operator>   <literal type="number">7</literal> <operator>+</operator>
 <operator>...</operator><operator>/</operator><name>lucene</name><operator>/</operator><name>analysis</name><operator>/</operator><name>tr</name><operator>/</operator><name><name>TurkishAnalyzer</name><operator>.</operator><name>java</name></name>   <operator>|</operator>   <literal type="number">7</literal> <operator>+</operator>
 <operator>...</operator><operator>/</operator><name>collation</name><operator>/</operator><name><name>CollationKeyAnalyzer</name><operator>.</operator><name>java</name></name>       <operator>|</operator>   <literal type="number">7</literal> <operator>+</operator>
 <operator>...</operator><operator>/</operator><name>core</name><operator>/</operator><name><name>TestAllAnalyzersHaveFactories</name><operator>.</operator><name>java</name></name>   <operator>|</operator>   <literal type="number">2</literal> <operator>+</operator>
 <operator>...</operator><operator>/</operator><name>lucene</name><operator>/</operator><name>analysis</name><operator>/</operator><name>core</name><operator>/</operator><name><name>TestAnalyzers</name><operator>.</operator><name>java</name></name>   <operator>|</operator>   <literal type="number">4</literal> <operator>+</operator>
 <operator>...</operator><operator>/</operator><name>analysis</name><operator>/</operator><name>core</name><operator>/</operator><name><name>TestRandomChains</name><operator>.</operator><name>java</name></name>       <operator>|</operator>  <literal type="number">10</literal> <operator>+</operator><operator>-</operator>
 <operator>...</operator><operator>/</operator><name>analysis</name><operator>/</operator><name>custom</name><operator>/</operator><name><name>TestCustomAnalyzer</name><operator>.</operator><name>java</name></name>   <operator>|</operator> <literal type="number">143</literal> <operator>++</operator><operator>++</operator><operator>++</operator><operator>++</operator><operator>++</operator>
 <operator>...</operator><operator>/</operator><name>lucene</name><operator>/</operator><name>analysis</name><operator>/</operator><name>ja</name><operator>/</operator><name><name>JapaneseAnalyzer</name><operator>.</operator><name>java</name></name>  <operator>|</operator>   <literal type="number">7</literal> <operator>+</operator>
 <operator>...</operator><operator>/</operator><name>morfologik</name><operator>/</operator><name><name>MorfologikAnalyzer</name><operator>.</operator><name>java</name></name>        <operator>|</operator>   <literal type="number">6</literal> <operator>+</operator>
 <operator>...</operator><operator>/</operator><name>cn</name><operator>/</operator><name>smart</name><operator>/</operator><name><name>SmartChineseAnalyzer</name><operator>.</operator><name>java</name></name>        <operator>|</operator>   <literal type="number">6</literal> <operator>+</operator>
 <operator>...</operator><operator>/</operator><name>lucene</name><operator>/</operator><name>analysis</name><operator>/</operator><name>pl</name><operator>/</operator><name><name>PolishAnalyzer</name><operator>.</operator><name>java</name></name>    <operator>|</operator>   <literal type="number">7</literal> <operator>+</operator>
 <operator>...</operator><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>analysis</name><operator>/</operator><name><name>Analyzer</name><operator>.</operator><name>java</name></name>  <operator>|</operator> <literal type="number">135</literal> <operator>++</operator><operator>++</operator><operator>++</operator><operator>++</operator><operator>-</operator>
 <operator>...</operator><operator>/</operator><name>analysis</name><operator>/</operator><name>standard</name><operator>/</operator><name><name>StandardAnalyzer</name><operator>.</operator><name>java</name></name>   <operator>|</operator>   <literal type="number">7</literal> <operator>+</operator>
 <operator>...</operator><operator>/</operator><name>standard</name><operator>/</operator><name><name>TestStandardAnalyzer</name><operator>.</operator><name>java</name></name>        <operator>|</operator>   <literal type="number">6</literal> <operator>+</operator>
 <operator>...</operator><operator>/</operator><name>analyzing</name><operator>/</operator><name><name>AnalyzingQueryParser</name><operator>.</operator><name>java</name></name>       <operator>|</operator> <literal type="number">202</literal> <operator>--</operator><operator>--</operator><operator>--</operator><operator>--</operator><operator>--</operator><operator>--</operator><operator>-</operator>
 <operator>...</operator><operator>/</operator><name>queryparser</name><operator>/</operator><name>classic</name><operator>/</operator><name><name>QueryParserBase</name><operator>.</operator><name>java</name></name>  <operator>|</operator> <literal type="number">140</literal> <operator>++</operator><operator>+</operator><operator>--</operator><operator>--</operator><operator>--</operator>
 <operator>...</operator><operator>/</operator><name><name>ComplexPhraseQueryParser</name><operator>.</operator><name>java</name></name>             <operator>|</operator>  <literal type="number">17</literal> <operator>+</operator><operator>-</operator>
 <operator>...</operator><operator>/</operator><name><name>CommonQueryParserConfiguration</name><operator>.</operator><name>java</name></name>       <operator>|</operator>  <literal type="number">12</literal> <operator>-</operator>
 <operator>...</operator><operator>/</operator><name>standard</name><operator>/</operator><name><name>StandardQueryParser</name><operator>.</operator><name>java</name></name>         <operator>|</operator>  <literal type="number">30</literal> <operator>--</operator>
 <operator>...</operator><operator>/</operator><name>config</name><operator>/</operator><name><name>StandardQueryConfigHandler</name><operator>.</operator><name>java</name></name>    <operator>|</operator>   <literal type="number">9</literal> <operator>-</operator>
 <operator>...</operator><operator>/</operator><name>processors</name><operator>/</operator><name><name>FuzzyQueryNodeProcessor</name><operator>.</operator><name>java</name></name>   <operator>|</operator>  <literal type="number">11</literal> <operator>+</operator><operator>-</operator>
 <operator>...</operator><name><name>ercaseExpandedTermsQueryNodeProcessor</name><operator>.</operator><name>java</name></name> <operator>|</operator> <literal type="number">100</literal> <operator>--</operator><operator>--</operator><operator>--</operator><operator>-</operator>
 <operator>...</operator><operator>/</operator><name>processors</name><operator>/</operator><name><name>RegexpQueryNodeProcessor</name><operator>.</operator><name>java</name></name>  <operator>|</operator>  <literal type="number">56</literal> <operator>++</operator><operator>++</operator>
 <operator>...</operator><operator>/</operator><name><name>StandardQueryNodeProcessorPipeline</name><operator>.</operator><name>java</name></name>   <operator>|</operator>   <literal type="number">4</literal> <operator>+</operator><operator>-</operator>
 <operator>...</operator><operator>/</operator><name><name>TermRangeQueryNodeProcessor</name><operator>.</operator><name>java</name></name>          <operator>|</operator>  <literal type="number">11</literal> <operator>+</operator><operator>-</operator>
 <operator>...</operator><operator>/</operator><name><name>WildcardQueryNodeProcessor</name><operator>.</operator><name>java</name></name>           <operator>|</operator>  <literal type="number">58</literal> <operator>++</operator><operator>+</operator><operator>-</operator>
 <operator>...</operator><operator>/</operator><name>queryparser</name><operator>/</operator><name>simple</name><operator>/</operator><name><name>SimpleQueryParser</name><operator>.</operator><name>java</name></name> <operator>|</operator>   <literal type="number">9</literal> <operator>+</operator><operator>-</operator>
 <operator>...</operator><operator>/</operator><name>analyzing</name><operator>/</operator><name><name>TestAnalyzingQueryParser</name><operator>.</operator><name>java</name></name>   <operator>|</operator> <literal type="number">268</literal> <operator>--</operator><operator>--</operator><operator>--</operator><operator>--</operator><operator>--</operator><operator>--</operator><operator>--</operator><operator>--</operator><operator>--</operator>
 <operator>...</operator><operator>/</operator><name>queryparser</name><operator>/</operator><name>classic</name><operator>/</operator><name><name>TestQueryParser</name><operator>.</operator><name>java</name></name>  <operator>|</operator> <literal type="number">241</literal> <operator>++</operator><operator>++</operator><operator>++</operator><operator>++</operator><operator>++</operator><operator>++</operator><operator>+</operator><operator>--</operator><operator>-</operator>
 <operator>...</operator><operator>/</operator><name>precedence</name><operator>/</operator><name><name>TestPrecedenceQueryParser</name><operator>.</operator><name>java</name></name> <operator>|</operator>  <literal type="number">44</literal> <operator>+</operator><operator>--</operator>
 <operator>...</operator><operator>/</operator><name>flexible</name><operator>/</operator><name>standard</name><operator>/</operator><name><name>TestQPHelper</name><operator>.</operator><name>java</name></name>       <operator>|</operator>  <literal type="number">57</literal> <operator>++</operator><operator>--</operator>
 <operator>...</operator><operator>/</operator><name>flexible</name><operator>/</operator><name>standard</name><operator>/</operator><name><name>TestStandardQP</name><operator>.</operator><name>java</name></name>     <operator>|</operator>  <literal type="number">15</literal> <operator>-</operator>
 <operator>...</operator><operator>/</operator><name>queryparser</name><operator>/</operator><name>util</name><operator>/</operator><name><name>QueryParserTestBase</name><operator>.</operator><name>java</name></name> <operator>|</operator>  <literal type="number">63</literal> <operator>++</operator><operator>--</operator>
 <operator>...</operator><operator>/</operator><name>analysis</name><operator>/</operator><name><name>BaseTokenStreamTestCase</name><operator>.</operator><name>java</name></name>     <operator>|</operator>   <literal type="number">5</literal> <operator>+</operator><operator>-</operator>
 <operator>...</operator><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>analysis</name><operator>/</operator><name><name>MockAnalyzer</name><operator>.</operator><name>java</name></name>  <operator>|</operator>  <literal type="number">11</literal> <operator>+</operator><operator>-</operator>
 <operator>...</operator><operator>/</operator><name>lucene</name><operator>/</operator><name>analysis</name><operator>/</operator><name><name>MockBytesAnalyzer</name><operator>.</operator><name>java</name></name>    <operator>|</operator>   <literal type="number">7</literal> <operator>+</operator>
 <operator>...</operator><operator>/</operator><name>lucene</name><operator>/</operator><name>analysis</name><operator>/</operator><name><name>MockLowerCaseFilter</name><operator>.</operator><name>java</name></name></expr>} |  <expr_stmt><expr><literal type="number">28</literal> <operator>+</operator><operator>-</operator>
 <operator>...</operator><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>analysis</name><operator>/</operator><name><name>TokenizerChain</name><operator>.</operator><name>java</name></name>  <operator>|</operator>  <literal type="number">28</literal> <operator>+</operator><operator>-</operator>
 <literal type="number">76</literal> <name>files</name> <name>changed</name></expr><operator>,</operator> <expr><literal type="number">1162</literal> <call><name>insertions</name><argument_list>(<argument><expr><operator>+</operator></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><literal type="number">925</literal> <call><name>deletions</name><argument_list>(<argument><expr><operator>-</operator></expr></argument>)</argument_list></call>
 <name>delete</name> <name>mode</name> <literal type="number">100644</literal> <name>lucene</name><operator>/</operator><name>queryparser</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>queryparser</name><operator>/</operator><name>analyzing</name><operator>/</operator><name><name>AnalyzingQueryParser</name><operator>.</operator><name>java</name></name>
 <name>delete</name> <name>mode</name> <literal type="number">100644</literal> <name>lucene</name><operator>/</operator><name>queryparser</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>queryparser</name><operator>/</operator><name>flexible</name><operator>/</operator><name>standard</name><operator>/</operator><name>processors</name><operator>/</operator><name><name>LowercaseExpandedTermsQueryNodeProcessor</name><operator>.</operator><name>java</name></name>
 <name>create</name> <name>mode</name> <literal type="number">100644</literal> <name>lucene</name><operator>/</operator><name>queryparser</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>queryparser</name><operator>/</operator><name>flexible</name><operator>/</operator><name>standard</name><operator>/</operator><name>processors</name><operator>/</operator><name><name>RegexpQueryNodeProcessor</name><operator>.</operator><name>java</name></name>
 <name>delete</name> <name>mode</name> <literal type="number">100644</literal> <name>lucene</name><operator>/</operator><name>queryparser</name><operator>/</operator><name>src</name><operator>/</operator><name>test</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>queryparser</name><operator>/</operator><name>analyzing</name><operator>/</operator><name><name>TestAnalyzingQueryParser</name><operator>.</operator><name>java</name></name>
 <name>rename</name> <name>lucene</name><operator>/</operator><block>{<expr><name>queryparser</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>queryparser</name><operator>/</operator><name>analyzing</name><operator>/</operator></expr><package>package-<name><name>info</name><operator>.</operator><name>java</name></name> =&gt; <name>test</name>-<name>framework</name>/<name>src</name>/<name>java</name>/<name>org</name>/<name>apache</name>/<name>lucene</name>/<name>analysis</name>/<name><name>MockLowerCaseFilter</name><operator>.</operator><name>java</name></name>} (55%</package>)

<name>diff</name> <operator>--</operator><name>git</name> <name>a</name><operator>/</operator><name>lucene</name><operator>/</operator><name><name>CHANGES</name><operator>.</operator><name>txt</name></name> <name>b</name><operator>/</operator><name>lucene</name><operator>/</operator><name><name>CHANGES</name><operator>.</operator><name>txt</name></name>
<name>index</name> <name>eba11c9bef0</name><operator>..</operator><name>c520e1bbca0</name> <literal type="number">100644</literal>
<operator>--</operator> <name>a</name><operator>/</operator><name>lucene</name><operator>/</operator><name><name>CHANGES</name><operator>.</operator><name>txt</name></name>
<operator>++</operator> <name>b</name><operator>/</operator><name>lucene</name><operator>/</operator><name><name>CHANGES</name><operator>.</operator><name>txt</name></name>
@@ <operator>-</operator><literal type="number">15</literal><operator>,</operator><literal type="number">6</literal> <operator>+</operator><literal type="number">15</literal><operator>,</operator><literal type="number">9</literal> @@ <name>API</name> <name>Changes</name>
 
 <operator>*</operator> <name>LUCENE</name><operator>-</operator><literal type="number">7368</literal><operator>:</operator> <name>Removed</name> <name>query</name> <name><name>normalization</name><operator>.</operator></name> (<name>Adrien</name> <name>Grand</name>)</block>
 
<operator>*</operator> <name>LUCENE</name><operator>-</operator><literal type="number">7355</literal><operator>:</operator> <name>AnalyzingQueryParser</name> <name>has</name> <name>been</name> <name>removed</name> <name>as</name> <name>its</name> <name>functionality</name> <name>has</name>
  <name>been</name> <name>folded</name> <name>into</name> <name>the</name> <name>classic</name> <name><name>QueryParser</name><operator>.</operator></name> (<name>Adrien</name> <name>Grand</name></expr></expr_stmt>)

 <expr_stmt><expr><name>Bug</name> <name>Fixes</name>
 
 <name>Improvements</name>
@@ <operator>-</operator><literal type="number">48</literal></expr><operator>,</operator><expr><literal type="number">6</literal> <operator>+</operator><literal type="number">51</literal></expr><operator>,</operator><expr><literal type="number">9</literal> @@ <name>New</name> <name>Features</name>
   <name>methods</name> <name><name>Directory</name><operator>.</operator><name>rename</name></name> <name>and</name> <name><name>Directory</name><operator>.</operator><name>syncMetaData</name></name> <call><name>instead</name> <argument_list>(<argument><expr><name>Robert</name> <name>Muir</name></expr></argument>,
   <argument><expr><name>Uwe</name> <name>Schindler</name></expr></argument>, <argument><expr><name>Mike</name> <name>McCandless</name></expr></argument>)</argument_list></call>
 
<operator>*</operator> <name>LUCENE</name><operator>-</operator><literal type="number">7355</literal><operator>:</operator> <name>Added</name> <name>Analyzer</name><operator>#</operator><call><name>normalize</name><argument_list>()</argument_list></call></expr><operator>,</operator> <expr><name>which</name> <name>only</name> <name>applies</name> <name>normalization</name> <name>to</name>
  <name>an</name> <name>input</name> <name><name>string</name><operator>.</operator></name> (<name>Adrien</name> <name>Grand</name></expr></expr_stmt>)

 <expr_stmt><expr><name>Bug</name> <name>Fixes</name>
 
 <operator>*</operator> <name>LUCENE</name><operator>-</operator><literal type="number">6662</literal><operator>:</operator> <name>Fixed</name> <name>potential</name> <name>resource</name> <name><name>leaks</name><operator>.</operator></name> (<name>Rishabh</name> <name>Patel</name> <name>via</name> <name>Adrien</name> <name>Grand</name></expr></expr_stmt>)
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">99</literal></expr><operator>,</operator><expr><literal type="number">6</literal> <operator>+</operator><literal type="number">105</literal></expr><operator>,</operator><expr><literal type="number">10</literal> @@ <name>Improvements</name>
 <operator>*</operator> <name>LUCENE</name><operator>-</operator><literal type="number">7276</literal><operator>:</operator> <name>MatchNoDocsQuery</name> <name>now</name> <name>includes</name> <name>an</name> <name>optional</name> <name>reason</name></expr></expr_stmt> <for>for
   why it was used <control>(<init><expr><name>Jim</name> <name>Ferenczi</name> <name>via</name> <name>Mike</name> <name>McCandless</name></expr></init>)</control><block type="pseudo"><block_content>
 
<expr_stmt><expr><operator>*</operator> <name>LUCENE</name><operator>-</operator><literal type="number">7355</literal><operator>:</operator> <name>AnalyzingQueryParser</name> <name>now</name> <name>only</name> <name>applies</name> <name>the</name> <name>subset</name> <name>of</name> <name>the</name> <name>analysis</name>
  <name>chain</name> <name>that</name> <name>is</name> <name>about</name> <name>normalization</name></expr></expr_stmt></block_content></block></for> <for>for range/fuzzy/wildcard queries.
  <control>(<init><expr><name>Adrien</name> <name>Grand</name></expr></init>)</control><block type="pseudo"><block_content>

 <expr_stmt><expr><name>Optimizations</name>
 
 <operator>*</operator> <name>LUCENE</name><operator>-</operator><literal type="number">7330</literal></expr><operator>,</operator> <expr><name>LUCENE</name><operator>-</operator><literal type="number">7339</literal><operator>:</operator> <name>Speed</name> <name>up</name> <name>conjunction</name> <name><name>queries</name><operator>.</operator></name> (<name>Adrien</name> <name>Grand</name></expr></expr_stmt></block_content></block></for>)
<expr_stmt><expr><name>diff</name> <operator>--</operator><name>git</name> <name>a</name><operator>/</operator><name>lucene</name><operator>/</operator><name><name>MIGRATE</name><operator>.</operator><name>txt</name></name> <name>b</name><operator>/</operator><name>lucene</name><operator>/</operator><name><name>MIGRATE</name><operator>.</operator><name>txt</name></name>
<name>index</name> <name>f914529a5e7</name><operator>..</operator><literal type="number">06e6a814f12</literal> <literal type="number">100644</literal>
<operator>--</operator> <name>a</name><operator>/</operator><name>lucene</name><operator>/</operator><name><name>MIGRATE</name><operator>.</operator><name>txt</name></name>
<operator>++</operator> <name>b</name><operator>/</operator><name>lucene</name><operator>/</operator><name><name>MIGRATE</name><operator>.</operator><name>txt</name></name>
@@ <operator>-</operator><literal type="number">36</literal></expr><operator>,</operator><expr><literal type="number">3</literal> <operator>+</operator><literal type="number">36</literal></expr><operator>,</operator><expr><literal type="number">14</literal> @@ <name>Query</name> <name>normalization</name><literal type="char">'s goal was to make scores comparable across queries, which
 was only implemented by the ClassicSimilarity. Since ClassicSimilarity is not
 the default similarity anymore, this functionality has been removed. Boosts are
 now propagated through Query#createWeight.

## AnalyzingQueryParser removed (LUCENE-7355)

The functionality of AnalyzingQueryParser has been folded into the classic
QueryParser, which now passes terms through Analyzer#normalize when generating
queries.

## CommonQueryParserConfiguration.setLowerCaseExpandedTerms removed (LUCENE-7355)

This option has been removed as expanded terms are now normalized through
Analyzer#normalize.
diff --git a/lucene/analysis/common/src/java/org/apache/lucene/analysis/ar/ArabicAnalyzer.java b/lucene/analysis/common/src/java/org/apache/lucene/analysis/ar/ArabicAnalyzer.java
index 889a8861f50..61100dd82a6 100644
-- a/lucene/analysis/common/src/java/org/apache/lucene/analysis/ar/ArabicAnalyzer.java
++ b/lucene/analysis/common/src/java/org/apache/lucene/analysis/ar/ArabicAnalyzer.java
@@ -143,5 +143,13 @@ public final class ArabicAnalyzer extends StopwordAnalyzerBase {
     }
     return new TokenStreamComponents(source, new ArabicStemFilter(result));
   }

  @Override
  protected TokenStream normalize(String fieldName, TokenStream in) {
    TokenStream result = new LowerCaseFilter(in);
    result = new DecimalDigitFilter(result);
    result = new ArabicNormalizationFilter(result);
    return result;
  }
 }
 
diff --git a/lucene/analysis/common/src/java/org/apache/lucene/analysis/bg/BulgarianAnalyzer.java b/lucene/analysis/common/src/java/org/apache/lucene/analysis/bg/BulgarianAnalyzer.java
index 9cb065712e9..06c7eea787e 100644
-- a/lucene/analysis/common/src/java/org/apache/lucene/analysis/bg/BulgarianAnalyzer.java
++ b/lucene/analysis/common/src/java/org/apache/lucene/analysis/bg/BulgarianAnalyzer.java
@@ -126,4 +126,11 @@ public final class BulgarianAnalyzer extends StopwordAnalyzerBase {
     result = new BulgarianStemFilter(result);
     return new TokenStreamComponents(source, result);
   }

  @Override
  protected TokenStream normalize(String fieldName, TokenStream in) {
    TokenStream result = new StandardFilter(in);
    result = new LowerCaseFilter(result);
    return result;
  }
 }
diff --git a/lucene/analysis/common/src/java/org/apache/lucene/analysis/br/BrazilianAnalyzer.java b/lucene/analysis/common/src/java/org/apache/lucene/analysis/br/BrazilianAnalyzer.java
index 5dd0cbc695d..ad1af92464e 100644
-- a/lucene/analysis/common/src/java/org/apache/lucene/analysis/br/BrazilianAnalyzer.java
++ b/lucene/analysis/common/src/java/org/apache/lucene/analysis/br/BrazilianAnalyzer.java
@@ -127,5 +127,12 @@ public final class BrazilianAnalyzer extends StopwordAnalyzerBase {
       result = new SetKeywordMarkerFilter(result, excltable);
     return new TokenStreamComponents(source, new BrazilianStemFilter(result));
   }

  @Override
  protected TokenStream normalize(String fieldName, TokenStream in) {
    TokenStream result = new StandardFilter(in);
    result = new LowerCaseFilter(result);
    return result;
  }
 }
 
diff --git a/lucene/analysis/common/src/java/org/apache/lucene/analysis/ca/CatalanAnalyzer.java b/lucene/analysis/common/src/java/org/apache/lucene/analysis/ca/CatalanAnalyzer.java
index 739b61a3f91..56f36e15f9f 100644
-- a/lucene/analysis/common/src/java/org/apache/lucene/analysis/ca/CatalanAnalyzer.java
++ b/lucene/analysis/common/src/java/org/apache/lucene/analysis/ca/CatalanAnalyzer.java
@@ -130,4 +130,12 @@ public final class CatalanAnalyzer extends StopwordAnalyzerBase {
     result = new SnowballFilter(result, new CatalanStemmer());
     return new TokenStreamComponents(source, result);
   }

  @Override
  protected TokenStream normalize(String fieldName, TokenStream in) {
    TokenStream result = new StandardFilter(in);
    result = new ElisionFilter(result, DEFAULT_ARTICLES);
    result = new LowerCaseFilter(result);
    return result;
  }
 }
diff --git a/lucene/analysis/common/src/java/org/apache/lucene/analysis/cjk/CJKAnalyzer.java b/lucene/analysis/common/src/java/org/apache/lucene/analysis/cjk/CJKAnalyzer.java
index d500ff9c51a..d4214a111c1 100644
-- a/lucene/analysis/common/src/java/org/apache/lucene/analysis/cjk/CJKAnalyzer.java
++ b/lucene/analysis/common/src/java/org/apache/lucene/analysis/cjk/CJKAnalyzer.java
@@ -92,4 +92,11 @@ public final class CJKAnalyzer extends StopwordAnalyzerBase {
     result = new CJKBigramFilter(result);
     return new TokenStreamComponents(source, new StopFilter(result, stopwords));
   }

  @Override
  protected TokenStream normalize(String fieldName, TokenStream in) {
    TokenStream result = new CJKWidthFilter(in);
    result = new LowerCaseFilter(result);
    return result;
  }
 }
diff --git a/lucene/analysis/common/src/java/org/apache/lucene/analysis/ckb/SoraniAnalyzer.java b/lucene/analysis/common/src/java/org/apache/lucene/analysis/ckb/SoraniAnalyzer.java
index 0f283b8ff11..e7ce3f39e44 100644
-- a/lucene/analysis/common/src/java/org/apache/lucene/analysis/ckb/SoraniAnalyzer.java
++ b/lucene/analysis/common/src/java/org/apache/lucene/analysis/ckb/SoraniAnalyzer.java
@@ -126,4 +126,13 @@ public final class SoraniAnalyzer extends StopwordAnalyzerBase {
     result = new SoraniStemFilter(result);
     return new TokenStreamComponents(source, result);
   }

  @Override
  protected TokenStream normalize(String fieldName, TokenStream in) {
    TokenStream result = new StandardFilter(in);
    result = new SoraniNormalizationFilter(result);
    result = new LowerCaseFilter(result);
    result = new DecimalDigitFilter(result);
    return result;
  }
 }
diff --git a/lucene/analysis/common/src/java/org/apache/lucene/analysis/core/SimpleAnalyzer.java b/lucene/analysis/common/src/java/org/apache/lucene/analysis/core/SimpleAnalyzer.java
index d0fdcf6cc9f..6e0f2f0b67e 100644
-- a/lucene/analysis/common/src/java/org/apache/lucene/analysis/core/SimpleAnalyzer.java
++ b/lucene/analysis/common/src/java/org/apache/lucene/analysis/core/SimpleAnalyzer.java
@@ -19,6 +19,7 @@ package org.apache.lucene.analysis.core;
 
 import org.apache.lucene.analysis.Analyzer;
 import org.apache.lucene.analysis.LowerCaseFilter;
import org.apache.lucene.analysis.TokenStream;
 
 /** An {@link Analyzer} that filters {@link LetterTokenizer} 
  *  with {@link LowerCaseFilter} 
@@ -35,4 +36,9 @@ public final class SimpleAnalyzer extends Analyzer {
   protected TokenStreamComponents createComponents(final String fieldName) {
     return new TokenStreamComponents(new LowerCaseTokenizer());
   }

  @Override
  protected TokenStream normalize(String fieldName, TokenStream in) {
    return new LowerCaseFilter(in);
  }
 }
diff --git a/lucene/analysis/common/src/java/org/apache/lucene/analysis/core/StopAnalyzer.java b/lucene/analysis/common/src/java/org/apache/lucene/analysis/core/StopAnalyzer.java
index 3fa498283e6..7d7f532b6a0 100644
-- a/lucene/analysis/common/src/java/org/apache/lucene/analysis/core/StopAnalyzer.java
++ b/lucene/analysis/common/src/java/org/apache/lucene/analysis/core/StopAnalyzer.java
@@ -25,6 +25,7 @@ import org.apache.lucene.analysis.CharArraySet;
 import org.apache.lucene.analysis.LowerCaseFilter;
 import org.apache.lucene.analysis.StopFilter;
 import org.apache.lucene.analysis.StopwordAnalyzerBase;
import org.apache.lucene.analysis.TokenStream;
 import org.apache.lucene.analysis.Tokenizer;
 import org.apache.lucene.analysis.WordlistLoader;
 import org.apache.lucene.analysis.standard.StandardAnalyzer;
@@ -79,5 +80,10 @@ public final class StopAnalyzer extends StopwordAnalyzerBase {
     final Tokenizer source = new LowerCaseTokenizer();
     return new TokenStreamComponents(source, new StopFilter(source, stopwords));
   }

  @Override
  protected TokenStream normalize(String fieldName, TokenStream in) {
    return new LowerCaseFilter(in);
  }
 }
 
diff --git a/lucene/analysis/common/src/java/org/apache/lucene/analysis/custom/CustomAnalyzer.java b/lucene/analysis/common/src/java/org/apache/lucene/analysis/custom/CustomAnalyzer.java
index f2ed01f4e9f..b2de5e8b34b 100644
-- a/lucene/analysis/common/src/java/org/apache/lucene/analysis/custom/CustomAnalyzer.java
++ b/lucene/analysis/common/src/java/org/apache/lucene/analysis/custom/CustomAnalyzer.java
@@ -37,6 +37,7 @@ import org.apache.lucene.analysis.util.AbstractAnalysisFactory;
 import org.apache.lucene.analysis.util.CharFilterFactory;
 import org.apache.lucene.analysis.util.ClasspathResourceLoader;
 import org.apache.lucene.analysis.util.FilesystemResourceLoader;
import org.apache.lucene.analysis.util.MultiTermAwareComponent;
 import org.apache.lucene.analysis.util.ResourceLoader;
 import org.apache.lucene.analysis.util.ResourceLoaderAware;
 import org.apache.lucene.analysis.util.TokenFilterFactory;
@@ -117,16 +118,39 @@ public final class CustomAnalyzer extends Analyzer {
     return reader;
   }
 
  @Override
  protected Reader initReaderForNormalization(String fieldName, Reader reader) {
    for (CharFilterFactory charFilter : charFilters) {
      if (charFilter instanceof MultiTermAwareComponent) {
        charFilter = (CharFilterFactory) ((MultiTermAwareComponent) charFilter).getMultiTermComponent();
        reader = charFilter.create(reader);
      }
    }
    return reader;
  }

   @Override
   protected TokenStreamComponents createComponents(String fieldName) {
    final Tokenizer tk = tokenizer.create();
    final Tokenizer tk = tokenizer.create(attributeFactory());
     TokenStream ts = tk;
     for (final TokenFilterFactory filter : tokenFilters) {
       ts = filter.create(ts);
     }
     return new TokenStreamComponents(tk, ts);
   }
  

  @Override
  protected TokenStream normalize(String fieldName, TokenStream in) {
    TokenStream result = in;
    for (TokenFilterFactory filter : tokenFilters) {
      if (filter instanceof MultiTermAwareComponent) {
        filter = (TokenFilterFactory) ((MultiTermAwareComponent) filter).getMultiTermComponent();
        result = filter.create(in);
      }
    }
    return result;
  }

   @Override
   public int getPositionIncrementGap(String fieldName) {
     // use default from Analyzer base class if null
diff --git a/lucene/analysis/common/src/java/org/apache/lucene/analysis/cz/CzechAnalyzer.java b/lucene/analysis/common/src/java/org/apache/lucene/analysis/cz/CzechAnalyzer.java
index 97771790939..fbb9efabdda 100644
-- a/lucene/analysis/common/src/java/org/apache/lucene/analysis/cz/CzechAnalyzer.java
++ b/lucene/analysis/common/src/java/org/apache/lucene/analysis/cz/CzechAnalyzer.java
@@ -125,5 +125,12 @@ public final class CzechAnalyzer extends StopwordAnalyzerBase {
     result = new CzechStemFilter(result);
     return new TokenStreamComponents(source, result);
   }

  @Override
  protected TokenStream normalize(String fieldName, TokenStream in) {
    TokenStream result = new StandardFilter(in);
    result = new LowerCaseFilter(result);
    return result;
  }
 }
 
diff --git a/lucene/analysis/common/src/java/org/apache/lucene/analysis/da/DanishAnalyzer.java b/lucene/analysis/common/src/java/org/apache/lucene/analysis/da/DanishAnalyzer.java
index f9c316d6dbd..ccbd9d1900e 100644
-- a/lucene/analysis/common/src/java/org/apache/lucene/analysis/da/DanishAnalyzer.java
++ b/lucene/analysis/common/src/java/org/apache/lucene/analysis/da/DanishAnalyzer.java
@@ -124,4 +124,11 @@ public final class DanishAnalyzer extends StopwordAnalyzerBase {
     result = new SnowballFilter(result, new DanishStemmer());
     return new TokenStreamComponents(source, result);
   }

  @Override
  protected TokenStream normalize(String fieldName, TokenStream in) {
    TokenStream result = new StandardFilter(in);
    result = new LowerCaseFilter(result);
    return result;
  }
 }
diff --git a/lucene/analysis/common/src/java/org/apache/lucene/analysis/de/GermanAnalyzer.java b/lucene/analysis/common/src/java/org/apache/lucene/analysis/de/GermanAnalyzer.java
index 790fc48112b..8a3994530fd 100644
-- a/lucene/analysis/common/src/java/org/apache/lucene/analysis/de/GermanAnalyzer.java
++ b/lucene/analysis/common/src/java/org/apache/lucene/analysis/de/GermanAnalyzer.java
@@ -139,4 +139,12 @@ public final class GermanAnalyzer extends StopwordAnalyzerBase {
     result = new GermanLightStemFilter(result);
     return new TokenStreamComponents(source, result);
   }

  @Override
  protected TokenStream normalize(String fieldName, TokenStream in) {
    TokenStream result = new StandardFilter(in);
    result = new LowerCaseFilter(result);
    result = new GermanNormalizationFilter(result);
    return result;
  }
 }
diff --git a/lucene/analysis/common/src/java/org/apache/lucene/analysis/el/GreekAnalyzer.java b/lucene/analysis/common/src/java/org/apache/lucene/analysis/el/GreekAnalyzer.java
index c85b6eccc92..bd09d255525 100644
-- a/lucene/analysis/common/src/java/org/apache/lucene/analysis/el/GreekAnalyzer.java
++ b/lucene/analysis/common/src/java/org/apache/lucene/analysis/el/GreekAnalyzer.java
@@ -104,4 +104,11 @@ public final class GreekAnalyzer extends StopwordAnalyzerBase {
     result = new GreekStemFilter(result);
     return new TokenStreamComponents(source, result);
   }

  @Override
  protected TokenStream normalize(String fieldName, TokenStream in) {
    TokenStream result = new StandardFilter(in);
    result = new GreekLowerCaseFilter(result);
    return result;
  }
 }
diff --git a/lucene/analysis/common/src/java/org/apache/lucene/analysis/en/EnglishAnalyzer.java b/lucene/analysis/common/src/java/org/apache/lucene/analysis/en/EnglishAnalyzer.java
index 16dc0c55da8..94ba43a710e 100644
-- a/lucene/analysis/common/src/java/org/apache/lucene/analysis/en/EnglishAnalyzer.java
++ b/lucene/analysis/common/src/java/org/apache/lucene/analysis/en/EnglishAnalyzer.java
@@ -107,4 +107,11 @@ public final class EnglishAnalyzer extends StopwordAnalyzerBase {
     result = new PorterStemFilter(result);
     return new TokenStreamComponents(source, result);
   }

  @Override
  protected TokenStream normalize(String fieldName, TokenStream in) {
    TokenStream result = new StandardFilter(in);
    result = new LowerCaseFilter(result);
    return result;
  }
 }
diff --git a/lucene/analysis/common/src/java/org/apache/lucene/analysis/es/SpanishAnalyzer.java b/lucene/analysis/common/src/java/org/apache/lucene/analysis/es/SpanishAnalyzer.java
index ab5b6c356d9..3b21cdde48a 100644
-- a/lucene/analysis/common/src/java/org/apache/lucene/analysis/es/SpanishAnalyzer.java
++ b/lucene/analysis/common/src/java/org/apache/lucene/analysis/es/SpanishAnalyzer.java
@@ -123,4 +123,11 @@ public final class SpanishAnalyzer extends StopwordAnalyzerBase {
     result = new SpanishLightStemFilter(result);
     return new TokenStreamComponents(source, result);
   }

  @Override
  protected TokenStream normalize(String fieldName, TokenStream in) {
    TokenStream result = new StandardFilter(in);
    result = new LowerCaseFilter(result);
    return result;
  }
 }
diff --git a/lucene/analysis/common/src/java/org/apache/lucene/analysis/eu/BasqueAnalyzer.java b/lucene/analysis/common/src/java/org/apache/lucene/analysis/eu/BasqueAnalyzer.java
index cff2da046ce..4bc1ba76600 100644
-- a/lucene/analysis/common/src/java/org/apache/lucene/analysis/eu/BasqueAnalyzer.java
++ b/lucene/analysis/common/src/java/org/apache/lucene/analysis/eu/BasqueAnalyzer.java
@@ -121,4 +121,11 @@ public final class BasqueAnalyzer extends StopwordAnalyzerBase {
     result = new SnowballFilter(result, new BasqueStemmer());
     return new TokenStreamComponents(source, result);
   }

  @Override
  protected TokenStream normalize(String fieldName, TokenStream in) {
    TokenStream result = new StandardFilter(in);
    result = new LowerCaseFilter(result);
    return result;
  }
 }
diff --git a/lucene/analysis/common/src/java/org/apache/lucene/analysis/fa/PersianAnalyzer.java b/lucene/analysis/common/src/java/org/apache/lucene/analysis/fa/PersianAnalyzer.java
index f29dfd3607e..9aebc2d675e 100644
-- a/lucene/analysis/common/src/java/org/apache/lucene/analysis/fa/PersianAnalyzer.java
++ b/lucene/analysis/common/src/java/org/apache/lucene/analysis/fa/PersianAnalyzer.java
@@ -29,6 +29,7 @@ import org.apache.lucene.analysis.TokenStream;
 import org.apache.lucene.analysis.Tokenizer;
 import org.apache.lucene.analysis.ar.ArabicNormalizationFilter;
 import org.apache.lucene.analysis.core.DecimalDigitFilter;
import org.apache.lucene.analysis.standard.StandardFilter;
 import org.apache.lucene.analysis.standard.StandardTokenizer;
 
 /**
@@ -125,7 +126,18 @@ public final class PersianAnalyzer extends StopwordAnalyzerBase {
      */
     return new TokenStreamComponents(source, new StopFilter(result, stopwords));
   }
  

  @Override
  protected TokenStream normalize(String fieldName, TokenStream in) {
    TokenStream result = new StandardFilter(in);
    result = new LowerCaseFilter(result);
    result = new DecimalDigitFilter(result);
    result = new ArabicNormalizationFilter(result);
    /* additional persian-specific normalization */
    result = new PersianNormalizationFilter(result);
    return result;
  }

   /** 
    * Wraps the Reader with {@link PersianCharFilter}
    */
diff --git a/lucene/analysis/common/src/java/org/apache/lucene/analysis/fi/FinnishAnalyzer.java b/lucene/analysis/common/src/java/org/apache/lucene/analysis/fi/FinnishAnalyzer.java
index 6b001016531..69cc5378612 100644
-- a/lucene/analysis/common/src/java/org/apache/lucene/analysis/fi/FinnishAnalyzer.java
++ b/lucene/analysis/common/src/java/org/apache/lucene/analysis/fi/FinnishAnalyzer.java
@@ -124,4 +124,11 @@ public final class FinnishAnalyzer extends StopwordAnalyzerBase {
     result = new SnowballFilter(result, new FinnishStemmer());
     return new TokenStreamComponents(source, result);
   }

  @Override
  protected TokenStream normalize(String fieldName, TokenStream in) {
    TokenStream result = new StandardFilter(in);
    result = new LowerCaseFilter(result);
    return result;
  }
 }
diff --git a/lucene/analysis/common/src/java/org/apache/lucene/analysis/fr/FrenchAnalyzer.java b/lucene/analysis/common/src/java/org/apache/lucene/analysis/fr/FrenchAnalyzer.java
index 5f90246b4b3..2e072be62a2 100644
-- a/lucene/analysis/common/src/java/org/apache/lucene/analysis/fr/FrenchAnalyzer.java
++ b/lucene/analysis/common/src/java/org/apache/lucene/analysis/fr/FrenchAnalyzer.java
@@ -144,5 +144,13 @@ public final class FrenchAnalyzer extends StopwordAnalyzerBase {
     result = new FrenchLightStemFilter(result);
     return new TokenStreamComponents(source, result);
   }

  @Override
  protected TokenStream normalize(String fieldName, TokenStream in) {
    TokenStream result = new StandardFilter(in);
    result = new ElisionFilter(result, DEFAULT_ARTICLES);
    result = new LowerCaseFilter(result);
    return result;
  }
 }
 
diff --git a/lucene/analysis/common/src/java/org/apache/lucene/analysis/ga/IrishAnalyzer.java b/lucene/analysis/common/src/java/org/apache/lucene/analysis/ga/IrishAnalyzer.java
index 1ca3455224d..3ae366d3eac 100644
-- a/lucene/analysis/common/src/java/org/apache/lucene/analysis/ga/IrishAnalyzer.java
++ b/lucene/analysis/common/src/java/org/apache/lucene/analysis/ga/IrishAnalyzer.java
@@ -141,4 +141,12 @@ public final class IrishAnalyzer extends StopwordAnalyzerBase {
     result = new SnowballFilter(result, new IrishStemmer());
     return new TokenStreamComponents(source, result);
   }

  @Override
  protected TokenStream normalize(String fieldName, TokenStream in) {
    TokenStream result = new StandardFilter(in);
    result = new ElisionFilter(result, DEFAULT_ARTICLES);
    result = new IrishLowerCaseFilter(result);
    return result;
  }
 }
diff --git a/lucene/analysis/common/src/java/org/apache/lucene/analysis/gl/GalicianAnalyzer.java b/lucene/analysis/common/src/java/org/apache/lucene/analysis/gl/GalicianAnalyzer.java
index 372a6ec9249..4f705968e40 100644
-- a/lucene/analysis/common/src/java/org/apache/lucene/analysis/gl/GalicianAnalyzer.java
++ b/lucene/analysis/common/src/java/org/apache/lucene/analysis/gl/GalicianAnalyzer.java
@@ -122,4 +122,11 @@ public final class GalicianAnalyzer extends StopwordAnalyzerBase {
     result = new GalicianStemFilter(result);
     return new TokenStreamComponents(source, result);
   }

  @Override
  protected TokenStream normalize(String fieldName, TokenStream in) {
    TokenStream result = new StandardFilter(in);
    result = new LowerCaseFilter(result);
    return result;
  }
 }
diff --git a/lucene/analysis/common/src/java/org/apache/lucene/analysis/hi/HindiAnalyzer.java b/lucene/analysis/common/src/java/org/apache/lucene/analysis/hi/HindiAnalyzer.java
index 8e4868b7a08..f3392954231 100644
-- a/lucene/analysis/common/src/java/org/apache/lucene/analysis/hi/HindiAnalyzer.java
++ b/lucene/analysis/common/src/java/org/apache/lucene/analysis/hi/HindiAnalyzer.java
@@ -29,6 +29,7 @@ import org.apache.lucene.analysis.Tokenizer;
 import org.apache.lucene.analysis.core.DecimalDigitFilter;
 import org.apache.lucene.analysis.in.IndicNormalizationFilter;
 import org.apache.lucene.analysis.miscellaneous.SetKeywordMarkerFilter;
import org.apache.lucene.analysis.standard.StandardFilter;
 import org.apache.lucene.analysis.standard.StandardTokenizer;
 
 /**
@@ -125,4 +126,14 @@ public final class HindiAnalyzer extends StopwordAnalyzerBase {
     result = new HindiStemFilter(result);
     return new TokenStreamComponents(source, result);
   }

  @Override
  protected TokenStream normalize(String fieldName, TokenStream in) {
    TokenStream result = new StandardFilter(in);
    result = new LowerCaseFilter(result);
    result = new DecimalDigitFilter(result);
    result = new IndicNormalizationFilter(result);
    result = new HindiNormalizationFilter(result);
    return result;
  }
 }
diff --git a/lucene/analysis/common/src/java/org/apache/lucene/analysis/hu/HungarianAnalyzer.java b/lucene/analysis/common/src/java/org/apache/lucene/analysis/hu/HungarianAnalyzer.java
index 0615bdc1667..e980f5a126a 100644
-- a/lucene/analysis/common/src/java/org/apache/lucene/analysis/hu/HungarianAnalyzer.java
++ b/lucene/analysis/common/src/java/org/apache/lucene/analysis/hu/HungarianAnalyzer.java
@@ -124,4 +124,11 @@ public final class HungarianAnalyzer extends StopwordAnalyzerBase {
     result = new SnowballFilter(result, new HungarianStemmer());
     return new TokenStreamComponents(source, result);
   }

  @Override
  protected TokenStream normalize(String fieldName, TokenStream in) {
    TokenStream result = new StandardFilter(in);
    result = new LowerCaseFilter(result);
    return result;
  }
 }
diff --git a/lucene/analysis/common/src/java/org/apache/lucene/analysis/hy/ArmenianAnalyzer.java b/lucene/analysis/common/src/java/org/apache/lucene/analysis/hy/ArmenianAnalyzer.java
index 8c046392333..95506e19d1c 100644
-- a/lucene/analysis/common/src/java/org/apache/lucene/analysis/hy/ArmenianAnalyzer.java
++ b/lucene/analysis/common/src/java/org/apache/lucene/analysis/hy/ArmenianAnalyzer.java
@@ -121,4 +121,11 @@ public final class ArmenianAnalyzer extends StopwordAnalyzerBase {
     result = new SnowballFilter(result, new ArmenianStemmer());
     return new TokenStreamComponents(source, result);
   }

  @Override
  protected TokenStream normalize(String fieldName, TokenStream in) {
    TokenStream result = new StandardFilter(in);
    result = new LowerCaseFilter(result);
    return result;
  }
 }
diff --git a/lucene/analysis/common/src/java/org/apache/lucene/analysis/id/IndonesianAnalyzer.java b/lucene/analysis/common/src/java/org/apache/lucene/analysis/id/IndonesianAnalyzer.java
index fc9b4d2550d..9804beafaa2 100644
-- a/lucene/analysis/common/src/java/org/apache/lucene/analysis/id/IndonesianAnalyzer.java
++ b/lucene/analysis/common/src/java/org/apache/lucene/analysis/id/IndonesianAnalyzer.java
@@ -119,4 +119,11 @@ public final class IndonesianAnalyzer extends StopwordAnalyzerBase {
     }
     return new TokenStreamComponents(source, new IndonesianStemFilter(result));
   }

  @Override
  protected TokenStream normalize(String fieldName, TokenStream in) {
    TokenStream result = new StandardFilter(in);
    result = new LowerCaseFilter(result);
    return result;
  }
 }
diff --git a/lucene/analysis/common/src/java/org/apache/lucene/analysis/it/ItalianAnalyzer.java b/lucene/analysis/common/src/java/org/apache/lucene/analysis/it/ItalianAnalyzer.java
index a18aa5d699e..32f4e30bf19 100644
-- a/lucene/analysis/common/src/java/org/apache/lucene/analysis/it/ItalianAnalyzer.java
++ b/lucene/analysis/common/src/java/org/apache/lucene/analysis/it/ItalianAnalyzer.java
@@ -133,4 +133,12 @@ public final class ItalianAnalyzer extends StopwordAnalyzerBase {
     result = new ItalianLightStemFilter(result);
     return new TokenStreamComponents(source, result);
   }

  @Override
  protected TokenStream normalize(String fieldName, TokenStream in) {
    TokenStream result = new StandardFilter(in);
    result = new ElisionFilter(result, DEFAULT_ARTICLES);
    result = new LowerCaseFilter(result);
    return result;
  }
 }
diff --git a/lucene/analysis/common/src/java/org/apache/lucene/analysis/lt/LithuanianAnalyzer.java b/lucene/analysis/common/src/java/org/apache/lucene/analysis/lt/LithuanianAnalyzer.java
index 5e24cf988b2..4eccc51121c 100644
-- a/lucene/analysis/common/src/java/org/apache/lucene/analysis/lt/LithuanianAnalyzer.java
++ b/lucene/analysis/common/src/java/org/apache/lucene/analysis/lt/LithuanianAnalyzer.java
@@ -121,4 +121,11 @@ public final class LithuanianAnalyzer extends StopwordAnalyzerBase {
     result = new SnowballFilter(result, new LithuanianStemmer());
     return new TokenStreamComponents(source, result);
   }

  @Override
  protected TokenStream normalize(String fieldName, TokenStream in) {
    TokenStream result = new StandardFilter(in);
    result = new LowerCaseFilter(result);
    return result;
  }
 }
diff --git a/lucene/analysis/common/src/java/org/apache/lucene/analysis/lv/LatvianAnalyzer.java b/lucene/analysis/common/src/java/org/apache/lucene/analysis/lv/LatvianAnalyzer.java
index 0a016af36be..1b08b3b5894 100644
-- a/lucene/analysis/common/src/java/org/apache/lucene/analysis/lv/LatvianAnalyzer.java
++ b/lucene/analysis/common/src/java/org/apache/lucene/analysis/lv/LatvianAnalyzer.java
@@ -122,4 +122,11 @@ public final class LatvianAnalyzer extends StopwordAnalyzerBase {
     result = new LatvianStemFilter(result);
     return new TokenStreamComponents(source, result);
   }

  @Override
  protected TokenStream normalize(String fieldName, TokenStream in) {
    TokenStream result = new StandardFilter(in);
    result = new LowerCaseFilter(result);
    return result;
  }
 }
diff --git a/lucene/analysis/common/src/java/org/apache/lucene/analysis/nl/DutchAnalyzer.java b/lucene/analysis/common/src/java/org/apache/lucene/analysis/nl/DutchAnalyzer.java
index 0391425d6f8..900d9c64b20 100644
-- a/lucene/analysis/common/src/java/org/apache/lucene/analysis/nl/DutchAnalyzer.java
++ b/lucene/analysis/common/src/java/org/apache/lucene/analysis/nl/DutchAnalyzer.java
@@ -159,4 +159,11 @@ public final class DutchAnalyzer extends Analyzer {
     result = new SnowballFilter(result, new org.tartarus.snowball.ext.DutchStemmer());
     return new TokenStreamComponents(source, result);
   }

  @Override
  protected TokenStream normalize(String fieldName, TokenStream in) {
    TokenStream result = new StandardFilter(in);
    result = new LowerCaseFilter(result);
    return result;
  }
 }
diff --git a/lucene/analysis/common/src/java/org/apache/lucene/analysis/no/NorwegianAnalyzer.java b/lucene/analysis/common/src/java/org/apache/lucene/analysis/no/NorwegianAnalyzer.java
index c413793bc82..3570ad42a31 100644
-- a/lucene/analysis/common/src/java/org/apache/lucene/analysis/no/NorwegianAnalyzer.java
++ b/lucene/analysis/common/src/java/org/apache/lucene/analysis/no/NorwegianAnalyzer.java
@@ -124,5 +124,12 @@ public final class NorwegianAnalyzer extends StopwordAnalyzerBase {
     result = new SnowballFilter(result, new NorwegianStemmer());
     return new TokenStreamComponents(source, result);
   }

  @Override
  protected TokenStream normalize(String fieldName, TokenStream in) {
    TokenStream result = new StandardFilter(in);
    result = new LowerCaseFilter(result);
    return result;
  }
 }
 
diff --git a/lucene/analysis/common/src/java/org/apache/lucene/analysis/pt/PortugueseAnalyzer.java b/lucene/analysis/common/src/java/org/apache/lucene/analysis/pt/PortugueseAnalyzer.java
index 769e1425bbd..8f548033be8 100644
-- a/lucene/analysis/common/src/java/org/apache/lucene/analysis/pt/PortugueseAnalyzer.java
++ b/lucene/analysis/common/src/java/org/apache/lucene/analysis/pt/PortugueseAnalyzer.java
@@ -123,4 +123,11 @@ public final class PortugueseAnalyzer extends StopwordAnalyzerBase {
     result = new PortugueseLightStemFilter(result);
     return new TokenStreamComponents(source, result);
   }

  @Override
  protected TokenStream normalize(String fieldName, TokenStream in) {
    TokenStream result = new StandardFilter(in);
    result = new LowerCaseFilter(result);
    return result;
  }
 }
diff --git a/lucene/analysis/common/src/java/org/apache/lucene/analysis/ro/RomanianAnalyzer.java b/lucene/analysis/common/src/java/org/apache/lucene/analysis/ro/RomanianAnalyzer.java
index 06ff9999e1b..1b74184af2d 100644
-- a/lucene/analysis/common/src/java/org/apache/lucene/analysis/ro/RomanianAnalyzer.java
++ b/lucene/analysis/common/src/java/org/apache/lucene/analysis/ro/RomanianAnalyzer.java
@@ -126,4 +126,11 @@ public final class RomanianAnalyzer extends StopwordAnalyzerBase {
     result = new SnowballFilter(result, new RomanianStemmer());
     return new TokenStreamComponents(source, result);
   }

  @Override
  protected TokenStream normalize(String fieldName, TokenStream in) {
    TokenStream result = new StandardFilter(in);
    result = new LowerCaseFilter(result);
    return result;
  }
 }
diff --git a/lucene/analysis/common/src/java/org/apache/lucene/analysis/ru/RussianAnalyzer.java b/lucene/analysis/common/src/java/org/apache/lucene/analysis/ru/RussianAnalyzer.java
index dfe8ef38adc..76bf49506d1 100644
-- a/lucene/analysis/common/src/java/org/apache/lucene/analysis/ru/RussianAnalyzer.java
++ b/lucene/analysis/common/src/java/org/apache/lucene/analysis/ru/RussianAnalyzer.java
@@ -121,4 +121,11 @@ public final class RussianAnalyzer extends StopwordAnalyzerBase {
       result = new SnowballFilter(result, new org.tartarus.snowball.ext.RussianStemmer());
       return new TokenStreamComponents(source, result);
     }

    @Override
    protected TokenStream normalize(String fieldName, TokenStream in) {
      TokenStream result = new StandardFilter(in);
      result = new LowerCaseFilter(result);
      return result;
    }
 }
diff --git a/lucene/analysis/common/src/java/org/apache/lucene/analysis/standard/ClassicAnalyzer.java b/lucene/analysis/common/src/java/org/apache/lucene/analysis/standard/ClassicAnalyzer.java
index dc6c1188fb1..ef2ef7ebb18 100644
-- a/lucene/analysis/common/src/java/org/apache/lucene/analysis/standard/ClassicAnalyzer.java
++ b/lucene/analysis/common/src/java/org/apache/lucene/analysis/standard/ClassicAnalyzer.java
@@ -100,4 +100,9 @@ public final class ClassicAnalyzer extends StopwordAnalyzerBase {
       }
     };
   }

  @Override
  protected TokenStream normalize(String fieldName, TokenStream in) {
    return new LowerCaseFilter(in);
  }
 }
diff --git a/lucene/analysis/common/src/java/org/apache/lucene/analysis/standard/UAX29URLEmailAnalyzer.java b/lucene/analysis/common/src/java/org/apache/lucene/analysis/standard/UAX29URLEmailAnalyzer.java
index 9994884e449..fe71b7e83f1 100644
-- a/lucene/analysis/common/src/java/org/apache/lucene/analysis/standard/UAX29URLEmailAnalyzer.java
++ b/lucene/analysis/common/src/java/org/apache/lucene/analysis/standard/UAX29URLEmailAnalyzer.java
@@ -97,4 +97,9 @@ public final class UAX29URLEmailAnalyzer extends StopwordAnalyzerBase {
       }
     };
   }

  @Override
  protected TokenStream normalize(String fieldName, TokenStream in) {
    return new LowerCaseFilter(in);
  }
 }
diff --git a/lucene/analysis/common/src/java/org/apache/lucene/analysis/sv/SwedishAnalyzer.java b/lucene/analysis/common/src/java/org/apache/lucene/analysis/sv/SwedishAnalyzer.java
index fd2aa2e54a9..3896d3ece8d 100644
-- a/lucene/analysis/common/src/java/org/apache/lucene/analysis/sv/SwedishAnalyzer.java
++ b/lucene/analysis/common/src/java/org/apache/lucene/analysis/sv/SwedishAnalyzer.java
@@ -124,4 +124,11 @@ public final class SwedishAnalyzer extends StopwordAnalyzerBase {
     result = new SnowballFilter(result, new SwedishStemmer());
     return new TokenStreamComponents(source, result);
   }

  @Override
  protected TokenStream normalize(String fieldName, TokenStream in) {
    TokenStream result = new StandardFilter(in);
    result = new LowerCaseFilter(result);
    return result;
  }
 }
diff --git a/lucene/analysis/common/src/java/org/apache/lucene/analysis/th/ThaiAnalyzer.java b/lucene/analysis/common/src/java/org/apache/lucene/analysis/th/ThaiAnalyzer.java
index 11f3f779cba..c1426b81cce 100644
-- a/lucene/analysis/common/src/java/org/apache/lucene/analysis/th/ThaiAnalyzer.java
++ b/lucene/analysis/common/src/java/org/apache/lucene/analysis/th/ThaiAnalyzer.java
@@ -102,4 +102,11 @@ public final class ThaiAnalyzer extends StopwordAnalyzerBase {
     result = new StopFilter(result, stopwords);
     return new TokenStreamComponents(source, result);
   }

  @Override
  protected TokenStream normalize(String fieldName, TokenStream in) {
    TokenStream result = new LowerCaseFilter(in);
    result = new DecimalDigitFilter(result);
    return result;
  }
 }
diff --git a/lucene/analysis/common/src/java/org/apache/lucene/analysis/tr/TurkishAnalyzer.java b/lucene/analysis/common/src/java/org/apache/lucene/analysis/tr/TurkishAnalyzer.java
index a21495fb3eb..719e4344077 100644
-- a/lucene/analysis/common/src/java/org/apache/lucene/analysis/tr/TurkishAnalyzer.java
++ b/lucene/analysis/common/src/java/org/apache/lucene/analysis/tr/TurkishAnalyzer.java
@@ -127,4 +127,11 @@ public final class TurkishAnalyzer extends StopwordAnalyzerBase {
     result = new SnowballFilter(result, new TurkishStemmer());
     return new TokenStreamComponents(source, result);
   }

  @Override
  protected TokenStream normalize(String fieldName, TokenStream in) {
    TokenStream result = new StandardFilter(in);
    result = new TurkishLowerCaseFilter(result);
    return result;
  }
 }
diff --git a/lucene/analysis/common/src/java/org/apache/lucene/collation/CollationKeyAnalyzer.java b/lucene/analysis/common/src/java/org/apache/lucene/collation/CollationKeyAnalyzer.java
index f7b15f6894f..ea987315b07 100644
-- a/lucene/analysis/common/src/java/org/apache/lucene/collation/CollationKeyAnalyzer.java
++ b/lucene/analysis/common/src/java/org/apache/lucene/collation/CollationKeyAnalyzer.java
@@ -20,6 +20,8 @@ package org.apache.lucene.collation;
 
 import org.apache.lucene.analysis.Analyzer;
 import org.apache.lucene.analysis.core.KeywordTokenizer;
import org.apache.lucene.util.AttributeFactory;

 import java.text.Collator;
 
 /**
@@ -82,6 +84,11 @@ public final class CollationKeyAnalyzer extends Analyzer {
     this.factory = new CollationAttributeFactory(collator);
   }
 
  @Override
  protected AttributeFactory attributeFactory() {
    return factory;
  }

   @Override
   protected TokenStreamComponents createComponents(String fieldName) {
     KeywordTokenizer tokenizer = new KeywordTokenizer(factory, KeywordTokenizer.DEFAULT_BUFFER_SIZE);
diff --git a/lucene/analysis/common/src/test/org/apache/lucene/analysis/core/TestAllAnalyzersHaveFactories.java b/lucene/analysis/common/src/test/org/apache/lucene/analysis/core/TestAllAnalyzersHaveFactories.java
index d826a60d677..7099566b447 100644
-- a/lucene/analysis/common/src/test/org/apache/lucene/analysis/core/TestAllAnalyzersHaveFactories.java
++ b/lucene/analysis/common/src/test/org/apache/lucene/analysis/core/TestAllAnalyzersHaveFactories.java
@@ -35,6 +35,7 @@ import org.apache.lucene.analysis.MockCharFilter;
 import org.apache.lucene.analysis.MockFixedLengthPayloadFilter;
 import org.apache.lucene.analysis.MockGraphTokenFilter;
 import org.apache.lucene.analysis.MockHoleInjectingTokenFilter;
import org.apache.lucene.analysis.MockLowerCaseFilter;
 import org.apache.lucene.analysis.MockRandomLookaheadTokenFilter;
 import org.apache.lucene.analysis.MockSynonymFilter;
 import org.apache.lucene.analysis.MockTokenFilter;
@@ -75,6 +76,7 @@ public class TestAllAnalyzersHaveFactories extends LuceneTestCase {
       MockFixedLengthPayloadFilter.class,
       MockGraphTokenFilter.class,
       MockHoleInjectingTokenFilter.class,
      MockLowerCaseFilter.class,
       MockRandomLookaheadTokenFilter.class,
       MockSynonymFilter.class,
       MockTokenFilter.class,
diff --git a/lucene/analysis/common/src/test/org/apache/lucene/analysis/core/TestAnalyzers.java b/lucene/analysis/common/src/test/org/apache/lucene/analysis/core/TestAnalyzers.java
index 8f7f2cd8a4b..6d514d171a8 100644
-- a/lucene/analysis/common/src/test/org/apache/lucene/analysis/core/TestAnalyzers.java
++ b/lucene/analysis/common/src/test/org/apache/lucene/analysis/core/TestAnalyzers.java
@@ -52,6 +52,7 @@ public class TestAnalyzers extends BaseTokenStreamTestCase {
                      new String[] { "b" });
     assertAnalyzesTo(a, "\"QUOTED\" word", 
                      new String[] { "quoted", "word" });
    assertEquals(new BytesRef("\"\\Ã 3[]()! cz@"), a.normalize("dummy", "\"\\Ã3[]()! Cz@"));
     a.close();
   }
 
@@ -73,6 +74,7 @@ public class TestAnalyzers extends BaseTokenStreamTestCase {
                      new String[] { "2B" });
     assertAnalyzesTo(a, "\"QUOTED\" word", 
                      new String[] { "\"QUOTED\"", "word" });
    assertEquals(new BytesRef("\"\\Ã3[]()! Cz@"), a.normalize("dummy", "\"\\Ã3[]()! Cz@"));
     a.close();
   }
 
@@ -82,6 +84,8 @@ public class TestAnalyzers extends BaseTokenStreamTestCase {
                      new String[] { "foo", "bar", "foo", "bar" });
     assertAnalyzesTo(a, "foo a bar such FOO THESE BAR", 
                      new String[] { "foo", "bar", "foo", "bar" });
    assertEquals(new BytesRef("\"\\Ã 3[]()! cz@"), a.normalize("dummy", "\"\\Ã3[]()! Cz@"));
    assertEquals(new BytesRef("the"), a.normalize("dummy", "the"));
     a.close();
   }
 
diff --git a/lucene/analysis/common/src/test/org/apache/lucene/analysis/core/TestRandomChains.java b/lucene/analysis/common/src/test/org/apache/lucene/analysis/core/TestRandomChains.java
index 4effc79f167..25ca7a3a3bc 100644
-- a/lucene/analysis/common/src/test/org/apache/lucene/analysis/core/TestRandomChains.java
++ b/lucene/analysis/common/src/test/org/apache/lucene/analysis/core/TestRandomChains.java
@@ -928,6 +928,7 @@ public class TestRandomChains extends BaseTokenStreamTestCase {
           System.out.println("Creating random analyzer:" + a);
         }
         try {
          checkNormalize(a);
           checkRandomData(random, a, 500*RANDOM_MULTIPLIER, 20, false,
               false /* We already validate our own offsets... */);
         } catch (Throwable e) {
@@ -937,7 +938,14 @@ public class TestRandomChains extends BaseTokenStreamTestCase {
       }
     }
   }
  

  public void checkNormalize(Analyzer a) {
    // normalization should not modify characters that may be used for wildcards
    // or regular expressions
    String s = "([0-9]+)?*";
    assertEquals(s, a.normalize("dummy", s).utf8ToString());
  }

   // we might regret this decision...
   public void testRandomChainsWithLargeStrings() throws Throwable {
     int numIterations = TEST_NIGHTLY ? atLeast(20) : 3;
diff --git a/lucene/analysis/common/src/test/org/apache/lucene/analysis/custom/TestCustomAnalyzer.java b/lucene/analysis/common/src/test/org/apache/lucene/analysis/custom/TestCustomAnalyzer.java
index 5160dab73c4..aa69b709ec9 100644
-- a/lucene/analysis/common/src/test/org/apache/lucene/analysis/custom/TestCustomAnalyzer.java
++ b/lucene/analysis/common/src/test/org/apache/lucene/analysis/custom/TestCustomAnalyzer.java
@@ -17,6 +17,8 @@
 package org.apache.lucene.analysis.custom;
 
 
import java.io.IOException;
import java.io.Reader;
 import java.nio.file.Paths;
 import java.util.Collections;
 import java.util.HashMap;
@@ -24,16 +26,25 @@ import java.util.List;
 import java.util.Map;
 
 import org.apache.lucene.analysis.BaseTokenStreamTestCase;
import org.apache.lucene.analysis.CharFilter;
import org.apache.lucene.analysis.TokenStream;
import org.apache.lucene.analysis.Tokenizer;
 import org.apache.lucene.analysis.charfilter.HTMLStripCharFilterFactory;
import org.apache.lucene.analysis.core.KeywordTokenizerFactory;
 import org.apache.lucene.analysis.core.LowerCaseFilterFactory;
import org.apache.lucene.analysis.core.LowerCaseTokenizer;
 import org.apache.lucene.analysis.core.StopFilterFactory;
 import org.apache.lucene.analysis.core.WhitespaceTokenizerFactory;
 import org.apache.lucene.analysis.miscellaneous.ASCIIFoldingFilterFactory;
 import org.apache.lucene.analysis.standard.ClassicTokenizerFactory;
 import org.apache.lucene.analysis.standard.StandardTokenizerFactory;
import org.apache.lucene.analysis.util.AbstractAnalysisFactory;
 import org.apache.lucene.analysis.util.CharFilterFactory;
import org.apache.lucene.analysis.util.MultiTermAwareComponent;
 import org.apache.lucene.analysis.util.TokenFilterFactory;
 import org.apache.lucene.analysis.util.TokenizerFactory;
import org.apache.lucene.util.AttributeFactory;
import org.apache.lucene.util.BytesRef;
 import org.apache.lucene.util.SetOnce.AlreadySetException;
 import org.apache.lucene.util.Version;
 
@@ -336,4 +347,136 @@ public class TestCustomAnalyzer extends BaseTokenStreamTestCase {
     });
   }
 
  private static class DummyCharFilter extends CharFilter {

    private final char match, repl;

    public DummyCharFilter(Reader input, char match, char repl) {
      super(input);
      this.match = match;
      this.repl = repl;
    }

    @Override
    protected int correct(int currentOff) {
      return currentOff;
    }

    @Override
    public int read(char[] cbuf, int off, int len) throws IOException {
      final int read = input.read(cbuf, off, len);
      for (int i = 0; i &lt; read; ++i) {
        if (cbuf[off+i] == match) {
          cbuf[off+i] = repl;
        }
      }
      return read;
    }
    
  }

  public static class DummyCharFilterFactory extends CharFilterFactory {

    private final char match, repl;

    public DummyCharFilterFactory(Map&lt;String,String&gt; args) {
      this(args, '</literal><literal type="number">0</literal><literal type="char">', '</literal><literal type="number">1</literal><literal type="char">');
    }

    DummyCharFilterFactory(Map&lt;String,String&gt; args, char match, char repl) {
      super(args);
      this.match = match;
      this.repl = repl;
    }

    @Override
    public Reader create(Reader input) {
      return new DummyCharFilter(input, match, repl);
    }
    
  }

  public static class DummyMultiTermAwareCharFilterFactory extends DummyCharFilterFactory implements MultiTermAwareComponent {

    public DummyMultiTermAwareCharFilterFactory(Map&lt;String,String&gt; args) {
      super(args);
    }

    @Override
    public AbstractAnalysisFactory getMultiTermComponent() {
      return new DummyCharFilterFactory(Collections.emptyMap(), '</literal><literal type="number">0</literal><literal type="char">', '</literal><literal type="number">2</literal><literal type="char">');
    }

  }

  public static class DummyTokenizerFactory extends TokenizerFactory {

    public DummyTokenizerFactory(Map&lt;String,String&gt; args) {
      super(args);
    }

    @Override
    public Tokenizer create(AttributeFactory factory) {
      return new LowerCaseTokenizer(factory);
    }

  }

  public static class DummyMultiTermAwareTokenizerFactory extends DummyTokenizerFactory implements MultiTermAwareComponent {

    public DummyMultiTermAwareTokenizerFactory(Map&lt;String,String&gt; args) {
      super(args);
    }

    @Override
    public AbstractAnalysisFactory getMultiTermComponent() {
      return new KeywordTokenizerFactory(getOriginalArgs());
    }
    
  }

  public static class DummyTokenFilterFactory extends TokenFilterFactory {

    public DummyTokenFilterFactory(Map&lt;String,String&gt; args) {
      super(args);
    }

    @Override
    public TokenStream create(TokenStream input) {
      return input;
    }
    
  }

  public static class DummyMultiTermAwareTokenFilterFactory extends DummyTokenFilterFactory implements MultiTermAwareComponent {

    public DummyMultiTermAwareTokenFilterFactory(Map&lt;String,String&gt; args) {
      super(args);
    }

    @Override
    public AbstractAnalysisFactory getMultiTermComponent() {
      return new ASCIIFoldingFilterFactory(Collections.emptyMap());
    }
    
  }

  public void testNormalization() throws IOException {
    CustomAnalyzer analyzer1 = CustomAnalyzer.builder()
        // none of these components are multi-term aware so they should not be applied
        .withTokenizer(DummyTokenizerFactory.class, Collections.emptyMap())
        .addCharFilter(DummyCharFilterFactory.class, Collections.emptyMap())
        .addTokenFilter(DummyTokenFilterFactory.class, Collections.emptyMap())
        .build();
    assertEquals(new BytesRef("0Ã"), analyzer1.normalize("dummy", "0Ã"));

    CustomAnalyzer analyzer2 = CustomAnalyzer.builder()
        // these components are multi-term aware so they should be applied
        .withTokenizer(DummyMultiTermAwareTokenizerFactory.class, Collections.emptyMap())
        .addCharFilter(DummyMultiTermAwareCharFilterFactory.class, Collections.emptyMap())
        .addTokenFilter(DummyMultiTermAwareTokenFilterFactory.class, Collections.emptyMap())
        .build();
    assertEquals(new BytesRef("2A"), analyzer2.normalize("dummy", "0Ã"));
  }

 }
diff --git a/lucene/analysis/kuromoji/src/java/org/apache/lucene/analysis/ja/JapaneseAnalyzer.java b/lucene/analysis/kuromoji/src/java/org/apache/lucene/analysis/ja/JapaneseAnalyzer.java
index 46d40b18b1e..06e119e0920 100644
-- a/lucene/analysis/kuromoji/src/java/org/apache/lucene/analysis/ja/JapaneseAnalyzer.java
++ b/lucene/analysis/kuromoji/src/java/org/apache/lucene/analysis/ja/JapaneseAnalyzer.java
@@ -94,4 +94,11 @@ public class JapaneseAnalyzer extends StopwordAnalyzerBase {
     stream = new LowerCaseFilter(stream);
     return new TokenStreamComponents(tokenizer, stream);
   }

  @Override
  protected TokenStream normalize(String fieldName, TokenStream in) {
    TokenStream result = new CJKWidthFilter(in);
    result = new LowerCaseFilter(result);
    return result;
  }
 }
diff --git a/lucene/analysis/morfologik/src/java/org/apache/lucene/analysis/morfologik/MorfologikAnalyzer.java b/lucene/analysis/morfologik/src/java/org/apache/lucene/analysis/morfologik/MorfologikAnalyzer.java
index 091acfdaf03..0caca357a8c 100644
-- a/lucene/analysis/morfologik/src/java/org/apache/lucene/analysis/morfologik/MorfologikAnalyzer.java
++ b/lucene/analysis/morfologik/src/java/org/apache/lucene/analysis/morfologik/MorfologikAnalyzer.java
@@ -23,6 +23,7 @@ import morfologik.stemming.Dictionary;
 import morfologik.stemming.polish.PolishStemmer;
 
 import org.apache.lucene.analysis.Analyzer;
import org.apache.lucene.analysis.TokenStream;
 import org.apache.lucene.analysis.Tokenizer;
 import org.apache.lucene.analysis.standard.StandardFilter;
 import org.apache.lucene.analysis.standard.StandardTokenizer;
@@ -69,4 +70,9 @@ public class MorfologikAnalyzer extends Analyzer {
         src, 
         new MorfologikFilter(new StandardFilter(src), dictionary));
   }

  @Override
  protected TokenStream normalize(String fieldName, TokenStream in) {
    return new StandardFilter(in);
  }
 }
diff --git a/lucene/analysis/smartcn/src/java/org/apache/lucene/analysis/cn/smart/SmartChineseAnalyzer.java b/lucene/analysis/smartcn/src/java/org/apache/lucene/analysis/cn/smart/SmartChineseAnalyzer.java
index 5f0347b2fa1..f604d4b8970 100644
-- a/lucene/analysis/smartcn/src/java/org/apache/lucene/analysis/cn/smart/SmartChineseAnalyzer.java
++ b/lucene/analysis/smartcn/src/java/org/apache/lucene/analysis/cn/smart/SmartChineseAnalyzer.java
@@ -22,6 +22,7 @@ import java.util.Set;
 
 import org.apache.lucene.analysis.Analyzer;
 import org.apache.lucene.analysis.CharArraySet;
import org.apache.lucene.analysis.LowerCaseFilter;
 import org.apache.lucene.analysis.StopFilter;
 import org.apache.lucene.analysis.TokenStream;
 import org.apache.lucene.analysis.Tokenizer;
@@ -139,4 +140,9 @@ public final class SmartChineseAnalyzer extends Analyzer {
     }
     return new TokenStreamComponents(tokenizer, result);
   }

  @Override
  protected TokenStream normalize(String fieldName, TokenStream in) {
    return new LowerCaseFilter(in);
  }
 }
diff --git a/lucene/analysis/stempel/src/java/org/apache/lucene/analysis/pl/PolishAnalyzer.java b/lucene/analysis/stempel/src/java/org/apache/lucene/analysis/pl/PolishAnalyzer.java
index 6ed4fda6ba1..2d3ef4cfa36 100644
-- a/lucene/analysis/stempel/src/java/org/apache/lucene/analysis/pl/PolishAnalyzer.java
++ b/lucene/analysis/stempel/src/java/org/apache/lucene/analysis/pl/PolishAnalyzer.java
@@ -146,4 +146,11 @@ public final class PolishAnalyzer extends StopwordAnalyzerBase {
     result = new StempelFilter(result, new StempelStemmer(stemTable));
     return new TokenStreamComponents(source, result);
   }

  @Override
  protected TokenStream normalize(String fieldName, TokenStream in) {
    TokenStream result = new StandardFilter(in);
    result = new LowerCaseFilter(result);
    return result;
  }
 }
diff --git a/lucene/core/src/java/org/apache/lucene/analysis/Analyzer.java b/lucene/core/src/java/org/apache/lucene/analysis/Analyzer.java
index cce740d14dc..0d60d2495dc 100644
-- a/lucene/core/src/java/org/apache/lucene/analysis/Analyzer.java
++ b/lucene/core/src/java/org/apache/lucene/analysis/Analyzer.java
@@ -18,11 +18,18 @@ package org.apache.lucene.analysis;
 
 
 import java.io.Closeable;
import java.io.IOException;
 import java.io.Reader;
import java.io.StringReader;
 import java.util.HashMap;
 import java.util.Map;
 
import org.apache.lucene.analysis.tokenattributes.CharTermAttribute;
import org.apache.lucene.analysis.tokenattributes.OffsetAttribute;
import org.apache.lucene.analysis.tokenattributes.TermToBytesRefAttribute;
 import org.apache.lucene.store.AlreadyClosedException;
import org.apache.lucene.util.AttributeFactory;
import org.apache.lucene.util.BytesRef;
 import org.apache.lucene.util.CloseableThreadLocal;
 import org.apache.lucene.util.Version;
 
@@ -44,6 +51,12 @@ import org.apache.lucene.util.Version;
  *     filter = new BarFilter(filter);
  *     return new TokenStreamComponents(source, filter);
  *   }
 *   {@literal @Override}
 *   protected TokenStream normalize(TokenStream in) {
 *     // Assuming FooFilter is about normalization and BarFilter is about
 *     // stemming, only FooFilter should be applied
 *     return new FooFilter(in);
 *   }
  * };
  * &lt;/pre&gt;
  * For more examples, see the {@link org.apache.lucene.analysis Analysis package documentation}.
@@ -107,6 +120,15 @@ public abstract class Analyzer implements Closeable {
    */
   protected abstract TokenStreamComponents createComponents(String fieldName);
 
  /**
   * Wrap the given {@link TokenStream} in order to apply normalization filters.
   * The default implementation returns the {@link TokenStream} as-is. This is
   * used by {@link #normalize(String, String)}.
   */
  protected TokenStream normalize(String fieldName, TokenStream in) {
    return in;
  }

   /**
    * Returns a TokenStream suitable for &lt;code&gt;fieldName&lt;/code&gt;, tokenizing
    * the contents of &lt;code&gt;reader&lt;/code&gt;.
@@ -181,7 +203,65 @@ public abstract class Analyzer implements Closeable {
     components.reusableStringReader = strReader;
     return components.getTokenStream();
   }
    

  /**
   * Normalize a string down to the representation that it would have in the
   * index.
   * &lt;p&gt;
   * This is typically used by query parsers in order to generate a query on
   * a given term, without tokenizing or stemming, which are undesirable if
   * the string to analyze is a partial word (eg. in case of a wildcard or
   * fuzzy query).
   * &lt;p&gt;
   * This method uses {@link #initReaderForNormalization(String, Reader)} in
   * order to apply necessary character-level normalization and then
   * {@link #normalize(String, TokenStream)} in order to apply the normalizing
   * token filters.
   */
  public final BytesRef normalize(final String fieldName, final String text) {
    try {
      // apply char filters
      final String filteredText;
      try (Reader reader = new StringReader(text)) {
        Reader filterReader = initReaderForNormalization(fieldName, reader);
        char[] buffer = new char[64];
        StringBuilder builder = new StringBuilder();
        for (;;) {
          final int read = filterReader.read(buffer, 0, buffer.length);
          if (read == -1) {
            break;
          }
          builder.append(buffer, 0, read);
        }
        filteredText = builder.toString();
      } catch (IOException e) {
        throw new IllegalStateException("Normalization threw an unexpected exeption", e);
      }

      final AttributeFactory attributeFactory = attributeFactory();
      try (TokenStream ts = normalize(fieldName,
          new StringTokenStream(attributeFactory, filteredText, text.length()))) {
        final TermToBytesRefAttribute termAtt = ts.addAttribute(TermToBytesRefAttribute.class);
        ts.reset();
        if (ts.incrementToken() == false) {
          throw new IllegalStateException("The normalization token stream is "
              + "expected to produce exactly 1 token, but got 0 for analyzer "
              + this + " and input \"" + text + "\"");
        }
        final BytesRef term = BytesRef.deepCopyOf(termAtt.getBytesRef());
        if (ts.incrementToken()) {
          throw new IllegalStateException("The normalization token stream is "
              + "expected to produce exactly 1 token, but got 2+ for analyzer "
              + this + " and input \"" + text + "\"");
        }
        ts.end();
        return term;
      }
    } catch (IOException e) {
      throw new IllegalStateException("Normalization threw an unexpected exeption", e);
    }
  }

   /**
    * Override this if you want to add a CharFilter chain.
    * &lt;p&gt;
@@ -196,6 +276,22 @@ public abstract class Analyzer implements Closeable {
     return reader;
   }
 
  /** Wrap the given {@link Reader} with {@link CharFilter}s that make sense
   *  for normalization. This is typically a subset of the {@link CharFilter}s
   *  that are applied in {@link #initReader(String, Reader)}. This is used by
   *  {@link #normalize(String, String)}. */
  protected Reader initReaderForNormalization(String fieldName, Reader reader) {
    return reader;
  }

  /** Return the {@link AttributeFactory} to be used for
   *  {@link #tokenStream analysis} and
   *  {@link #normalize(String, String) normalization}. The default
   *  implementation returns {@link AttributeFactory#DEFAULT_ATTRIBUTE_FACTORY}. */
  protected AttributeFactory attributeFactory() {
    return AttributeFactory.DEFAULT_ATTRIBUTE_FACTORY;
  }

   /**
    * Invoked before indexing a IndexableField instance if
    * terms have already been added to that field.  This allows custom
@@ -435,4 +531,41 @@ public abstract class Analyzer implements Closeable {
     }
   };
 
  private static final class StringTokenStream extends TokenStream {

    private final String value;
    private final int length;
    private boolean used = true;
    private final CharTermAttribute termAttribute = addAttribute(CharTermAttribute.class);
    private final OffsetAttribute offsetAttribute = addAttribute(OffsetAttribute.class);

    StringTokenStream(AttributeFactory attributeFactory, String value, int length) {
      super(attributeFactory);
      this.value = value;
      this.length = length;
    }

    @Override
    public void reset() {
      used = false;
    }

    @Override
    public boolean incrementToken() {
      if (used) {
        return false;
      }
      clearAttributes();
      termAttribute.append(value);
      offsetAttribute.setOffset(0, length);
      used = true;
      return true;
    }

    @Override
    public void end() throws IOException {
      super.end();
      offsetAttribute.setOffset(length, length);
    }
  }
 }
diff --git a/lucene/core/src/java/org/apache/lucene/analysis/standard/StandardAnalyzer.java b/lucene/core/src/java/org/apache/lucene/analysis/standard/StandardAnalyzer.java
index 251017d6b2b..fb57573fb4e 100644
-- a/lucene/core/src/java/org/apache/lucene/analysis/standard/StandardAnalyzer.java
++ b/lucene/core/src/java/org/apache/lucene/analysis/standard/StandardAnalyzer.java
@@ -112,4 +112,11 @@ public final class StandardAnalyzer extends StopwordAnalyzerBase {
       }
     };
   }

  @Override
  protected TokenStream normalize(String fieldName, TokenStream in) {
    TokenStream result = new StandardFilter(in);
    result = new LowerCaseFilter(result);
    return result;
  }
 }
diff --git a/lucene/core/src/test/org/apache/lucene/analysis/standard/TestStandardAnalyzer.java b/lucene/core/src/test/org/apache/lucene/analysis/standard/TestStandardAnalyzer.java
index 6c6ddc86cfe..2cc9274ad42 100644
-- a/lucene/core/src/test/org/apache/lucene/analysis/standard/TestStandardAnalyzer.java
++ b/lucene/core/src/test/org/apache/lucene/analysis/standard/TestStandardAnalyzer.java
@@ -27,6 +27,7 @@ import org.apache.lucene.analysis.BaseTokenStreamTestCase;
 import org.apache.lucene.analysis.MockGraphTokenFilter;
 import org.apache.lucene.analysis.TokenStream;
 import org.apache.lucene.analysis.Tokenizer;
import org.apache.lucene.util.BytesRef;
 import org.apache.lucene.util.TestUtil;
 
 public class TestStandardAnalyzer extends BaseTokenStreamTestCase {
@@ -387,4 +388,9 @@ public class TestStandardAnalyzer extends BaseTokenStreamTestCase {
     checkRandomData(random, analyzer, 100*RANDOM_MULTIPLIER, 8192);
     analyzer.close();
   }

  public void testNormalize() {
    Analyzer a = new StandardAnalyzer();
    assertEquals(new BytesRef("\"\\Ã 3[]()! cz@"), a.normalize("dummy", "\"\\Ã3[]()! Cz@"));
  }
 }
diff --git a/lucene/queryparser/src/java/org/apache/lucene/queryparser/analyzing/AnalyzingQueryParser.java b/lucene/queryparser/src/java/org/apache/lucene/queryparser/analyzing/AnalyzingQueryParser.java
deleted file mode 100644
index 49690fee265..00000000000
-- a/lucene/queryparser/src/java/org/apache/lucene/queryparser/analyzing/AnalyzingQueryParser.java
++ /dev/null
@@ -1,202 +0,0 @@
/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.lucene.queryparser.analyzing;

import java.io.IOException;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.apache.lucene.analysis.Analyzer;
import org.apache.lucene.analysis.TokenStream;
import org.apache.lucene.analysis.tokenattributes.CharTermAttribute;
import org.apache.lucene.queryparser.classic.ParseException;
import org.apache.lucene.search.Query;

/**
 * Overrides Lucene'</literal><name>s</name> default <name>QueryParser</name> <name>so</name> <name>that</name> <name>Fuzzy</name><operator>-</operator></expr><operator>,</operator> <expr><name>Prefix</name><operator>-</operator></expr><operator>,</operator> <expr><name>Range</name><operator>-</operator></expr><operator>,</operator> <expr><name>and</name> <name>WildcardQuerys</name>
 <operator>*</operator> <name>are</name> <name>also</name> <name>passed</name> <name>through</name> <name>the</name> <name>given</name> <name>analyzer</name></expr><operator>,</operator> <expr><name>but</name> <name>wildcard</name> <name><name>characters</name> <argument_list type="generic">&lt;<argument><name>code</name></argument>&gt;</argument_list></name><operator>*</operator><operator>&lt;</operator><operator>/</operator><name>code</name><operator>&gt;</operator> <name>and</name>
 <operator>*</operator> <operator>&lt;</operator><name>code</name><operator>&gt;</operator><operator>?</operator><operator>&lt;</operator><operator>/</operator><name>code</name><operator>&gt;</operator> <name>don</name><literal type="char">'t get removed from the search terms.
 * 
 * &lt;p&gt;&lt;b&gt;Warning:&lt;/b&gt; This class should only be used with analyzers that do not use stopwords
 * or that add tokens. Also, several stemming analyzers are inappropriate: for example, GermanAnalyzer 
 * will turn &lt;code&gt;H&amp;auml;user&lt;/code&gt; into &lt;code&gt;hau&lt;/code&gt;, but &lt;code&gt;H?user&lt;/code&gt; will 
 * become &lt;code&gt;h?user&lt;/code&gt; when using this parser and thus no match would be found (i.e.
 * using this parser will be no improvement over QueryParser in such cases). 
 */
public class AnalyzingQueryParser extends org.apache.lucene.queryparser.classic.QueryParser {
  // gobble escaped chars or find a wildcard character 
  private final Pattern wildcardPattern = Pattern.compile("(\\.)|([?*]+)");
  public AnalyzingQueryParser(String field, Analyzer analyzer) {
    super(field, analyzer);
    setAnalyzeRangeTerms(true);
  }

  /**
   * Called when parser parses an input term that contains one or more wildcard
   * characters (like &lt;code&gt;*&lt;/code&gt;), but is not a prefix term (one that has
   * just a single &lt;code&gt;*&lt;/code&gt; character at the end).
   * &lt;p&gt;
   * Example: will be called for &lt;code&gt;H?user&lt;/code&gt; or for &lt;code&gt;H*user&lt;/code&gt;.
   * &lt;p&gt;
   * Depending on analyzer and settings, a wildcard term may (most probably will)
   * be lower-cased automatically. It &lt;b&gt;will&lt;/b&gt; go through the default Analyzer.
   * &lt;p&gt;
   * Overrides super class, by passing terms through analyzer.
   *
   * @param  field   Name of the field query will use.
   * @param  termStr Term that contains one or more wildcard
   *                 characters (? or *), but is not simple prefix term
   *
   * @return Resulting {@link Query} built for the term
   */
  @Override
  protected Query getWildcardQuery(String field, String termStr) throws ParseException {

    if (termStr == null){
      //can'</literal><name>t</name> <name>imagine</name> <name>this</name> <name>would</name> <name>ever</name> <name>happen</name>
      <throw>throw <argument_list>new <argument><expr><call><name>ParseException</name><argument_list>(<argument><expr><literal type="string">"Passed null value as term to getWildcardQuery"</literal></expr></argument>)</argument_list></call></expr></argument></argument_list></throw></expr>;</expr_stmt>
    }
    if <expr_stmt><expr><operator>(</operator> <operator>!</operator> <call><name>getAllowLeadingWildcard</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><call><name><name>termStr</name><operator>.</operator><name>startsWith</name></name><argument_list>(<argument><expr><literal type="string">"*"</literal></expr></argument>)</argument_list></call> <operator>||</operator> <call><name><name>termStr</name><operator>.</operator><name>startsWith</name></name><argument_list>(<argument><expr><literal type="string">"?"</literal></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator> <block>{
      <throw>throw <argument_list>new <argument><expr><call><name>ParseException</name><argument_list>(<argument><expr><literal type="string">"'*' or '?' not allowed as first character in WildcardQuery"</literal>
                              <operator>+</operator> <literal type="string">" unless getAllowLeadingWildcard() returns true"</literal></expr></argument>)</argument_list></call></expr></argument></argument_list></throw>;
    }</block>
    
    <name>Matcher</name> <name>wildcardMatcher</name> <operator>=</operator> <call><name><name>wildcardPattern</name><operator>.</operator><name>matcher</name></name><argument_list>(<argument><expr><name>termStr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>StringBuilder</name></type> <name>sb</name> <init>= <expr><operator>new</operator> <call><name>StringBuilder</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>last</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  
    <while>while <condition>(<expr><call><name><name>wildcardMatcher</name><operator>.</operator><name>find</name></name><argument_list>()</argument_list></call></expr>)</condition><block>{<block_content>
      <comment type="line">// continue if escaped char</comment>
      <if_stmt><if>if <condition>(<expr><call><name><name>wildcardMatcher</name><operator>.</operator><name>group</name></name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition><block>{<block_content>
        <continue>continue;</continue>
      </block_content>}</block></if></if_stmt>
     
      <if_stmt><if>if <condition>(<expr><call><name><name>wildcardMatcher</name><operator>.</operator><name>start</name></name><argument_list>()</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block>{<block_content>
        <decl_stmt><decl><type><name>String</name></type> <name>chunk</name> <init>= <expr><call><name><name>termStr</name><operator>.</operator><name>substring</name></name><argument_list>(<argument><expr><name>last</name></expr></argument>, <argument><expr><call><name><name>wildcardMatcher</name><operator>.</operator><name>start</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>String</name></type> <name>analyzed</name> <init>= <expr><call><name>analyzeSingleChunk</name><argument_list>(<argument><expr><name>field</name></expr></argument>, <argument><expr><name>termStr</name></expr></argument>, <argument><expr><name>chunk</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>sb</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>analyzed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <comment type="line">//append the wildcard character</comment>
      <expr_stmt><expr><call><name><name>sb</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><call><name><name>wildcardMatcher</name><operator>.</operator><name>group</name></name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
     
      <expr_stmt><expr><name>last</name> <operator>=</operator> <call><name><name>wildcardMatcher</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
    <if_stmt><if>if <condition>(<expr><name>last</name> <operator>&lt;</operator> <call><name><name>termStr</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr>)</condition><block>{<block_content>
      <expr_stmt><expr><call><name><name>sb</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><call><name>analyzeSingleChunk</name><argument_list>(<argument><expr><name>field</name></expr></argument>, <argument><expr><name>termStr</name></expr></argument>, <argument><expr><call><name><name>termStr</name><operator>.</operator><name>substring</name></name><argument_list>(<argument><expr><name>last</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><call><name><name>super</name><operator>.</operator><name>getWildcardQuery</name></name><argument_list>(<argument><expr><name>field</name></expr></argument>, <argument><expr><call><name><name>sb</name><operator>.</operator><name>toString</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
  }
  
  <comment type="block" format="javadoc">/**
   * Called when parser parses an input term
   * that uses prefix notation; that is, contains a single '*' wildcard
   * character as its last character. Since this is a special case
   * of generic wildcard term, and such a query can be optimized easily,
   * this usually results in a different query object.
   * &lt;p&gt;
   * Depending on analyzer and settings, a prefix term may (most probably will)
   * be lower-cased automatically. It &lt;b&gt;will&lt;/b&gt; go through the default Analyzer.
   * &lt;p&gt;
   * Overrides super class, by passing terms through analyzer.
   *
   * @param  field   Name of the field query will use.
   * @param  termStr Term to use for building term for the query
   *                 (&lt;b&gt;without&lt;/b&gt; trailing '*' character!)
   *
   * @return Resulting {@link Query} built for the term
   */</comment>
  @<function><type><name>Override</name>
  <specifier>protected</specifier> <name>Query</name></type> <name>getPrefixQuery</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>field</name></decl></parameter>, <parameter><decl><type><name>String</name></type> <name>termStr</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>ParseException</name></expr></argument></throws> <block>{<block_content>
    <decl_stmt><decl><type><name>String</name></type> <name>analyzed</name> <init>= <expr><call><name>analyzeSingleChunk</name><argument_list>(<argument><expr><name>field</name></expr></argument>, <argument><expr><name>termStr</name></expr></argument>, <argument><expr><name>termStr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <return>return <expr><call><name><name>super</name><operator>.</operator><name>getPrefixQuery</name></name><argument_list>(<argument><expr><name>field</name></expr></argument>, <argument><expr><name>analyzed</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></function>

  <comment type="block" format="javadoc">/**
   * Called when parser parses an input term that has the fuzzy suffix (~) appended.
   * &lt;p&gt;
   * Depending on analyzer and settings, a fuzzy term may (most probably will)
   * be lower-cased automatically. It &lt;b&gt;will&lt;/b&gt; go through the default Analyzer.
   * &lt;p&gt;
   * Overrides super class, by passing terms through analyzer.
   *
   * @param field Name of the field query will use.
   * @param termStr Term to use for building term for the query
   *
   * @return Resulting {@link Query} built for the term
   */</comment>
  <function><annotation>@<name>Override</name></annotation>
  <type><specifier>protected</specifier> <name>Query</name></type> <name>getFuzzyQuery</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>field</name></decl></parameter>, <parameter><decl><type><name>String</name></type> <name>termStr</name></decl></parameter>, <parameter><decl><type><name>float</name></type> <name>minSimilarity</name></decl></parameter>)</parameter_list>
      <throws>throws <argument><expr><name>ParseException</name></expr></argument></throws> <block>{<block_content>
   
    <decl_stmt><decl><type><name>String</name></type> <name>analyzed</name> <init>= <expr><call><name>analyzeSingleChunk</name><argument_list>(<argument><expr><name>field</name></expr></argument>, <argument><expr><name>termStr</name></expr></argument>, <argument><expr><name>termStr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <return>return <expr><call><name><name>super</name><operator>.</operator><name>getFuzzyQuery</name></name><argument_list>(<argument><expr><name>field</name></expr></argument>, <argument><expr><name>analyzed</name></expr></argument>, <argument><expr><name>minSimilarity</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></function>

  <comment type="block" format="javadoc">/**
   * Returns the analyzed form for the given chunk
   * 
   * If the analyzer produces more than one output token from the given chunk,
   * a ParseException is thrown.
   *
   * @param field The target field
   * @param termStr The full term from which the given chunk is excerpted
   * @param chunk The portion of the given termStr to be analyzed
   * @return The result of analyzing the given chunk
   * @throws ParseException when analysis returns other than one output token
   */</comment>
  <function><type><specifier>protected</specifier> <name>String</name></type> <name>analyzeSingleChunk</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>field</name></decl></parameter>, <parameter><decl><type><name>String</name></type> <name>termStr</name></decl></parameter>, <parameter><decl><type><name>String</name></type> <name>chunk</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>ParseException</name></expr></argument></throws><block>{<block_content>
    <decl_stmt><decl><type><name>String</name></type> <name>analyzed</name> <init>= <expr><literal type="null">null</literal></expr></init></decl>;</decl_stmt>
    <try>try <init>(<decl><type><name>TokenStream</name></type> <name>stream</name> <init>= <expr><call><name>getAnalyzer</name><argument_list>()</argument_list></call><operator>.</operator><call><name>tokenStream</name><argument_list>(<argument><expr><name>field</name></expr></argument>, <argument><expr><name>chunk</name></expr></argument>)</argument_list></call></expr></init></decl>)</init> <block>{<block_content>
      <expr_stmt><expr><call><name><name>stream</name><operator>.</operator><name>reset</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <decl_stmt><decl><type><name>CharTermAttribute</name></type> <name>termAtt</name> <init>= <expr><call><name><name>stream</name><operator>.</operator><name>getAttribute</name></name><argument_list>(<argument><expr><name><name>CharTermAttribute</name><operator>.</operator><name>class</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <comment type="line">// get first and hopefully only output token</comment>
      <if_stmt><if>if <condition>(<expr><call><name><name>stream</name><operator>.</operator><name>incrementToken</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>analyzed</name> <operator>=</operator> <call><name><name>termAtt</name><operator>.</operator><name>toString</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        
        <comment type="line">// try to increment again, there should only be one output token</comment>
        <decl_stmt><decl><type><name>StringBuilder</name></type> <name>multipleOutputs</name> <init>= <expr><literal type="null">null</literal></expr></init></decl>;</decl_stmt>
        <while>while <condition>(<expr><call><name><name>stream</name><operator>.</operator><name>incrementToken</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><literal type="null">null</literal> <operator>==</operator> <name>multipleOutputs</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>multipleOutputs</name> <operator>=</operator> <operator>new</operator> <call><name>StringBuilder</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>multipleOutputs</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><literal type="char">'"'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>multipleOutputs</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>analyzed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>multipleOutputs</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><literal type="char">'"'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><call><name><name>multipleOutputs</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name><name>multipleOutputs</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><literal type="char">'"'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name><name>multipleOutputs</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><call><name><name>termAtt</name><operator>.</operator><name>toString</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name><name>multipleOutputs</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><literal type="char">'"'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></while>
        <expr_stmt><expr><call><name><name>stream</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><literal type="null">null</literal> <operator>!=</operator> <name>multipleOutputs</name></expr>)</condition> <block>{<block_content>
          <throw>throw <expr><operator>new</operator> <call><name>ParseException</name><argument_list>(
              <argument><expr><call><name><name>String</name><operator>.</operator><name>format</name></name><argument_list>(<argument><expr><call><name>getLocale</name><argument_list>()</argument_list></call></expr></argument>,
                  <argument><expr><literal type="string">"Analyzer created multiple terms for \"%s\": %s"</literal></expr></argument>, <argument><expr><name>chunk</name></expr></argument>, <argument><expr><call><name><name>multipleOutputs</name><operator>.</operator><name>toString</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if> <else>else <block>{<block_content>
        <comment type="line">// nothing returned by analyzer.  Was it a stop word and the user accidentally</comment>
        <comment type="line">// used an analyzer with stop words?</comment>
        <expr_stmt><expr><call><name><name>stream</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <throw>throw <expr><operator>new</operator> <call><name>ParseException</name><argument_list>(<argument><expr><call><name><name>String</name><operator>.</operator><name>format</name></name><argument_list>(<argument><expr><call><name>getLocale</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="string">"Analyzer returned nothing for \"%s\""</literal></expr></argument>, <argument><expr><name>chunk</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block> <catch>catch <parameter_list>(<parameter><decl><type><name>IOException</name></type> <name>e</name></decl></parameter>)</parameter_list><block>{<block_content>
      <throw>throw <expr><operator>new</operator> <call><name>ParseException</name><argument_list>(
          <argument><expr><call><name><name>String</name><operator>.</operator><name>format</name></name><argument_list>(<argument><expr><call><name>getLocale</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="string">"IO error while trying to analyze single term: \"%s\""</literal></expr></argument>, <argument><expr><name>termStr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw>
    </block_content>}</block></catch></try>
    <return>return <expr><name>analyzed</name></expr>;</return>
  </block_content>}</block></function>
}
diff <expr_stmt><expr><operator>--</operator><name>git</name> <name>a</name><operator>/</operator><name>lucene</name><operator>/</operator><name>queryparser</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>queryparser</name><operator>/</operator><name>classic</name><operator>/</operator><name><name>QueryParserBase</name><operator>.</operator><name>java</name></name> <name>b</name><operator>/</operator><name>lucene</name><operator>/</operator><name>queryparser</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>queryparser</name><operator>/</operator><name>classic</name><operator>/</operator><name><name>QueryParserBase</name><operator>.</operator><name>java</name></name>
<name>index</name> <name>cdfa4776175</name><operator>..</operator><name>fbe08a90770</name> <literal type="number">100644</literal>
<operator>--</operator> <name>a</name><operator>/</operator><name>lucene</name><operator>/</operator><name>queryparser</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>queryparser</name><operator>/</operator><name>classic</name><operator>/</operator><name><name>QueryParserBase</name><operator>.</operator><name>java</name></name>
<operator>++</operator> <name>b</name><operator>/</operator><name>lucene</name><operator>/</operator><name>queryparser</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>queryparser</name><operator>/</operator><name>classic</name><operator>/</operator><name><name>QueryParserBase</name><operator>.</operator><name>java</name></name>
@@ <operator>-</operator><literal type="number">16</literal></expr><operator>,</operator><expr><literal type="number">14</literal> <operator>+</operator><literal type="number">16</literal></expr><operator>,</operator><expr><literal type="number">13</literal> @@
  <operator>*</operator><operator>/</operator></expr></expr_stmt>
 <package>package <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>queryparser</name><operator>.</operator><name>classic</name></name>;</package>
 
<import>import <name><name>java</name><operator>.</operator><name>io</name><operator>.</operator><name>IOException</name></name>;</import>
 <import>import <name><name>java</name><operator>.</operator><name>io</name><operator>.</operator><name>StringReader</name></name>;</import>
 <import>import <name><name>java</name><operator>.</operator><name>text</name><operator>.</operator><name>DateFormat</name></name>;</import>
 <import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>*</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>regex</name><operator>.</operator><name>Matcher</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>regex</name><operator>.</operator><name>Pattern</name></name>;</import>
 
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>analysis</name><operator>.</operator><name>Analyzer</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>analysis</name><operator>.</operator><name>TokenStream</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>analysis</name><operator>.</operator><name>tokenattributes</name><operator>.</operator><name>TermToBytesRefAttribute</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>document</name><operator>.</operator><name>DateTools</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>index</name><operator>.</operator><name>Term</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>queryparser</name><operator>.</operator><name>classic</name><operator>.</operator><name>QueryParser</name><operator>.</operator><name>Operator</name></name>;</import>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">32</literal></expr><operator>,</operator><expr><literal type="number">6</literal> <operator>+</operator><literal type="number">31</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@</expr></expr_stmt> <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>search</name><operator>.</operator><name>*</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>search</name><operator>.</operator><name>BooleanClause</name><operator>.</operator><name>Occur</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>search</name><operator>.</operator><name>BooleanQuery</name><operator>.</operator><name>TooManyClauses</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>util</name><operator>.</operator><name>BytesRef</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>util</name><operator>.</operator><name>BytesRefBuilder</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>util</name><operator>.</operator><name>QueryBuilder</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>util</name><operator>.</operator><name>automaton</name><operator>.</operator><name>RegExp</name></name>;</import>
 
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">41</literal></expr><operator>,</operator><expr><literal type="number">9</literal> <operator>+</operator><literal type="number">41</literal></expr><operator>,</operator><expr><literal type="number">6</literal> @@</expr></expr_stmt> <import>import static <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>util</name><operator>.</operator><name>automaton</name><operator>.</operator><name>Operations</name><operator>.</operator><name>DEFAULT_MAX_DETERMINIZ</name></name>
  * <name>and</name> <name>acts</name> <name>to</name> <name>separate</name> <name>the</name> <name>majority</name> <name>of</name> <name>the</name> <name>Java</name> <name>code</name> <name>from</name> <name><name>the</name> <operator>.</operator><name>jj</name></name> <name>grammar</name> <name><name>file</name><operator>.</operator></name> 
  */
 public abstract class <name>QueryParserBase</name> extends <name>QueryBuilder</name> implements <name>CommonQueryParserConfiguration</name> <block>{<block_content>
  
  <comment type="block" format="javadoc">/** Do not catch this exception in your code, it means you are using methods that you should no longer use. */</comment>
  <class><specifier>public</specifier> <specifier>static</specifier> class <name>MethodRemovedUseAnother</name> <super_list><extends>extends <super><name>Throwable</name></super></extends></super_list> <block>{}</block></class>
 
   <decl_stmt><decl><type><specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>CONJ_NONE</name>   <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
   <decl_stmt><decl><type><specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>CONJ_AND</name>    <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">63</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">60</literal></expr><operator>,</operator><expr><literal type="number">6</literal> @@ <specifier>public</specifier> <specifier>abstract</specifier> <name>class</name> <name>QueryParserBase</name> extends <name>QueryBuilder</name> implements <name>CommonQuer</name>
   <comment type="block" format="javadoc">/** The actual operator that parser uses to combine query terms */</comment>
   <name>Operator</name> <name>operator</name> <operator>=</operator> <name>OR_OPERATOR</name></expr>;</expr_stmt>
 
  <decl_stmt><decl><type><name>boolean</name></type> <name>lowercaseExpandedTerms</name> <init>= <expr><literal type="boolean">true</literal></expr></init></decl>;</decl_stmt>
   <decl_stmt><decl><type><name><name>MultiTermQuery</name><operator>.</operator><name>RewriteMethod</name></name></type> <name>multiTermRewriteMethod</name> <init>= <expr><name><name>MultiTermQuery</name><operator>.</operator><name>CONSTANT_SCORE_REWRITE</name></name></expr></init></decl>;</decl_stmt>
   <decl_stmt><decl><type><name>boolean</name></type> <name>allowLeadingWildcard</name> <init>= <expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt>
 
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">79</literal></expr><operator>,</operator><expr><literal type="number">10</literal> <operator>+</operator><literal type="number">75</literal></expr><operator>,</operator><expr><literal type="number">6</literal> @@ <specifier>public</specifier> <specifier>abstract</specifier> <name>class</name> <name>QueryParserBase</name> extends <name>QueryBuilder</name> implements <name>CommonQuer</name>
   <comment type="line">// maps field names to date resolutions</comment>
   <name><name>Map</name><argument_list type="generic">&lt;<argument><name>String</name></argument>,<argument><name><name>DateTools</name><operator>.</operator><name>Resolution</name></name></argument>&gt;</argument_list></name> <name>fieldToDateResolution</name> <operator>=</operator> <literal type="null">null</literal></expr>;</expr_stmt>
 
  <comment type="line">//Whether or not to analyze range terms when constructing RangeQuerys</comment>
  <comment type="line">// (For example, analyzing terms into collation keys for locale-sensitive RangeQuery)</comment>
  <decl_stmt><decl><type><name>boolean</name></type> <name>analyzeRangeTerms</name> <init>= <expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt>

   <decl_stmt><decl><type><name>boolean</name></type> <name>autoGeneratePhraseQueries</name></decl>;</decl_stmt>
   <decl_stmt><decl><type><name>int</name></type> <name>maxDeterminizedStates</name> <init>= <expr><name>DEFAULT_MAX_DETERMINIZED_STATES</name></expr></init></decl>;</decl_stmt>
 
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">253</literal></expr><operator>,</operator><expr><literal type="number">24</literal> <operator>+</operator><literal type="number">245</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@ <specifier>public</specifier> <specifier>abstract</specifier> <name>class</name> <name>QueryParserBase</name> extends <name>QueryBuilder</name> implements <name>CommonQuer</name></expr></expr_stmt>
     <return>return <expr><name>operator</name></expr>;</return>
   </block_content>}</block></import>
 

  <comment type="block" format="javadoc">/**
   * Whether terms of wildcard, prefix, fuzzy and range queries are to be automatically
   * lower-cased or not.  Default is &lt;code&gt;true&lt;/code&gt;.
   */</comment>
  <function><annotation>@<name>Override</name></annotation>
  <type><specifier>public</specifier> <name>void</name></type> <name>setLowercaseExpandedTerms</name><parameter_list>(<parameter><decl><type><name>boolean</name></type> <name>lowercaseExpandedTerms</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><name><name>this</name><operator>.</operator><name>lowercaseExpandedTerms</name></name> <operator>=</operator> <name>lowercaseExpandedTerms</name></expr>;</expr_stmt>
  </block_content>}</block></function>

  <comment type="block" format="javadoc">/**
   * @see #setLowercaseExpandedTerms(boolean)
   */</comment>
  <function><annotation>@<name>Override</name></annotation>
  <type><specifier>public</specifier> <name>boolean</name></type> <name>getLowercaseExpandedTerms</name><parameter_list>()</parameter_list> <block>{<block_content>
    <return>return <expr><name>lowercaseExpandedTerms</name></expr>;</return>
  </block_content>}</block></function>

  
   <comment type="block" format="javadoc">/**
    * By default QueryParser uses {@link org.apache.lucene.search.MultiTermQuery#CONSTANT_SCORE_REWRITE}
    * when creating a {@link PrefixQuery}, {@link WildcardQuery} or {@link TermRangeQuery}. This implementation is generally preferable because it
@@ -378,24 +353,6 @@ public abstract class QueryParserBase extends QueryBuilder implements CommonQuer
     return resolution;
   }
 
  /**
   * Set whether or not to analyze range terms when constructing {@link TermRangeQuery}s.
   * For example, setting this to true can enable analyzing terms into 
   * collation keys for locale-sensitive {@link TermRangeQuery}.
   * 
   * @param analyzeRangeTerms whether or not terms should be analyzed for RangeQuerys
   */</comment>
  <function><type><specifier>public</specifier> <name>void</name></type> <name>setAnalyzeRangeTerms</name><parameter_list>(<parameter><decl><type><name>boolean</name></type> <name>analyzeRangeTerms</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><name><name>this</name><operator>.</operator><name>analyzeRangeTerms</name></name> <operator>=</operator> <name>analyzeRangeTerms</name></expr>;</expr_stmt>
  </block_content>}</block></function>

  <comment type="block" format="javadoc">/**
   * @return whether or not to analyze range terms when constructing {@link TermRangeQuery}s.
   */</comment>
  <function><type><specifier>public</specifier> <name>boolean</name></type> <name>getAnalyzeRangeTerms</name><parameter_list>()</parameter_list> <block>{<block_content>
    <return>return <expr><name>analyzeRangeTerms</name></expr>;</return>
  </block_content>}</block></function>

   <comment type="block" format="javadoc">/**
    * @param maxDeterminizedStates the maximum number of states that
    *   determinizing a regexp query can result in.  If the query results in any
@@ -558,12 +515,6 @@ public abstract class QueryParserBase extends QueryBuilder implements CommonQuer
                                 boolean startInclusive,
                                 boolean endInclusive) throws ParseException
   {
    if (lowercaseExpandedTerms) {
      part1 = part1==null ? null : part1.toLowerCase(locale);
      part2 = part2==null ? null : part2.toLowerCase(locale);
    }


     DateFormat df = DateFormat.getDateInstance(DateFormat.SHORT, locale);
     df.setLenient(true);
     DateTools.Resolution resolution = getDateResolution(field);
@@ -640,31 +591,6 @@ public abstract class QueryParserBase extends QueryBuilder implements CommonQuer
     return new FuzzyQuery(term,numEdits,prefixLength);
   }
 
  // TODO: Should this be protected instead?
  private BytesRef analyzeMultitermTerm(String field, String part) {
    return analyzeMultitermTerm(field, part, getAnalyzer());
  }

  protected BytesRef analyzeMultitermTerm(String field, String part, Analyzer analyzerIn) {
    if (analyzerIn == null) analyzerIn = getAnalyzer();

    try (TokenStream source = analyzerIn.tokenStream(field, part)) {
      source.reset();
      
      TermToBytesRefAttribute termAtt = source.getAttribute(TermToBytesRefAttribute.class);

      if (!source.incrementToken())
        throw new IllegalArgumentException("analyzer returned no terms for multiTerm term: " + part);
      BytesRef bytes = BytesRef.deepCopyOf(termAtt.getBytesRef());
      if (source.incrementToken())
        throw new IllegalArgumentException("analyzer returned too many terms for multiTerm term: " + part);
      source.end();
      return bytes;
    } catch (IOException e) {
      throw new RuntimeException("Error analyzing multiTerm term: " + part, e);
    }
  }

   /**
    * Builds a new {@link TermRangeQuery} instance
    * @param field Field
@@ -681,13 +607,13 @@ public abstract class QueryParserBase extends QueryBuilder implements CommonQuer
     if (part1 == null) {
       start = null;
     } else {
      start = analyzeRangeTerms ? analyzeMultitermTerm(field, part1) : new BytesRef(part1);
      start = getAnalyzer().normalize(field, part1);
     }
      
     if (part2 == null) {
       end = null;
     } else {
      end = analyzeRangeTerms ? analyzeMultitermTerm(field, part2) : new BytesRef(part2);
      end = getAnalyzer().normalize(field, part2);
     }
       
     final TermRangeQuery query = new TermRangeQuery(field, start, end, startInclusive, endInclusive);
@@ -767,13 +693,38 @@ public abstract class QueryParserBase extends QueryBuilder implements CommonQuer
     }
     if (!allowLeadingWildcard &amp;&amp; (termStr.startsWith("*") || termStr.startsWith("?")))
       throw new ParseException("'*' or '?' not allowed as first character in WildcardQuery");
    if (lowercaseExpandedTerms) {
      termStr = termStr.toLowerCase(locale);
    }
    Term t = new Term(field, termStr);

    Term t = new Term(field, analyzeWildcard(field, termStr));
     return newWildcardQuery(t);
   }
 
  private static final Pattern WILDCARD_PATTERN = Pattern.compile("(\\\\.)|([?*]+)");

  private BytesRef analyzeWildcard(String field, String termStr) {
    // best effort to not pass the wildcard characters and escaped characters through #normalize
    Matcher wildcardMatcher = WILDCARD_PATTERN.matcher(termStr);
    BytesRefBuilder sb = new BytesRefBuilder();
    int last = 0;

    while (wildcardMatcher.find()){
      if (wildcardMatcher.start() &gt; 0) {
        String chunk = termStr.substring(last, wildcardMatcher.start());
        BytesRef normalized = getAnalyzer().normalize(field, chunk);
        sb.append(normalized);
      }
      //append the matched group - without normalizing
      sb.append(new BytesRef(wildcardMatcher.group()));

      last = wildcardMatcher.end();
    }
    if (last &lt; termStr.length()){
      String chunk = termStr.substring(last);
      BytesRef normalized = getAnalyzer().normalize(field, chunk);
      sb.append(normalized);
    }
    return sb.toBytesRef();
  }

   /**
    * Factory method for generating a query. Called when parser
    * parses an input term token that contains a regular expression
@@ -796,10 +747,11 @@ public abstract class QueryParserBase extends QueryBuilder implements CommonQuer
    */</comment>
   <function><type><specifier>protected</specifier> <name>Query</name></type> <name>getRegexpQuery</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>field</name></decl></parameter>, <parameter><decl><type><name>String</name></type> <name>termStr</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>ParseException</name></expr></argument></throws>
   <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>lowercaseExpandedTerms</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>termStr</name> <operator>=</operator> <call><name><name>termStr</name><operator>.</operator><name>toLowerCase</name></name><argument_list>(<argument><expr><name>locale</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <decl_stmt><decl><type><name>Term</name></type> <name>t</name> <init>= <expr><operator>new</operator> <call><name>Term</name><argument_list>(<argument><expr><name>field</name></expr></argument>, <argument><expr><name>termStr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <comment type="line">// We need to pass the whole string to #normalize, which will not work with</comment>
    <comment type="line">// custom attribute factories for the binary term impl, and may not work</comment>
    <comment type="line">// with some analyzers</comment>
    <decl_stmt><decl><type><name>BytesRef</name></type> <name>term</name> <init>= <expr><call><name>getAnalyzer</name><argument_list>()</argument_list></call><operator>.</operator><call><name>normalize</name><argument_list>(<argument><expr><name>field</name></expr></argument>, <argument><expr><name>termStr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Term</name></type> <name>t</name> <init>= <expr><operator>new</operator> <call><name>Term</name><argument_list>(<argument><expr><name>field</name></expr></argument>, <argument><expr><name>term</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
     <return>return <expr><call><name>newRegexpQuery</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</return>
   </block_content>}</block></function>
 
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">830</literal></expr><operator>,</operator><expr><literal type="number">10</literal> <operator>+</operator><literal type="number">782</literal></expr><operator>,</operator><expr><literal type="number">8</literal> @@ <specifier>public</specifier> <specifier>abstract</specifier> <name>class</name> <name>QueryParserBase</name> extends <name>QueryBuilder</name> implements <name>CommonQuer</name>
   <block>{
     <if_stmt><if>if <condition>(<expr><operator>!</operator><name>allowLeadingWildcard</name> <operator>&amp;&amp;</operator> <call><name><name>termStr</name><operator>.</operator><name>startsWith</name></name><argument_list>(<argument><expr><literal type="string">"*"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
       <throw>throw <expr><operator>new</operator> <call><name>ParseException</name><argument_list>(<argument><expr><literal type="string">"'*' not allowed as first character in PrefixQuery"</literal></expr></argument>)</argument_list></call></expr>;</throw></block_content></block></if></if_stmt></block></expr></expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>lowercaseExpandedTerms</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>termStr</name> <operator>=</operator> <call><name><name>termStr</name><operator>.</operator><name>toLowerCase</name></name><argument_list>(<argument><expr><name>locale</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <decl_stmt><decl><type><name>Term</name></type> <name>t</name> <init>= <expr><operator>new</operator> <call><name>Term</name><argument_list>(<argument><expr><name>field</name></expr></argument>, <argument><expr><name>termStr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BytesRef</name></type> <name>term</name> <init>= <expr><call><name>getAnalyzer</name><argument_list>()</argument_list></call><operator>.</operator><call><name>normalize</name><argument_list>(<argument><expr><name>field</name></expr></argument>, <argument><expr><name>termStr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Term</name></type> <name>t</name> <init>= <expr><operator>new</operator> <call><name>Term</name><argument_list>(<argument><expr><name>field</name></expr></argument>, <argument><expr><name>term</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
     <return>return <expr><call><name>newPrefixQuery</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</return>
   }
 
@<annotation>@</annotation> -<expr_stmt><expr><literal type="number">850</literal></expr><operator>,</operator><expr><literal type="number">10</literal> <operator>+</operator><literal type="number">800</literal></expr><operator>,</operator><expr><literal type="number">8</literal> @@ <specifier>public</specifier> <specifier>abstract</specifier> <name>class</name> <name>QueryParserBase</name> extends <name>QueryBuilder</name> implements <name>CommonQuer</name>
    <operator>*</operator><operator>/</operator>
   <specifier>protected</specifier> <name>Query</name> <call><name>getFuzzyQuery</name><argument_list>(<argument><expr><name>String</name> <name>field</name></expr></argument>, <argument><expr><name>String</name> <name>termStr</name></expr></argument>, <argument><expr><name>float</name> <name>minSimilarity</name></expr></argument>)</argument_list></call> <throws>throws <argument><expr><name>ParseException</name>
   <block>{</block></expr></argument></throws></expr></expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>lowercaseExpandedTerms</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>termStr</name> <operator>=</operator> <call><name><name>termStr</name><operator>.</operator><name>toLowerCase</name></name><argument_list>(<argument><expr><name>locale</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <decl_stmt><decl><type><name>Term</name></type> <name>t</name> <init>= <expr><operator>new</operator> <call><name>Term</name><argument_list>(<argument><expr><name>field</name></expr></argument>, <argument><expr><name>termStr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BytesRef</name></type> <name>term</name> <init>= <expr><call><name>getAnalyzer</name><argument_list>()</argument_list></call><operator>.</operator><call><name>normalize</name><argument_list>(<argument><expr><name>field</name></expr></argument>, <argument><expr><name>termStr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Term</name></type> <name>t</name> <init>= <expr><operator>new</operator> <call><name>Term</name><argument_list>(<argument><expr><name>field</name></expr></argument>, <argument><expr><name>term</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
     <return>return <expr><call><name>newFuzzyQuery</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>minSimilarity</name></expr></argument>, <argument><expr><name>fuzzyPrefixLength</name></expr></argument>)</argument_list></call></expr>;</return>
   }
 
diff <expr_stmt><expr><operator>--</operator><name>git</name> <name>a</name><operator>/</operator><name>lucene</name><operator>/</operator><name>queryparser</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>queryparser</name><operator>/</operator><name>complexPhrase</name><operator>/</operator><name><name>ComplexPhraseQueryParser</name><operator>.</operator><name>java</name></name> <name>b</name><operator>/</operator><name>lucene</name><operator>/</operator><name>queryparser</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>queryparser</name><operator>/</operator><name>complexPhrase</name><operator>/</operator><name><name>ComplexPhraseQueryParser</name><operator>.</operator><name>java</name></name>
<name>index</name> <name>ac808d7a364</name><operator>..</operator><literal type="number">1a7e5e108c1</literal> <literal type="number">100644</literal>
<operator>--</operator> <name>a</name><operator>/</operator><name>lucene</name><operator>/</operator><name>queryparser</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>queryparser</name><operator>/</operator><name>complexPhrase</name><operator>/</operator><name><name>ComplexPhraseQueryParser</name><operator>.</operator><name>java</name></name>
<operator>++</operator> <name>b</name><operator>/</operator><name>lucene</name><operator>/</operator><name>queryparser</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>queryparser</name><operator>/</operator><name>complexPhrase</name><operator>/</operator><name><name>ComplexPhraseQueryParser</name><operator>.</operator><name>java</name></name>
@@ <operator>-</operator><literal type="number">33</literal></expr><operator>,</operator><expr><literal type="number">9</literal> <operator>+</operator><literal type="number">33</literal></expr><operator>,</operator><expr><literal type="number">9</literal> @@</expr></expr_stmt> <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>search</name><operator>.</operator><name>BoostQuery</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>search</name><operator>.</operator><name>IndexSearcher</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>search</name><operator>.</operator><name>MatchNoDocsQuery</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>search</name><operator>.</operator><name>MultiTermQuery</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>search</name><operator>.</operator><name>MultiTermQuery</name><operator>.</operator><name>RewriteMethod</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>search</name><operator>.</operator><name>Query</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>search</name><operator>.</operator><name>TermQuery</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>search</name><operator>.</operator><name>TermRangeQuery</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>search</name><operator>.</operator><name>spans</name><operator>.</operator><name>SpanBoostQuery</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>search</name><operator>.</operator><name>spans</name><operator>.</operator><name>SpanNearQuery</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>search</name><operator>.</operator><name>spans</name><operator>.</operator><name>SpanNotQuery</name></name>;</import>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">186</literal></expr><operator>,</operator><expr><literal type="number">14</literal> <operator>+</operator><literal type="number">186</literal></expr><operator>,</operator><expr><literal type="number">15</literal> @@ <specifier>public</specifier> <name>class</name> <name>ComplexPhraseQueryParser</name> extends <name>QueryParser</name> <block>{
   @<expr><name>Override</name>
   <specifier>protected</specifier> <name>Query</name> <call><name>newRangeQuery</name><argument_list>(<argument><expr><name>String</name> <name>field</name></expr></argument>, <argument><expr><name>String</name> <name>part1</name></expr></argument>, <argument><expr><name>String</name> <name>part2</name></expr></argument>,
       <argument><expr><name>boolean</name> <name>startInclusive</name></expr></argument>, <argument><expr><name>boolean</name> <name>endInclusive</name></expr></argument>)</argument_list></call> <block>{
    <if_stmt><if>if <condition>(<expr><name>isPass2ResolvingPhrases</name></expr>)</condition> <block>{<block_content>
      <comment type="line">// Must use old-style RangeQuery in order to produce a BooleanQuery</comment>
      <comment type="line">// that can be turned into SpanOr clause</comment>
      <decl_stmt><decl><type><name>TermRangeQuery</name></type> <name>rangeQuery</name> <init>= <expr><call><name><name>TermRangeQuery</name><operator>.</operator><name>newStringRange</name></name><argument_list>(<argument><expr><name>field</name></expr></argument>, <argument><expr><name>part1</name></expr></argument>, <argument><expr><name>part2</name></expr></argument>, <argument><expr><name>startInclusive</name></expr></argument>, <argument><expr><name>endInclusive</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name><name>rangeQuery</name><operator>.</operator><name>setRewriteMethod</name></name><argument_list>(<argument><expr><name><name>MultiTermQuery</name><operator>.</operator><name>SCORING_BOOLEAN_REWRITE</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>rangeQuery</name></expr>;</return>
    <decl_stmt><decl><type><name>RewriteMethod</name></type> <name>originalRewriteMethod</name> <init>= <expr><call><name>getMultiTermRewriteMethod</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <try>try <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>isPass2ResolvingPhrases</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>setMultiTermRewriteMethod</name><argument_list>(<argument><expr><name><name>MultiTermQuery</name><operator>.</operator><name>SCORING_BOOLEAN_REWRITE</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt/></block_content></block></if></if_stmt></block_content></block></try></block_content></block></if></if_stmt>}</block></expr>
      <return>return <expr><call><name><name>super</name><operator>.</operator><name>newRangeQuery</name></name><argument_list>(<argument><expr><name>field</name></expr></argument>, <argument><expr><name>part1</name></expr></argument>, <argument><expr><name>part2</name></expr></argument>, <argument><expr><name>startInclusive</name></expr></argument>, <argument><expr><name>endInclusive</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></expr></expr_stmt> <finally>finally <block>{<block_content>
      <expr_stmt><expr><call><name>setMultiTermRewriteMethod</name><argument_list>(<argument><expr><name>originalRewriteMethod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
     </block_content>}</block></finally>
    <return>return <expr><call><name><name>super</name><operator>.</operator><name>newRangeQuery</name></name><argument_list>(<argument><expr><name>field</name></expr></argument>, <argument><expr><name>part1</name></expr></argument>, <argument><expr><name>part2</name></expr></argument>, <argument><expr><name>startInclusive</name></expr></argument>, <argument><expr><name>endInclusive</name></expr></argument>)</argument_list></call></expr>;</return>
   }
 
   @<expr_stmt><expr><name>Override</name>
<name>diff</name> <operator>--</operator><name>git</name> <name>a</name><operator>/</operator><name>lucene</name><operator>/</operator><name>queryparser</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>queryparser</name><operator>/</operator><name>flexible</name><operator>/</operator><name>standard</name><operator>/</operator><name><name>CommonQueryParserConfiguration</name><operator>.</operator><name>java</name></name> <name>b</name><operator>/</operator><name>lucene</name><operator>/</operator><name>queryparser</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>queryparser</name><operator>/</operator><name>flexible</name><operator>/</operator><name>standard</name><operator>/</operator><name><name>CommonQueryParserConfiguration</name><operator>.</operator><name>java</name></name>
<name>index</name> <literal type="number">55e43cd1f65</literal><operator>..</operator><name>c44e9e0e651</name> <literal type="number">100644</literal>
<operator>--</operator> <name>a</name><operator>/</operator><name>lucene</name><operator>/</operator><name>queryparser</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>queryparser</name><operator>/</operator><name>flexible</name><operator>/</operator><name>standard</name><operator>/</operator><name><name>CommonQueryParserConfiguration</name><operator>.</operator><name>java</name></name>
<operator>++</operator> <name>b</name><operator>/</operator><name>lucene</name><operator>/</operator><name>queryparser</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>queryparser</name><operator>/</operator><name>flexible</name><operator>/</operator><name>standard</name><operator>/</operator><name><name>CommonQueryParserConfiguration</name><operator>.</operator><name>java</name></name>
@@ <operator>-</operator><literal type="number">31</literal></expr><operator>,</operator><expr><literal type="number">18</literal> <operator>+</operator><literal type="number">31</literal></expr><operator>,</operator><expr><literal type="number">6</literal> @@</expr></expr_stmt> <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>search</name><operator>.</operator><name>MultiTermQuery</name></name>;</import>
  <expr_stmt><expr><operator>*</operator><operator>/</operator>
 <specifier>public</specifier> interface <name>CommonQueryParserConfiguration</name> <block>{
   
  <comment type="block" format="javadoc">/**
   * Whether terms of multi-term queries (e.g., wildcard,
   * prefix, fuzzy and range) should be automatically
   * lower-cased or not.  Default is &lt;code&gt;true&lt;/code&gt;.
   */</comment>
  <expr><specifier>public</specifier> <name>void</name> <call><name>setLowercaseExpandedTerms</name><argument_list>(<argument><expr><name>boolean</name> <name>lowercaseExpandedTerms</name></expr></argument>)</argument_list></call></expr>;
  
  <comment type="block" format="javadoc">/**
   * @see #setLowercaseExpandedTerms(boolean)
   */</comment>
  <expr><specifier>public</specifier> <name>boolean</name> <call><name>getLowercaseExpandedTerms</name><argument_list>()</argument_list></call></expr>;
  
   <comment type="block" format="javadoc">/**
    * Set to &lt;code&gt;true&lt;/code&gt; to allow leading wildcard characters.
    * &lt;p&gt;
diff --git a/lucene/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/StandardQueryParser.java b/lucene/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/StandardQueryParser.java
index 2cd8084e809..32cbd0233b3 100644
-- a/lucene/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/StandardQueryParser.java
++ b/lucene/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/StandardQueryParser.java
@@ -180,36 +180,6 @@ public class StandardQueryParser extends QueryParserHelper implements CommonQuer
     getQueryConfigHandler().set(ConfigurationKeys.DEFAULT_OPERATOR, operator);
   }
   
  /**
   * Set to &lt;code&gt;true&lt;/code&gt; to allow leading wildcard characters.
   * &lt;p&gt;
   * When set, &lt;code&gt;*&lt;/code&gt; or &lt;code&gt;?&lt;/code&gt; are allowed as the first
   * character of a PrefixQuery and WildcardQuery. Note that this can produce
   * very slow queries on big indexes.
   * &lt;p&gt;
   * Default: false.
   */</comment>
  @<expr><name>Override</name>
  <specifier>public</specifier> <name>void</name> <call><name>setLowercaseExpandedTerms</name><argument_list>(<argument><expr><name>boolean</name> <name>lowercaseExpandedTerms</name></expr></argument>)</argument_list></call> <block>{
    <expr><call><name>getQueryConfigHandler</name><argument_list>()</argument_list></call><operator>.</operator><call><name>set</name><argument_list>(<argument><expr><name><name>ConfigurationKeys</name><operator>.</operator><name>LOWERCASE_EXPANDED_TERMS</name></name></expr></argument>, <argument><expr><name>lowercaseExpandedTerms</name></expr></argument>)</argument_list></call></expr>;
  }</block>
  
  <comment type="block" format="javadoc">/**
   * @see #setLowercaseExpandedTerms(boolean)
   */</comment>
  @<name>Override</name>
  <specifier>public</specifier> <name>boolean</name> <call><name>getLowercaseExpandedTerms</name><argument_list>()</argument_list></call> <block>{
    <expr><name>Boolean</name> <name>lowercaseExpandedTerms</name> <operator>=</operator> <call><name>getQueryConfigHandler</name><argument_list>()</argument_list></call><operator>.</operator><call><name>get</name><argument_list>(<argument><expr><name><name>ConfigurationKeys</name><operator>.</operator><name>LOWERCASE_EXPANDED_TERMS</name></name></expr></argument>)</argument_list></call></expr>;
    
    <if_stmt><if>if <condition>(<expr><name>lowercaseExpandedTerms</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
      <return>return <expr><literal type="boolean">true</literal></expr>;</return>
      
    <expr_stmt/></block_content></block></if></if_stmt>}</block></expr> <if_stmt><else>else <block>{<block_content>
      <return>return <expr><name>lowercaseExpandedTerms</name></expr>;</return>
    <expr_stmt/></block_content></block></else></if_stmt>}</block></expr></expr_stmt>
    
  }
  
   <comment type="block" format="javadoc">/**
    * Set to &lt;code&gt;true&lt;/code&gt; to allow leading wildcard characters.
    * &lt;p&gt;
diff --git a/lucene/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/config/StandardQueryConfigHandler.java b/lucene/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/config/StandardQueryConfigHandler.java
index bba95eed91f..5c53d02f2ed 100644
-- a/lucene/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/config/StandardQueryConfigHandler.java
++ b/lucene/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/config/StandardQueryConfigHandler.java
@@ -55,14 +55,6 @@ public class StandardQueryConfigHandler extends QueryConfigHandler {
      * @see StandardQueryParser#getEnablePositionIncrements()
      */</comment>
     final <decl_stmt><decl><type><specifier>public</specifier> <specifier>static</specifier> <name><name>ConfigurationKey</name><argument_list type="generic">&lt;<argument><name>Boolean</name></argument>&gt;</argument_list></name></type> <name>ENABLE_POSITION_INCREMENTS</name> <init>= <expr><call><name><name>ConfigurationKey</name><operator>.</operator><name>newInstance</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    
    <comment type="block" format="javadoc">/**
     * Key used to set whether expanded terms should be lower-cased
     * 
     * @see StandardQueryParser#setLowercaseExpandedTerms(boolean)
     * @see StandardQueryParser#getLowercaseExpandedTerms()
     */</comment>
    <decl_stmt><decl><type><specifier>final</specifier> <specifier>public</specifier> <specifier>static</specifier> <name><name>ConfigurationKey</name><argument_list type="generic">&lt;<argument><name>Boolean</name></argument>&gt;</argument_list></name></type> <name>LOWERCASE_EXPANDED_TERMS</name> <init>= <expr><call><name><name>ConfigurationKey</name><operator>.</operator><name>newInstance</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
 
     <comment type="block" format="javadoc">/**
      * Key used to set whether leading wildcards are supported
@@ -223,7 +215,6 @@ public class StandardQueryConfigHandler extends QueryConfigHandler {
     set(ConfigurationKeys.ANALYZER, null); //default value 2.4
     set(ConfigurationKeys.DEFAULT_OPERATOR, Operator.OR);
     set(ConfigurationKeys.PHRASE_SLOP, 0); //default value 2.4
    set(ConfigurationKeys.LOWERCASE_EXPANDED_TERMS, true); //default value 2.4
     set(ConfigurationKeys.ENABLE_POSITION_INCREMENTS, false); //default value 2.4
     set(ConfigurationKeys.FIELD_BOOST_MAP, new LinkedHashMap&lt;String, Float&gt;());
     set(ConfigurationKeys.FUZZY_CONFIG, new FuzzyConfig());
diff --git a/lucene/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/processors/FuzzyQueryNodeProcessor.java b/lucene/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/processors/FuzzyQueryNodeProcessor.java
index 0b8a9a72c29..9479fcf65a3 100644
-- a/lucene/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/processors/FuzzyQueryNodeProcessor.java
++ b/lucene/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/processors/FuzzyQueryNodeProcessor.java
@@ -18,6 +18,7 @@ package org.apache.lucene.queryparser.flexible.standard.processors;
 
 import java.util.List;
 
import org.apache.lucene.analysis.Analyzer;
 import org.apache.lucene.queryparser.flexible.core.QueryNodeException;
 import org.apache.lucene.queryparser.flexible.core.config.QueryConfigHandler;
 import org.apache.lucene.queryparser.flexible.core.nodes.FuzzyQueryNode;
@@ -55,9 +56,17 @@ public class FuzzyQueryNodeProcessor extends QueryNodeProcessorImpl {
       FuzzyQueryNode fuzzyNode = (FuzzyQueryNode) node;
       QueryConfigHandler config = getQueryConfigHandler();
 
      Analyzer analyzer = getQueryConfigHandler().get(ConfigurationKeys.ANALYZER);
      if (analyzer != null) {
        // because we call utf8ToString, this will only work with the default TermToBytesRefAttribute
        String text = fuzzyNode.getTextAsString();
        text = analyzer.normalize(fuzzyNode.getFieldAsString(), text).utf8ToString();
        fuzzyNode.setText(text);
      }

       FuzzyConfig fuzzyConfig = null;
       
      if (config != null &amp;&amp; (fuzzyConfig = config.get(ConfigurationKeys.FUZZY_CONFIG)) != null) {
      if ((fuzzyConfig = config.get(ConfigurationKeys.FUZZY_CONFIG)) != null) {
         fuzzyNode.setPrefixLength(fuzzyConfig.getPrefixLength());
 
         if (fuzzyNode.getSimilarity() &lt; 0) {
diff --git a/lucene/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/processors/LowercaseExpandedTermsQueryNodeProcessor.java b/lucene/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/processors/LowercaseExpandedTermsQueryNodeProcessor.java
deleted file mode 100644
index 3bb207584bb..00000000000
-- a/lucene/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/processors/LowercaseExpandedTermsQueryNodeProcessor.java
++ /dev/null
@@ -1,100 +0,0 @@
/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</comment>
<package>package <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>queryparser</name><operator>.</operator><name>flexible</name><operator>.</operator><name>standard</name><operator>.</operator><name>processors</name></name>;</package>

<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>List</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>Locale</name></name>;</import>

<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>queryparser</name><operator>.</operator><name>flexible</name><operator>.</operator><name>core</name><operator>.</operator><name>QueryNodeException</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>queryparser</name><operator>.</operator><name>flexible</name><operator>.</operator><name>core</name><operator>.</operator><name>config</name><operator>.</operator><name>QueryConfigHandler</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>queryparser</name><operator>.</operator><name>flexible</name><operator>.</operator><name>core</name><operator>.</operator><name>nodes</name><operator>.</operator><name>FieldQueryNode</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>queryparser</name><operator>.</operator><name>flexible</name><operator>.</operator><name>core</name><operator>.</operator><name>nodes</name><operator>.</operator><name>FuzzyQueryNode</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>queryparser</name><operator>.</operator><name>flexible</name><operator>.</operator><name>core</name><operator>.</operator><name>nodes</name><operator>.</operator><name>QueryNode</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>queryparser</name><operator>.</operator><name>flexible</name><operator>.</operator><name>core</name><operator>.</operator><name>nodes</name><operator>.</operator><name>RangeQueryNode</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>queryparser</name><operator>.</operator><name>flexible</name><operator>.</operator><name>core</name><operator>.</operator><name>nodes</name><operator>.</operator><name>TextableQueryNode</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>queryparser</name><operator>.</operator><name>flexible</name><operator>.</operator><name>core</name><operator>.</operator><name>processors</name><operator>.</operator><name>QueryNodeProcessorImpl</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>queryparser</name><operator>.</operator><name>flexible</name><operator>.</operator><name>core</name><operator>.</operator><name>util</name><operator>.</operator><name>UnescapedCharSequence</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>queryparser</name><operator>.</operator><name>flexible</name><operator>.</operator><name>standard</name><operator>.</operator><name>config</name><operator>.</operator><name>StandardQueryConfigHandler</name><operator>.</operator><name>ConfigurationKeys</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>queryparser</name><operator>.</operator><name>flexible</name><operator>.</operator><name>standard</name><operator>.</operator><name>nodes</name><operator>.</operator><name>RegexpQueryNode</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>queryparser</name><operator>.</operator><name>flexible</name><operator>.</operator><name>standard</name><operator>.</operator><name>nodes</name><operator>.</operator><name>WildcardQueryNode</name></name>;</import>

<comment type="block" format="javadoc">/**
 * This processor verifies if 
 * {@link ConfigurationKeys#LOWERCASE_EXPANDED_TERMS} is defined in the
 * {@link QueryConfigHandler}. If it is and the expanded terms should be
 * lower-cased, it looks for every {@link WildcardQueryNode},
 * {@link FuzzyQueryNode} and children of a {@link RangeQueryNode} and lower-case its
 * term.
 * 
 * @see ConfigurationKeys#LOWERCASE_EXPANDED_TERMS
 */</comment>
<class><specifier>public</specifier> class <name>LowercaseExpandedTermsQueryNodeProcessor</name> <super_list><extends>extends
    <super><name>QueryNodeProcessorImpl</name></super></extends></super_list> <block>{

  <constructor><specifier>public</specifier> <name>LowercaseExpandedTermsQueryNodeProcessor</name><parameter_list>()</parameter_list> <block>{<block_content>
  </block_content>}</block></constructor>

  <function><annotation>@<name>Override</name></annotation>
  <type><specifier>public</specifier> <name>QueryNode</name></type> <name>process</name><parameter_list>(<parameter><decl><type><name>QueryNode</name></type> <name>queryTree</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>QueryNodeException</name></expr></argument></throws> <block>{<block_content>
    <decl_stmt><decl><type><name>Boolean</name></type> <name>lowercaseExpandedTerms</name> <init>= <expr><call><name>getQueryConfigHandler</name><argument_list>()</argument_list></call><operator>.</operator><call><name>get</name><argument_list>(<argument><expr><name><name>ConfigurationKeys</name><operator>.</operator><name>LOWERCASE_EXPANDED_TERMS</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>lowercaseExpandedTerms</name> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <name>lowercaseExpandedTerms</name></expr>)</condition> <block>{<block_content>
      <return>return <expr><call><name><name>super</name><operator>.</operator><name>process</name></name><argument_list>(<argument><expr><name>queryTree</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>queryTree</name></expr>;</return>

  </block_content>}</block></function>

  <function><annotation>@<name>Override</name></annotation>
  <type><specifier>protected</specifier> <name>QueryNode</name></type> <name>postProcessNode</name><parameter_list>(<parameter><decl><type><name>QueryNode</name></type> <name>node</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>QueryNodeException</name></expr></argument></throws> <block>{<block_content>
    
    <decl_stmt><decl><type><name>Locale</name></type> <name>locale</name> <init>= <expr><call><name>getQueryConfigHandler</name><argument_list>()</argument_list></call><operator>.</operator><call><name>get</name><argument_list>(<argument><expr><name><name>ConfigurationKeys</name><operator>.</operator><name>LOCALE</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>locale</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>locale</name> <operator>=</operator> <call><name><name>Locale</name><operator>.</operator><name>getDefault</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>node</name> <operator>instanceof</operator> <name>WildcardQueryNode</name>
        <operator>||</operator> <name>node</name> <operator>instanceof</operator> <name>FuzzyQueryNode</name>
        <operator>||</operator> <operator>(</operator><name>node</name> <operator>instanceof</operator> <name>FieldQueryNode</name> <operator>&amp;&amp;</operator> <call><name><name>node</name><operator>.</operator><name>getParent</name></name><argument_list>()</argument_list></call> <operator>instanceof</operator> <name>RangeQueryNode</name><operator>)</operator>
        <operator>||</operator> <name>node</name> <operator>instanceof</operator> <name>RegexpQueryNode</name></expr>)</condition> <block>{<block_content>

      <decl_stmt><decl><type><name>TextableQueryNode</name></type> <name>txtNode</name> <init>= <expr><operator>(</operator><name>TextableQueryNode</name><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>CharSequence</name></type> <name>text</name> <init>= <expr><call><name><name>txtNode</name><operator>.</operator><name>getText</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name><name>txtNode</name><operator>.</operator><name>setText</name></name><argument_list>(<argument><expr><ternary><condition><expr><name>text</name> <operator>!=</operator> <literal type="null">null</literal></expr> ?</condition><then> <expr><call><name><name>UnescapedCharSequence</name><operator>.</operator><name>toLowerCase</name></name><argument_list>(<argument><expr><name>text</name></expr></argument>, <argument><expr><name>locale</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="null">null</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>node</name></expr>;</return>

  </block_content>}</block></function>

  <function><annotation>@<name>Override</name></annotation>
  <type><specifier>protected</specifier> <name>QueryNode</name></type> <name>preProcessNode</name><parameter_list>(<parameter><decl><type><name>QueryNode</name></type> <name>node</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>QueryNodeException</name></expr></argument></throws> <block>{<block_content>

    <return>return <expr><name>node</name></expr>;</return>

  </block_content>}</block></function>

  <function><annotation>@<name>Override</name></annotation>
  <type><specifier>protected</specifier> <name><name>List</name><argument_list type="generic">&lt;<argument><name>QueryNode</name></argument>&gt;</argument_list></name></type> <name>setChildrenOrder</name><parameter_list>(<parameter><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name>QueryNode</name></argument>&gt;</argument_list></name></type> <name>children</name></decl></parameter>)</parameter_list>
      <throws>throws <argument><expr><name>QueryNodeException</name></expr></argument></throws> <block>{<block_content>

    <return>return <expr><name>children</name></expr>;</return>

  </block_content>}</block></function>

}</block></class>
<expr_stmt><expr><name>diff</name> <operator>--</operator><name>git</name> <name>a</name><operator>/</operator><name>lucene</name><operator>/</operator><name>queryparser</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>queryparser</name><operator>/</operator><name>flexible</name><operator>/</operator><name>standard</name><operator>/</operator><name>processors</name><operator>/</operator><name><name>RegexpQueryNodeProcessor</name><operator>.</operator><name>java</name></name> <name>b</name><operator>/</operator><name>lucene</name><operator>/</operator><name>queryparser</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>queryparser</name><operator>/</operator><name>flexible</name><operator>/</operator><name>standard</name><operator>/</operator><name>processors</name><operator>/</operator><name><name>RegexpQueryNodeProcessor</name><operator>.</operator><name>java</name></name>
<operator>new</operator> <name>file</name> <name>mode</name> <literal type="number">100644</literal>
<name>index</name> <literal type="number">00000000000..652de875861</literal>
<operator>--</operator> <operator>/</operator><name>dev</name><operator>/</operator><literal type="null">null</literal>
<operator>++</operator> <name>b</name><operator>/</operator><name>lucene</name><operator>/</operator><name>queryparser</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>queryparser</name><operator>/</operator><name>flexible</name><operator>/</operator><name>standard</name><operator>/</operator><name>processors</name><operator>/</operator><name><name>RegexpQueryNodeProcessor</name><operator>.</operator><name>java</name></name>
@@ <operator>-</operator><literal type="number">0</literal></expr><operator>,</operator><expr><literal type="number">0</literal> <operator>+</operator><literal type="number">1</literal></expr><operator>,</operator><expr><literal type="number">56</literal> @@</expr></expr_stmt>
<comment type="block">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</comment>
<package>package <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>queryparser</name><operator>.</operator><name>flexible</name><operator>.</operator><name>standard</name><operator>.</operator><name>processors</name></name>;</package>

<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>List</name></name>;</import>

<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>analysis</name><operator>.</operator><name>Analyzer</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>queryparser</name><operator>.</operator><name>flexible</name><operator>.</operator><name>core</name><operator>.</operator><name>QueryNodeException</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>queryparser</name><operator>.</operator><name>flexible</name><operator>.</operator><name>core</name><operator>.</operator><name>nodes</name><operator>.</operator><name>QueryNode</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>queryparser</name><operator>.</operator><name>flexible</name><operator>.</operator><name>core</name><operator>.</operator><name>processors</name><operator>.</operator><name>QueryNodeProcessorImpl</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>queryparser</name><operator>.</operator><name>flexible</name><operator>.</operator><name>standard</name><operator>.</operator><name>config</name><operator>.</operator><name>StandardQueryConfigHandler</name><operator>.</operator><name>ConfigurationKeys</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>queryparser</name><operator>.</operator><name>flexible</name><operator>.</operator><name>standard</name><operator>.</operator><name>nodes</name><operator>.</operator><name>RegexpQueryNode</name></name>;</import>

<comment type="block" format="javadoc">/** Processor for Regexp queries. */</comment>
<class><specifier>public</specifier> class <name>RegexpQueryNodeProcessor</name> <super_list><extends>extends <super><name>QueryNodeProcessorImpl</name></super></extends></super_list> <block>{

  <function><annotation>@<name>Override</name></annotation>
  <type><specifier>protected</specifier> <name>QueryNode</name></type> <name>preProcessNode</name><parameter_list>(<parameter><decl><type><name>QueryNode</name></type> <name>node</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>QueryNodeException</name></expr></argument></throws> <block>{<block_content>
    <return>return <expr><name>node</name></expr>;</return>
  </block_content>}</block></function>

  <function><annotation>@<name>Override</name></annotation>
  <type><specifier>protected</specifier> <name>QueryNode</name></type> <name>postProcessNode</name><parameter_list>(<parameter><decl><type><name>QueryNode</name></type> <name>node</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>QueryNodeException</name></expr></argument></throws> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>node</name> <operator>instanceof</operator> <name>RegexpQueryNode</name></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>RegexpQueryNode</name></type> <name>regexpNode</name> <init>= <expr><operator>(</operator><name>RegexpQueryNode</name><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>Analyzer</name></type> <name>analyzer</name> <init>= <expr><call><name>getQueryConfigHandler</name><argument_list>()</argument_list></call><operator>.</operator><call><name>get</name><argument_list>(<argument><expr><name><name>ConfigurationKeys</name><operator>.</operator><name>ANALYZER</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><name>analyzer</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>String</name></type> <name>text</name> <init>= <expr><call><name><name>regexpNode</name><operator>.</operator><name>getText</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>toString</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <comment type="line">// because we call utf8ToString, this will only work with the default TermToBytesRefAttribute</comment>
        <expr_stmt><expr><name>text</name> <operator>=</operator> <call><name><name>analyzer</name><operator>.</operator><name>normalize</name></name><argument_list>(<argument><expr><call><name><name>regexpNode</name><operator>.</operator><name>getFieldAsString</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>text</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>utf8ToString</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>regexpNode</name><operator>.</operator><name>setText</name></name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>node</name></expr>;</return>
  </block_content>}</block></function>

  <function><annotation>@<name>Override</name></annotation>
  <type><specifier>protected</specifier> <name><name>List</name><argument_list type="generic">&lt;<argument><name>QueryNode</name></argument>&gt;</argument_list></name></type> <name>setChildrenOrder</name><parameter_list>(<parameter><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name>QueryNode</name></argument>&gt;</argument_list></name></type> <name>children</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>QueryNodeException</name></expr></argument></throws> <block>{<block_content>
    <return>return <expr><name>children</name></expr>;</return>
  </block_content>}</block></function>

}</block></class>
<expr_stmt><expr><name>diff</name> <operator>--</operator><name>git</name> <name>a</name><operator>/</operator><name>lucene</name><operator>/</operator><name>queryparser</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>queryparser</name><operator>/</operator><name>flexible</name><operator>/</operator><name>standard</name><operator>/</operator><name>processors</name><operator>/</operator><name><name>StandardQueryNodeProcessorPipeline</name><operator>.</operator><name>java</name></name> <name>b</name><operator>/</operator><name>lucene</name><operator>/</operator><name>queryparser</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>queryparser</name><operator>/</operator><name>flexible</name><operator>/</operator><name>standard</name><operator>/</operator><name>processors</name><operator>/</operator><name><name>StandardQueryNodeProcessorPipeline</name><operator>.</operator><name>java</name></name>
<name>index</name> <literal type="number">38a9a4715c0</literal><operator>..</operator><literal type="number">5b681b41931</literal> <literal type="number">100644</literal>
<operator>--</operator> <name>a</name><operator>/</operator><name>lucene</name><operator>/</operator><name>queryparser</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>queryparser</name><operator>/</operator><name>flexible</name><operator>/</operator><name>standard</name><operator>/</operator><name>processors</name><operator>/</operator><name><name>StandardQueryNodeProcessorPipeline</name><operator>.</operator><name>java</name></name>
<operator>++</operator> <name>b</name><operator>/</operator><name>lucene</name><operator>/</operator><name>queryparser</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>queryparser</name><operator>/</operator><name>flexible</name><operator>/</operator><name>standard</name><operator>/</operator><name>processors</name><operator>/</operator><name><name>StandardQueryNodeProcessorPipeline</name><operator>.</operator><name>java</name></name>
@@ <operator>-</operator><literal type="number">47</literal></expr><operator>,</operator><expr><literal type="number">16</literal> <operator>+</operator><literal type="number">47</literal></expr><operator>,</operator><expr><literal type="number">16</literal> @@ <specifier>public</specifier> <name>class</name> <name>StandardQueryNodeProcessorPipeline</name> extends
   <specifier>public</specifier> <call><name>StandardQueryNodeProcessorPipeline</name><argument_list>(<argument><expr><name>QueryConfigHandler</name> <name>queryConfig</name></expr></argument>)</argument_list></call> <block>{
     <expr><call><name>super</name><argument_list>(<argument><expr><name>queryConfig</name></expr></argument>)</argument_list></call></expr>;
 
    <expr><call><name>add</name><argument_list>(<argument><expr><operator>new</operator> <call><name>WildcardQueryNodeProcessor</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;    
    <expr><call><name>add</name><argument_list>(<argument><expr><operator>new</operator> <call><name>WildcardQueryNodeProcessor</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;   
     <expr><call><name>add</name><argument_list>(<argument><expr><operator>new</operator> <call><name>MultiFieldQueryNodeProcessor</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
     <expr><call><name>add</name><argument_list>(<argument><expr><operator>new</operator> <call><name>FuzzyQueryNodeProcessor</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
    <expr><call><name>add</name><argument_list>(<argument><expr><operator>new</operator> <call><name>RegexpQueryNodeProcessor</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
     <expr><call><name>add</name><argument_list>(<argument><expr><operator>new</operator> <call><name>MatchAllDocsQueryNodeProcessor</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
     <expr><call><name>add</name><argument_list>(<argument><expr><operator>new</operator> <call><name>OpenRangeQueryNodeProcessor</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
     <expr><call><name>add</name><argument_list>(<argument><expr><operator>new</operator> <call><name>LegacyNumericQueryNodeProcessor</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
     <expr><call><name>add</name><argument_list>(<argument><expr><operator>new</operator> <call><name>LegacyNumericRangeQueryNodeProcessor</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
     <expr><call><name>add</name><argument_list>(<argument><expr><operator>new</operator> <call><name>PointQueryNodeProcessor</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
     <expr><call><name>add</name><argument_list>(<argument><expr><operator>new</operator> <call><name>PointRangeQueryNodeProcessor</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
    <expr><call><name>add</name><argument_list>(<argument><expr><operator>new</operator> <call><name>LowercaseExpandedTermsQueryNodeProcessor</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
     <expr><call><name>add</name><argument_list>(<argument><expr><operator>new</operator> <call><name>TermRangeQueryNodeProcessor</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
     <expr><call><name>add</name><argument_list>(<argument><expr><operator>new</operator> <call><name>AllowLeadingWildcardProcessor</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;    
     <expr><call><name>add</name><argument_list>(<argument><expr><operator>new</operator> <call><name>AnalyzerQueryNodeProcessor</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><name>diff</name> <operator>--</operator><name>git</name> <name>a</name><operator>/</operator><name>lucene</name><operator>/</operator><name>queryparser</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>queryparser</name><operator>/</operator><name>flexible</name><operator>/</operator><name>standard</name><operator>/</operator><name>processors</name><operator>/</operator><name><name>TermRangeQueryNodeProcessor</name><operator>.</operator><name>java</name></name> <name>b</name><operator>/</operator><name>lucene</name><operator>/</operator><name>queryparser</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>queryparser</name><operator>/</operator><name>flexible</name><operator>/</operator><name>standard</name><operator>/</operator><name>processors</name><operator>/</operator><name><name>TermRangeQueryNodeProcessor</name><operator>.</operator><name>java</name></name>
<name>index</name> <name>f9a45833bbf</name><operator>..</operator><literal type="number">557c605c159</literal> <literal type="number">100644</literal>
<operator>--</operator> <name>a</name><operator>/</operator><name>lucene</name><operator>/</operator><name>queryparser</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>queryparser</name><operator>/</operator><name>flexible</name><operator>/</operator><name>standard</name><operator>/</operator><name>processors</name><operator>/</operator><name><name>TermRangeQueryNodeProcessor</name><operator>.</operator><name>java</name></name>
<operator>++</operator> <name>b</name><operator>/</operator><name>lucene</name><operator>/</operator><name>queryparser</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>queryparser</name><operator>/</operator><name>flexible</name><operator>/</operator><name>standard</name><operator>/</operator><name>processors</name><operator>/</operator><name><name>TermRangeQueryNodeProcessor</name><operator>.</operator><name>java</name></name>
@@ <operator>-</operator><literal type="number">23</literal></expr>,<expr><literal type="number">6</literal> <operator>+</operator><literal type="number">23</literal></expr>,<expr><literal type="number">7</literal> @@</expr> <import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>List</name></name>;</import></block></expr></expr_stmt>
 <import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>Locale</name></name>;</import>
 <import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>TimeZone</name></name>;</import>
 
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>analysis</name><operator>.</operator><name>Analyzer</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>document</name><operator>.</operator><name>DateTools</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>document</name><operator>.</operator><name>DateTools</name><operator>.</operator><name>Resolution</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>queryparser</name><operator>.</operator><name>flexible</name><operator>.</operator><name>core</name><operator>.</operator><name>QueryNodeException</name></name>;</import>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">134</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">135</literal></expr><operator>,</operator><expr><literal type="number">15</literal> @@ <specifier>public</specifier> <name>class</name> <name>TermRangeQueryNodeProcessor</name> extends <name>QueryNodeProcessorImpl</name> <block>{
         }</block></expr></expr_stmt>
         
       } catch <expr_stmt><expr><operator>(</operator><name>Exception</name> <name>e</name><operator>)</operator> <block>{
        <comment type="line">// do nothing</comment>
        <comment type="line">// not a date</comment>
        <expr><name>Analyzer</name> <name>analyzer</name> <operator>=</operator> <call><name>getQueryConfigHandler</name><argument_list>()</argument_list></call><operator>.</operator><call><name>get</name><argument_list>(<argument><expr><name><name>ConfigurationKeys</name><operator>.</operator><name>ANALYZER</name></name></expr></argument>)</argument_list></call></expr>;
        <if_stmt><if>if <condition>(<expr><name>analyzer</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
          <comment type="line">// because we call utf8ToString, this will only work with the default TermToBytesRefAttribute</comment>
          <expr_stmt><expr><name>part1</name> <operator>=</operator> <call><name><name>analyzer</name><operator>.</operator><name>normalize</name></name><argument_list>(<argument><expr><call><name><name>lower</name><operator>.</operator><name>getFieldAsString</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>part1</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>utf8ToString</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>part2</name> <operator>=</operator> <call><name><name>analyzer</name><operator>.</operator><name>normalize</name></name><argument_list>(<argument><expr><call><name><name>lower</name><operator>.</operator><name>getFieldAsString</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>part2</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>utf8ToString</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name><name>lower</name><operator>.</operator><name>setText</name></name><argument_list>(<argument><expr><name>part1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name><name>upper</name><operator>.</operator><name>setText</name></name><argument_list>(<argument><expr><name>part2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt/></block_content></block></if></if_stmt>}</block></expr></expr_stmt>
       }
       
     }
<expr_stmt><expr><name>diff</name> <operator>--</operator><name>git</name> <name>a</name><operator>/</operator><name>lucene</name><operator>/</operator><name>queryparser</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>queryparser</name><operator>/</operator><name>flexible</name><operator>/</operator><name>standard</name><operator>/</operator><name>processors</name><operator>/</operator><name><name>WildcardQueryNodeProcessor</name><operator>.</operator><name>java</name></name> <name>b</name><operator>/</operator><name>lucene</name><operator>/</operator><name>queryparser</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>queryparser</name><operator>/</operator><name>flexible</name><operator>/</operator><name>standard</name><operator>/</operator><name>processors</name><operator>/</operator><name><name>WildcardQueryNodeProcessor</name><operator>.</operator><name>java</name></name>
<name>index</name> <literal type="number">718257500b7</literal><operator>..</operator><literal type="number">39eb0df13ed</literal> <literal type="number">100644</literal>
<operator>--</operator> <name>a</name><operator>/</operator><name>lucene</name><operator>/</operator><name>queryparser</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>queryparser</name><operator>/</operator><name>flexible</name><operator>/</operator><name>standard</name><operator>/</operator><name>processors</name><operator>/</operator><name><name>WildcardQueryNodeProcessor</name><operator>.</operator><name>java</name></name>
<operator>++</operator> <name>b</name><operator>/</operator><name>lucene</name><operator>/</operator><name>queryparser</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>queryparser</name><operator>/</operator><name>flexible</name><operator>/</operator><name>standard</name><operator>/</operator><name>processors</name><operator>/</operator><name><name>WildcardQueryNodeProcessor</name><operator>.</operator><name>java</name></name>
@@ <operator>-</operator><literal type="number">17</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">17</literal></expr><operator>,</operator><expr><literal type="number">10</literal> @@</expr></expr_stmt>
 <package>package <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>queryparser</name><operator>.</operator><name>flexible</name><operator>.</operator><name>standard</name><operator>.</operator><name>processors</name></name>;</package>
 
 <import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>List</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>regex</name><operator>.</operator><name>Matcher</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>regex</name><operator>.</operator><name>Pattern</name></name>;</import>
 
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>analysis</name><operator>.</operator><name>Analyzer</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>queryparser</name><operator>.</operator><name>flexible</name><operator>.</operator><name>core</name><operator>.</operator><name>QueryNodeException</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>queryparser</name><operator>.</operator><name>flexible</name><operator>.</operator><name>core</name><operator>.</operator><name>nodes</name><operator>.</operator><name>FieldQueryNode</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>queryparser</name><operator>.</operator><name>flexible</name><operator>.</operator><name>core</name><operator>.</operator><name>nodes</name><operator>.</operator><name>FuzzyQueryNode</name></name>;</import>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">25</literal></expr><operator>,</operator><expr><literal type="number">11</literal> <operator>+</operator><literal type="number">28</literal></expr><operator>,</operator><expr><literal type="number">13</literal> @@</expr></expr_stmt> <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>queryparser</name><operator>.</operator><name>flexible</name><operator>.</operator><name>core</name><operator>.</operator><name>nodes</name><operator>.</operator><name>QueryNode</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>queryparser</name><operator>.</operator><name>flexible</name><operator>.</operator><name>core</name><operator>.</operator><name>nodes</name><operator>.</operator><name>QuotedFieldQueryNode</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>queryparser</name><operator>.</operator><name>flexible</name><operator>.</operator><name>core</name><operator>.</operator><name>processors</name><operator>.</operator><name>QueryNodeProcessorImpl</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>queryparser</name><operator>.</operator><name>flexible</name><operator>.</operator><name>core</name><operator>.</operator><name>util</name><operator>.</operator><name>UnescapedCharSequence</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>queryparser</name><operator>.</operator><name>flexible</name><operator>.</operator><name>standard</name><operator>.</operator><name>config</name><operator>.</operator><name>StandardQueryConfigHandler</name><operator>.</operator><name>ConfigurationKeys</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>queryparser</name><operator>.</operator><name>flexible</name><operator>.</operator><name>standard</name><operator>.</operator><name>nodes</name><operator>.</operator><name>PrefixWildcardQueryNode</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>queryparser</name><operator>.</operator><name>flexible</name><operator>.</operator><name>standard</name><operator>.</operator><name>nodes</name><operator>.</operator><name>TermRangeQueryNode</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>queryparser</name><operator>.</operator><name>flexible</name><operator>.</operator><name>standard</name><operator>.</operator><name>nodes</name><operator>.</operator><name>WildcardQueryNode</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>queryparser</name><operator>.</operator><name>flexible</name><operator>.</operator><name>standard</name><operator>.</operator><name>parser</name><operator>.</operator><name>StandardSyntaxParser</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>search</name><operator>.</operator><name>PrefixQuery</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>util</name><operator>.</operator><name>BytesRef</name></name>;</import>
 
 <comment type="block" format="javadoc">/**
  * The {@link StandardSyntaxParser} creates {@link PrefixWildcardQueryNode} nodes which
@@ -43,6 +48,39 @@ import org.apache.lucene.search.PrefixQuery;
  */</comment>
 <class><specifier>public</specifier> class <name>WildcardQueryNodeProcessor</name> <super_list><extends>extends <super><name>QueryNodeProcessorImpl</name></super></extends></super_list> <block>{
 
  <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>Pattern</name></type> <name>WILDCARD_PATTERN</name> <init>= <expr><call><name><name>Pattern</name><operator>.</operator><name>compile</name></name><argument_list>(<argument><expr><literal type="string">"(\\.)|([?*]+)"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <comment type="line">// because we call utf8ToString, this will only work with the default TermToBytesRefAttribute</comment>
  <function><type><specifier>private</specifier> <specifier>static</specifier> <name>String</name></type> <name>analyzeWildcard</name><parameter_list>(<parameter><decl><type><name>Analyzer</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>String</name></type> <name>field</name></decl></parameter>, <parameter><decl><type><name>String</name></type> <name>wildcard</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <comment type="line">// best effort to not pass the wildcard characters through #normalize</comment>
    <decl_stmt><decl><type><name>Matcher</name></type> <name>wildcardMatcher</name> <init>= <expr><call><name><name>WILDCARD_PATTERN</name><operator>.</operator><name>matcher</name></name><argument_list>(<argument><expr><name>wildcard</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>StringBuilder</name></type> <name>sb</name> <init>= <expr><operator>new</operator> <call><name>StringBuilder</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>last</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <while>while <condition>(<expr><call><name><name>wildcardMatcher</name><operator>.</operator><name>find</name></name><argument_list>()</argument_list></call></expr>)</condition><block>{<block_content>
      <comment type="line">// continue if escaped char</comment>
      <if_stmt><if>if <condition>(<expr><call><name><name>wildcardMatcher</name><operator>.</operator><name>group</name></name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition><block>{<block_content>
        <continue>continue;</continue>
      </block_content>}</block></if></if_stmt>

      <if_stmt><if>if <condition>(<expr><call><name><name>wildcardMatcher</name><operator>.</operator><name>start</name></name><argument_list>()</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block>{<block_content>
        <decl_stmt><decl><type><name>String</name></type> <name>chunk</name> <init>= <expr><call><name><name>wildcard</name><operator>.</operator><name>substring</name></name><argument_list>(<argument><expr><name>last</name></expr></argument>, <argument><expr><call><name><name>wildcardMatcher</name><operator>.</operator><name>start</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>BytesRef</name></type> <name>normalized</name> <init>= <expr><call><name><name>a</name><operator>.</operator><name>normalize</name></name><argument_list>(<argument><expr><name>field</name></expr></argument>, <argument><expr><name>chunk</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>sb</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><call><name><name>normalized</name><operator>.</operator><name>utf8ToString</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <comment type="line">//append the wildcard character</comment>
      <expr_stmt><expr><call><name><name>sb</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><call><name><name>wildcardMatcher</name><operator>.</operator><name>group</name></name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><name>last</name> <operator>=</operator> <call><name><name>wildcardMatcher</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
    <if_stmt><if>if <condition>(<expr><name>last</name> <operator>&lt;</operator> <call><name><name>wildcard</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr>)</condition><block>{<block_content>
      <decl_stmt><decl><type><name>String</name></type> <name>chunk</name> <init>= <expr><call><name><name>wildcard</name><operator>.</operator><name>substring</name></name><argument_list>(<argument><expr><name>last</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>BytesRef</name></type> <name>normalized</name> <init>= <expr><call><name><name>a</name><operator>.</operator><name>normalize</name></name><argument_list>(<argument><expr><name>field</name></expr></argument>, <argument><expr><name>chunk</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name><name>sb</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><call><name><name>normalized</name><operator>.</operator><name>utf8ToString</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><call><name><name>sb</name><operator>.</operator><name>toString</name></name><argument_list>()</argument_list></call></expr>;</return>
  </block_content>}</block></function>

   <constructor><specifier>public</specifier> <name>WildcardQueryNodeProcessor</name><parameter_list>()</parameter_list> <block>{<block_content>
     <comment type="line">// empty constructor</comment>
   </block_content>}</block></constructor>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">67</literal></expr><operator>,</operator><expr><literal type="number">15</literal> <operator>+</operator><literal type="number">105</literal></expr><operator>,</operator><expr><literal type="number">19</literal> @@ <specifier>public</specifier> <name>class</name> <name>WildcardQueryNodeProcessor</name> extends <name>QueryNodeProcessorImpl</name> <block>{
       
       <comment type="line">// Code below simulates the old lucene parser behavior for wildcards</comment>
       
      <if_stmt><if>if <condition>(<expr><call><name>isPrefixWildcard</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>        
        <decl_stmt><decl><type><name>PrefixWildcardQueryNode</name></type> <name>prefixWildcardQN</name> <init>= <expr><operator>new</operator> <call><name>PrefixWildcardQueryNode</name><argument_list>(<argument><expr><name>fqn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <return>return <expr><name>prefixWildcardQN</name></expr>;</return>
        
      <expr_stmt/></block_content></block></if></if_stmt>}</block></expr></expr_stmt> <if_stmt><if type="elseif">else if <condition>(<expr><call><name>isWildcard</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>
        <decl_stmt><decl><type><name>WildcardQueryNode</name></type> <name>wildcardQN</name> <init>= <expr><operator>new</operator> <call><name>WildcardQueryNode</name><argument_list>(<argument><expr><name>fqn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <return>return <expr><name>wildcardQN</name></expr>;</return>
      
      <if_stmt><if>if <condition>(<expr><call><name>isWildcard</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>Analyzer</name></type> <name>analyzer</name> <init>= <expr><call><name>getQueryConfigHandler</name><argument_list>()</argument_list></call><operator>.</operator><call><name>get</name><argument_list>(<argument><expr><name><name>ConfigurationKeys</name><operator>.</operator><name>ANALYZER</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>analyzer</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><name>text</name> <operator>=</operator> <call><name>analyzeWildcard</name><argument_list>(<argument><expr><name>analyzer</name></expr></argument>, <argument><expr><call><name><name>fqn</name><operator>.</operator><name>getFieldAsString</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>text</name><operator>.</operator><name>toString</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>isPrefixWildcard</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
          <return>return <expr><operator>new</operator> <call><name>PrefixWildcardQueryNode</name><argument_list>(<argument><expr><call><name><name>fqn</name><operator>.</operator><name>getField</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><call><name><name>fqn</name><operator>.</operator><name>getBegin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>fqn</name><operator>.</operator><name>getEnd</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block></if> <else>else <block>{<block_content>
          <return>return <expr><operator>new</operator> <call><name>WildcardQueryNode</name><argument_list>(<argument><expr><call><name><name>fqn</name><operator>.</operator><name>getField</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><call><name><name>fqn</name><operator>.</operator><name>getBegin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>fqn</name><operator>.</operator><name>getEnd</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block></else></if_stmt>
       </block_content>}</block></if></if_stmt>
             

     </block_content>}</block></if></if_stmt>
 
     <return>return <expr><name>node</name></expr>;</return>
<expr_stmt><expr><name>diff</name> <operator>--</operator><name>git</name> <name>a</name><operator>/</operator><name>lucene</name><operator>/</operator><name>queryparser</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>queryparser</name><operator>/</operator><name>simple</name><operator>/</operator><name><name>SimpleQueryParser</name><operator>.</operator><name>java</name></name> <name>b</name><operator>/</operator><name>lucene</name><operator>/</operator><name>queryparser</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>queryparser</name><operator>/</operator><name>simple</name><operator>/</operator><name><name>SimpleQueryParser</name><operator>.</operator><name>java</name></name>
<name>index</name> <literal type="number">3f9d9a42680</literal><operator>..</operator><name>a417d1b889c</name> <literal type="number">100644</literal>
<operator>--</operator> <name>a</name><operator>/</operator><name>lucene</name><operator>/</operator><name>queryparser</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>queryparser</name><operator>/</operator><name>simple</name><operator>/</operator><name><name>SimpleQueryParser</name><operator>.</operator><name>java</name></name>
<operator>++</operator> <name>b</name><operator>/</operator><name>lucene</name><operator>/</operator><name>queryparser</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>queryparser</name><operator>/</operator><name>simple</name><operator>/</operator><name><name>SimpleQueryParser</name><operator>.</operator><name>java</name></name>
@@ <operator>-</operator><literal type="number">26</literal></expr><operator>,</operator><expr><literal type="number">6</literal> <operator>+</operator><literal type="number">26</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@</expr></expr_stmt> <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>search</name><operator>.</operator><name>MatchAllDocsQuery</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>search</name><operator>.</operator><name>MatchNoDocsQuery</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>search</name><operator>.</operator><name>PrefixQuery</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>search</name><operator>.</operator><name>Query</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>util</name><operator>.</operator><name>BytesRef</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>util</name><operator>.</operator><name>QueryBuilder</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>util</name><operator>.</operator><name>automaton</name><operator>.</operator><name>LevenshteinAutomata</name></name>;</import>
 
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">548</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">549</literal></expr><operator>,</operator><expr><literal type="number">9</literal> @@ <specifier>public</specifier> <name>class</name> <name>SimpleQueryParser</name> extends <name>QueryBuilder</name> <block>{
   <expr><specifier>protected</specifier> <name>Query</name> <call><name>newFuzzyQuery</name><argument_list>(<argument><expr><name>String</name> <name>text</name></expr></argument>, <argument><expr><name>int</name> <name>fuzziness</name></expr></argument>)</argument_list></call> <block>{
     <expr><name><name>BooleanQuery</name><operator>.</operator><name>Builder</name></name> <name>bq</name> <operator>=</operator> <operator>new</operator> <call><name><name>BooleanQuery</name><operator>.</operator><name>Builder</name></name><argument_list>()</argument_list></call></expr>;
     <for>for <control>(<init><decl><type><name><name>Map</name><operator>.</operator><name><name>Entry</name><argument_list type="generic">&lt;<argument><name>String</name></argument>,<argument><name>Float</name></argument>&gt;</argument_list></name></name></type> <name>entry</name> <range>: <expr><call><name><name>weights</name><operator>.</operator><name>entrySet</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control> <block>{<block_content>
      <decl_stmt><decl><type><name>Query</name></type> <name>q</name> <init>= <expr><operator>new</operator> <call><name>FuzzyQuery</name><argument_list>(<argument><expr><operator>new</operator> <call><name>Term</name><argument_list>(<argument><expr><call><name><name>entry</name><operator>.</operator><name>getKey</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fuzziness</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>final</specifier> <name>String</name></type> <name>fieldName</name> <init>= <expr><call><name><name>entry</name><operator>.</operator><name>getKey</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>final</specifier> <name>BytesRef</name></type> <name>term</name> <init>= <expr><call><name>getAnalyzer</name><argument_list>()</argument_list></call><operator>.</operator><call><name>normalize</name><argument_list>(<argument><expr><name>fieldName</name></expr></argument>, <argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>Query</name></type> <name>q</name> <init>= <expr><operator>new</operator> <call><name>FuzzyQuery</name><argument_list>(<argument><expr><operator>new</operator> <call><name>Term</name><argument_list>(<argument><expr><name>fieldName</name></expr></argument>, <argument><expr><name>term</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fuzziness</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
       <decl_stmt><decl><type><name>float</name></type> <name>boost</name> <init>= <expr><call><name><name>entry</name><operator>.</operator><name>getValue</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
       <if_stmt><if>if <condition>(<expr><name>boost</name> <operator>!=</operator> <literal type="number">1f</literal></expr>)</condition> <block>{<block_content>
         <expr_stmt><expr><name>q</name> <operator>=</operator> <operator>new</operator> <call><name>BoostQuery</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name>boost</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">582</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">585</literal></expr><operator>,</operator><expr><literal type="number">9</literal> @@ <specifier>public</specifier> <name>class</name> <name>SimpleQueryParser</name> extends <name>QueryBuilder</name> <block>{
   <expr><specifier>protected</specifier> <name>Query</name> <call><name>newPrefixQuery</name><argument_list>(<argument><expr><name>String</name> <name>text</name></expr></argument>)</argument_list></call> <block>{
     <expr><name><name>BooleanQuery</name><operator>.</operator><name>Builder</name></name> <name>bq</name> <operator>=</operator> <operator>new</operator> <call><name><name>BooleanQuery</name><operator>.</operator><name>Builder</name></name><argument_list>()</argument_list></call></expr>;</block></expr>
     <for>for <control>(<init><decl><type><name><name>Map</name><operator>.</operator><name><name>Entry</name><argument_list type="generic">&lt;<argument><name>String</name></argument>,<argument><name>Float</name></argument>&gt;</argument_list></name></name></type> <name>entry</name> <range>: <expr><call><name><name>weights</name><operator>.</operator><name>entrySet</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control> <block>{<block_content>
      <decl_stmt><decl><type><name>Query</name></type> <name>q</name> <init>= <expr><operator>new</operator> <call><name>PrefixQuery</name><argument_list>(<argument><expr><operator>new</operator> <call><name>Term</name><argument_list>(<argument><expr><call><name><name>entry</name><operator>.</operator><name>getKey</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>final</specifier> <name>String</name></type> <name>fieldName</name> <init>= <expr><call><name><name>entry</name><operator>.</operator><name>getKey</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>final</specifier> <name>BytesRef</name></type> <name>term</name> <init>= <expr><call><name>getAnalyzer</name><argument_list>()</argument_list></call><operator>.</operator><call><name>normalize</name><argument_list>(<argument><expr><name>fieldName</name></expr></argument>, <argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>Query</name></type> <name>q</name> <init>= <expr><operator>new</operator> <call><name>PrefixQuery</name><argument_list>(<argument><expr><operator>new</operator> <call><name>Term</name><argument_list>(<argument><expr><name>fieldName</name></expr></argument>, <argument><expr><name>term</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
       <decl_stmt><decl><type><name>float</name></type> <name>boost</name> <init>= <expr><call><name><name>entry</name><operator>.</operator><name>getValue</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
       <if_stmt><if>if <condition>(<expr><name>boost</name> <operator>!=</operator> <literal type="number">1f</literal></expr>)</condition> <block>{<block_content>
         <expr_stmt><expr><name>q</name> <operator>=</operator> <operator>new</operator> <call><name>BoostQuery</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name>boost</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>diff</name> <operator>--</operator><name>git</name> <name>a</name><operator>/</operator><name>lucene</name><operator>/</operator><name>queryparser</name><operator>/</operator><name>src</name><operator>/</operator><name>test</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>queryparser</name><operator>/</operator><name>analyzing</name><operator>/</operator><name><name>TestAnalyzingQueryParser</name><operator>.</operator><name>java</name></name> <name>b</name><operator>/</operator><name>lucene</name><operator>/</operator><name>queryparser</name><operator>/</operator><name>src</name><operator>/</operator><name>test</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>queryparser</name><operator>/</operator><name>analyzing</name><operator>/</operator><name><name>TestAnalyzingQueryParser</name><operator>.</operator><name>java</name></name>
<name>deleted</name> <name>file</name> <name>mode</name> <literal type="number">100644</literal>
<name>index</name> <name>bf5f69f7b61</name><operator>..</operator><literal type="number">00000000000</literal>
<operator>--</operator> <name>a</name><operator>/</operator><name>lucene</name><operator>/</operator><name>queryparser</name><operator>/</operator><name>src</name><operator>/</operator><name>test</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>queryparser</name><operator>/</operator><name>analyzing</name><operator>/</operator><name><name>TestAnalyzingQueryParser</name><operator>.</operator><name>java</name></name>
<operator>++</operator> <operator>/</operator><name>dev</name><operator>/</operator><literal type="null">null</literal>
@@ <operator>-</operator><literal type="number">1</literal></expr><operator>,</operator><expr><literal type="number">268</literal> <operator>+</operator><literal type="number">0</literal></expr><operator>,</operator><expr><literal type="number">0</literal> @@</expr></expr_stmt>
<comment type="block">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</comment>
<package>package <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>queryparser</name><operator>.</operator><name>analyzing</name></name>;</package>

<import>import <name><name>java</name><operator>.</operator><name>io</name><operator>.</operator><name>IOException</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>Map</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>TreeMap</name></name>;</import>

<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>analysis</name><operator>.</operator><name>Analyzer</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>analysis</name><operator>.</operator><name>MockAnalyzer</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>analysis</name><operator>.</operator><name>MockBytesAnalyzer</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>analysis</name><operator>.</operator><name>MockTokenFilter</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>analysis</name><operator>.</operator><name>MockTokenizer</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>analysis</name><operator>.</operator><name>TokenFilter</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>analysis</name><operator>.</operator><name>TokenStream</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>analysis</name><operator>.</operator><name>Tokenizer</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>analysis</name><operator>.</operator><name>tokenattributes</name><operator>.</operator><name>CharTermAttribute</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>document</name><operator>.</operator><name>Document</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>document</name><operator>.</operator><name>Field</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>document</name><operator>.</operator><name>FieldType</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>index</name><operator>.</operator><name>DirectoryReader</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>index</name><operator>.</operator><name>IndexOptions</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>index</name><operator>.</operator><name>RandomIndexWriter</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>queryparser</name><operator>.</operator><name>classic</name><operator>.</operator><name>ParseException</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>queryparser</name><operator>.</operator><name>classic</name><operator>.</operator><name>QueryParser</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>search</name><operator>.</operator><name>IndexSearcher</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>search</name><operator>.</operator><name>Query</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>store</name><operator>.</operator><name>Directory</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>util</name><operator>.</operator><name>LuceneTestCase</name></name>;</import>

<comment type="block" format="javadoc">/**
 */</comment>
<class><specifier>public</specifier> class <name>TestAnalyzingQueryParser</name> <super_list><extends>extends <super><name>LuceneTestCase</name></super></extends></super_list> <block>{
  <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <specifier>static</specifier> <name>String</name></type> <name>FIELD</name> <init>= <expr><literal type="string">"field"</literal></expr></init></decl>;</decl_stmt>
   
  <decl_stmt><decl><type><specifier>private</specifier> <name>Analyzer</name></type> <name>a</name></decl>;</decl_stmt>

  <decl_stmt><decl><type><specifier>private</specifier> <name><name>String</name><index>[]</index></name></type> <name>wildcardInput</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>private</specifier> <name><name>String</name><index>[]</index></name></type> <name>wildcardExpected</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>private</specifier> <name><name>String</name><index>[]</index></name></type> <name>prefixInput</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>private</specifier> <name><name>String</name><index>[]</index></name></type> <name>prefixExpected</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>private</specifier> <name><name>String</name><index>[]</index></name></type> <name>rangeInput</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>private</specifier> <name><name>String</name><index>[]</index></name></type> <name>rangeExpected</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>private</specifier> <name><name>String</name><index>[]</index></name></type> <name>fuzzyInput</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>private</specifier> <name><name>String</name><index>[]</index></name></type> <name>fuzzyExpected</name></decl>;</decl_stmt>

  <decl_stmt><decl><type><specifier>private</specifier> <name><name>Map</name><argument_list type="generic">&lt;<argument><name>String</name></argument>, <argument><name>String</name></argument>&gt;</argument_list></name></type> <name>wildcardEscapeHits</name> <init>= <expr><operator>new</operator> <call><name><name>TreeMap</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>private</specifier> <name><name>Map</name><argument_list type="generic">&lt;<argument><name>String</name></argument>, <argument><name>String</name></argument>&gt;</argument_list></name></type> <name>wildcardEscapeMisses</name> <init>= <expr><operator>new</operator> <call><name><name>TreeMap</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

  <function><annotation>@<name>Override</name></annotation>
  <type><specifier>public</specifier> <name>void</name></type> <name>setUp</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>Exception</name></expr></argument></throws> <block>{<block_content>
    <expr_stmt><expr><call><name><name>super</name><operator>.</operator><name>setUp</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>wildcardInput</name> <operator>=</operator> <operator>new</operator> <name><name>String</name><index>[]</index></name> <block>{ <expr><literal type="string">"*bersetzung Ã¼ber*ung"</literal></expr>,
        <expr><literal type="string">"MÃ¶tley Cr\u00fce MÃ¶tl?* CrÃ¼?"</literal></expr>, <expr><literal type="string">"RenÃ©e Zellweger Ren?? Zellw?ger"</literal></expr> }</block></expr>;</expr_stmt>
    <expr_stmt><expr><name>wildcardExpected</name> <operator>=</operator> <operator>new</operator> <name><name>String</name><index>[]</index></name> <block>{ <expr><literal type="string">"*bersetzung uber*ung"</literal></expr>, <expr><literal type="string">"motley crue motl?* cru?"</literal></expr>,
        <expr><literal type="string">"renee zellweger ren?? zellw?ger"</literal></expr> }</block></expr>;</expr_stmt>

    <expr_stmt><expr><name>prefixInput</name> <operator>=</operator> <operator>new</operator> <name><name>String</name><index>[]</index></name> <block>{ <expr><literal type="string">"Ã¼bersetzung Ã¼bersetz*"</literal></expr>,
        <expr><literal type="string">"MÃ¶tley CrÃ¼e MÃ¶tl* crÃ¼*"</literal></expr>, <expr><literal type="string">"RenÃ©? Zellw*"</literal></expr> }</block></expr>;</expr_stmt>
    <expr_stmt><expr><name>prefixExpected</name> <operator>=</operator> <operator>new</operator> <name><name>String</name><index>[]</index></name> <block>{ <expr><literal type="string">"ubersetzung ubersetz*"</literal></expr>, <expr><literal type="string">"motley crue motl* cru*"</literal></expr>,
        <expr><literal type="string">"rene? zellw*"</literal></expr> }</block></expr>;</expr_stmt>

    <expr_stmt><expr><name>rangeInput</name> <operator>=</operator> <operator>new</operator> <name><name>String</name><index>[]</index></name> <block>{ <expr><literal type="string">"[aa TO bb]"</literal></expr>, <expr><literal type="string">"{AnaÃ¯s TO ZoÃ©}"</literal></expr> }</block></expr>;</expr_stmt>
    <expr_stmt><expr><name>rangeExpected</name> <operator>=</operator> <operator>new</operator> <name><name>String</name><index>[]</index></name> <block>{ <expr><literal type="string">"[aa TO bb]"</literal></expr>, <expr><literal type="string">"{anais TO zoe}"</literal></expr> }</block></expr>;</expr_stmt>

    <expr_stmt><expr><name>fuzzyInput</name> <operator>=</operator> <operator>new</operator> <name><name>String</name><index>[]</index></name> <block>{ <expr><literal type="string">"Ãbersetzung Ãbersetzung~0.9"</literal></expr>,
        <expr><literal type="string">"MÃ¶tley CrÃ¼e MÃ¶tley~0.75 CrÃ¼e~0.5"</literal></expr>,
        <expr><literal type="string">"RenÃ©e Zellweger RenÃ©e~0.9 Zellweger~"</literal></expr> }</block></expr>;</expr_stmt>
    <expr_stmt><expr><name>fuzzyExpected</name> <operator>=</operator> <operator>new</operator> <name><name>String</name><index>[]</index></name> <block>{ <expr><literal type="string">"ubersetzung ubersetzung~1"</literal></expr>,
        <expr><literal type="string">"motley crue motley~1 crue~2"</literal></expr>, <expr><literal type="string">"renee zellweger renee~0 zellweger~2"</literal></expr> }</block></expr>;</expr_stmt>

    <expr_stmt><expr><call><name><name>wildcardEscapeHits</name><operator>.</operator><name>put</name></name><argument_list>(<argument><expr><literal type="string">"mÃ¶*tley"</literal></expr></argument>, <argument><expr><literal type="string">"moatley"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// need to have at least one genuine wildcard to trigger the wildcard analysis</comment>
    <comment type="line">// hence the * before the y</comment>
    <expr_stmt><expr><call><name><name>wildcardEscapeHits</name><operator>.</operator><name>put</name></name><argument_list>(<argument><expr><literal type="string">"mÃ¶\\*tl*y"</literal></expr></argument>, <argument><expr><literal type="string">"mo*tley"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// escaped backslash then true wildcard</comment>
    <expr_stmt><expr><call><name><name>wildcardEscapeHits</name><operator>.</operator><name>put</name></name><argument_list>(<argument><expr><literal type="string">"mÃ¶\\\\*tley"</literal></expr></argument>, <argument><expr><literal type="string">"mo\\atley"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <comment type="line">// escaped wildcard then true wildcard</comment>
    <expr_stmt><expr><call><name><name>wildcardEscapeHits</name><operator>.</operator><name>put</name></name><argument_list>(<argument><expr><literal type="string">"mÃ¶\\??ley"</literal></expr></argument>, <argument><expr><literal type="string">"mo?tley"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// the first is an escaped * which should yield a miss</comment>
    <expr_stmt><expr><call><name><name>wildcardEscapeMisses</name><operator>.</operator><name>put</name></name><argument_list>(<argument><expr><literal type="string">"mÃ¶\\*tl*y"</literal></expr></argument>, <argument><expr><literal type="string">"moatley"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      
    <expr_stmt><expr><name>a</name> <operator>=</operator> <operator>new</operator> <call><name>ASCIIAnalyzer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt/></block_content></block></function></block></class></block_content></block></if></if_stmt></block_content></block></for></block></expr></expr_stmt></block_content></block></if></if_stmt></block_content></block></for>}</block>

  <specifier>public</specifier> <name>void</name> <call><name>testSingleChunkExceptions</name><argument_list>()</argument_list></call> <block>{
    <expr><name>String</name> <name>termStr</name> <operator>=</operator> <literal type="string">"the*tre"</literal></expr>;
      
    <expr><name>Analyzer</name> <name>stopsAnalyzer</name> <operator>=</operator> <operator>new</operator> <call><name>MockAnalyzer</name>
        <argument_list>(<argument><expr><call><name>random</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>MockTokenizer</name><operator>.</operator><name>WHITESPACE</name></name></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>, <argument><expr><name><name>MockTokenFilter</name><operator>.</operator><name>ENGLISH_STOPSET</name></name></expr></argument>)</argument_list></call></expr>;

    <expr><name>ParseException</name> <name>expected</name> <operator>=</operator> <call><name>expectThrows</name><argument_list>(<argument><expr><name><name>ParseException</name><operator>.</operator><name>class</name></name></expr></argument>, <argument><expr><lambda><parameter_list>()</parameter_list> -&gt; <block>{<block_content>
      <expr_stmt><expr><call><name>parseWithAnalyzingQueryParser</name><argument_list>(<argument><expr><name>termStr</name></expr></argument>, <argument><expr><name>stopsAnalyzer</name></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt/>}</block_content></block></lambda></expr></argument>)</argument_list></call></expr>;
    <expr><call><name>assertTrue</name><argument_list>(<argument><expr><call><name><name>expected</name><operator>.</operator><name>getMessage</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>contains</name><argument_list>(<argument><expr><literal type="string">"returned nothing"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
     
    <expr><name>AnalyzingQueryParser</name> <name>qp</name> <operator>=</operator> <operator>new</operator> <call><name>AnalyzingQueryParser</name><argument_list>(<argument><expr><name>FIELD</name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;
    <expr><name>expected</name> <operator>=</operator> <call><name>expectThrows</name><argument_list>(<argument><expr><name><name>ParseException</name><operator>.</operator><name>class</name></name></expr></argument>, <argument><expr><lambda><parameter_list>()</parameter_list> -&gt; <block>{<block_content>
      <expr_stmt><expr><call><name><name>qp</name><operator>.</operator><name>analyzeSingleChunk</name></name><argument_list>(<argument><expr><name>FIELD</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><literal type="string">"not a single chunk"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt/>}</block_content></block></lambda></expr></argument>)</argument_list></call></expr>;
    <expr><call><name>assertTrue</name><argument_list>(<argument><expr><call><name><name>expected</name><operator>.</operator><name>getMessage</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>contains</name><argument_list>(<argument><expr><literal type="string">"multiple terms"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
  }</block>
   
  <specifier>public</specifier> <name>void</name> <call><name>testWildcardAlone</name><argument_list>()</argument_list></call> <throws>throws <argument><expr><name>ParseException</name> <block>{
    <comment type="line">//seems like crazy edge case, but can be useful in concordance </comment>
    <expr><call><name>expectThrows</name><argument_list>(<argument><expr><name><name>ParseException</name><operator>.</operator><name>class</name></name></expr></argument>, <argument><expr><lambda><parameter_list>()</parameter_list> -&gt; <block>{
      <expr><call><name>getAnalyzedQuery</name><argument_list>(<argument><expr><literal type="string">"*"</literal></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr></block></lambda></expr></argument></argument_list></call></expr></block></expr></argument></throws></expr>;
    }</block></expr></expr_stmt>)</block>;</class>
      
    <decl_stmt><decl><type><name>String</name></type> <name>qString</name> <init>= <expr><call><name>parseWithAnalyzingQueryParser</name><argument_list>(<argument><expr><literal type="string">"*"</literal></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><literal type="string">"Every word"</literal></expr></argument>, <argument><expr><literal type="string">"*"</literal></expr></argument>, <argument><expr><name>qString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }
  public <function><type><name>void</name></type> <name>testWildCardEscapes</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>ParseException</name></expr></argument>, <argument><expr><name>IOException</name></expr></argument></throws> <block>{<block_content>

    <for>for <control>(<init><decl><type><name><name>Map</name><operator>.</operator><name><name>Entry</name><argument_list type="generic">&lt;<argument><name>String</name></argument>, <argument><name>String</name></argument>&gt;</argument_list></name></name></type> <name>entry</name> <range>: <expr><call><name><name>wildcardEscapeHits</name><operator>.</operator><name>entrySet</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>Query</name></type> <name>q</name> <init>= <expr><call><name>getAnalyzedQuery</name><argument_list>(<argument><expr><call><name><name>entry</name><operator>.</operator><name>getKey</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><literal type="string">"WildcardEscapeHits: "</literal> <operator>+</operator> <call><name><name>entry</name><operator>.</operator><name>getKey</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>, <argument><expr><call><name>isAHit</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><call><name><name>entry</name><operator>.</operator><name>getValue</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <for>for <control>(<init><decl><type><name><name>Map</name><operator>.</operator><name><name>Entry</name><argument_list type="generic">&lt;<argument><name>String</name></argument>, <argument><name>String</name></argument>&gt;</argument_list></name></name></type> <name>entry</name> <range>: <expr><call><name><name>wildcardEscapeMisses</name><operator>.</operator><name>entrySet</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>Query</name></type> <name>q</name> <init>= <expr><call><name>getAnalyzedQuery</name><argument_list>(<argument><expr><call><name><name>entry</name><operator>.</operator><name>getKey</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><literal type="string">"WildcardEscapeMisses: "</literal> <operator>+</operator> <call><name><name>entry</name><operator>.</operator><name>getKey</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>, <argument><expr><call><name>isAHit</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><call><name><name>entry</name><operator>.</operator><name>getValue</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

  </block_content>}</block></function>
  <function><type><specifier>public</specifier> <name>void</name></type> <name>testWildCardQueryNoLeadingAllowed</name><parameter_list>()</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>expectThrows</name><argument_list>(<argument><expr><name><name>ParseException</name><operator>.</operator><name>class</name></name></expr></argument>, <argument><expr><lambda><parameter_list>()</parameter_list> -&gt; <block>{<block_content>
      <expr_stmt><expr><call><name>parseWithAnalyzingQueryParser</name><argument_list>(<argument><expr><name><name>wildcardInput</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></lambda></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></function>

  <function><type><specifier>public</specifier> <name>void</name></type> <name>testWildCardQuery</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>ParseException</name></expr></argument></throws> <block>{<block_content>
    <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>wildcardInput</name><operator>.</operator><name>length</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
      <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><literal type="string">"Testing wildcards with analyzer "</literal> <operator>+</operator> <call><name><name>a</name><operator>.</operator><name>getClass</name></name><argument_list>()</argument_list></call> <operator>+</operator> <literal type="string">", input string: "</literal>
          <operator>+</operator> <name><name>wildcardInput</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>wildcardExpected</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><call><name>parseWithAnalyzingQueryParser</name><argument_list>(<argument><expr><name><name>wildcardInput</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block></function>


  <function><type><specifier>public</specifier> <name>void</name></type> <name>testPrefixQuery</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>ParseException</name></expr></argument></throws> <block>{<block_content>
    <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>prefixInput</name><operator>.</operator><name>length</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
      <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><literal type="string">"Testing prefixes with analyzer "</literal> <operator>+</operator> <call><name><name>a</name><operator>.</operator><name>getClass</name></name><argument_list>()</argument_list></call> <operator>+</operator> <literal type="string">", input string: "</literal>
          <operator>+</operator> <name><name>prefixInput</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>prefixExpected</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><call><name>parseWithAnalyzingQueryParser</name><argument_list>(<argument><expr><name><name>prefixInput</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block></function>

  <function><type><specifier>public</specifier> <name>void</name></type> <name>testRangeQuery</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>ParseException</name></expr></argument></throws> <block>{<block_content>
    <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>rangeInput</name><operator>.</operator><name>length</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
      <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><literal type="string">"Testing ranges with analyzer "</literal> <operator>+</operator> <call><name><name>a</name><operator>.</operator><name>getClass</name></name><argument_list>()</argument_list></call> <operator>+</operator> <literal type="string">", input string: "</literal>
          <operator>+</operator> <name><name>rangeInput</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>rangeExpected</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><call><name>parseWithAnalyzingQueryParser</name><argument_list>(<argument><expr><name><name>rangeInput</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block></function>

  <function><type><specifier>public</specifier> <name>void</name></type> <name>testFuzzyQuery</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>ParseException</name></expr></argument></throws> <block>{<block_content>
    <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>fuzzyInput</name><operator>.</operator><name>length</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
      <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><literal type="string">"Testing fuzzys with analyzer "</literal> <operator>+</operator> <call><name><name>a</name><operator>.</operator><name>getClass</name></name><argument_list>()</argument_list></call> <operator>+</operator> <literal type="string">", input string: "</literal>
          <operator>+</operator> <name><name>fuzzyInput</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>fuzzyExpected</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><call><name>parseWithAnalyzingQueryParser</name><argument_list>(<argument><expr><name><name>fuzzyInput</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block></function>


  <function><type><specifier>private</specifier> <name>String</name></type> <name>parseWithAnalyzingQueryParser</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>s</name></decl></parameter>, <parameter><decl><type><name>Analyzer</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>boolean</name></type> <name>allowLeadingWildcard</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>ParseException</name></expr></argument></throws> <block>{<block_content>
    <decl_stmt><decl><type><name>Query</name></type> <name>q</name> <init>= <expr><call><name>getAnalyzedQuery</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>allowLeadingWildcard</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <return>return <expr><call><name><name>q</name><operator>.</operator><name>toString</name></name><argument_list>(<argument><expr><name>FIELD</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></function>

  <function><type><specifier>private</specifier> <name>Query</name></type> <name>getAnalyzedQuery</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>s</name></decl></parameter>, <parameter><decl><type><name>Analyzer</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>boolean</name></type> <name>allowLeadingWildcard</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>ParseException</name></expr></argument></throws> <block>{<block_content>
    <decl_stmt><decl><type><name>AnalyzingQueryParser</name></type> <name>qp</name> <init>= <expr><operator>new</operator> <call><name>AnalyzingQueryParser</name><argument_list>(<argument><expr><name>FIELD</name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>qp</name><operator>.</operator><name>setAllowLeadingWildcard</name></name><argument_list>(<argument><expr><name>allowLeadingWildcard</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>search</name><operator>.</operator><name>Query</name></name></type> <name>q</name> <init>= <expr><call><name><name>qp</name><operator>.</operator><name>parse</name></name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <return>return <expr><name>q</name></expr>;</return>
  </block_content>}</block></function>

  <class><specifier>final</specifier> <specifier>static</specifier> class <name>FoldingFilter</name> <super_list><extends>extends <super><name>TokenFilter</name></super></extends></super_list> <block>{
    <decl_stmt><decl><type><specifier>final</specifier> <name>CharTermAttribute</name></type> <name>termAtt</name> <init>= <expr><call><name>addAttribute</name><argument_list>(<argument><expr><name><name>CharTermAttribute</name><operator>.</operator><name>class</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <constructor><specifier>public</specifier> <name>FoldingFilter</name><parameter_list>(<parameter><decl><type><name>TokenStream</name></type> <name>input</name></decl></parameter>)</parameter_list> <block>{<block_content>
      <expr_stmt><expr><call><name>super</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></constructor>

    <function><annotation>@<name>Override</name></annotation>
    <type><specifier>public</specifier> <name>boolean</name></type> <name>incrementToken</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><call><name><name>input</name><operator>.</operator><name>incrementToken</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>char</name></type> <name><name>term</name><index>[]</index></name> <init>= <expr><call><name><name>termAtt</name><operator>.</operator><name>buffer</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>term</name><operator>.</operator><name>length</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
          <switch>switch<condition>(<expr><name><name>term</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition> <block>{<block_content>
            <case>case <expr><literal type="char">'Ã¼'</literal></expr>:</case>
              <expr_stmt><expr><name><name>term</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="char">'u'</literal></expr>;</expr_stmt> 
              <break>break;</break>
            <case>case <expr><literal type="char">'Ã¶'</literal></expr>:</case> 
              <expr_stmt><expr><name><name>term</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="char">'o'</literal></expr>;</expr_stmt> 
              <break>break;</break>
            <case>case <expr><literal type="char">'Ã©'</literal></expr>:</case> 
              <expr_stmt><expr><name><name>term</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="char">'e'</literal></expr>;</expr_stmt> 
              <break>break;</break>
            <case>case <expr><literal type="char">'Ã¯'</literal></expr>:</case> 
              <expr_stmt><expr><name><name>term</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="char">'i'</literal></expr>;</expr_stmt> 
              <break>break;</break>
          </block_content>}</block></switch></block_content></block></for>
        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
      </block_content>}</block></if> <else>else <block>{<block_content>
        <return>return <expr><literal type="boolean">false</literal></expr>;</return>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></function>
  }</block></class>

  <class><specifier>final</specifier> <specifier>static</specifier> class <name>ASCIIAnalyzer</name> <super_list><extends>extends <super><name>Analyzer</name></super></extends></super_list> <block>{
    <function><annotation>@<name>Override</name></annotation>
    <type><specifier>public</specifier> <name>TokenStreamComponents</name></type> <name>createComponents</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>fieldName</name></decl></parameter>)</parameter_list> <block>{<block_content>
      <decl_stmt><decl><type><name>Tokenizer</name></type> <name>result</name> <init>= <expr><operator>new</operator> <call><name>MockTokenizer</name><argument_list>(<argument><expr><name><name>MockTokenizer</name><operator>.</operator><name>WHITESPACE</name></name></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <return>return <expr><operator>new</operator> <call><name>TokenStreamComponents</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><operator>new</operator> <call><name>FoldingFilter</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>
  }</block></class>
   

  <comment type="line">// LUCENE-4176</comment>
  <function><type><specifier>public</specifier> <name>void</name></type> <name>testByteTerms</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>Exception</name></expr></argument></throws> <block>{<block_content>
    <decl_stmt><decl><type><name>String</name></type> <name>s</name> <init>= <expr><literal type="string">"à¹à¸"</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Analyzer</name></type> <name>analyzer</name> <init>= <expr><operator>new</operator> <call><name>MockBytesAnalyzer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>QueryParser</name></type> <name>qp</name> <init>= <expr><operator>new</operator> <call><name>AnalyzingQueryParser</name><argument_list>(<argument><expr><name>FIELD</name></expr></argument>, <argument><expr><name>analyzer</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Query</name></type> <name>q</name> <init>= <expr><call><name><name>qp</name><operator>.</operator><name>parse</name></name><argument_list>(<argument><expr><literal type="string">"[à¹à¸ TO à¹à¸]"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><literal type="boolean">true</literal></expr></argument>, <argument><expr><call><name>isAHit</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>analyzer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></function>
   
  
  <function><type><specifier>private</specifier> <name>boolean</name></type> <name>isAHit</name><parameter_list>(<parameter><decl><type><name>Query</name></type> <name>q</name></decl></parameter>, <parameter><decl><type><name>String</name></type> <name>content</name></decl></parameter>, <parameter><decl><type><name>Analyzer</name></type> <name>analyzer</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws><block>{<block_content>
    <decl_stmt><decl><type><name>Directory</name></type> <name>ramDir</name> <init>= <expr><call><name>newDirectory</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RandomIndexWriter</name></type> <name>writer</name> <init>= <expr><operator>new</operator> <call><name>RandomIndexWriter</name><argument_list>(<argument><expr><call><name>random</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>ramDir</name></expr></argument>, <argument><expr><name>analyzer</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Document</name></type> <name>doc</name> <init>= <expr><operator>new</operator> <call><name>Document</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>FieldType</name></type> <name>fieldType</name> <init>= <expr><operator>new</operator> <call><name>FieldType</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>fieldType</name><operator>.</operator><name>setIndexOptions</name></name><argument_list>(<argument><expr><name><name>IndexOptions</name><operator>.</operator><name>DOCS_AND_FREQS_AND_POSITIONS</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>fieldType</name><operator>.</operator><name>setTokenized</name></name><argument_list>(<argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>fieldType</name><operator>.</operator><name>setStored</name></name><argument_list>(<argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>Field</name></type> <name>field</name> <init>= <expr><operator>new</operator> <call><name>Field</name><argument_list>(<argument><expr><name>FIELD</name></expr></argument>, <argument><expr><name>content</name></expr></argument>, <argument><expr><name>fieldType</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>doc</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name>field</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>writer</name><operator>.</operator><name>addDocument</name></name><argument_list>(<argument><expr><name>doc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>writer</name><operator>.</operator><name>close</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>DirectoryReader</name></type> <name>ir</name> <init>= <expr><call><name><name>DirectoryReader</name><operator>.</operator><name>open</name></name><argument_list>(<argument><expr><name>ramDir</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>IndexSearcher</name></type> <name>is</name> <init>= <expr><operator>new</operator> <call><name>IndexSearcher</name><argument_list>(<argument><expr><name>ir</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      
    <decl_stmt><decl><type><name>int</name></type> <name>hits</name> <init>= <expr><call><name><name>is</name><operator>.</operator><name>search</name></name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call><operator>.</operator><name>totalHits</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>ir</name><operator>.</operator><name>close</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>ramDir</name><operator>.</operator><name>close</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>hits</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block>{<block_content>
      <return>return <expr><literal type="boolean">true</literal></expr>;</return>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <return>return <expr><literal type="boolean">false</literal></expr>;</return>
    </block_content>}</block></else></if_stmt>

  </block_content>}</block></function>
}
diff <expr_stmt><expr><operator>--</operator><name>git</name> <name>a</name><operator>/</operator><name>lucene</name><operator>/</operator><name>queryparser</name><operator>/</operator><name>src</name><operator>/</operator><name>test</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>queryparser</name><operator>/</operator><name>classic</name><operator>/</operator><name><name>TestQueryParser</name><operator>.</operator><name>java</name></name> <name>b</name><operator>/</operator><name>lucene</name><operator>/</operator><name>queryparser</name><operator>/</operator><name>src</name><operator>/</operator><name>test</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>queryparser</name><operator>/</operator><name>classic</name><operator>/</operator><name><name>TestQueryParser</name><operator>.</operator><name>java</name></name>
<name>index</name> <literal type="number">7a988004b31</literal><operator>..</operator><name>de90e29affe</name> <literal type="number">100644</literal>
<operator>--</operator> <name>a</name><operator>/</operator><name>lucene</name><operator>/</operator><name>queryparser</name><operator>/</operator><name>src</name><operator>/</operator><name>test</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>queryparser</name><operator>/</operator><name>classic</name><operator>/</operator><name><name>TestQueryParser</name><operator>.</operator><name>java</name></name>
<operator>++</operator> <name>b</name><operator>/</operator><name>lucene</name><operator>/</operator><name>queryparser</name><operator>/</operator><name>src</name><operator>/</operator><name>test</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>queryparser</name><operator>/</operator><name>classic</name><operator>/</operator><name><name>TestQueryParser</name><operator>.</operator><name>java</name></name>
@@ <operator>-</operator><literal type="number">18</literal></expr><operator>,</operator><expr><literal type="number">6</literal> <operator>+</operator><literal type="number">18</literal></expr><operator>,</operator><expr><literal type="number">8</literal> @@</expr></expr_stmt> <package>package <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>queryparser</name><operator>.</operator><name>classic</name></name>;</package>
 
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>analysis</name><operator>.</operator><name>Analyzer</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>analysis</name><operator>.</operator><name>MockAnalyzer</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>analysis</name><operator>.</operator><name>MockBytesAnalyzer</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>analysis</name><operator>.</operator><name>MockLowerCaseFilter</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>analysis</name><operator>.</operator><name>MockSynonymAnalyzer</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>analysis</name><operator>.</operator><name>MockTokenizer</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>analysis</name><operator>.</operator><name>TokenFilter</name></name>;</import>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">25</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">27</literal></expr><operator>,</operator><expr><literal type="number">13</literal> @@</expr></expr_stmt> <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>analysis</name><operator>.</operator><name>TokenStream</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>analysis</name><operator>.</operator><name>Tokenizer</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>analysis</name><operator>.</operator><name>tokenattributes</name><operator>.</operator><name>CharTermAttribute</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>analysis</name><operator>.</operator><name>tokenattributes</name><operator>.</operator><name>PositionIncrementAttribute</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>document</name><operator>.</operator><name>Document</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>document</name><operator>.</operator><name>Field</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>document</name><operator>.</operator><name>FieldType</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>document</name><operator>.</operator><name>DateTools</name><operator>.</operator><name>Resolution</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>index</name><operator>.</operator><name>DirectoryReader</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>index</name><operator>.</operator><name>IndexOptions</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>index</name><operator>.</operator><name>RandomIndexWriter</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>index</name><operator>.</operator><name>Term</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>queryparser</name><operator>.</operator><name>classic</name><operator>.</operator><name>QueryParser</name><operator>.</operator><name>Operator</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>queryparser</name><operator>.</operator><name>flexible</name><operator>.</operator><name>standard</name><operator>.</operator><name>CommonQueryParserConfiguration</name></name>;</import>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">33</literal></expr><operator>,</operator><expr><literal type="number">11</literal> <operator>+</operator><literal type="number">41</literal></expr><operator>,</operator><expr><literal type="number">14</literal> @@</expr></expr_stmt> <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>queryparser</name><operator>.</operator><name>util</name><operator>.</operator><name>QueryParserTestBase</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>search</name><operator>.</operator><name>BooleanClause</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>search</name><operator>.</operator><name>BooleanQuery</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>search</name><operator>.</operator><name>BoostQuery</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>search</name><operator>.</operator><name>IndexSearcher</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>search</name><operator>.</operator><name>MatchAllDocsQuery</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>search</name><operator>.</operator><name>MultiPhraseQuery</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>search</name><operator>.</operator><name>PhraseQuery</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>search</name><operator>.</operator><name>Query</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>search</name><operator>.</operator><name>SynonymQuery</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>search</name><operator>.</operator><name>TermQuery</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>store</name><operator>.</operator><name>Directory</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>util</name><operator>.</operator><name>automaton</name><operator>.</operator><name>TooComplexToDeterminizeException</name></name>;</import>
 
 <import>import <name><name>java</name><operator>.</operator><name>io</name><operator>.</operator><name>IOException</name></name>;</import>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">48</literal></expr><operator>,</operator><expr><literal type="number">6</literal> <operator>+</operator><literal type="number">59</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@</expr></expr_stmt> <import>import <name><name>java</name><operator>.</operator><name>io</name><operator>.</operator><name>IOException</name></name>;</import>
 <class><specifier>public</specifier> class <name>TestQueryParser</name> <super_list><extends>extends <super><name>QueryParserTestBase</name></super></extends></super_list> <block>{
 
   <decl_stmt><decl><type><specifier>protected</specifier> <name>boolean</name></type> <name>splitOnWhitespace</name> <init>= <expr><name><name>QueryParser</name><operator>.</operator><name>DEFAULT_SPLIT_ON_WHITESPACE</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>String</name></type> <name>FIELD</name> <init>= <expr><literal type="string">"field"</literal></expr></init></decl>;</decl_stmt>
 
   <class><specifier>public</specifier> <specifier>static</specifier> class <name>QPTestParser</name> <super_list><extends>extends <super><name>QueryParser</name></super></extends></super_list> <block>{
     <constructor><specifier>public</specifier> <name>QPTestParser</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>f</name></decl></parameter>, <parameter><decl><type><name>Analyzer</name></type> <name>a</name></decl></parameter>)</parameter_list> <block>{<block_content>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">114</literal></expr><operator>,</operator><expr><literal type="number">14</literal> <operator>+</operator><literal type="number">126</literal></expr><operator>,</operator><expr><literal type="number">6</literal> @@ <specifier>public</specifier> <name>class</name> <name>TestQueryParser</name> extends <name>QueryParserTestBase</name> <block>{
     <expr><call><name><name>qp</name><operator>.</operator><name>setDefaultOperator</name></name><argument_list>(<argument><expr><name><name>Operator</name><operator>.</operator><name>AND</name></name></expr></argument>)</argument_list></call></expr>;
   }</block>
   
  @<name>Override</name>
  <specifier>public</specifier> <name>void</name> <call><name>setAnalyzeRangeTerms</name><argument_list>(<argument><expr><name>CommonQueryParserConfiguration</name> <name>cqpC</name></expr></argument>,
      <argument><expr><name>boolean</name> <name>value</name></expr></argument>)</argument_list></call> <block>{
    <assert>assert <expr><operator>(</operator><name>cqpC</name> <operator>instanceof</operator> <name>QueryParser</name><operator>)</operator></expr>;</assert>
    <name>QueryParser</name> <name>qp</name> <operator>=</operator> <operator>(</operator><name>QueryParser</name><operator>)</operator> <name>cqpC</name></block></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>qp</name><operator>.</operator><name>setAnalyzeRangeTerms</name></name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></constructor>
  
   <function><annotation>@<name>Override</name></annotation>
   <type><specifier>public</specifier> <name>void</name></type> <name>setAutoGeneratePhraseQueries</name><parameter_list>(<parameter><decl><type><name>CommonQueryParserConfiguration</name></type> <name>cqpC</name></decl></parameter>,
       <parameter><decl><type><name>boolean</name></type> <name>value</name></decl></parameter>)</parameter_list> <block>{<block_content>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">200</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">204</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@ <specifier>public</specifier> <name>class</name> <name>TestQueryParser</name> extends <name>QueryParserTestBase</name> <block>{
   @<expr><name>Override</name>
   <specifier>public</specifier> <name>void</name> <call><name>testStarParsing</name><argument_list>()</argument_list></call> <throws>throws <argument><expr><name>Exception</name> <block>{
     <expr><name>final</name> <name><name>int</name><index>[]</index></name> <name>type</name> <operator>=</operator> <operator>new</operator> <name><name>int</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></block></expr></argument></throws></expr>;
    <expr><name>QueryParser</name> <name>qp</name> <operator>=</operator> <operator>new</operator> <call><name>QueryParser</name><argument_list>(<argument><expr><literal type="string">"field"</literal></expr></argument>,
    <argument><expr><name>QueryParser</name> <name>qp</name> <operator>=</operator> <operator>new</operator> <class><super><name>QueryParser</name></super><argument_list>(<argument><expr><name>FIELD</name></expr></argument>,
         <argument><expr><operator>new</operator> <call><name>MockAnalyzer</name><argument_list>(<argument><expr><call><name>random</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>MockTokenizer</name><operator>.</operator><name>WHITESPACE</name></name></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list> <block>{
       <function><annotation>@<name>Override</name></annotation>
       <type><specifier>protected</specifier> <name>Query</name></type> <name>getWildcardQuery</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>field</name></decl></parameter>, <parameter><decl><type><name>String</name></type> <name>termStr</name></decl></parameter>)</parameter_list> <block>{<block_content>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">285</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">289</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@ <specifier>public</specifier> class <name>TestQueryParser</name> extends <name>QueryParserTestBase</name> <block>{
     <expr><name>Analyzer</name> <name>morePrecise</name> <operator>=</operator> <operator>new</operator> <call><name>Analyzer2</name><argument_list>()</argument_list></call></expr>;
     
     <expr><specifier>public</specifier> <call><name>SmartQueryParser</name><argument_list>()</argument_list></call> <block>{
      <expr><call><name>super</name><argument_list>(<argument><expr><literal type="string">"field"</literal></expr></argument>, <argument><expr><operator>new</operator> <call><name>Analyzer1</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
      <expr><call><name>super</name><argument_list>(<argument><expr><name>FIELD</name></expr></argument>, <argument><expr><operator>new</operator> <call><name>Analyzer1</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
     }</block>
     
     @<name>Override</name>
@@ <operator>-</operator><literal type="number">299</literal></expr>,<expr><literal type="number">9</literal> <operator>+</operator><literal type="number">303</literal></expr>,<expr><literal type="number">9</literal> @@ <specifier>public</specifier> class <name>TestQueryParser</name> extends <name>QueryParserTestBase</name> <block>{
   @<expr><name>Override</name>
   <specifier>public</specifier> <name>void</name> <call><name>testNewFieldQuery</name><argument_list>()</argument_list></call> <throws>throws <argument><expr><name>Exception</name> <block>{
     <comment type="block" format="javadoc">/** ordinary behavior, synonyms form uncoordinated boolean query */</comment>
    <expr><name>QueryParser</name> <name>dumb</name> <operator>=</operator> <operator>new</operator> <call><name>QueryParser</name><argument_list>(<argument><expr><literal type="string">"field"</literal></expr></argument>,
    <argument><expr><name>QueryParser</name> <name>dumb</name> <operator>=</operator> <operator>new</operator> <call><name>QueryParser</name><argument_list>(<argument><expr><name>FIELD</name></expr></argument>,
         <argument><expr><operator>new</operator> <call><name>Analyzer1</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument></argument_list></call></expr></block></expr></argument></throws></expr>;
    <expr><name>Query</name> <name>expanded</name> <operator>=</operator> <operator>new</operator> <call><name>SynonymQuery</name><argument_list>(<argument><expr><operator>new</operator> <call><name>Term</name><argument_list>(<argument><expr><literal type="string">"field"</literal></expr></argument>, <argument><expr><literal type="string">"dogs"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>new</operator> <call><name>Term</name><argument_list>(<argument><expr><literal type="string">"field"</literal></expr></argument>, <argument><expr><literal type="string">"dog"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
    <expr><name>Query</name> <name>expanded</name> <operator>=</operator> <operator>new</operator> <call><name>SynonymQuery</name><argument_list>(<argument><expr><operator>new</operator> <call><name>Term</name><argument_list>(<argument><expr><name>FIELD</name></expr></argument>, <argument><expr><literal type="string">"dogs"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>new</operator> <call><name>Term</name><argument_list>(<argument><expr><name>FIELD</name></expr></argument>, <argument><expr><literal type="string">"dog"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
     <expr><call><name>assertEquals</name><argument_list>(<argument><expr><name>expanded</name></expr></argument>, <argument><expr><call><name><name>dumb</name><operator>.</operator><name>parse</name></name><argument_list>(<argument><expr><literal type="string">"\"dogs\""</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
     <comment type="block" format="javadoc">/** even with the phrase operator the behavior is the same */</comment>
     <expr><call><name>assertEquals</name><argument_list>(<argument><expr><name>expanded</name></expr></argument>, <argument><expr><call><name><name>dumb</name><operator>.</operator><name>parse</name></name><argument_list>(<argument><expr><literal type="string">"dogs"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
@@ <expr><operator>-</operator><literal type="number">312</literal></expr>,<expr><literal type="number">14</literal> <operator>+</operator><literal type="number">316</literal></expr>,<expr><literal type="number">14</literal> @@ <specifier>public</specifier> class <name>TestQueryParser</name> extends <name>QueryParserTestBase</name> <block>{
     <expr><name>QueryParser</name> <name>smart</name> <operator>=</operator> <operator>new</operator> <call><name>SmartQueryParser</name><argument_list>()</argument_list></call></expr>;
     <expr><call><name>assertEquals</name><argument_list>(<argument><expr><name>expanded</name></expr></argument>, <argument><expr><call><name><name>smart</name><operator>.</operator><name>parse</name></name><argument_list>(<argument><expr><literal type="string">"dogs"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
     
    <expr><name>Query</name> <name>unexpanded</name> <operator>=</operator> <operator>new</operator> <call><name>TermQuery</name><argument_list>(<argument><expr><operator>new</operator> <call><name>Term</name><argument_list>(<argument><expr><literal type="string">"field"</literal></expr></argument>, <argument><expr><literal type="string">"dogs"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
    <expr><name>Query</name> <name>unexpanded</name> <operator>=</operator> <operator>new</operator> <call><name>TermQuery</name><argument_list>(<argument><expr><operator>new</operator> <call><name>Term</name><argument_list>(<argument><expr><name>FIELD</name></expr></argument>, <argument><expr><literal type="string">"dogs"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
     <expr><call><name>assertEquals</name><argument_list>(<argument><expr><name>unexpanded</name></expr></argument>, <argument><expr><call><name><name>smart</name><operator>.</operator><name>parse</name></name><argument_list>(<argument><expr><literal type="string">"\"dogs\""</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
   }</block>
 
   <comment type="block" format="javadoc">/** simple synonyms test */</comment>
   <specifier>public</specifier> <name>void</name> <call><name>testSynonyms</name><argument_list>()</argument_list></call> <throws>throws <argument><expr><name>Exception</name> <block>{
    <expr><name>Query</name> <name>expected</name> <operator>=</operator> <operator>new</operator> <call><name>SynonymQuery</name><argument_list>(<argument><expr><operator>new</operator> <call><name>Term</name><argument_list>(<argument><expr><literal type="string">"field"</literal></expr></argument>, <argument><expr><literal type="string">"dogs"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>new</operator> <call><name>Term</name><argument_list>(<argument><expr><literal type="string">"field"</literal></expr></argument>, <argument><expr><literal type="string">"dog"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></block></expr></argument></throws></expr>;
    <expr><name>QueryParser</name> <name>qp</name> <operator>=</operator> <operator>new</operator> <call><name>QueryParser</name><argument_list>(<argument><expr><literal type="string">"field"</literal></expr></argument>, <argument><expr><operator>new</operator> <call><name>MockSynonymAnalyzer</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
    <expr><name>Query</name> <name>expected</name> <operator>=</operator> <operator>new</operator> <call><name>SynonymQuery</name><argument_list>(<argument><expr><operator>new</operator> <call><name>Term</name><argument_list>(<argument><expr><name>FIELD</name></expr></argument>, <argument><expr><literal type="string">"dogs"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>new</operator> <call><name>Term</name><argument_list>(<argument><expr><name>FIELD</name></expr></argument>, <argument><expr><literal type="string">"dog"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
    <expr><name>QueryParser</name> <name>qp</name> <operator>=</operator> <operator>new</operator> <call><name>QueryParser</name><argument_list>(<argument><expr><name>FIELD</name></expr></argument>, <argument><expr><operator>new</operator> <call><name>MockSynonymAnalyzer</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
     <expr><call><name>assertEquals</name><argument_list>(<argument><expr><name>expected</name></expr></argument>, <argument><expr><call><name><name>qp</name><operator>.</operator><name>parse</name></name><argument_list>(<argument><expr><literal type="string">"dogs"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
     <expr><call><name>assertEquals</name><argument_list>(<argument><expr><name>expected</name></expr></argument>, <argument><expr><call><name><name>qp</name><operator>.</operator><name>parse</name></name><argument_list>(<argument><expr><literal type="string">"\"dogs\""</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
     <expr><call><name><name>qp</name><operator>.</operator><name>setDefaultOperator</name></name><argument_list>(<argument><expr><name><name>Operator</name><operator>.</operator><name>AND</name></name></expr></argument>)</argument_list></call></expr>;
@@ <expr><operator>-</operator><literal type="number">333</literal></expr>,<expr><literal type="number">9</literal> <operator>+</operator><literal type="number">337</literal></expr>,<expr><literal type="number">9</literal> @@ <specifier>public</specifier> class <name>TestQueryParser</name> extends <name>QueryParserTestBase</name> <block>{
   <comment type="block" format="javadoc">/** forms multiphrase query */</comment>
   <expr><specifier>public</specifier> <name>void</name> <call><name>testSynonymsPhrase</name><argument_list>()</argument_list></call> <throws>throws <argument><expr><name>Exception</name> <block>{
     <expr><name><name>MultiPhraseQuery</name><operator>.</operator><name>Builder</name></name> <name>expectedQBuilder</name> <operator>=</operator> <operator>new</operator> <call><name><name>MultiPhraseQuery</name><operator>.</operator><name>Builder</name></name><argument_list>()</argument_list></call></expr></block></expr></argument></throws></expr>;
    <expr><call><name><name>expectedQBuilder</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><operator>new</operator> <call><name>Term</name><argument_list>(<argument><expr><literal type="string">"field"</literal></expr></argument>, <argument><expr><literal type="string">"old"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
    <expr><call><name><name>expectedQBuilder</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><operator>new</operator> <name><name>Term</name><index>[]</index></name> <block>{ <expr><operator>new</operator> <call><name>Term</name><argument_list>(<argument><expr><literal type="string">"field"</literal></expr></argument>, <argument><expr><literal type="string">"dogs"</literal></expr></argument>)</argument_list></call></expr>, <expr><operator>new</operator> <call><name>Term</name><argument_list>(<argument><expr><literal type="string">"field"</literal></expr></argument>, <argument><expr><literal type="string">"dog"</literal></expr></argument>)</argument_list></call></expr> }</block></expr></argument>)</argument_list></call></expr>;
    <expr><name>QueryParser</name> <name>qp</name> <operator>=</operator> <operator>new</operator> <call><name>QueryParser</name><argument_list>(<argument><expr><literal type="string">"field"</literal></expr></argument>, <argument><expr><operator>new</operator> <call><name>MockSynonymAnalyzer</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
    <expr><call><name><name>expectedQBuilder</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><operator>new</operator> <call><name>Term</name><argument_list>(<argument><expr><name>FIELD</name></expr></argument>, <argument><expr><literal type="string">"old"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
    <expr><call><name><name>expectedQBuilder</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><operator>new</operator> <name><name>Term</name><index>[]</index></name> <block>{ <expr><operator>new</operator> <call><name>Term</name><argument_list>(<argument><expr><name>FIELD</name></expr></argument>, <argument><expr><literal type="string">"dogs"</literal></expr></argument>)</argument_list></call></expr>, <expr><operator>new</operator> <call><name>Term</name><argument_list>(<argument><expr><name>FIELD</name></expr></argument>, <argument><expr><literal type="string">"dog"</literal></expr></argument>)</argument_list></call></expr> }</block></expr></argument>)</argument_list></call></expr>;
    <expr><name>QueryParser</name> <name>qp</name> <operator>=</operator> <operator>new</operator> <call><name>QueryParser</name><argument_list>(<argument><expr><name>FIELD</name></expr></argument>, <argument><expr><operator>new</operator> <call><name>MockSynonymAnalyzer</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
     <expr><call><name>assertEquals</name><argument_list>(<argument><expr><call><name><name>expectedQBuilder</name><operator>.</operator><name>build</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>qp</name><operator>.</operator><name>parse</name></name><argument_list>(<argument><expr><literal type="string">"\"old dogs\""</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
     <expr><call><name><name>qp</name><operator>.</operator><name>setDefaultOperator</name></name><argument_list>(<argument><expr><name><name>Operator</name><operator>.</operator><name>AND</name></name></expr></argument>)</argument_list></call></expr>;
     <expr><call><name>assertEquals</name><argument_list>(<argument><expr><call><name><name>expectedQBuilder</name><operator>.</operator><name>build</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>qp</name><operator>.</operator><name>parse</name></name><argument_list>(<argument><expr><literal type="string">"\"old dogs\""</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
@@ <expr><operator>-</operator><literal type="number">387</literal></expr>,<expr><literal type="number">8</literal> <operator>+</operator><literal type="number">391</literal></expr>,<expr><literal type="number">8</literal> @@ <specifier>public</specifier> class <name>TestQueryParser</name> extends <name>QueryParserTestBase</name> <block>{
   
   <comment type="block" format="javadoc">/** simple CJK synonym test */</comment>
   <expr><specifier>public</specifier> <name>void</name> <call><name>testCJKSynonym</name><argument_list>()</argument_list></call> <throws>throws <argument><expr><name>Exception</name> <block>{
    <expr><name>Query</name> <name>expected</name> <operator>=</operator> <operator>new</operator> <call><name>SynonymQuery</name><argument_list>(<argument><expr><operator>new</operator> <call><name>Term</name><argument_list>(<argument><expr><literal type="string">"field"</literal></expr></argument>, <argument><expr><literal type="string">"å½"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>new</operator> <call><name>Term</name><argument_list>(<argument><expr><literal type="string">"field"</literal></expr></argument>, <argument><expr><literal type="string">"å"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></block></expr></argument></throws></expr>;
    <expr><name>QueryParser</name> <name>qp</name> <operator>=</operator> <operator>new</operator> <call><name>QueryParser</name><argument_list>(<argument><expr><literal type="string">"field"</literal></expr></argument>, <argument><expr><operator>new</operator> <call><name>MockCJKSynonymAnalyzer</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
    <expr><name>Query</name> <name>expected</name> <operator>=</operator> <operator>new</operator> <call><name>SynonymQuery</name><argument_list>(<argument><expr><operator>new</operator> <call><name>Term</name><argument_list>(<argument><expr><name>FIELD</name></expr></argument>, <argument><expr><literal type="string">"å½"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>new</operator> <call><name>Term</name><argument_list>(<argument><expr><name>FIELD</name></expr></argument>, <argument><expr><literal type="string">"å"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
    <expr><name>QueryParser</name> <name>qp</name> <operator>=</operator> <operator>new</operator> <call><name>QueryParser</name><argument_list>(<argument><expr><name>FIELD</name></expr></argument>, <argument><expr><operator>new</operator> <call><name>MockCJKSynonymAnalyzer</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
     <expr><call><name>assertEquals</name><argument_list>(<argument><expr><name>expected</name></expr></argument>, <argument><expr><call><name><name>qp</name><operator>.</operator><name>parse</name></name><argument_list>(<argument><expr><literal type="string">"å½"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
     <expr><call><name><name>qp</name><operator>.</operator><name>setDefaultOperator</name></name><argument_list>(<argument><expr><name><name>Operator</name><operator>.</operator><name>AND</name></name></expr></argument>)</argument_list></call></expr>;
     <expr><call><name>assertEquals</name><argument_list>(<argument><expr><name>expected</name></expr></argument>, <argument><expr><call><name><name>qp</name><operator>.</operator><name>parse</name></name><argument_list>(<argument><expr><literal type="string">"å½"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
@@ <expr><operator>-</operator><literal type="number">399</literal></expr>,<expr><literal type="number">11</literal> <operator>+</operator><literal type="number">403</literal></expr>,<expr><literal type="number">11</literal> @@ <specifier>public</specifier> class <name>TestQueryParser</name> extends <name>QueryParserTestBase</name> <block>{
   <comment type="block" format="javadoc">/** synonyms with default OR operator */</comment>
   <expr><specifier>public</specifier> <name>void</name> <call><name>testCJKSynonymsOR</name><argument_list>()</argument_list></call> <throws>throws <argument><expr><name>Exception</name> <block>{
     <expr><name><name>BooleanQuery</name><operator>.</operator><name>Builder</name></name> <name>expectedB</name> <operator>=</operator> <operator>new</operator> <call><name><name>BooleanQuery</name><operator>.</operator><name>Builder</name></name><argument_list>()</argument_list></call></expr></block></expr></argument></throws></expr>;
    <expr><call><name><name>expectedB</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><operator>new</operator> <call><name>TermQuery</name><argument_list>(<argument><expr><operator>new</operator> <call><name>Term</name><argument_list>(<argument><expr><literal type="string">"field"</literal></expr></argument>, <argument><expr><literal type="string">"ä¸­"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>BooleanClause</name><operator>.</operator><name>Occur</name><operator>.</operator><name>SHOULD</name></name></expr></argument>)</argument_list></call></expr>;
    <expr><name>Query</name> <name>inner</name> <operator>=</operator> <operator>new</operator> <call><name>SynonymQuery</name><argument_list>(<argument><expr><operator>new</operator> <call><name>Term</name><argument_list>(<argument><expr><literal type="string">"field"</literal></expr></argument>, <argument><expr><literal type="string">"å½"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>new</operator> <call><name>Term</name><argument_list>(<argument><expr><literal type="string">"field"</literal></expr></argument>, <argument><expr><literal type="string">"å"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
    <expr><call><name><name>expectedB</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><operator>new</operator> <call><name>TermQuery</name><argument_list>(<argument><expr><operator>new</operator> <call><name>Term</name><argument_list>(<argument><expr><name>FIELD</name></expr></argument>, <argument><expr><literal type="string">"ä¸­"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>BooleanClause</name><operator>.</operator><name>Occur</name><operator>.</operator><name>SHOULD</name></name></expr></argument>)</argument_list></call></expr>;
    <expr><name>Query</name> <name>inner</name> <operator>=</operator> <operator>new</operator> <call><name>SynonymQuery</name><argument_list>(<argument><expr><operator>new</operator> <call><name>Term</name><argument_list>(<argument><expr><name>FIELD</name></expr></argument>, <argument><expr><literal type="string">"å½"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>new</operator> <call><name>Term</name><argument_list>(<argument><expr><name>FIELD</name></expr></argument>, <argument><expr><literal type="string">"å"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
     <expr><call><name><name>expectedB</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name>inner</name></expr></argument>, <argument><expr><name><name>BooleanClause</name><operator>.</operator><name>Occur</name><operator>.</operator><name>SHOULD</name></name></expr></argument>)</argument_list></call></expr>;
     <expr><name>Query</name> <name>expected</name> <operator>=</operator> <call><name><name>expectedB</name><operator>.</operator><name>build</name></name><argument_list>()</argument_list></call></expr>;
    <expr><name>QueryParser</name> <name>qp</name> <operator>=</operator> <operator>new</operator> <call><name>QueryParser</name><argument_list>(<argument><expr><literal type="string">"field"</literal></expr></argument>, <argument><expr><operator>new</operator> <call><name>MockCJKSynonymAnalyzer</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
    <expr><name>QueryParser</name> <name>qp</name> <operator>=</operator> <operator>new</operator> <call><name>QueryParser</name><argument_list>(<argument><expr><name>FIELD</name></expr></argument>, <argument><expr><operator>new</operator> <call><name>MockCJKSynonymAnalyzer</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
     <expr><call><name>assertEquals</name><argument_list>(<argument><expr><name>expected</name></expr></argument>, <argument><expr><call><name><name>qp</name><operator>.</operator><name>parse</name></name><argument_list>(<argument><expr><literal type="string">"ä¸­å½"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
     <expr><name>expected</name> <operator>=</operator> <operator>new</operator> <call><name>BoostQuery</name><argument_list>(<argument><expr><name>expected</name></expr></argument>, <argument><expr><literal type="number">2f</literal></expr></argument>)</argument_list></call></expr>;
     <expr><call><name>assertEquals</name><argument_list>(<argument><expr><name>expected</name></expr></argument>, <argument><expr><call><name><name>qp</name><operator>.</operator><name>parse</name></name><argument_list>(<argument><expr><literal type="string">"ä¸­å½^2"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
@@ <expr><operator>-</operator><literal type="number">412</literal></expr>,<expr><literal type="number">13</literal> <operator>+</operator><literal type="number">416</literal></expr>,<expr><literal type="number">13</literal> @@ <specifier>public</specifier> class <name>TestQueryParser</name> extends <name>QueryParserTestBase</name> <block>{
   <comment type="block" format="javadoc">/** more complex synonyms with default OR operator */</comment>
   <expr><specifier>public</specifier> <name>void</name> <call><name>testCJKSynonymsOR2</name><argument_list>()</argument_list></call> <throws>throws <argument><expr><name>Exception</name> <block>{
     <expr><name><name>BooleanQuery</name><operator>.</operator><name>Builder</name></name> <name>expectedB</name> <operator>=</operator> <operator>new</operator> <call><name><name>BooleanQuery</name><operator>.</operator><name>Builder</name></name><argument_list>()</argument_list></call></expr></block></expr></argument></throws></expr>;
    <expr><call><name><name>expectedB</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><operator>new</operator> <call><name>TermQuery</name><argument_list>(<argument><expr><operator>new</operator> <call><name>Term</name><argument_list>(<argument><expr><literal type="string">"field"</literal></expr></argument>, <argument><expr><literal type="string">"ä¸­"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>BooleanClause</name><operator>.</operator><name>Occur</name><operator>.</operator><name>SHOULD</name></name></expr></argument>)</argument_list></call></expr>;
    <expr><name>SynonymQuery</name> <name>inner</name> <operator>=</operator> <operator>new</operator> <call><name>SynonymQuery</name><argument_list>(<argument><expr><operator>new</operator> <call><name>Term</name><argument_list>(<argument><expr><literal type="string">"field"</literal></expr></argument>, <argument><expr><literal type="string">"å½"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>new</operator> <call><name>Term</name><argument_list>(<argument><expr><literal type="string">"field"</literal></expr></argument>, <argument><expr><literal type="string">"å"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
    <expr><call><name><name>expectedB</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><operator>new</operator> <call><name>TermQuery</name><argument_list>(<argument><expr><operator>new</operator> <call><name>Term</name><argument_list>(<argument><expr><name>FIELD</name></expr></argument>, <argument><expr><literal type="string">"ä¸­"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>BooleanClause</name><operator>.</operator><name>Occur</name><operator>.</operator><name>SHOULD</name></name></expr></argument>)</argument_list></call></expr>;
    <expr><name>SynonymQuery</name> <name>inner</name> <operator>=</operator> <operator>new</operator> <call><name>SynonymQuery</name><argument_list>(<argument><expr><operator>new</operator> <call><name>Term</name><argument_list>(<argument><expr><name>FIELD</name></expr></argument>, <argument><expr><literal type="string">"å½"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>new</operator> <call><name>Term</name><argument_list>(<argument><expr><name>FIELD</name></expr></argument>, <argument><expr><literal type="string">"å"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
     <expr><call><name><name>expectedB</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name>inner</name></expr></argument>, <argument><expr><name><name>BooleanClause</name><operator>.</operator><name>Occur</name><operator>.</operator><name>SHOULD</name></name></expr></argument>)</argument_list></call></expr>;
    <expr><name>SynonymQuery</name> <name>inner2</name> <operator>=</operator> <operator>new</operator> <call><name>SynonymQuery</name><argument_list>(<argument><expr><operator>new</operator> <call><name>Term</name><argument_list>(<argument><expr><literal type="string">"field"</literal></expr></argument>, <argument><expr><literal type="string">"å½"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>new</operator> <call><name>Term</name><argument_list>(<argument><expr><literal type="string">"field"</literal></expr></argument>, <argument><expr><literal type="string">"å"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
    <expr><name>SynonymQuery</name> <name>inner2</name> <operator>=</operator> <operator>new</operator> <call><name>SynonymQuery</name><argument_list>(<argument><expr><operator>new</operator> <call><name>Term</name><argument_list>(<argument><expr><name>FIELD</name></expr></argument>, <argument><expr><literal type="string">"å½"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>new</operator> <call><name>Term</name><argument_list>(<argument><expr><name>FIELD</name></expr></argument>, <argument><expr><literal type="string">"å"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
     <expr><call><name><name>expectedB</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name>inner2</name></expr></argument>, <argument><expr><name><name>BooleanClause</name><operator>.</operator><name>Occur</name><operator>.</operator><name>SHOULD</name></name></expr></argument>)</argument_list></call></expr>;
     <expr><name>Query</name> <name>expected</name> <operator>=</operator> <call><name><name>expectedB</name><operator>.</operator><name>build</name></name><argument_list>()</argument_list></call></expr>;
    <expr><name>QueryParser</name> <name>qp</name> <operator>=</operator> <operator>new</operator> <call><name>QueryParser</name><argument_list>(<argument><expr><literal type="string">"field"</literal></expr></argument>, <argument><expr><operator>new</operator> <call><name>MockCJKSynonymAnalyzer</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
    <expr><name>QueryParser</name> <name>qp</name> <operator>=</operator> <operator>new</operator> <call><name>QueryParser</name><argument_list>(<argument><expr><name>FIELD</name></expr></argument>, <argument><expr><operator>new</operator> <call><name>MockCJKSynonymAnalyzer</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
     <expr><call><name>assertEquals</name><argument_list>(<argument><expr><name>expected</name></expr></argument>, <argument><expr><call><name><name>qp</name><operator>.</operator><name>parse</name></name><argument_list>(<argument><expr><literal type="string">"ä¸­å½å½"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
     <expr><name>expected</name> <operator>=</operator> <operator>new</operator> <call><name>BoostQuery</name><argument_list>(<argument><expr><name>expected</name></expr></argument>, <argument><expr><literal type="number">2f</literal></expr></argument>)</argument_list></call></expr>;
     <expr><call><name>assertEquals</name><argument_list>(<argument><expr><name>expected</name></expr></argument>, <argument><expr><call><name><name>qp</name><operator>.</operator><name>parse</name></name><argument_list>(<argument><expr><literal type="string">"ä¸­å½å½^2"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
@@ <expr><operator>-</operator><literal type="number">427</literal></expr>,<expr><literal type="number">11</literal> <operator>+</operator><literal type="number">431</literal></expr>,<expr><literal type="number">11</literal> @@ <specifier>public</specifier> class <name>TestQueryParser</name> extends <name>QueryParserTestBase</name> <block>{
   <comment type="block" format="javadoc">/** synonyms with default AND operator */</comment>
   <expr><specifier>public</specifier> <name>void</name> <call><name>testCJKSynonymsAND</name><argument_list>()</argument_list></call> <throws>throws <argument><expr><name>Exception</name> <block>{
     <expr><name><name>BooleanQuery</name><operator>.</operator><name>Builder</name></name> <name>expectedB</name> <operator>=</operator> <operator>new</operator> <call><name><name>BooleanQuery</name><operator>.</operator><name>Builder</name></name><argument_list>()</argument_list></call></expr></block></expr></argument></throws></expr>;
    <expr><call><name><name>expectedB</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><operator>new</operator> <call><name>TermQuery</name><argument_list>(<argument><expr><operator>new</operator> <call><name>Term</name><argument_list>(<argument><expr><literal type="string">"field"</literal></expr></argument>, <argument><expr><literal type="string">"ä¸­"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>BooleanClause</name><operator>.</operator><name>Occur</name><operator>.</operator><name>MUST</name></name></expr></argument>)</argument_list></call></expr>;
    <expr><name>Query</name> <name>inner</name> <operator>=</operator> <operator>new</operator> <call><name>SynonymQuery</name><argument_list>(<argument><expr><operator>new</operator> <call><name>Term</name><argument_list>(<argument><expr><literal type="string">"field"</literal></expr></argument>, <argument><expr><literal type="string">"å½"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>new</operator> <call><name>Term</name><argument_list>(<argument><expr><literal type="string">"field"</literal></expr></argument>, <argument><expr><literal type="string">"å"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
    <expr><call><name><name>expectedB</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><operator>new</operator> <call><name>TermQuery</name><argument_list>(<argument><expr><operator>new</operator> <call><name>Term</name><argument_list>(<argument><expr><name>FIELD</name></expr></argument>, <argument><expr><literal type="string">"ä¸­"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>BooleanClause</name><operator>.</operator><name>Occur</name><operator>.</operator><name>MUST</name></name></expr></argument>)</argument_list></call></expr>;
    <expr><name>Query</name> <name>inner</name> <operator>=</operator> <operator>new</operator> <call><name>SynonymQuery</name><argument_list>(<argument><expr><operator>new</operator> <call><name>Term</name><argument_list>(<argument><expr><name>FIELD</name></expr></argument>, <argument><expr><literal type="string">"å½"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>new</operator> <call><name>Term</name><argument_list>(<argument><expr><name>FIELD</name></expr></argument>, <argument><expr><literal type="string">"å"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
     <expr><call><name><name>expectedB</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name>inner</name></expr></argument>, <argument><expr><name><name>BooleanClause</name><operator>.</operator><name>Occur</name><operator>.</operator><name>MUST</name></name></expr></argument>)</argument_list></call></expr>;
     <expr><name>Query</name> <name>expected</name> <operator>=</operator> <call><name><name>expectedB</name><operator>.</operator><name>build</name></name><argument_list>()</argument_list></call></expr>;
    <expr><name>QueryParser</name> <name>qp</name> <operator>=</operator> <operator>new</operator> <call><name>QueryParser</name><argument_list>(<argument><expr><literal type="string">"field"</literal></expr></argument>, <argument><expr><operator>new</operator> <call><name>MockCJKSynonymAnalyzer</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
    <expr><name>QueryParser</name> <name>qp</name> <operator>=</operator> <operator>new</operator> <call><name>QueryParser</name><argument_list>(<argument><expr><name>FIELD</name></expr></argument>, <argument><expr><operator>new</operator> <call><name>MockCJKSynonymAnalyzer</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
     <expr><call><name><name>qp</name><operator>.</operator><name>setDefaultOperator</name></name><argument_list>(<argument><expr><name><name>Operator</name><operator>.</operator><name>AND</name></name></expr></argument>)</argument_list></call></expr>;
     <expr><call><name>assertEquals</name><argument_list>(<argument><expr><name>expected</name></expr></argument>, <argument><expr><call><name><name>qp</name><operator>.</operator><name>parse</name></name><argument_list>(<argument><expr><literal type="string">"ä¸­å½"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
     <expr><name>expected</name> <operator>=</operator> <operator>new</operator> <call><name>BoostQuery</name><argument_list>(<argument><expr><name>expected</name></expr></argument>, <argument><expr><literal type="number">2f</literal></expr></argument>)</argument_list></call></expr>;
@@ <expr><operator>-</operator><literal type="number">441</literal></expr>,<expr><literal type="number">13</literal> <operator>+</operator><literal type="number">445</literal></expr>,<expr><literal type="number">13</literal> @@ <specifier>public</specifier> class <name>TestQueryParser</name> extends <name>QueryParserTestBase</name> <block>{
   <comment type="block" format="javadoc">/** more complex synonyms with default AND operator */</comment>
   <expr><specifier>public</specifier> <name>void</name> <call><name>testCJKSynonymsAND2</name><argument_list>()</argument_list></call> <throws>throws <argument><expr><name>Exception</name> <block>{
     <expr><name><name>BooleanQuery</name><operator>.</operator><name>Builder</name></name> <name>expectedB</name> <operator>=</operator> <operator>new</operator> <call><name><name>BooleanQuery</name><operator>.</operator><name>Builder</name></name><argument_list>()</argument_list></call></expr></block></expr></argument></throws></expr>;
    <expr><call><name><name>expectedB</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><operator>new</operator> <call><name>TermQuery</name><argument_list>(<argument><expr><operator>new</operator> <call><name>Term</name><argument_list>(<argument><expr><literal type="string">"field"</literal></expr></argument>, <argument><expr><literal type="string">"ä¸­"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>BooleanClause</name><operator>.</operator><name>Occur</name><operator>.</operator><name>MUST</name></name></expr></argument>)</argument_list></call></expr>;
    <expr><name>Query</name> <name>inner</name> <operator>=</operator> <operator>new</operator> <call><name>SynonymQuery</name><argument_list>(<argument><expr><operator>new</operator> <call><name>Term</name><argument_list>(<argument><expr><literal type="string">"field"</literal></expr></argument>, <argument><expr><literal type="string">"å½"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>new</operator> <call><name>Term</name><argument_list>(<argument><expr><literal type="string">"field"</literal></expr></argument>, <argument><expr><literal type="string">"å"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
    <expr><call><name><name>expectedB</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><operator>new</operator> <call><name>TermQuery</name><argument_list>(<argument><expr><operator>new</operator> <call><name>Term</name><argument_list>(<argument><expr><name>FIELD</name></expr></argument>, <argument><expr><literal type="string">"ä¸­"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>BooleanClause</name><operator>.</operator><name>Occur</name><operator>.</operator><name>MUST</name></name></expr></argument>)</argument_list></call></expr>;
    <expr><name>Query</name> <name>inner</name> <operator>=</operator> <operator>new</operator> <call><name>SynonymQuery</name><argument_list>(<argument><expr><operator>new</operator> <call><name>Term</name><argument_list>(<argument><expr><name>FIELD</name></expr></argument>, <argument><expr><literal type="string">"å½"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>new</operator> <call><name>Term</name><argument_list>(<argument><expr><name>FIELD</name></expr></argument>, <argument><expr><literal type="string">"å"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
     <expr><call><name><name>expectedB</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name>inner</name></expr></argument>, <argument><expr><name><name>BooleanClause</name><operator>.</operator><name>Occur</name><operator>.</operator><name>MUST</name></name></expr></argument>)</argument_list></call></expr>;
    <expr><name>Query</name> <name>inner2</name> <operator>=</operator> <operator>new</operator> <call><name>SynonymQuery</name><argument_list>(<argument><expr><operator>new</operator> <call><name>Term</name><argument_list>(<argument><expr><literal type="string">"field"</literal></expr></argument>, <argument><expr><literal type="string">"å½"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>new</operator> <call><name>Term</name><argument_list>(<argument><expr><literal type="string">"field"</literal></expr></argument>, <argument><expr><literal type="string">"å"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
    <expr><name>Query</name> <name>inner2</name> <operator>=</operator> <operator>new</operator> <call><name>SynonymQuery</name><argument_list>(<argument><expr><operator>new</operator> <call><name>Term</name><argument_list>(<argument><expr><name>FIELD</name></expr></argument>, <argument><expr><literal type="string">"å½"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>new</operator> <call><name>Term</name><argument_list>(<argument><expr><name>FIELD</name></expr></argument>, <argument><expr><literal type="string">"å"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
     <expr><call><name><name>expectedB</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name>inner2</name></expr></argument>, <argument><expr><name><name>BooleanClause</name><operator>.</operator><name>Occur</name><operator>.</operator><name>MUST</name></name></expr></argument>)</argument_list></call></expr>;
     <expr><name>Query</name> <name>expected</name> <operator>=</operator> <call><name><name>expectedB</name><operator>.</operator><name>build</name></name><argument_list>()</argument_list></call></expr>;
    <expr><name>QueryParser</name> <name>qp</name> <operator>=</operator> <operator>new</operator> <call><name>QueryParser</name><argument_list>(<argument><expr><literal type="string">"field"</literal></expr></argument>, <argument><expr><operator>new</operator> <call><name>MockCJKSynonymAnalyzer</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
    <expr><name>QueryParser</name> <name>qp</name> <operator>=</operator> <operator>new</operator> <call><name>QueryParser</name><argument_list>(<argument><expr><name>FIELD</name></expr></argument>, <argument><expr><operator>new</operator> <call><name>MockCJKSynonymAnalyzer</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
     <expr><call><name><name>qp</name><operator>.</operator><name>setDefaultOperator</name></name><argument_list>(<argument><expr><name><name>Operator</name><operator>.</operator><name>AND</name></name></expr></argument>)</argument_list></call></expr>;
     <expr><call><name>assertEquals</name><argument_list>(<argument><expr><name>expected</name></expr></argument>, <argument><expr><call><name><name>qp</name><operator>.</operator><name>parse</name></name><argument_list>(<argument><expr><literal type="string">"ä¸­å½å½"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
     <expr><name>expected</name> <operator>=</operator> <operator>new</operator> <call><name>BoostQuery</name><argument_list>(<argument><expr><name>expected</name></expr></argument>, <argument><expr><literal type="number">2f</literal></expr></argument>)</argument_list></call></expr>;
@@ <expr><operator>-</operator><literal type="number">457</literal></expr>,<expr><literal type="number">9</literal> <operator>+</operator><literal type="number">461</literal></expr>,<expr><literal type="number">9</literal> @@ <specifier>public</specifier> class <name>TestQueryParser</name> extends <name>QueryParserTestBase</name> <block>{
   <comment type="block" format="javadoc">/** forms multiphrase query */</comment>
   <expr><specifier>public</specifier> <name>void</name> <call><name>testCJKSynonymsPhrase</name><argument_list>()</argument_list></call> <throws>throws <argument><expr><name>Exception</name> <block>{
     <expr><name><name>MultiPhraseQuery</name><operator>.</operator><name>Builder</name></name> <name>expectedQBuilder</name> <operator>=</operator> <operator>new</operator> <call><name><name>MultiPhraseQuery</name><operator>.</operator><name>Builder</name></name><argument_list>()</argument_list></call></expr></block></expr></argument></throws></expr>;
    <expr><call><name><name>expectedQBuilder</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><operator>new</operator> <call><name>Term</name><argument_list>(<argument><expr><literal type="string">"field"</literal></expr></argument>, <argument><expr><literal type="string">"ä¸­"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
    <expr><call><name><name>expectedQBuilder</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><operator>new</operator> <name><name>Term</name><index>[]</index></name> <block>{ <expr><operator>new</operator> <call><name>Term</name><argument_list>(<argument><expr><literal type="string">"field"</literal></expr></argument>, <argument><expr><literal type="string">"å½"</literal></expr></argument>)</argument_list></call></expr>, <expr><operator>new</operator> <call><name>Term</name><argument_list>(<argument><expr><literal type="string">"field"</literal></expr></argument>, <argument><expr><literal type="string">"å"</literal></expr></argument>)</argument_list></call></expr>}</block></expr></argument>)</argument_list></call></expr>;
    <expr><name>QueryParser</name> <name>qp</name> <operator>=</operator> <operator>new</operator> <call><name>QueryParser</name><argument_list>(<argument><expr><literal type="string">"field"</literal></expr></argument>, <argument><expr><operator>new</operator> <call><name>MockCJKSynonymAnalyzer</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
    <expr><call><name><name>expectedQBuilder</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><operator>new</operator> <call><name>Term</name><argument_list>(<argument><expr><name>FIELD</name></expr></argument>, <argument><expr><literal type="string">"ä¸­"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
    <expr><call><name><name>expectedQBuilder</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><operator>new</operator> <name><name>Term</name><index>[]</index></name> <block>{ <expr><operator>new</operator> <call><name>Term</name><argument_list>(<argument><expr><name>FIELD</name></expr></argument>, <argument><expr><literal type="string">"å½"</literal></expr></argument>)</argument_list></call></expr>, <expr><operator>new</operator> <call><name>Term</name><argument_list>(<argument><expr><name>FIELD</name></expr></argument>, <argument><expr><literal type="string">"å"</literal></expr></argument>)</argument_list></call></expr>}</block></expr></argument>)</argument_list></call></expr>;
    <expr><name>QueryParser</name> <name>qp</name> <operator>=</operator> <operator>new</operator> <call><name>QueryParser</name><argument_list>(<argument><expr><name>FIELD</name></expr></argument>, <argument><expr><operator>new</operator> <call><name>MockCJKSynonymAnalyzer</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
     <expr><call><name><name>qp</name><operator>.</operator><name>setDefaultOperator</name></name><argument_list>(<argument><expr><name><name>Operator</name><operator>.</operator><name>AND</name></name></expr></argument>)</argument_list></call></expr>;
     <expr><call><name>assertEquals</name><argument_list>(<argument><expr><call><name><name>expectedQBuilder</name><operator>.</operator><name>build</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>qp</name><operator>.</operator><name>parse</name></name><argument_list>(<argument><expr><literal type="string">"\"ä¸­å½\""</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
     <expr><name>Query</name> <name>expected</name> <operator>=</operator> <operator>new</operator> <call><name>BoostQuery</name><argument_list>(<argument><expr><call><name><name>expectedQBuilder</name><operator>.</operator><name>build</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="number">2f</literal></expr></argument>)</argument_list></call></expr>;
@@ <expr><operator>-</operator><literal type="number">471</literal></expr>,<expr><literal type="number">7</literal> <operator>+</operator><literal type="number">475</literal></expr>,<expr><literal type="number">7</literal> @@ <specifier>public</specifier> class <name>TestQueryParser</name> extends <name>QueryParserTestBase</name> <block>{
 
   <comment type="block" format="javadoc">/** LUCENE-6677: make sure wildcard query respects maxDeterminizedStates. */</comment>
   <expr><specifier>public</specifier> <name>void</name> <call><name>testWildcardMaxDeterminizedStates</name><argument_list>()</argument_list></call> <throws>throws <argument><expr><name>Exception</name> <block>{
    <expr><name>QueryParser</name> <name>qp</name> <operator>=</operator> <operator>new</operator> <call><name>QueryParser</name><argument_list>(<argument><expr><literal type="string">"field"</literal></expr></argument>, <argument><expr><operator>new</operator> <call><name>MockAnalyzer</name><argument_list>(<argument><expr><call><name>random</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></block></expr></argument></throws></expr>;
    <expr><name>QueryParser</name> <name>qp</name> <operator>=</operator> <operator>new</operator> <call><name>QueryParser</name><argument_list>(<argument><expr><name>FIELD</name></expr></argument>, <argument><expr><operator>new</operator> <call><name>MockAnalyzer</name><argument_list>(<argument><expr><call><name>random</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
     <expr><call><name><name>qp</name><operator>.</operator><name>setMaxDeterminizedStates</name></name><argument_list>(<argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;
     <expr><call><name>expectThrows</name><argument_list>(<argument><expr><name><name>TooComplexToDeterminizeException</name><operator>.</operator><name>class</name></name></expr></argument>, <argument><expr><lambda><parameter_list>()</parameter_list> -&gt; <block>{<block_content>
       <expr_stmt><expr><call><name><name>qp</name><operator>.</operator><name>parse</name></name><argument_list>(<argument><expr><literal type="string">"a*aaaaaaa"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">703</literal></expr><operator>,</operator><expr><literal type="number">4</literal> <operator>+</operator><literal type="number">707</literal></expr><operator>,</operator><expr><literal type="number">163</literal> @@ <specifier>public</specifier> class <name>TestQueryParser</name> extends <name>QueryParserTestBase</name> <block>{<block_content>
     <expr_stmt><expr><call><name>assertQueryEquals</name><argument_list>(<argument><expr><literal type="string">"guinea pig"</literal></expr></argument>, <argument><expr><operator>new</operator> <call><name>MockSynonymAnalyzer</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="string">"Synonym(cavy guinea) pig"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
     <expr_stmt><expr><name>splitOnWhitespace</name> <operator>=</operator> <name>oldSplitOnWhitespace</name></expr>;</expr_stmt>
   <expr_stmt/>}</block_content>
}
\ No newline at end of file
   
  public void testWildcardAlone(</block></expr></expr_stmt>)</block_content> <throws>throws <argument><expr><name>ParseException</name> <block>{
    <comment type="line">//seems like crazy edge case, but can be useful in concordance </comment>
    <expr><name>QueryParser</name> <name>parser</name> <operator>=</operator> <operator>new</operator> <call><name>QueryParser</name><argument_list>(<argument><expr><name>FIELD</name></expr></argument>, <argument><expr><operator>new</operator> <call><name>ASCIIAnalyzer</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></block></expr></argument></throws></block></lambda></expr></argument>;
    <argument><expr><call><name><name>parser</name><operator>.</operator><name>setAllowLeadingWildcard</name></name><argument_list>(<argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr></argument>;
    <argument><expr><call><name>expectThrows</name><argument_list>(<argument><expr><name><name>ParseException</name><operator>.</operator><name>class</name></name></expr></argument>, <argument><expr><lambda><parameter_list>()</parameter_list> -&gt; <block>{<block_content>
      <expr_stmt><expr><call><name><name>parser</name><operator>.</operator><name>parse</name></name><argument_list>(<argument><expr><literal type="string">"*"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt/>}</block_content></block></lambda></expr></argument>)</argument_list></call></expr></argument>;

    <argument><expr><name>QueryParser</name> <name>parser2</name> <operator>=</operator> <operator>new</operator> <call><name>QueryParser</name><argument_list>(<argument><expr><literal type="string">"*"</literal></expr></argument>, <argument><expr><operator>new</operator> <call><name>ASCIIAnalyzer</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>;
    <argument><expr><call><name><name>parser2</name><operator>.</operator><name>setAllowLeadingWildcard</name></name><argument_list>(<argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr></argument>;
    <argument><expr><call><name>assertEquals</name><argument_list>(<argument><expr><operator>new</operator> <call><name>MatchAllDocsQuery</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>parser2</name><operator>.</operator><name>parse</name></name><argument_list>(<argument><expr><literal type="string">"*"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>;
  }</argument_list></call>

  <specifier>public</specifier> <name>void</name> <call><name>testWildCardEscapes</name><argument_list>()</argument_list></call> <throws>throws <argument><expr><name>ParseException</name></expr></argument>, <argument><expr><name>IOException</name> <block>{
    <expr><name>Analyzer</name> <name>a</name> <operator>=</operator> <operator>new</operator> <call><name>ASCIIAnalyzer</name><argument_list>()</argument_list></call></expr></block></expr></argument></throws></expr>;
    <expr><name>QueryParser</name> <name>parser</name> <operator>=</operator> <operator>new</operator> <call><name>QueryParser</name><argument_list>(<argument><expr><name>FIELD</name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;
    <expr><call><name>assertTrue</name><argument_list>(<argument><expr><call><name>isAHit</name><argument_list>(<argument><expr><call><name><name>parser</name><operator>.</operator><name>parse</name></name><argument_list>(<argument><expr><literal type="string">"mÃ¶*tley"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"moatley"</literal></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
    <comment type="line">// need to have at least one genuine wildcard to trigger the wildcard analysis</comment>
    <comment type="line">// hence the * before the y</comment>
    <expr><call><name>assertTrue</name><argument_list>(<argument><expr><call><name>isAHit</name><argument_list>(<argument><expr><call><name><name>parser</name><operator>.</operator><name>parse</name></name><argument_list>(<argument><expr><literal type="string">"mÃ¶\\*tl*y"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"mo*tley"</literal></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
    <comment type="line">// escaped backslash then true wildcard</comment>
    <expr><call><name>assertTrue</name><argument_list>(<argument><expr><call><name>isAHit</name><argument_list>(<argument><expr><call><name><name>parser</name><operator>.</operator><name>parse</name></name><argument_list>(<argument><expr><literal type="string">"mÃ¶\\\\*tley"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"mo\\atley"</literal></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
    <comment type="line">// escaped wildcard then true wildcard</comment>
    <expr><call><name>assertTrue</name><argument_list>(<argument><expr><call><name>isAHit</name><argument_list>(<argument><expr><call><name><name>parser</name><operator>.</operator><name>parse</name></name><argument_list>(<argument><expr><literal type="string">"mÃ¶\\??ley"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"mo?tley"</literal></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;

    <comment type="line">// the first is an escaped * which should yield a miss</comment>
    <expr><call><name>assertFalse</name><argument_list>(<argument><expr><call><name>isAHit</name><argument_list>(<argument><expr><call><name><name>parser</name><operator>.</operator><name>parse</name></name><argument_list>(<argument><expr><literal type="string">"mÃ¶\\*tl*y"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"moatley"</literal></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
  }</block>

  <specifier>public</specifier> <name>void</name> <call><name>testWildcardDoesNotNormalizeEscapedChars</name><argument_list>()</argument_list></call> <throws>throws <argument><expr><name>Exception</name> <block>{
    <expr><name>Analyzer</name> <name>asciiAnalyzer</name> <operator>=</operator> <operator>new</operator> <call><name>ASCIIAnalyzer</name><argument_list>()</argument_list></call></expr></block></expr></argument></throws></expr>;
    <expr><name>Analyzer</name> <name>keywordAnalyzer</name> <operator>=</operator> <operator>new</operator> <call><name>MockAnalyzer</name><argument_list>(<argument><expr><call><name>random</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
    <expr><name>QueryParser</name> <name>parser</name> <operator>=</operator> <operator>new</operator> <call><name>QueryParser</name><argument_list>(<argument><expr><name>FIELD</name></expr></argument>, <argument><expr><name>asciiAnalyzer</name></expr></argument>)</argument_list></call></expr>;

    <expr><call><name>assertTrue</name><argument_list>(<argument><expr><call><name>isAHit</name><argument_list>(<argument><expr><call><name><name>parser</name><operator>.</operator><name>parse</name></name><argument_list>(<argument><expr><literal type="string">"e*e"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"Ã©tude"</literal></expr></argument>, <argument><expr><name>asciiAnalyzer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
    <expr><call><name>assertTrue</name><argument_list>(<argument><expr><call><name>isAHit</name><argument_list>(<argument><expr><call><name><name>parser</name><operator>.</operator><name>parse</name></name><argument_list>(<argument><expr><literal type="string">"Ã©*e"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"etude"</literal></expr></argument>, <argument><expr><name>asciiAnalyzer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
    <expr><call><name>assertFalse</name><argument_list>(<argument><expr><call><name>isAHit</name><argument_list>(<argument><expr><call><name><name>parser</name><operator>.</operator><name>parse</name></name><argument_list>(<argument><expr><literal type="string">"\\Ã©*e"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"etude"</literal></expr></argument>, <argument><expr><name>asciiAnalyzer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
    <expr><call><name>assertTrue</name><argument_list>(<argument><expr><call><name>isAHit</name><argument_list>(<argument><expr><call><name><name>parser</name><operator>.</operator><name>parse</name></name><argument_list>(<argument><expr><literal type="string">"\\Ã©*e"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"Ã©tude"</literal></expr></argument>, <argument><expr><name>keywordAnalyzer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
  }</block>

  <specifier>public</specifier> <name>void</name> <call><name>testWildCardQuery</name><argument_list>()</argument_list></call> <throws>throws <argument><expr><name>ParseException</name> <block>{
    <expr><name>Analyzer</name> <name>a</name> <operator>=</operator> <operator>new</operator> <call><name>ASCIIAnalyzer</name><argument_list>()</argument_list></call></expr></block></expr></argument></throws></expr>;
    <expr><name>QueryParser</name> <name>parser</name> <operator>=</operator> <operator>new</operator> <call><name>QueryParser</name><argument_list>(<argument><expr><name>FIELD</name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;
    <expr><call><name><name>parser</name><operator>.</operator><name>setAllowLeadingWildcard</name></name><argument_list>(<argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr>;
    <expr><call><name>assertEquals</name><argument_list>(<argument><expr><literal type="string">"*bersetzung uber*ung"</literal></expr></argument>, <argument><expr><call><name><name>parser</name><operator>.</operator><name>parse</name></name><argument_list>(<argument><expr><literal type="string">"*bersetzung Ã¼ber*ung"</literal></expr></argument>)</argument_list></call><operator>.</operator><call><name>toString</name><argument_list>(<argument><expr><name>FIELD</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
    <expr><call><name><name>parser</name><operator>.</operator><name>setAllowLeadingWildcard</name></name><argument_list>(<argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;
    <expr><call><name>assertEquals</name><argument_list>(<argument><expr><literal type="string">"motley crue motl?* cru?"</literal></expr></argument>, <argument><expr><call><name><name>parser</name><operator>.</operator><name>parse</name></name><argument_list>(<argument><expr><literal type="string">"MÃ¶tley Cr\u00fce MÃ¶tl?* CrÃ¼?"</literal></expr></argument>)</argument_list></call><operator>.</operator><call><name>toString</name><argument_list>(<argument><expr><name>FIELD</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
    <expr><call><name>assertEquals</name><argument_list>(<argument><expr><literal type="string">"renee zellweger ren?? zellw?ger"</literal></expr></argument>, <argument><expr><call><name><name>parser</name><operator>.</operator><name>parse</name></name><argument_list>(<argument><expr><literal type="string">"RenÃ©e Zellweger Ren?? Zellw?ger"</literal></expr></argument>)</argument_list></call><operator>.</operator><call><name>toString</name><argument_list>(<argument><expr><name>FIELD</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
  }</block>


  <specifier>public</specifier> <name>void</name> <call><name>testPrefixQuery</name><argument_list>()</argument_list></call> <throws>throws <argument><expr><name>ParseException</name> <block>{
    <expr><name>Analyzer</name> <name>a</name> <operator>=</operator> <operator>new</operator> <call><name>ASCIIAnalyzer</name><argument_list>()</argument_list></call></expr></block></expr></argument></throws></expr>;
    <expr><name>QueryParser</name> <name>parser</name> <operator>=</operator> <operator>new</operator> <call><name>QueryParser</name><argument_list>(<argument><expr><name>FIELD</name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;
    <expr><call><name>assertEquals</name><argument_list>(<argument><expr><literal type="string">"ubersetzung ubersetz*"</literal></expr></argument>, <argument><expr><call><name><name>parser</name><operator>.</operator><name>parse</name></name><argument_list>(<argument><expr><literal type="string">"Ã¼bersetzung Ã¼bersetz*"</literal></expr></argument>)</argument_list></call><operator>.</operator><call><name>toString</name><argument_list>(<argument><expr><name>FIELD</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
    <expr><call><name>assertEquals</name><argument_list>(<argument><expr><literal type="string">"motley crue motl* cru*"</literal></expr></argument>, <argument><expr><call><name><name>parser</name><operator>.</operator><name>parse</name></name><argument_list>(<argument><expr><literal type="string">"MÃ¶tley CrÃ¼e MÃ¶tl* crÃ¼*"</literal></expr></argument>)</argument_list></call><operator>.</operator><call><name>toString</name><argument_list>(<argument><expr><name>FIELD</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
    <expr><call><name>assertEquals</name><argument_list>(<argument><expr><literal type="string">"rene? zellw*"</literal></expr></argument>, <argument><expr><call><name><name>parser</name><operator>.</operator><name>parse</name></name><argument_list>(<argument><expr><literal type="string">"RenÃ©? Zellw*"</literal></expr></argument>)</argument_list></call><operator>.</operator><call><name>toString</name><argument_list>(<argument><expr><name>FIELD</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
  }</block>

  <specifier>public</specifier> <name>void</name> <call><name>testRangeQuery</name><argument_list>()</argument_list></call> <throws>throws <argument><expr><name>ParseException</name> <block>{
    <expr><name>Analyzer</name> <name>a</name> <operator>=</operator> <operator>new</operator> <call><name>ASCIIAnalyzer</name><argument_list>()</argument_list></call></expr></block></expr></argument></throws></expr>;
    <expr><name>QueryParser</name> <name>parser</name> <operator>=</operator> <operator>new</operator> <call><name>QueryParser</name><argument_list>(<argument><expr><name>FIELD</name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;
    <expr><call><name>assertEquals</name><argument_list>(<argument><expr><literal type="string">"[aa TO bb]"</literal></expr></argument>, <argument><expr><call><name><name>parser</name><operator>.</operator><name>parse</name></name><argument_list>(<argument><expr><literal type="string">"[aa TO bb]"</literal></expr></argument>)</argument_list></call><operator>.</operator><call><name>toString</name><argument_list>(<argument><expr><name>FIELD</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
    <expr><call><name>assertEquals</name><argument_list>(<argument><expr><literal type="string">"{anais TO zoe}"</literal></expr></argument>, <argument><expr><call><name><name>parser</name><operator>.</operator><name>parse</name></name><argument_list>(<argument><expr><literal type="string">"{AnaÃ¯s TO ZoÃ©}"</literal></expr></argument>)</argument_list></call><operator>.</operator><call><name>toString</name><argument_list>(<argument><expr><name>FIELD</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
  }</block>

  <specifier>public</specifier> <name>void</name> <call><name>testFuzzyQuery</name><argument_list>()</argument_list></call> <throws>throws <argument><expr><name>ParseException</name> <block>{
    <expr><name>Analyzer</name> <name>a</name> <operator>=</operator> <operator>new</operator> <call><name>ASCIIAnalyzer</name><argument_list>()</argument_list></call></expr></block></expr></argument></throws></expr>;
    <expr><name>QueryParser</name> <name>parser</name> <operator>=</operator> <operator>new</operator> <call><name>QueryParser</name><argument_list>(<argument><expr><name>FIELD</name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;
    <expr><call><name>assertEquals</name><argument_list>(<argument><expr><literal type="string">"ubersetzung ubersetzung~1"</literal></expr></argument>, <argument><expr><call><name><name>parser</name><operator>.</operator><name>parse</name></name><argument_list>(<argument><expr><literal type="string">"Ãbersetzung Ãbersetzung~0.9"</literal></expr></argument>)</argument_list></call><operator>.</operator><call><name>toString</name><argument_list>(<argument><expr><name>FIELD</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
    <expr><call><name>assertEquals</name><argument_list>(<argument><expr><literal type="string">"motley crue motley~1 crue~2"</literal></expr></argument>, <argument><expr><call><name><name>parser</name><operator>.</operator><name>parse</name></name><argument_list>(<argument><expr><literal type="string">"MÃ¶tley CrÃ¼e MÃ¶tley~0.75 CrÃ¼e~0.5"</literal></expr></argument>)</argument_list></call><operator>.</operator><call><name>toString</name><argument_list>(<argument><expr><name>FIELD</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
    <expr><call><name>assertEquals</name><argument_list>(<argument><expr><literal type="string">"renee zellweger renee~0 zellweger~2"</literal></expr></argument>, <argument><expr><call><name><name>parser</name><operator>.</operator><name>parse</name></name><argument_list>(<argument><expr><literal type="string">"RenÃ©e Zellweger RenÃ©e~0.9 Zellweger~"</literal></expr></argument>)</argument_list></call><operator>.</operator><call><name>toString</name><argument_list>(<argument><expr><name>FIELD</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
  }</block>

  <name>final</name> <specifier>static</specifier> class <name>FoldingFilter</name> extends <name>TokenFilter</name> <block>{
    <expr><name>final</name> <name>CharTermAttribute</name> <name>termAtt</name> <operator>=</operator> <call><name>addAttribute</name><argument_list>(<argument><expr><name><name>CharTermAttribute</name><operator>.</operator><name>class</name></name></expr></argument>)</argument_list></call></expr>;

    <expr><specifier>public</specifier> <call><name>FoldingFilter</name><argument_list>(<argument><expr><name>TokenStream</name> <name>input</name></expr></argument>)</argument_list></call> <block>{
      <expr><call><name>super</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>;
    }</block>

    @<name>Override</name>
    <specifier>public</specifier> <name>boolean</name> <call><name>incrementToken</name><argument_list>()</argument_list></call> <throws>throws <argument><expr><name>IOException</name> <block>{</block></expr></argument></throws></expr>
      <if_stmt><if>if <condition>(<expr><call><name><name>input</name><operator>.</operator><name>incrementToken</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>char</name></type> <name><name>term</name><index>[]</index></name> <init>= <expr><call><name><name>termAtt</name><operator>.</operator><name>buffer</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>term</name><operator>.</operator><name>length</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
          <switch>switch<condition>(<expr><name><name>term</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition> <block>{<block_content>
            <case>case <expr><literal type="char">'Ã¼'</literal></expr>:</case>
              <expr_stmt><expr><name><name>term</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="char">'u'</literal></expr>;</expr_stmt> 
              <break>break;</break>
            <case>case <expr><literal type="char">'Ã¶'</literal></expr>:</case> 
              <expr_stmt><expr><name><name>term</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="char">'o'</literal></expr>;</expr_stmt> 
              <break>break;</break>
            <case>case <expr><literal type="char">'Ã©'</literal></expr>:</case> 
              <expr_stmt><expr><name><name>term</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="char">'e'</literal></expr>;</expr_stmt> 
              <break>break;</break>
            <case>case <expr><literal type="char">'Ã¯'</literal></expr>:</case> 
              <expr_stmt><expr><name><name>term</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="char">'i'</literal></expr>;</expr_stmt> 
              <break>break;</break>
          <expr_stmt/>}</block_content>
        return true</block><empty_stmt>;</empty_stmt></switch></block_content></block></for>
      <expr_stmt/>}</block_content> else <block>{<block_content>
        <return>return <expr><literal type="boolean">false</literal></expr>;</return>
      <expr_stmt/>}</block_content>
    }
  }

  final static class ASCIIAnalyzer extends Analyzer <block>{<block_content>
    <function><annotation>@<name>Override</name></annotation>
    <type><specifier>public</specifier> <name>TokenStreamComponents</name></type> <name>createComponents</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>fieldName</name></decl></parameter>)</parameter_list> <block>{<block_content>
      <decl_stmt><decl><type><name>Tokenizer</name></type> <name>result</name> <init>= <expr><operator>new</operator> <call><name>MockTokenizer</name><argument_list>(<argument><expr><name><name>MockTokenizer</name><operator>.</operator><name>WHITESPACE</name></name></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <return>return <expr><operator>new</operator> <call><name>TokenStreamComponents</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><operator>new</operator> <call><name>FoldingFilter</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    <expr_stmt/>}</block_content>
    @Override
    protected TokenStream normalize(String fieldName</block><operator>,</operator> TokenStream in</function>)</block_content> <block>{<block_content>
      <return>return <expr><operator>new</operator> <call><name>FoldingFilter</name><argument_list>(<argument><expr><operator>new</operator> <call><name>MockLowerCaseFilter</name><argument_list>(<argument><expr><name>in</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    <expr_stmt/>}</block_content>
  }

  <comment type="line">// LUCENE-4176</comment>
  public void testByteTerms(</block></block></block></block></if></if_stmt>) <throws>throws <argument><expr><name>Exception</name> <block>{
    <expr><name>String</name> <name>s</name> <operator>=</operator> <literal type="string">"à¹à¸"</literal></expr></block></expr></argument></throws></block></expr>;
    <expr><name>Analyzer</name> <name>analyzer</name> <operator>=</operator> <operator>new</operator> <call><name>MockBytesAnalyzer</name><argument_list>()</argument_list></call></expr>;
    <expr><name>QueryParser</name> <name>qp</name> <operator>=</operator> <operator>new</operator> <call><name>QueryParser</name><argument_list>(<argument><expr><name>FIELD</name></expr></argument>, <argument><expr><name>analyzer</name></expr></argument>)</argument_list></call></expr>;

    <expr><call><name>assertTrue</name><argument_list>(<argument><expr><call><name>isAHit</name><argument_list>(<argument><expr><call><name><name>qp</name><operator>.</operator><name>parse</name></name><argument_list>(<argument><expr><literal type="string">"[à¹à¸ TO à¹à¸]"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>analyzer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
    <expr><call><name>assertTrue</name><argument_list>(<argument><expr><call><name>isAHit</name><argument_list>(<argument><expr><call><name><name>qp</name><operator>.</operator><name>parse</name></name><argument_list>(<argument><expr><literal type="string">"à¹à¸~1"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>analyzer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
    <expr><call><name>assertTrue</name><argument_list>(<argument><expr><call><name>isAHit</name><argument_list>(<argument><expr><call><name><name>qp</name><operator>.</operator><name>parse</name></name><argument_list>(<argument><expr><literal type="string">"à¹à¸*"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>analyzer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
    <expr><call><name>assertTrue</name><argument_list>(<argument><expr><call><name>isAHit</name><argument_list>(<argument><expr><call><name><name>qp</name><operator>.</operator><name>parse</name></name><argument_list>(<argument><expr><literal type="string">"à¹*"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>analyzer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
    <expr><call><name>assertTrue</name><argument_list>(<argument><expr><call><name>isAHit</name><argument_list>(<argument><expr><call><name><name>qp</name><operator>.</operator><name>parse</name></name><argument_list>(<argument><expr><literal type="string">"à¹??"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>analyzer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
  }</block>
   
  
  <specifier>private</specifier> <name>boolean</name> <call><name>isAHit</name><argument_list>(<argument><expr><name>Query</name> <name>q</name></expr></argument>, <argument><expr><name>String</name> <name>content</name></expr></argument>, <argument><expr><name>Analyzer</name> <name>analyzer</name></expr></argument>)</argument_list></call> <throws>throws <argument><expr><name>IOException</name><block>{
    <expr><name>Directory</name> <name>ramDir</name> <operator>=</operator> <call><name>newDirectory</name><argument_list>()</argument_list></call></expr></block></expr></argument></throws></expr>;
    <expr><name>RandomIndexWriter</name> <name>writer</name> <operator>=</operator> <operator>new</operator> <call><name>RandomIndexWriter</name><argument_list>(<argument><expr><call><name>random</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>ramDir</name></expr></argument>, <argument><expr><name>analyzer</name></expr></argument>)</argument_list></call></expr>;
    <expr><name>Document</name> <name>doc</name> <operator>=</operator> <operator>new</operator> <call><name>Document</name><argument_list>()</argument_list></call></expr>;
    <expr><name>FieldType</name> <name>fieldType</name> <operator>=</operator> <operator>new</operator> <call><name>FieldType</name><argument_list>()</argument_list></call></expr>;
    <expr><call><name><name>fieldType</name><operator>.</operator><name>setIndexOptions</name></name><argument_list>(<argument><expr><name><name>IndexOptions</name><operator>.</operator><name>DOCS_AND_FREQS_AND_POSITIONS</name></name></expr></argument>)</argument_list></call></expr>;
    <expr><call><name><name>fieldType</name><operator>.</operator><name>setTokenized</name></name><argument_list>(<argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr>;
    <expr><call><name><name>fieldType</name><operator>.</operator><name>setStored</name></name><argument_list>(<argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr>;
    <expr><name>Field</name> <name>field</name> <operator>=</operator> <operator>new</operator> <call><name>Field</name><argument_list>(<argument><expr><name>FIELD</name></expr></argument>, <argument><expr><name>content</name></expr></argument>, <argument><expr><name>fieldType</name></expr></argument>)</argument_list></call></expr>;
    <expr><call><name><name>doc</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name>field</name></expr></argument>)</argument_list></call></expr>;
    <expr><call><name><name>writer</name><operator>.</operator><name>addDocument</name></name><argument_list>(<argument><expr><name>doc</name></expr></argument>)</argument_list></call></expr>;
    <expr><call><name><name>writer</name><operator>.</operator><name>close</name></name><argument_list>()</argument_list></call></expr>;
    <expr><name>DirectoryReader</name> <name>ir</name> <operator>=</operator> <call><name><name>DirectoryReader</name><operator>.</operator><name>open</name></name><argument_list>(<argument><expr><name>ramDir</name></expr></argument>)</argument_list></call></expr>;
    <expr><name>IndexSearcher</name> <name>is</name> <operator>=</operator> <operator>new</operator> <call><name>IndexSearcher</name><argument_list>(<argument><expr><name>ir</name></expr></argument>)</argument_list></call></expr>;
      
    <expr><name>int</name> <name>hits</name> <operator>=</operator> <call><name><name>is</name><operator>.</operator><name>search</name></name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call><operator>.</operator><name>totalHits</name></expr>;
    <expr><call><name><name>ir</name><operator>.</operator><name>close</name></name><argument_list>()</argument_list></call></expr>;
    <expr><call><name><name>ramDir</name><operator>.</operator><name>close</name></name><argument_list>()</argument_list></call></expr>;
    <if_stmt><if>if <condition>(<expr><name>hits</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block>{<block_content>
      <return>return <expr><literal type="boolean">true</literal></expr>;</return>
    <expr_stmt/>}</block_content> else <block>{<block_content>
      <return>return <expr><literal type="boolean">false</literal></expr>;</return>
    <expr_stmt/>}</block_content>

  }
}
diff --git a/lucene/queryparser/src/test/org/apache/lucene/queryparser/flexible/precedence/TestPrecedenceQueryParser.java b/lucene/queryparser/src/test/org/apache/lucene/queryparser/flexible/precedence/TestPrecedenceQueryParser.java
index 88e8b9b3cf2..d2deaa6a4aa 100644
-- a/lucene/queryparser/src/test/org/apache/lucene/queryparser/flexible/precedence/TestPrecedenceQueryParser.java
++ b/lucene/queryparser/src/test/org/apache/lucene/queryparser/flexible/precedence/TestPrecedenceQueryParser.java
@@ -181</block></block><operator>,</operator><expr_stmt><expr><literal type="number">20</literal> <operator>+</operator><literal type="number">181</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@ <specifier>public</specifier> class <name>TestPrecedenceQueryParser</name> extends <name>LuceneTestCase</name> <block>{
     }</block></expr></expr_stmt></if></if_stmt>
   }</block>
 
  <specifier>public</specifier> <name>void</name> <call><name>assertWildcardQueryEquals</name><argument_list>(<argument><expr><name>String</name> <name>query</name></expr></argument>, <argument><expr><name>boolean</name> <name>lowercase</name></expr></argument>,
      <argument><expr><name>String</name> <name>result</name></expr></argument>)</argument_list></call> <throws>throws <argument><expr><name>Exception</name> <block>{
    <expr><name>PrecedenceQueryParser</name> <name>qp</name> <operator>=</operator> <call><name>getParser</name><argument_list>(<argument><expr><literal type="null">null</literal></expr></argument>)</argument_list></call></expr></block></expr></argument></throws></expr>;
    <expr><call><name><name>qp</name><operator>.</operator><name>setLowercaseExpandedTerms</name></name><argument_list>(<argument><expr><name>lowercase</name></expr></argument>)</argument_list></call></expr>;
    <expr><name>Query</name> <name>q</name> <operator>=</operator> <call><name><name>qp</name><operator>.</operator><name>parse</name></name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"field"</literal></expr></argument>)</argument_list></call></expr>;
    <expr><name>String</name> <name>s</name> <operator>=</operator> <call><name><name>q</name><operator>.</operator><name>toString</name></name><argument_list>(<argument><expr><literal type="string">"field"</literal></expr></argument>)</argument_list></call></expr>;
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>s</name><operator>.</operator><name>equals</name></name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"WildcardQuery /"</literal> <operator>+</operator> <name>query</name> <operator>+</operator> <literal type="string">"/ yielded /"</literal> <operator>+</operator> <name>s</name> <operator>+</operator> <literal type="string">"/, expecting /"</literal>
          <operator>+</operator> <name>result</name> <operator>+</operator> <literal type="string">"/"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt/>}</block_content>
  }

  public void assertWildcardQueryEquals(String query</block><operator>,</operator> <expr_stmt><expr><name>String</name> <name>result</name></expr></expr_stmt></if></if_stmt></block></expr></block></expr></expr_stmt></block_content></block></function></block></class></expr></argument>)</argument_list></call>
      <throws>throws <argument><expr><name>Exception</name> <block>{
  <expr><specifier>public</specifier> <name>void</name> <call><name>assertWildcardQueryEquals</name><argument_list>(<argument><expr><name>String</name> <name>query</name></expr></argument>, <argument><expr><name>String</name> <name>result</name></expr></argument>)</argument_list></call></expr></block></expr></argument></throws> <throws>throws <argument><expr><name>Exception</name> <block>{
     <expr><name>PrecedenceQueryParser</name> <name>qp</name> <operator>=</operator> <call><name>getParser</name><argument_list>(<argument><expr><literal type="null">null</literal></expr></argument>)</argument_list></call></expr></block></expr></argument></throws></expr>;
     <expr><name>Query</name> <name>q</name> <operator>=</operator> <call><name><name>qp</name><operator>.</operator><name>parse</name></name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"field"</literal></expr></argument>)</argument_list></call></expr>;
     <expr><name>String</name> <name>s</name> <operator>=</operator> <call><name><name>q</name><operator>.</operator><name>toString</name></name><argument_list>(<argument><expr><literal type="string">"field"</literal></expr></argument>)</argument_list></call></expr>;
@@ <expr><operator>-</operator><literal type="number">339</literal></expr>,<expr><literal type="number">36</literal> <operator>+</operator><literal type="number">326</literal></expr>,<expr><literal type="number">23</literal> @@ <specifier>public</specifier> <name>class</name> <name>TestPrecedenceQueryParser</name> extends <name>LuceneTestCase</name> <block>{
      <expr><operator>*</operator><operator>/</operator>
     <comment type="line">// First prefix queries:</comment>
     <comment type="line">// by default, convert to lowercase:</comment>
    <call><name>assertWildcardQueryEquals</name><argument_list>(<argument><expr><literal type="string">"Term*"</literal></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>, <argument><expr><literal type="string">"term*"</literal></expr></argument>)</argument_list></call></expr>;
    <expr><call><name>assertWildcardQueryEquals</name><argument_list>(<argument><expr><literal type="string">"Term*"</literal></expr></argument>, <argument><expr><literal type="string">"term*"</literal></expr></argument>)</argument_list></call></expr>;
     <comment type="line">// explicitly set lowercase:</comment>
    <expr><call><name>assertWildcardQueryEquals</name><argument_list>(<argument><expr><literal type="string">"term*"</literal></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>, <argument><expr><literal type="string">"term*"</literal></expr></argument>)</argument_list></call></expr>;
    <expr><call><name>assertWildcardQueryEquals</name><argument_list>(<argument><expr><literal type="string">"Term*"</literal></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>, <argument><expr><literal type="string">"term*"</literal></expr></argument>)</argument_list></call></expr>;
    <expr><call><name>assertWildcardQueryEquals</name><argument_list>(<argument><expr><literal type="string">"TERM*"</literal></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>, <argument><expr><literal type="string">"term*"</literal></expr></argument>)</argument_list></call></expr>;
    <comment type="line">// explicitly disable lowercase conversion:</comment>
    <expr><call><name>assertWildcardQueryEquals</name><argument_list>(<argument><expr><literal type="string">"term*"</literal></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>, <argument><expr><literal type="string">"term*"</literal></expr></argument>)</argument_list></call></expr>;
    <expr><call><name>assertWildcardQueryEquals</name><argument_list>(<argument><expr><literal type="string">"Term*"</literal></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>, <argument><expr><literal type="string">"Term*"</literal></expr></argument>)</argument_list></call></expr>;
    <expr><call><name>assertWildcardQueryEquals</name><argument_list>(<argument><expr><literal type="string">"TERM*"</literal></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>, <argument><expr><literal type="string">"TERM*"</literal></expr></argument>)</argument_list></call></expr>;
    <expr><call><name>assertWildcardQueryEquals</name><argument_list>(<argument><expr><literal type="string">"term*"</literal></expr></argument>, <argument><expr><literal type="string">"term*"</literal></expr></argument>)</argument_list></call></expr>;
    <expr><call><name>assertWildcardQueryEquals</name><argument_list>(<argument><expr><literal type="string">"Term*"</literal></expr></argument>, <argument><expr><literal type="string">"term*"</literal></expr></argument>)</argument_list></call></expr>;
    <expr><call><name>assertWildcardQueryEquals</name><argument_list>(<argument><expr><literal type="string">"TERM*"</literal></expr></argument>, <argument><expr><literal type="string">"term*"</literal></expr></argument>)</argument_list></call></expr>;
     <comment type="line">// Then 'full' wildcard queries:</comment>
     <comment type="line">// by default, convert to lowercase:</comment>
     <expr><call><name>assertWildcardQueryEquals</name><argument_list>(<argument><expr><literal type="string">"Te?m"</literal></expr></argument>, <argument><expr><literal type="string">"te?m"</literal></expr></argument>)</argument_list></call></expr>;
     <comment type="line">// explicitly set lowercase:</comment>
    <expr><call><name>assertWildcardQueryEquals</name><argument_list>(<argument><expr><literal type="string">"te?m"</literal></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>, <argument><expr><literal type="string">"te?m"</literal></expr></argument>)</argument_list></call></expr>;
    <expr><call><name>assertWildcardQueryEquals</name><argument_list>(<argument><expr><literal type="string">"Te?m"</literal></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>, <argument><expr><literal type="string">"te?m"</literal></expr></argument>)</argument_list></call></expr>;
    <expr><call><name>assertWildcardQueryEquals</name><argument_list>(<argument><expr><literal type="string">"TE?M"</literal></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>, <argument><expr><literal type="string">"te?m"</literal></expr></argument>)</argument_list></call></expr>;
    <expr><call><name>assertWildcardQueryEquals</name><argument_list>(<argument><expr><literal type="string">"Te?m*gerM"</literal></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>, <argument><expr><literal type="string">"te?m*germ"</literal></expr></argument>)</argument_list></call></expr>;
    <comment type="line">// explicitly disable lowercase conversion:</comment>
    <expr><call><name>assertWildcardQueryEquals</name><argument_list>(<argument><expr><literal type="string">"te?m"</literal></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>, <argument><expr><literal type="string">"te?m"</literal></expr></argument>)</argument_list></call></expr>;
    <expr><call><name>assertWildcardQueryEquals</name><argument_list>(<argument><expr><literal type="string">"Te?m"</literal></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>, <argument><expr><literal type="string">"Te?m"</literal></expr></argument>)</argument_list></call></expr>;
    <expr><call><name>assertWildcardQueryEquals</name><argument_list>(<argument><expr><literal type="string">"TE?M"</literal></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>, <argument><expr><literal type="string">"TE?M"</literal></expr></argument>)</argument_list></call></expr>;
    <expr><call><name>assertWildcardQueryEquals</name><argument_list>(<argument><expr><literal type="string">"Te?m*gerM"</literal></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>, <argument><expr><literal type="string">"Te?m*gerM"</literal></expr></argument>)</argument_list></call></expr>;
    <expr><call><name>assertWildcardQueryEquals</name><argument_list>(<argument><expr><literal type="string">"te?m"</literal></expr></argument>, <argument><expr><literal type="string">"te?m"</literal></expr></argument>)</argument_list></call></expr>;
    <expr><call><name>assertWildcardQueryEquals</name><argument_list>(<argument><expr><literal type="string">"Te?m"</literal></expr></argument>, <argument><expr><literal type="string">"te?m"</literal></expr></argument>)</argument_list></call></expr>;
    <expr><call><name>assertWildcardQueryEquals</name><argument_list>(<argument><expr><literal type="string">"TE?M"</literal></expr></argument>, <argument><expr><literal type="string">"te?m"</literal></expr></argument>)</argument_list></call></expr>;
    <expr><call><name>assertWildcardQueryEquals</name><argument_list>(<argument><expr><literal type="string">"Te?m*gerM"</literal></expr></argument>, <argument><expr><literal type="string">"te?m*germ"</literal></expr></argument>)</argument_list></call></expr>;
     <comment type="line">// Fuzzy queries:</comment>
     <expr><call><name>assertWildcardQueryEquals</name><argument_list>(<argument><expr><literal type="string">"Term~"</literal></expr></argument>, <argument><expr><literal type="string">"term~2"</literal></expr></argument>)</argument_list></call></expr>;
    <expr><call><name>assertWildcardQueryEquals</name><argument_list>(<argument><expr><literal type="string">"Term~"</literal></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>, <argument><expr><literal type="string">"term~2"</literal></expr></argument>)</argument_list></call></expr>;
    <expr><call><name>assertWildcardQueryEquals</name><argument_list>(<argument><expr><literal type="string">"Term~"</literal></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>, <argument><expr><literal type="string">"Term~2"</literal></expr></argument>)</argument_list></call></expr>;
     <comment type="line">// Range queries:</comment>
     <expr><call><name>assertWildcardQueryEquals</name><argument_list>(<argument><expr><literal type="string">"[A TO C]"</literal></expr></argument>, <argument><expr><literal type="string">"[a TO c]"</literal></expr></argument>)</argument_list></call></expr>;
    <expr><call><name>assertWildcardQueryEquals</name><argument_list>(<argument><expr><literal type="string">"[A TO C]"</literal></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>, <argument><expr><literal type="string">"[a TO c]"</literal></expr></argument>)</argument_list></call></expr>;
    <expr><call><name>assertWildcardQueryEquals</name><argument_list>(<argument><expr><literal type="string">"[A TO C]"</literal></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>, <argument><expr><literal type="string">"[A TO C]"</literal></expr></argument>)</argument_list></call></expr>;
   }</block>
 
   <specifier>public</specifier> <name>void</name> <call><name>testQPA</name><argument_list>()</argument_list></call> <throws>throws <argument><expr><name>Exception</name> <block>{
<expr><name>diff</name> <operator>--</operator><name>git</name> <name>a</name><operator>/</operator><name>lucene</name><operator>/</operator><name>queryparser</name><operator>/</operator><name>src</name><operator>/</operator><name>test</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>queryparser</name><operator>/</operator><name>flexible</name><operator>/</operator><name>standard</name><operator>/</operator><name><name>TestQPHelper</name><operator>.</operator><name>java</name></name> <name>b</name><operator>/</operator><name>lucene</name><operator>/</operator><name>queryparser</name><operator>/</operator><name>src</name><operator>/</operator><name>test</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>queryparser</name><operator>/</operator><name>flexible</name><operator>/</operator><name>standard</name><operator>/</operator><name><name>TestQPHelper</name><operator>.</operator><name>java</name></name>
<name>index</name> <literal type="number">91b799dc093</literal><operator>..</operator><literal type="number">2d5ee43d452</literal> <literal type="number">100644</literal>
<operator>--</operator> <name>a</name><operator>/</operator><name>lucene</name><operator>/</operator><name>queryparser</name><operator>/</operator><name>src</name><operator>/</operator><name>test</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>queryparser</name><operator>/</operator><name>flexible</name><operator>/</operator><name>standard</name><operator>/</operator><name><name>TestQPHelper</name><operator>.</operator><name>java</name></name>
<operator>++</operator> <name>b</name><operator>/</operator><name>lucene</name><operator>/</operator><name>queryparser</name><operator>/</operator><name>src</name><operator>/</operator><name>test</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>queryparser</name><operator>/</operator><name>flexible</name><operator>/</operator><name>standard</name><operator>/</operator><name><name>TestQPHelper</name><operator>.</operator><name>java</name></name></expr></block></expr></argument>
@<argument>@ <expr><operator>-</operator><literal type="number">288</literal></expr></argument>,<argument><expr><literal type="number">10</literal> <operator>+</operator><literal type="number">288</literal></expr></argument>,<argument><expr><literal type="number">9</literal> @@ <specifier>public</specifier> <name>class</name> <name>TestQPHelper</name> extends <name>LuceneTestCase</name></expr></argument></throws> <block>{<block_content>
     <expr_stmt/></block_content></block></expr>}</block></expr></expr_stmt>
   </block_content>}</block></function>
 
  <decl_stmt><decl><type><specifier>public</specifier> <name>void</name></type> <name>assertWildcardQueryEquals</name><argument_list>(<argument><expr><name>String</name> <name>query</name></expr></argument>, <argument><expr><name>boolean</name> <name>lowercase</name></expr></argument>,
  <argument><expr><specifier>public</specifier> <name>void</name> <call><name>assertWildcardQueryEquals</name><argument_list>(<argument><expr><name>String</name> <name>query</name></expr></argument>,
       <argument><expr><name>String</name> <name>result</name></expr></argument>, <argument><expr><name>boolean</name> <name>allowLeadingWildcard</name></expr></argument>)</argument_list></call> <throws>throws <argument><expr><name>Exception</name> <block>{
     <expr><name>StandardQueryParser</name> <name>qp</name> <operator>=</operator> <call><name>getParser</name><argument_list>(<argument><expr><literal type="null">null</literal></expr></argument>)</argument_list></call></expr></block></expr></argument></throws></expr></argument>;
    <argument><expr><call><name><name>qp</name><operator>.</operator><name>setLowercaseExpandedTerms</name></name><argument_list>(<argument><expr><name>lowercase</name></expr></argument>)</argument_list></call></expr></argument>;
     <argument><expr><call><name><name>qp</name><operator>.</operator><name>setAllowLeadingWildcard</name></name><argument_list>(<argument><expr><name>allowLeadingWildcard</name></expr></argument>)</argument_list></call></expr></argument>;
     <argument><expr><name>Query</name> <name>q</name> <operator>=</operator> <call><name><name>qp</name><operator>.</operator><name>parse</name></name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"field"</literal></expr></argument>)</argument_list></call></expr></argument>;
     <argument><expr><name>String</name> <name>s</name> <operator>=</operator> <call><name><name>q</name><operator>.</operator><name>toString</name></name><argument_list>(<argument><expr><literal type="string">"field"</literal></expr></argument>)</argument_list></call></expr></argument>;
<argument>@@ <expr><operator>-</operator><literal type="number">301</literal></expr></argument>,<argument><expr><literal type="number">20</literal> <operator>+</operator><literal type="number">300</literal></expr></argument>,<argument><expr><literal type="number">9</literal> @@ <specifier>public</specifier> class <name>TestQPHelper</name> extends <name>LuceneTestCase</name> <block>{
     }</block></expr></argument></argument_list></decl></decl_stmt>
   }</block></class>
 
  <decl_stmt><decl><type><specifier>public</specifier> <name>void</name></type> <name>assertWildcardQueryEquals</name><argument_list>(<argument><expr><name>String</name> <name>query</name></expr></argument>, <argument><expr><name>boolean</name> <name>lowercase</name></expr></argument>,
  <argument><expr><specifier>public</specifier> <name>void</name> <call><name>assertWildcardQueryEquals</name><argument_list>(<argument><expr><name>String</name> <name>query</name></expr></argument>,
       <argument><expr><name>String</name> <name>result</name></expr></argument>)</argument_list></call> <throws>throws <argument><expr><name>Exception</name> <block>{
    <expr><call><name>assertWildcardQueryEquals</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>lowercase</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr></block></expr></argument></throws></expr></argument>;</argument_list></decl></decl_stmt>
  }</block></class>

  <function><type><specifier>public</specifier> <name>void</name></type> <name>assertWildcardQueryEquals</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>query</name></decl></parameter>, <parameter><decl><type><name>String</name></type> <name>result</name></decl></parameter>)</parameter_list>
      <throws>throws <argument><expr><name>Exception</name></expr></argument></throws> <block>{<block_content>
    <decl_stmt><decl><type><name>StandardQueryParser</name></type> <name>qp</name> <init>= <expr><call><name>getParser</name><argument_list>(<argument><expr><literal type="null">null</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Query</name></type> <name>q</name> <init>= <expr><call><name><name>qp</name><operator>.</operator><name>parse</name></name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"field"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>String</name></type> <name>s</name> <init>= <expr><call><name><name>q</name><operator>.</operator><name>toString</name></name><argument_list>(<argument><expr><literal type="string">"field"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>s</name><operator>.</operator><name>equals</name></name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"WildcardQuery /"</literal> <operator>+</operator> <name>query</name> <operator>+</operator> <literal type="string">"/ yielded /"</literal> <operator>+</operator> <name>s</name> <operator>+</operator> <literal type="string">"/, expecting /"</literal>
          <operator>+</operator> <name>result</name> <operator>+</operator> <literal type="string">"/"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>assertWildcardQueryEquals</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
   </block_content>}</block></function>
 
   <function><type><specifier>public</specifier> <name>Query</name></type> <name>getQueryDOA</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>query</name></decl></parameter>, <parameter><decl><type><name>Analyzer</name></type> <name>a</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>Exception</name></expr></argument></throws> <block>{<block_content>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">597</literal></expr><operator>,</operator><expr><literal type="number">32</literal> <operator>+</operator><literal type="number">585</literal></expr><operator>,</operator><expr><literal type="number">21</literal> @@ <specifier>public</specifier> <name>class</name> <name>TestQPHelper</name> extends <name>LuceneTestCase</name> <block>{
      <expr><operator>*</operator><operator>/</operator>
     <comment type="line">// First prefix queries:</comment>
     <comment type="line">// by default, convert to lowercase:</comment>
    <call><name>assertWildcardQueryEquals</name><argument_list>(<argument><expr><literal type="string">"Term*"</literal></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>, <argument><expr><literal type="string">"term*"</literal></expr></argument>)</argument_list></call></expr>;
    <expr><call><name>assertWildcardQueryEquals</name><argument_list>(<argument><expr><literal type="string">"Term*"</literal></expr></argument>, <argument><expr><literal type="string">"term*"</literal></expr></argument>)</argument_list></call></expr>;
     <comment type="line">// explicitly set lowercase:</comment>
    <expr><call><name>assertWildcardQueryEquals</name><argument_list>(<argument><expr><literal type="string">"term*"</literal></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>, <argument><expr><literal type="string">"term*"</literal></expr></argument>)</argument_list></call></expr>;
    <expr><call><name>assertWildcardQueryEquals</name><argument_list>(<argument><expr><literal type="string">"Term*"</literal></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>, <argument><expr><literal type="string">"term*"</literal></expr></argument>)</argument_list></call></expr>;
    <expr><call><name>assertWildcardQueryEquals</name><argument_list>(<argument><expr><literal type="string">"TERM*"</literal></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>, <argument><expr><literal type="string">"term*"</literal></expr></argument>)</argument_list></call></expr>;
    <comment type="line">// explicitly disable lowercase conversion:</comment>
    <expr><call><name>assertWildcardQueryEquals</name><argument_list>(<argument><expr><literal type="string">"term*"</literal></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>, <argument><expr><literal type="string">"term*"</literal></expr></argument>)</argument_list></call></expr>;
    <expr><call><name>assertWildcardQueryEquals</name><argument_list>(<argument><expr><literal type="string">"Term*"</literal></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>, <argument><expr><literal type="string">"Term*"</literal></expr></argument>)</argument_list></call></expr>;
    <expr><call><name>assertWildcardQueryEquals</name><argument_list>(<argument><expr><literal type="string">"TERM*"</literal></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>, <argument><expr><literal type="string">"TERM*"</literal></expr></argument>)</argument_list></call></expr>;
    <expr><call><name>assertWildcardQueryEquals</name><argument_list>(<argument><expr><literal type="string">"term*"</literal></expr></argument>, <argument><expr><literal type="string">"term*"</literal></expr></argument>)</argument_list></call></expr>;
    <expr><call><name>assertWildcardQueryEquals</name><argument_list>(<argument><expr><literal type="string">"Term*"</literal></expr></argument>, <argument><expr><literal type="string">"term*"</literal></expr></argument>)</argument_list></call></expr>;
    <expr><call><name>assertWildcardQueryEquals</name><argument_list>(<argument><expr><literal type="string">"TERM*"</literal></expr></argument>, <argument><expr><literal type="string">"term*"</literal></expr></argument>)</argument_list></call></expr>;
     <comment type="line">// Then 'full' wildcard queries:</comment>
     <comment type="line">// by default, convert to lowercase:</comment>
     <expr><call><name>assertWildcardQueryEquals</name><argument_list>(<argument><expr><literal type="string">"Te?m"</literal></expr></argument>, <argument><expr><literal type="string">"te?m"</literal></expr></argument>)</argument_list></call></expr>;
     <comment type="line">// explicitly set lowercase:</comment>
    <expr><call><name>assertWildcardQueryEquals</name><argument_list>(<argument><expr><literal type="string">"te?m"</literal></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>, <argument><expr><literal type="string">"te?m"</literal></expr></argument>)</argument_list></call></expr>;
    <expr><call><name>assertWildcardQueryEquals</name><argument_list>(<argument><expr><literal type="string">"Te?m"</literal></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>, <argument><expr><literal type="string">"te?m"</literal></expr></argument>)</argument_list></call></expr>;
    <expr><call><name>assertWildcardQueryEquals</name><argument_list>(<argument><expr><literal type="string">"TE?M"</literal></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>, <argument><expr><literal type="string">"te?m"</literal></expr></argument>)</argument_list></call></expr>;
    <expr><call><name>assertWildcardQueryEquals</name><argument_list>(<argument><expr><literal type="string">"Te?m*gerM"</literal></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>, <argument><expr><literal type="string">"te?m*germ"</literal></expr></argument>)</argument_list></call></expr>;
    <comment type="line">// explicitly disable lowercase conversion:</comment>
    <expr><call><name>assertWildcardQueryEquals</name><argument_list>(<argument><expr><literal type="string">"te?m"</literal></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>, <argument><expr><literal type="string">"te?m"</literal></expr></argument>)</argument_list></call></expr>;
    <expr><call><name>assertWildcardQueryEquals</name><argument_list>(<argument><expr><literal type="string">"Te?m"</literal></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>, <argument><expr><literal type="string">"Te?m"</literal></expr></argument>)</argument_list></call></expr>;
    <expr><call><name>assertWildcardQueryEquals</name><argument_list>(<argument><expr><literal type="string">"TE?M"</literal></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>, <argument><expr><literal type="string">"TE?M"</literal></expr></argument>)</argument_list></call></expr>;
    <expr><call><name>assertWildcardQueryEquals</name><argument_list>(<argument><expr><literal type="string">"Te?m*gerM"</literal></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>, <argument><expr><literal type="string">"Te?m*gerM"</literal></expr></argument>)</argument_list></call></expr>;
    <expr><call><name>assertWildcardQueryEquals</name><argument_list>(<argument><expr><literal type="string">"te?m"</literal></expr></argument>, <argument><expr><literal type="string">"te?m"</literal></expr></argument>)</argument_list></call></expr>;
    <expr><call><name>assertWildcardQueryEquals</name><argument_list>(<argument><expr><literal type="string">"Te?m"</literal></expr></argument>, <argument><expr><literal type="string">"te?m"</literal></expr></argument>)</argument_list></call></expr>;
    <expr><call><name>assertWildcardQueryEquals</name><argument_list>(<argument><expr><literal type="string">"TE?M"</literal></expr></argument>, <argument><expr><literal type="string">"te?m"</literal></expr></argument>)</argument_list></call></expr>;
    <expr><call><name>assertWildcardQueryEquals</name><argument_list>(<argument><expr><literal type="string">"Te?m*gerM"</literal></expr></argument>, <argument><expr><literal type="string">"te?m*germ"</literal></expr></argument>)</argument_list></call></expr>;
     <comment type="line">// Fuzzy queries:</comment>
     <expr><call><name>assertWildcardQueryEquals</name><argument_list>(<argument><expr><literal type="string">"Term~"</literal></expr></argument>, <argument><expr><literal type="string">"term~2"</literal></expr></argument>)</argument_list></call></expr>;
    <expr><call><name>assertWildcardQueryEquals</name><argument_list>(<argument><expr><literal type="string">"Term~"</literal></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>, <argument><expr><literal type="string">"term~2"</literal></expr></argument>)</argument_list></call></expr>;
    <expr><call><name>assertWildcardQueryEquals</name><argument_list>(<argument><expr><literal type="string">"Term~"</literal></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>, <argument><expr><literal type="string">"Term~2"</literal></expr></argument>)</argument_list></call></expr>;
     <comment type="line">// Range queries:</comment>
 
     <comment type="line">// TODO: implement this on QueryParser</comment>
@@ <expr><operator>-</operator><literal type="number">630</literal></expr>,<expr><literal type="number">20</literal> <operator>+</operator><literal type="number">607</literal></expr>,<expr><literal type="number">18</literal> @@ <specifier>public</specifier> <name>class</name> <name>TestQPHelper</name> extends <name>LuceneTestCase</name> <block>{
     <comment type="line">// C]': Lexical error at line 1, column 1. Encountered: "[" (91), after</comment>
     <comment type="line">// : ""</comment>
     <expr><call><name>assertWildcardQueryEquals</name><argument_list>(<argument><expr><literal type="string">"[A TO C]"</literal></expr></argument>, <argument><expr><literal type="string">"[a TO c]"</literal></expr></argument>)</argument_list></call></expr>;
    <expr><call><name>assertWildcardQueryEquals</name><argument_list>(<argument><expr><literal type="string">"[A TO C]"</literal></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>, <argument><expr><literal type="string">"[a TO c]"</literal></expr></argument>)</argument_list></call></expr>;
    <expr><call><name>assertWildcardQueryEquals</name><argument_list>(<argument><expr><literal type="string">"[A TO C]"</literal></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>, <argument><expr><literal type="string">"[A TO C]"</literal></expr></argument>)</argument_list></call></expr>;
     <comment type="line">// Test suffix queries: first disallow</comment>
     <expr><call><name>expectThrows</name><argument_list>(<argument><expr><name><name>QueryNodeException</name><operator>.</operator><name>class</name></name></expr></argument>, <argument><expr><lambda><parameter_list>()</parameter_list> -&gt; <block>{<block_content>
      <expr_stmt><expr><call><name>assertWildcardQueryEquals</name><argument_list>(<argument><expr><literal type="string">"*Term"</literal></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>, <argument><expr><literal type="string">"*term"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assertWildcardQueryEquals</name><argument_list>(<argument><expr><literal type="string">"*Term"</literal></expr></argument>, <argument><expr><literal type="string">"*term"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
     <expr_stmt/>}</block_content></block></lambda></expr></argument>)</argument_list></call></expr>;
 
     <expr><call><name>expectThrows</name><argument_list>(<argument><expr><name><name>QueryNodeException</name><operator>.</operator><name>class</name></name></expr></argument>, <argument><expr><lambda><parameter_list>()</parameter_list> -&gt; <block>{<block_content>
      <expr_stmt><expr><call><name>assertWildcardQueryEquals</name><argument_list>(<argument><expr><literal type="string">"?Term"</literal></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>, <argument><expr><literal type="string">"?term"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assertWildcardQueryEquals</name><argument_list>(<argument><expr><literal type="string">"?Term"</literal></expr></argument>, <argument><expr><literal type="string">"?term"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
     <expr_stmt/>}</block_content></block></lambda></expr></argument>)</argument_list></call></expr>;
 
     <comment type="line">// Test suffix queries: then allow</comment>
    <expr><call><name>assertWildcardQueryEquals</name><argument_list>(<argument><expr><literal type="string">"*Term"</literal></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>, <argument><expr><literal type="string">"*term"</literal></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr>;
    <expr><call><name>assertWildcardQueryEquals</name><argument_list>(<argument><expr><literal type="string">"?Term"</literal></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>, <argument><expr><literal type="string">"?term"</literal></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr>;
    <expr><call><name>assertWildcardQueryEquals</name><argument_list>(<argument><expr><literal type="string">"*Term"</literal></expr></argument>, <argument><expr><literal type="string">"*term"</literal></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr>;
    <expr><call><name>assertWildcardQueryEquals</name><argument_list>(<argument><expr><literal type="string">"?Term"</literal></expr></argument>, <argument><expr><literal type="string">"?term"</literal></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr>;
   }</block>
 
   <specifier>public</specifier> <name>void</name> <call><name>testLeadingWildcardType</name><argument_list>()</argument_list></call> <throws>throws <argument><expr><name>Exception</name> <block>{</block></expr></argument>
@<argument>@ <expr><operator>-</operator><literal type="number">1159</literal></expr></argument>,<argument><expr><literal type="number">10</literal> <operator>+</operator><literal type="number">1134</literal></expr></argument>,<argument><expr><literal type="number">10</literal> @@ <specifier>public</specifier> <name>class</name> <name>TestQPHelper</name> extends <name>LuceneTestCase</name></expr></argument></throws> <block>{<block_content>
   
   <function><type><specifier>public</specifier> <name>void</name></type> <name>testRegexps</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>Exception</name></expr></argument></throws> <block>{<block_content>
     <decl_stmt><decl><type><name>StandardQueryParser</name></type> <name>qp</name> <init>= <expr><operator>new</operator> <call><name>StandardQueryParser</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>qp</name><operator>.</operator><name>setAnalyzer</name></name><argument_list>(<argument><expr><operator>new</operator> <call><name>MockAnalyzer</name><argument_list>(<argument><expr><call><name>random</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>MockTokenizer</name><operator>.</operator><name>WHITESPACE</name></name></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
     <decl_stmt><decl><type><specifier>final</specifier> <name>String</name></type> <name>df</name> <init>= <expr><literal type="string">"field"</literal></expr></init></decl> ;</decl_stmt>
     <decl_stmt><decl><type><name>RegexpQuery</name></type> <name>q</name> <init>= <expr><operator>new</operator> <call><name>RegexpQuery</name><argument_list>(<argument><expr><operator>new</operator> <call><name>Term</name><argument_list>(<argument><expr><literal type="string">"field"</literal></expr></argument>, <argument><expr><literal type="string">"[a-z][123]"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
     <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><call><name><name>qp</name><operator>.</operator><name>parse</name></name><argument_list>(<argument><expr><literal type="string">"/[a-z][123]/"</literal></expr></argument>, <argument><expr><name>df</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>qp</name><operator>.</operator><name>setLowercaseExpandedTerms</name></name><argument_list>(<argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
     <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><call><name><name>qp</name><operator>.</operator><name>parse</name></name><argument_list>(<argument><expr><literal type="string">"/[A-Z][123]/"</literal></expr></argument>, <argument><expr><name>df</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
     <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><operator>new</operator> <call><name>BoostQuery</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="number">0.5f</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>qp</name><operator>.</operator><name>parse</name></name><argument_list>(<argument><expr><literal type="string">"/[A-Z][123]/^0.5"</literal></expr></argument>, <argument><expr><name>df</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
     <expr_stmt><expr><call><name><name>qp</name><operator>.</operator><name>setMultiTermRewriteMethod</name></name><argument_list>(<argument><expr><name><name>MultiTermQuery</name><operator>.</operator><name>SCORING_BOOLEAN_REWRITE</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>diff</name> <operator>--</operator><name>git</name> <name>a</name><operator>/</operator><name>lucene</name><operator>/</operator><name>queryparser</name><operator>/</operator><name>src</name><operator>/</operator><name>test</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>queryparser</name><operator>/</operator><name>flexible</name><operator>/</operator><name>standard</name><operator>/</operator><name><name>TestStandardQP</name><operator>.</operator><name>java</name></name> <name>b</name><operator>/</operator><name>lucene</name><operator>/</operator><name>queryparser</name><operator>/</operator><name>src</name><operator>/</operator><name>test</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>queryparser</name><operator>/</operator><name>flexible</name><operator>/</operator><name>standard</name><operator>/</operator><name><name>TestStandardQP</name><operator>.</operator><name>java</name></name>
<name>index</name> <name>f678796559e</name><operator>..</operator><literal type="number">7e50eeb6631</literal> <literal type="number">100644</literal>
<operator>--</operator> <name>a</name><operator>/</operator><name>lucene</name><operator>/</operator><name>queryparser</name><operator>/</operator><name>src</name><operator>/</operator><name>test</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>queryparser</name><operator>/</operator><name>flexible</name><operator>/</operator><name>standard</name><operator>/</operator><name><name>TestStandardQP</name><operator>.</operator><name>java</name></name>
<operator>++</operator> <name>b</name><operator>/</operator><name>lucene</name><operator>/</operator><name>queryparser</name><operator>/</operator><name>src</name><operator>/</operator><name>test</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>queryparser</name><operator>/</operator><name>flexible</name><operator>/</operator><name>standard</name><operator>/</operator><name><name>TestStandardQP</name><operator>.</operator><name>java</name></name>
@@ <operator>-</operator><literal type="number">87</literal></expr><operator>,</operator><expr><literal type="number">12</literal> <operator>+</operator><literal type="number">87</literal></expr><operator>,</operator><expr><literal type="number">6</literal> @@ <specifier>public</specifier> <name>class</name> <name>TestStandardQP</name> extends <name>QueryParserTestBase</name> <block>{
     <expr><call><name><name>qp</name><operator>.</operator><name>setDefaultOperator</name></name><argument_list>(<argument><expr><name><name>Operator</name><operator>.</operator><name>AND</name></name></expr></argument>)</argument_list></call></expr>;
   }</block>
   
  @<name>Override</name>
  <specifier>public</specifier> <name>void</name> <call><name>setAnalyzeRangeTerms</name><argument_list>(<argument><expr><name>CommonQueryParserConfiguration</name> <name>cqpC</name></expr></argument>,
      <argument><expr><name>boolean</name> <name>value</name></expr></argument>)</argument_list></call> <block>{
    <throw>throw <argument_list>new <argument><expr><call><name>UnsupportedOperationException</name><argument_list>()</argument_list></call></expr></argument></argument_list></throw>;
  }</block>
  
   @<name>Override</name>
   <specifier>public</specifier> <name>void</name> <call><name>setAutoGeneratePhraseQueries</name><argument_list>(<argument><expr><name>CommonQueryParserConfiguration</name> <name>cqpC</name></expr></argument>,
       <argument><expr><name>boolean</name> <name>value</name></expr></argument>)</argument_list></call> <block>{
@@ <expr><operator>-</operator><literal type="number">149</literal></expr>,<expr><literal type="number">15</literal> <operator>+</operator><literal type="number">143</literal></expr>,<expr><literal type="number">6</literal> @@ <specifier>public</specifier> <name>class</name> <name>TestStandardQP</name> extends <name>QueryParserTestBase</name> <block>{
     <expr><name>WildcardQuery</name> <name>q</name> <operator>=</operator> <operator>new</operator> <call><name>WildcardQuery</name><argument_list>(<argument><expr><operator>new</operator> <call><name>Term</name><argument_list>(<argument><expr><literal type="string">"field"</literal></expr></argument>, <argument><expr><literal type="string">"foo?ba?r"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;<comment type="line">//TODO not correct!!</comment>
     <expr><call><name>assertEquals</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><call><name>getQuery</name><argument_list>(<argument><expr><literal type="string">"foo\\?ba?r"</literal></expr></argument>, <argument><expr><name>qp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
   }</block>

  
  @<name>Override</name>
  <specifier>public</specifier> <name>void</name> <call><name>testCollatedRange</name><argument_list>()</argument_list></call> <throws>throws <argument><expr><name>Exception</name> <block>{
    <expr><call><name>expectThrows</name><argument_list>(<argument><expr><name><name>UnsupportedOperationException</name><operator>.</operator><name>class</name></name></expr></argument>, <argument><expr><lambda><parameter_list>()</parameter_list> -&gt; <block>{
      <expr><call><name>setAnalyzeRangeTerms</name><argument_list>(<argument><expr><call><name>getParser</name><argument_list>(<argument><expr><literal type="null">null</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr></block></lambda></expr></argument></argument_list></call></expr></block></expr></argument></throws></expr>;
      <expr><call><name><name>super</name><operator>.</operator><name>testCollatedRange</name></name><argument_list>()</argument_list></call></expr>;
    }</block></expr></expr_stmt>)</block_content></block>;</function>
  <expr_stmt/></block_content></block></expr>}</block>
   
   @<name>Override</name>
   <specifier>public</specifier> <name>void</name> <call><name>testAutoGeneratePhraseQueriesOn</name><argument_list>()</argument_list></call> <throws>throws <argument><expr><name>Exception</name> <block>{
<expr><name>diff</name> <operator>--</operator><name>git</name> <name>a</name><operator>/</operator><name>lucene</name><operator>/</operator><name>queryparser</name><operator>/</operator><name>src</name><operator>/</operator><name>test</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>queryparser</name><operator>/</operator><name>util</name><operator>/</operator><name><name>QueryParserTestBase</name><operator>.</operator><name>java</name></name> <name>b</name><operator>/</operator><name>lucene</name><operator>/</operator><name>queryparser</name><operator>/</operator><name>src</name><operator>/</operator><name>test</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>queryparser</name><operator>/</operator><name>util</name><operator>/</operator><name><name>QueryParserTestBase</name><operator>.</operator><name>java</name></name>
<name>index</name> <name>d58f6605670</name><operator>..</operator><literal type="number">217019350b7</literal> <literal type="number">100644</literal>
<operator>--</operator> <name>a</name><operator>/</operator><name>lucene</name><operator>/</operator><name>queryparser</name><operator>/</operator><name>src</name><operator>/</operator><name>test</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>queryparser</name><operator>/</operator><name>util</name><operator>/</operator><name><name>QueryParserTestBase</name><operator>.</operator><name>java</name></name>
<operator>++</operator> <name>b</name><operator>/</operator><name>lucene</name><operator>/</operator><name>queryparser</name><operator>/</operator><name>src</name><operator>/</operator><name>test</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>queryparser</name><operator>/</operator><name>util</name><operator>/</operator><name><name>QueryParserTestBase</name><operator>.</operator><name>java</name></name></expr></block></expr></argument>
@<argument>@ <expr><operator>-</operator><literal type="number">145</literal></expr></argument>,<argument><expr><literal type="number">8</literal> <operator>+</operator><literal type="number">145</literal></expr></argument>,<argument><expr><literal type="number">6</literal> @@ <specifier>public</specifier> <specifier>abstract</specifier> <name>class</name> <name>QueryParserTestBase</name> extends <name>LuceneTestCase</name></expr></argument></throws> <block>{<block_content>
 
   <decl_stmt><decl><type><specifier>public</specifier> <specifier>abstract</specifier> <name>void</name></type> <name>setDefaultOperatorAND</name><argument_list>(<argument><expr><name>CommonQueryParserConfiguration</name> <name>cqpC</name></expr></argument>)</argument_list></decl>;</decl_stmt>
 
  <decl_stmt><decl><type><specifier>public</specifier> <specifier>abstract</specifier> <name>void</name></type> <name>setAnalyzeRangeTerms</name><argument_list>(<argument><expr><name>CommonQueryParserConfiguration</name> <name>cqpC</name></expr></argument>, <argument><expr><name>boolean</name> <name>value</name></expr></argument>)</argument_list></decl>;</decl_stmt>

   <decl_stmt><decl><type><specifier>public</specifier> <specifier>abstract</specifier> <name>void</name></type> <name>setAutoGeneratePhraseQueries</name><argument_list>(<argument><expr><name>CommonQueryParserConfiguration</name> <name>cqpC</name></expr></argument>, <argument><expr><name>boolean</name> <name>value</name></expr></argument>)</argument_list></decl>;</decl_stmt>
 
   <decl_stmt><decl><type><specifier>public</specifier> <specifier>abstract</specifier> <name>void</name></type> <name>setDateResolution</name><argument_list>(<argument><expr><name>CommonQueryParserConfiguration</name> <name>cqpC</name></expr></argument>, <argument><expr><name>CharSequence</name> <name>field</name></expr></argument>, <argument><expr><name><name>DateTools</name><operator>.</operator><name>Resolution</name></name> <name>value</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">203</literal></expr><operator>,</operator><expr><literal type="number">10</literal> <operator>+</operator><literal type="number">201</literal></expr><operator>,</operator><expr><literal type="number">9</literal> @@ <specifier>public</specifier> <specifier>abstract</specifier> <name>class</name> <name>QueryParserTestBase</name> extends <name>LuceneTestCase</name> <block>{
     }</block></expr></expr_stmt>
   </block_content>}</block></expr></expr_stmt>
 
  <decl_stmt><decl><type><specifier>public</specifier> <name>void</name></type> <name>assertWildcardQueryEquals</name><argument_list>(<argument><expr><name>String</name> <name>query</name></expr></argument>, <argument><expr><name>boolean</name> <name>lowercase</name></expr></argument>, <argument><expr><name>String</name> <name>result</name></expr></argument>, <argument><expr><name>boolean</name> <name>allowLeadingWildcard</name></expr></argument>)</argument_list>
  public <name>void</name> <name>assertWildcardQueryEquals</name><argument_list>(<argument><expr><name>String</name> <name>query</name></expr></argument>, <argument><expr><name>String</name> <name>result</name></expr></argument>, <argument><expr><name>boolean</name> <name>allowLeadingWildcard</name></expr></argument>)</argument_list>
     <throws>throws <argument><expr><name>Exception</name> <block>{
     <expr><name>CommonQueryParserConfiguration</name> <name>cqpC</name> <operator>=</operator> <call><name>getParserConfig</name><argument_list>(<argument><expr><literal type="null">null</literal></expr></argument>)</argument_list></call></expr></block></expr></argument></throws></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>cqpC</name><operator>.</operator><name>setLowercaseExpandedTerms</name></name><argument_list>(<argument><expr><name>lowercase</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
     <expr_stmt><expr><call><name><name>cqpC</name><operator>.</operator><name>setAllowLeadingWildcard</name></name><argument_list>(<argument><expr><name>allowLeadingWildcard</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
     <decl_stmt><decl><type><name>Query</name></type> <name>q</name> <init>= <expr><call><name>getQuery</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>cqpC</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
     <decl_stmt><decl><type><name>String</name></type> <name>s</name> <init>= <expr><call><name><name>q</name><operator>.</operator><name>toString</name></name><argument_list>(<argument><expr><literal type="string">"field"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">216</literal></expr><operator>,</operator><expr><literal type="number">18</literal> <operator>+</operator><literal type="number">213</literal></expr><operator>,</operator><expr><literal type="number">9</literal> @@ <specifier>public</specifier> <specifier>abstract</specifier> <name>class</name> <name>QueryParserTestBase</name> extends <name>LuceneTestCase</name> <block>{
     }</block></expr></expr_stmt>
   </block_content>}</block></function>
 
  <decl_stmt><decl><type><specifier>public</specifier> <name>void</name></type> <name>assertWildcardQueryEquals</name><argument_list>(<argument><expr><name>String</name> <name>query</name></expr></argument>, <argument><expr><name>boolean</name> <name>lowercase</name></expr></argument>, <argument><expr><name>String</name> <name>result</name></expr></argument>)</argument_list>
  public <name>void</name> <name>assertWildcardQueryEquals</name><argument_list>(<argument><expr><name>String</name> <name>query</name></expr></argument>, <argument><expr><name>String</name> <name>result</name></expr></argument>)</argument_list>
     <throws>throws <argument><expr><name>Exception</name> <block>{
    <expr><call><name>assertWildcardQueryEquals</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>lowercase</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr></block></expr></argument></throws></decl>;</decl_stmt>
  }

  public <function><type><name>void</name></type> <name>assertWildcardQueryEquals</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>query</name></decl></parameter>, <parameter><decl><type><name>String</name></type> <name>result</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>Exception</name></expr></argument></throws> <block>{<block_content>
    <decl_stmt><decl><type><name>Query</name></type> <name>q</name> <init>= <expr><call><name>getQuery</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>String</name></type> <name>s</name> <init>= <expr><call><name><name>q</name><operator>.</operator><name>toString</name></name><argument_list>(<argument><expr><literal type="string">"field"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>s</name><operator>.</operator><name>equals</name></name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"WildcardQuery /"</literal> <operator>+</operator> <name>query</name> <operator>+</operator> <literal type="string">"/ yielded /"</literal> <operator>+</operator> <name>s</name> <operator>+</operator> <literal type="string">"/, expecting /"</literal>
          <operator>+</operator> <name>result</name> <operator>+</operator> <literal type="string">"/"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>assertWildcardQueryEquals</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
   </block_content>}</block></function>
 
   <decl_stmt><decl><type><specifier>public</specifier> <name>Query</name></type> <name>getQueryDOA</name><argument_list>(<argument><expr><name>String</name> <name>query</name></expr></argument>, <argument><expr><name>Analyzer</name> <name>a</name></expr></argument>)</argument_list>
@@ -473</decl>,39 +461,26 @@ public abstract <decl><type ref="prev"/><name>class</name> <name>QueryParserTestBase</name> extends <name>LuceneTestCase</name> <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><operator>/</operator>
 <comment type="line">// First prefix queries:</comment>
     <comment type="line">// by default, convert to lowercase:</comment>
    <call><name>assertWildcardQueryEquals</name><argument_list>(<argument><expr><literal type="string">"Term*"</literal></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>, <argument><expr><literal type="string">"term*"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assertWildcardQueryEquals</name><argument_list>(<argument><expr><literal type="string">"Term*"</literal></expr></argument>, <argument><expr><literal type="string">"term*"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
     <comment type="line">// explicitly set lowercase:</comment>
    <expr_stmt><expr><call><name>assertWildcardQueryEquals</name><argument_list>(<argument><expr><literal type="string">"term*"</literal></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>, <argument><expr><literal type="string">"term*"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assertWildcardQueryEquals</name><argument_list>(<argument><expr><literal type="string">"Term*"</literal></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>, <argument><expr><literal type="string">"term*"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assertWildcardQueryEquals</name><argument_list>(<argument><expr><literal type="string">"TERM*"</literal></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>, <argument><expr><literal type="string">"term*"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="line">// explicitly disable lowercase conversion:</comment>
    <expr_stmt><expr><call><name>assertWildcardQueryEquals</name><argument_list>(<argument><expr><literal type="string">"term*"</literal></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>, <argument><expr><literal type="string">"term*"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assertWildcardQueryEquals</name><argument_list>(<argument><expr><literal type="string">"Term*"</literal></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>, <argument><expr><literal type="string">"Term*"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assertWildcardQueryEquals</name><argument_list>(<argument><expr><literal type="string">"TERM*"</literal></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>, <argument><expr><literal type="string">"TERM*"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assertWildcardQueryEquals</name><argument_list>(<argument><expr><literal type="string">"term*"</literal></expr></argument>, <argument><expr><literal type="string">"term*"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assertWildcardQueryEquals</name><argument_list>(<argument><expr><literal type="string">"Term*"</literal></expr></argument>, <argument><expr><literal type="string">"term*"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assertWildcardQueryEquals</name><argument_list>(<argument><expr><literal type="string">"TERM*"</literal></expr></argument>, <argument><expr><literal type="string">"term*"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
 <comment type="line">// Then 'full' wildcard queries:</comment>
     <comment type="line">// by default, convert to lowercase:</comment>
     <expr_stmt><expr><call><name>assertWildcardQueryEquals</name><argument_list>(<argument><expr><literal type="string">"Te?m"</literal></expr></argument>, <argument><expr><literal type="string">"te?m"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
     <comment type="line">// explicitly set lowercase:</comment>
    <expr_stmt><expr><call><name>assertWildcardQueryEquals</name><argument_list>(<argument><expr><literal type="string">"te?m"</literal></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>, <argument><expr><literal type="string">"te?m"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assertWildcardQueryEquals</name><argument_list>(<argument><expr><literal type="string">"Te?m"</literal></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>, <argument><expr><literal type="string">"te?m"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assertWildcardQueryEquals</name><argument_list>(<argument><expr><literal type="string">"TE?M"</literal></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>, <argument><expr><literal type="string">"te?m"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assertWildcardQueryEquals</name><argument_list>(<argument><expr><literal type="string">"Te?m*gerM"</literal></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>, <argument><expr><literal type="string">"te?m*germ"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="line">// explicitly disable lowercase conversion:</comment>
    <expr_stmt><expr><call><name>assertWildcardQueryEquals</name><argument_list>(<argument><expr><literal type="string">"te?m"</literal></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>, <argument><expr><literal type="string">"te?m"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assertWildcardQueryEquals</name><argument_list>(<argument><expr><literal type="string">"Te?m"</literal></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>, <argument><expr><literal type="string">"Te?m"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assertWildcardQueryEquals</name><argument_list>(<argument><expr><literal type="string">"TE?M"</literal></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>, <argument><expr><literal type="string">"TE?M"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assertWildcardQueryEquals</name><argument_list>(<argument><expr><literal type="string">"Te?m*gerM"</literal></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>, <argument><expr><literal type="string">"Te?m*gerM"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assertWildcardQueryEquals</name><argument_list>(<argument><expr><literal type="string">"te?m"</literal></expr></argument>, <argument><expr><literal type="string">"te?m"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assertWildcardQueryEquals</name><argument_list>(<argument><expr><literal type="string">"Te?m"</literal></expr></argument>, <argument><expr><literal type="string">"te?m"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assertWildcardQueryEquals</name><argument_list>(<argument><expr><literal type="string">"TE?M"</literal></expr></argument>, <argument><expr><literal type="string">"te?m"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assertWildcardQueryEquals</name><argument_list>(<argument><expr><literal type="string">"Te?m*gerM"</literal></expr></argument>, <argument><expr><literal type="string">"te?m*germ"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
 <comment type="line">//  Fuzzy queries:</comment>
     <expr_stmt><expr><call><name>assertWildcardQueryEquals</name><argument_list>(<argument><expr><literal type="string">"Term~"</literal></expr></argument>, <argument><expr><literal type="string">"term~2"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assertWildcardQueryEquals</name><argument_list>(<argument><expr><literal type="string">"Term~"</literal></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>, <argument><expr><literal type="string">"term~2"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assertWildcardQueryEquals</name><argument_list>(<argument><expr><literal type="string">"Term~"</literal></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>, <argument><expr><literal type="string">"Term~2"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
 <comment type="line">//  Range queries:</comment>
     <expr_stmt><expr><call><name>assertWildcardQueryEquals</name><argument_list>(<argument><expr><literal type="string">"[A TO C]"</literal></expr></argument>, <argument><expr><literal type="string">"[a TO c]"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assertWildcardQueryEquals</name><argument_list>(<argument><expr><literal type="string">"[A TO C]"</literal></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>, <argument><expr><literal type="string">"[a TO c]"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assertWildcardQueryEquals</name><argument_list>(<argument><expr><literal type="string">"[A TO C]"</literal></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>, <argument><expr><literal type="string">"[A TO C]"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
     <comment type="line">// Test suffix queries: first disallow</comment>
     <try>try <block>{<block_content>
      <expr_stmt><expr><call><name>assertWildcardQueryEquals</name><argument_list>(<argument><expr><literal type="string">"*Term"</literal></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>, <argument><expr><literal type="string">"*term"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assertWildcardQueryEquals</name><argument_list>(<argument><expr><literal type="string">"*Term"</literal></expr></argument>, <argument><expr><literal type="string">"*term"</literal></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
     </block_content>}</block> <catch>catch<parameter_list>(<parameter><decl><type><name>Exception</name></type> <name>pe</name></decl></parameter>)</parameter_list> <block>{<block_content>
       <comment type="line">// expected exception</comment>
       <if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>isQueryParserException</name><argument_list>(<argument><expr><name>pe</name></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">513</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">488</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@ <specifier>public</specifier> <specifier>abstract</specifier> <name>class</name> <name>QueryParserTestBase</name> extends <name>LuceneTestCase</name> <block>{
       }</block></expr></expr_stmt>
     </block_content>}</block></if></if_stmt>
     <try>try <block>{<block_content>
      <expr_stmt><expr><call><name>assertWildcardQueryEquals</name><argument_list>(<argument><expr><literal type="string">"?Term"</literal></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>, <argument><expr><literal type="string">"?term"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assertWildcardQueryEquals</name><argument_list>(<argument><expr><literal type="string">"?Term"</literal></expr></argument>, <argument><expr><literal type="string">"?term"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
       <expr_stmt><expr><call><name>fail</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
     </block_content>}</block> <catch>catch<parameter_list>(<parameter><decl><type><name>Exception</name></type> <name>pe</name></decl></parameter>)</parameter_list> <block>{<block_content>
       <comment type="line">// expected exception</comment>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">522</literal></expr><operator>,</operator><expr><literal type="number">8</literal> <operator>+</operator><literal type="number">497</literal></expr><operator>,</operator><expr><literal type="number">8</literal> @@ <specifier>public</specifier> <specifier>abstract</specifier> <name>class</name> <name>QueryParserTestBase</name> extends <name>LuceneTestCase</name> <block>{
       }</block></expr></expr_stmt>
     </block_content>}</block></catch></try>
     <comment type="line">// Test suffix queries: then allow</comment>
    <expr_stmt><expr><call><name>assertWildcardQueryEquals</name><argument_list>(<argument><expr><literal type="string">"*Term"</literal></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>, <argument><expr><literal type="string">"*term"</literal></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assertWildcardQueryEquals</name><argument_list>(<argument><expr><literal type="string">"?Term"</literal></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>, <argument><expr><literal type="string">"?term"</literal></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assertWildcardQueryEquals</name><argument_list>(<argument><expr><literal type="string">"*Term"</literal></expr></argument>, <argument><expr><literal type="string">"*term"</literal></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assertWildcardQueryEquals</name><argument_list>(<argument><expr><literal type="string">"?Term"</literal></expr></argument>, <argument><expr><literal type="string">"?term"</literal></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
   </block_content>}</block></catch></try>
   
   <function><type><specifier>public</specifier> <name>void</name></type> <name>testLeadingWildcardType</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>Exception</name></expr></argument></throws> <block>{<block_content>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">982</literal></expr><operator>,</operator><expr><literal type="number">10</literal> <operator>+</operator><literal type="number">957</literal></expr><operator>,</operator><expr><literal type="number">9</literal> @@ <specifier>public</specifier> <specifier>abstract</specifier> <name>class</name> <name>QueryParserTestBase</name> extends <name>LuceneTestCase</name> <block>{
   }</block>
   
   <specifier>public</specifier> <name>void</name> <call><name>testRegexps</name><argument_list>()</argument_list></call> <throws>throws <argument><expr><name>Exception</name> <block>{
    <expr><name>CommonQueryParserConfiguration</name> <name>qp</name> <operator>=</operator> <call><name>getParserConfig</name><argument_list>( <argument><expr><operator>new</operator> <call><name>MockAnalyzer</name><argument_list>(<argument><expr><call><name>random</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>MockTokenizer</name><operator>.</operator><name>WHITESPACE</name></name></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></block></expr></argument></throws></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>CommonQueryParserConfiguration</name></type> <name>qp</name> <init>= <expr><call><name>getParserConfig</name><argument_list>( <argument><expr><operator>new</operator> <call><name>MockAnalyzer</name><argument_list>(<argument><expr><call><name>random</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>MockTokenizer</name><operator>.</operator><name>WHITESPACE</name></name></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
     <decl_stmt><decl><type><name>RegexpQuery</name></type> <name>q</name> <init>= <expr><operator>new</operator> <call><name>RegexpQuery</name><argument_list>(<argument><expr><operator>new</operator> <call><name>Term</name><argument_list>(<argument><expr><literal type="string">"field"</literal></expr></argument>, <argument><expr><literal type="string">"[a-z][123]"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
     <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><call><name>getQuery</name><argument_list>(<argument><expr><literal type="string">"/[a-z][123]/"</literal></expr></argument>,<argument><expr><name>qp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>qp</name><operator>.</operator><name>setLowercaseExpandedTerms</name></name><argument_list>(<argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
     <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><call><name>getQuery</name><argument_list>(<argument><expr><literal type="string">"/[A-Z][123]/"</literal></expr></argument>,<argument><expr><name>qp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
     <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><operator>new</operator> <call><name>BoostQuery</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="number">0.5f</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>getQuery</name><argument_list>(<argument><expr><literal type="string">"/[A-Z][123]/^0.5"</literal></expr></argument>,<argument><expr><name>qp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
     <expr_stmt><expr><call><name><name>qp</name><operator>.</operator><name>setMultiTermRewriteMethod</name></name><argument_list>(<argument><expr><name><name>MultiTermQuery</name><operator>.</operator><name>SCORING_BOOLEAN_REWRITE</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">1169</literal></expr><operator>,</operator><expr><literal type="number">11</literal> <operator>+</operator><literal type="number">1143</literal></expr><operator>,</operator><expr><literal type="number">14</literal> @@ <specifier>public</specifier> <specifier>abstract</specifier> <name>class</name> <name>QueryParserTestBase</name> extends <name>LuceneTestCase</name> <block>{
       <expr><name>Tokenizer</name> <name>tokenizer</name> <operator>=</operator> <operator>new</operator> <call><name>MockTokenizer</name><argument_list>(<argument><expr><name><name>MockTokenizer</name><operator>.</operator><name>WHITESPACE</name></name></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr>;
       <return>return <expr><operator>new</operator> <call><name>TokenStreamComponents</name><argument_list>(<argument><expr><name>tokenizer</name></expr></argument>, <argument><expr><operator>new</operator> <call><name>MockCollationFilter</name><argument_list>(<argument><expr><name>tokenizer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
     }</block></expr></expr_stmt>
    <function><annotation>@<name>Override</name></annotation>
    <type><specifier>protected</specifier> <name>TokenStream</name></type> <name>normalize</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>fieldName</name></decl></parameter>, <parameter><decl><type><name>TokenStream</name></type> <name>in</name></decl></parameter>)</parameter_list> <block>{<block_content>
      <return>return <expr><operator>new</operator> <call><name>MockCollationFilter</name><argument_list>(<argument><expr><operator>new</operator> <call><name>LowerCaseFilter</name><argument_list>(<argument><expr><name>in</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>
   </block_content>}</block></function>
   
   <function><type><specifier>public</specifier> <name>void</name></type> <name>testCollatedRange</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>Exception</name></expr></argument></throws> <block>{<block_content>
     <decl_stmt><decl><type><name>CommonQueryParserConfiguration</name></type> <name>qp</name> <init>= <expr><call><name>getParserConfig</name><argument_list>(<argument><expr><operator>new</operator> <call><name>MockCollationAnalyzer</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>setAnalyzeRangeTerms</name><argument_list>(<argument><expr><name>qp</name></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
     <decl_stmt><decl><type><name>Query</name></type> <name>expected</name> <init>= <expr><call><name><name>TermRangeQuery</name><operator>.</operator><name>newStringRange</name></name><argument_list>(<argument><expr><call><name>getDefaultField</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="string">"collatedabc"</literal></expr></argument>, <argument><expr><literal type="string">"collateddef"</literal></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
     <decl_stmt><decl><type><name>Query</name></type> <name>actual</name> <init>= <expr><call><name>getQuery</name><argument_list>(<argument><expr><literal type="string">"[abc TO def]"</literal></expr></argument>, <argument><expr><name>qp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
     <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><name>expected</name></expr></argument>, <argument><expr><name>actual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>diff</name> <operator>--</operator><name>git</name> <name>a</name><operator>/</operator><name>lucene</name><operator>/</operator><name>test</name><operator>-</operator><name>framework</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>analysis</name><operator>/</operator><name><name>BaseTokenStreamTestCase</name><operator>.</operator><name>java</name></name> <name>b</name><operator>/</operator><name>lucene</name><operator>/</operator><name>test</name><operator>-</operator><name>framework</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>analysis</name><operator>/</operator><name><name>BaseTokenStreamTestCase</name><operator>.</operator><name>java</name></name>
<name>index</name> <name>c57a8bca6d1</name><operator>..</operator><literal type="number">0bb623fe36d</literal> <literal type="number">100644</literal>
<operator>--</operator> <name>a</name><operator>/</operator><name>lucene</name><operator>/</operator><name>test</name><operator>-</operator><name>framework</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>analysis</name><operator>/</operator><name><name>BaseTokenStreamTestCase</name><operator>.</operator><name>java</name></name>
<operator>++</operator> <name>b</name><operator>/</operator><name>lucene</name><operator>/</operator><name>test</name><operator>-</operator><name>framework</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>analysis</name><operator>/</operator><name><name>BaseTokenStreamTestCase</name><operator>.</operator><name>java</name></name>
@@ <operator>-</operator><literal type="number">883</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">883</literal></expr><operator>,</operator><expr><literal type="number">10</literal> @@ <specifier>public</specifier> <specifier>abstract</specifier> <name>class</name> <name>BaseTokenStreamTestCase</name> extends <name>LuceneTestCase</name> <block>{
       <expr><call><name>assertTokenStreamContents</name><argument_list>(<argument><expr><name>ts</name></expr></argument>, 
                                 <argument><expr><call><name><name>tokens</name><operator>.</operator><name>toArray</name></name><argument_list>(<argument><expr><operator>new</operator> <name><name>String</name><index>[<expr><call><name><name>tokens</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
     }</block>
    

    <call><name><name>a</name><operator>.</operator><name>normalize</name></name><argument_list>(<argument><expr><literal type="string">"dummy"</literal></expr></argument>, <argument><expr><name>text</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="line">// TODO: what can we do besides testing that the above method does not throw?</comment>

     <if_stmt><if>if <condition>(<expr><name>field</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
       <expr_stmt><expr><name>reader</name> <operator>=</operator> <operator>new</operator> <call><name>StringReader</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
       <expr_stmt><expr><name>random</name> <operator>=</operator> <operator>new</operator> <call><name>Random</name><argument_list>(<argument><expr><name>seed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>diff</name> <operator>--</operator><name>git</name> <name>a</name><operator>/</operator><name>lucene</name><operator>/</operator><name>test</name><operator>-</operator><name>framework</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>analysis</name><operator>/</operator><name><name>MockAnalyzer</name><operator>.</operator><name>java</name></name> <name>b</name><operator>/</operator><name>lucene</name><operator>/</operator><name>test</name><operator>-</operator><name>framework</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>analysis</name><operator>/</operator><name><name>MockAnalyzer</name><operator>.</operator><name>java</name></name>
<name>index</name> <name>e87bf45d3f5</name><operator>..</operator><name>bbeffe953fb</name> <literal type="number">100644</literal>
<operator>--</operator> <name>a</name><operator>/</operator><name>lucene</name><operator>/</operator><name>test</name><operator>-</operator><name>framework</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>analysis</name><operator>/</operator><name><name>MockAnalyzer</name><operator>.</operator><name>java</name></name>
<operator>++</operator> <name>b</name><operator>/</operator><name>lucene</name><operator>/</operator><name>test</name><operator>-</operator><name>framework</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>analysis</name><operator>/</operator><name><name>MockAnalyzer</name><operator>.</operator><name>java</name></name>
@@ <operator>-</operator><literal type="number">92</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">92</literal></expr><operator>,</operator><expr><literal type="number">16</literal> @@ <specifier>public</specifier> <name>final</name> <name>class</name> <name>MockAnalyzer</name> extends <name>Analyzer</name> <block>{
     <expr><name>MockTokenFilter</name> <name>filt</name> <operator>=</operator> <operator>new</operator> <call><name>MockTokenFilter</name><argument_list>(<argument><expr><name>tokenizer</name></expr></argument>, <argument><expr><name>filter</name></expr></argument>)</argument_list></call></expr>;</block></expr></expr_stmt>
     <return>return <expr><operator>new</operator> <call><name>TokenStreamComponents</name><argument_list>(<argument><expr><name>tokenizer</name></expr></argument>, <argument><expr><call><name>maybePayload</name><argument_list>(<argument><expr><name>filt</name></expr></argument>, <argument><expr><name>fieldName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
   </block_content>}</block></if></if_stmt>
  

  <function><annotation>@<name>Override</name></annotation>
  <type><specifier>protected</specifier> <name>TokenStream</name></type> <name>normalize</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>fieldName</name></decl></parameter>, <parameter><decl><type><name>TokenStream</name></type> <name>in</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>TokenStream</name></type> <name>result</name> <init>= <expr><name>in</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>lowerCase</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>new</operator> <call><name>MockLowerCaseFilter</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>result</name></expr>;</return>
  </block_content>}</block></function>

   <function><type><specifier>private</specifier> <specifier>synchronized</specifier> <name>TokenFilter</name></type> <name>maybePayload</name><parameter_list>(<parameter><decl><type><name>TokenFilter</name></type> <name>stream</name></decl></parameter>, <parameter><decl><type><name>String</name></type> <name>fieldName</name></decl></parameter>)</parameter_list> <block>{<block_content>
     <decl_stmt><decl><type><name>Integer</name></type> <name>val</name> <init>= <expr><call><name><name>previousMappings</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>fieldName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
     <if_stmt><if>if <condition>(<expr><name>val</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>diff</name> <operator>--</operator><name>git</name> <name>a</name><operator>/</operator><name>lucene</name><operator>/</operator><name>test</name><operator>-</operator><name>framework</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>analysis</name><operator>/</operator><name><name>MockBytesAnalyzer</name><operator>.</operator><name>java</name></name> <name>b</name><operator>/</operator><name>lucene</name><operator>/</operator><name>test</name><operator>-</operator><name>framework</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>analysis</name><operator>/</operator><name><name>MockBytesAnalyzer</name><operator>.</operator><name>java</name></name>
<name>index</name> <literal type="number">01f3d4d1092</literal><operator>..</operator><name>b8cfc5be1d6</name> <literal type="number">100644</literal>
<operator>--</operator> <name>a</name><operator>/</operator><name>lucene</name><operator>/</operator><name>test</name><operator>-</operator><name>framework</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>analysis</name><operator>/</operator><name><name>MockBytesAnalyzer</name><operator>.</operator><name>java</name></name>
<operator>++</operator> <name>b</name><operator>/</operator><name>lucene</name><operator>/</operator><name>test</name><operator>-</operator><name>framework</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>analysis</name><operator>/</operator><name><name>MockBytesAnalyzer</name><operator>.</operator><name>java</name></name>
@@ <operator>-</operator><literal type="number">16</literal></expr><operator>,</operator><expr><literal type="number">6</literal> <operator>+</operator><literal type="number">16</literal></expr><operator>,</operator><expr><literal type="number">8</literal> @@
  <operator>*</operator><operator>/</operator></expr></expr_stmt>
 <package>package <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>analysis</name></name>;</package>
 
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>util</name><operator>.</operator><name>AttributeFactory</name></name>;</import>

 <comment type="block" format="javadoc">/**
  * Analyzer for testing that encodes terms as UTF-16 bytes.
  */</comment>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">26</literal></expr><operator>,</operator><expr><literal type="number">4</literal> <operator>+</operator><literal type="number">28</literal></expr><operator>,</operator><expr><literal type="number">9</literal> @@ <specifier>public</specifier> <name>final</name> <name>class</name> <name>MockBytesAnalyzer</name> extends <name>Analyzer</name> <block>{
         <expr><name><name>MockTokenizer</name><operator>.</operator><name>KEYWORD</name></name></expr>, <expr><literal type="boolean">false</literal></expr>, <expr><name><name>MockTokenizer</name><operator>.</operator><name>DEFAULT_MAX_TOKEN_LENGTH</name></name></expr>)</block></expr>;</expr_stmt>
     <return>return <expr><operator>new</operator> <call><name>TokenStreamComponents</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</return>
   </block_content>}</block></if></if_stmt>

  <function><annotation>@<name>Override</name></annotation>
  <type><specifier>protected</specifier> <name>AttributeFactory</name></type> <name>attributeFactory</name><parameter_list>()</parameter_list> <block>{<block_content>
    <return>return <expr><name><name>MockUTF16TermAttributeImpl</name><operator>.</operator><name>UTF16_TERM_ATTRIBUTE_FACTORY</name></name></expr>;</return>
  </block_content>}</block></function>
 </block_content>}</block></function>
<expr_stmt><expr><name>diff</name> <operator>--</operator><name>git</name> <name>a</name><operator>/</operator><name>lucene</name><operator>/</operator><name>queryparser</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>lucene</name><operator>/</operator><name>queryparser</name><operator>/</operator><name>analyzing</name><operator>/</operator></expr></expr_stmt><package>package-<name><name>info</name><operator>.</operator><name>java</name></name> <name>b</name>/<name>lucene</name>/<name>test</name>-<name>framework</name>/<name>src</name>/<name>java</name>/<name>org</name>/<name>apache</name>/<name>lucene</name>/<name>analysis</name>/<name><name>MockLowerCaseFilter</name><operator>.</operator><name>java</name></name>
<name>similarity</name> <name>index</name> 55%
<name>rename</name> <name>from</name> <name>lucene</name>/<name>queryparser</name>/<name>src</name>/<name>java</name>/<name>org</name>/<name>apache</name>/<name>lucene</name>/<name>queryparser</name>/<name>analyzing</name>/package-<name><name>info</name><operator>.</operator><name>java</name></name>
<name>rename</name> <name>to</name> <name>lucene</name>/<name>test</name>-<name>framework</name>/<name>src</name>/<name>java</name>/<name>org</name>/<name>apache</name>/<name>lucene</name>/<name>analysis</name>/<name><name>MockLowerCaseFilter</name><operator>.</operator><name>java</name></name>
<name>index</name> 77397b45cbf..<name>b1aea3d9af7</name> 100644
-- <name>a</name>/<name>lucene</name>/<name>queryparser</name>/<name>src</name>/<name>java</name>/<name>org</name>/<name>apache</name>/<name>lucene</name>/<name>queryparser</name>/<name>analyzing</name>/package-<name><name>info</name><operator>.</operator><name>java</name></name>
++ <name>b</name>/<name>lucene</name>/<name>test</name>-<name>framework</name>/<name>src</name>/<name>java</name>/<name>org</name>/<name>apache</name>/<name>lucene</name>/<name>analysis</name>/<name><name>MockLowerCaseFilter</name><operator>.</operator><name>java</name></name>
@@ -14<operator>,</operator>9 +14<operator>,</operator>27 @@
  * <name>See</name> <name>the</name> <name>License</name> for <name>the</name> <name>specific</name> <name>language</name> <name>governing</name> <name>permissions</name> <name>and</name>
  * <name>limitations</name> <name>under</name> <name>the</name> <name><name>License</name><operator>.</operator></name>
  */
 
<comment type="block" format="javadoc">/** 
 * QueryParser that passes Fuzzy-, Prefix-, Range-, and WildcardQuerys through the given analyzer.
 */</comment>
package <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>queryparser</name><operator>.</operator><name>analyzing</name></name>;</package>
<package>package <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>analysis</name></name>;</package>

<import>import <name><name>java</name><operator>.</operator><name>io</name><operator>.</operator><name>IOException</name></name>;</import>

<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>analysis</name><operator>.</operator><name>tokenattributes</name><operator>.</operator><name>CharTermAttribute</name></name>;</import>

<comment type="block" format="javadoc">/** A lowercasing {@link TokenFilter}. */</comment>
<class><specifier>public</specifier> <specifier>final</specifier> class <name>MockLowerCaseFilter</name> <super_list><extends>extends <super><name>TokenFilter</name></super></extends></super_list> <block>{
  <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>CharTermAttribute</name></type> <name>termAtt</name> <init>= <expr><call><name>addAttribute</name><argument_list>(<argument><expr><name><name>CharTermAttribute</name><operator>.</operator><name>class</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
 
  <comment type="block" format="javadoc">/** Sole constructor. */</comment>
  <constructor><specifier>public</specifier> <name>MockLowerCaseFilter</name><parameter_list>(<parameter><decl><type><name>TokenStream</name></type> <name>in</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>super</name><argument_list>(<argument><expr><name>in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></constructor>
  
  <function><annotation>@<name>Override</name></annotation>
  <type><specifier>public</specifier> <specifier>final</specifier> <name>boolean</name></type> <name>incrementToken</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name><name>input</name><operator>.</operator><name>incrementToken</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name><name>CharacterUtils</name><operator>.</operator><name>toLowerCase</name></name><argument_list>(<argument><expr><call><name><name>termAtt</name><operator>.</operator><name>buffer</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name><name>termAtt</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><literal type="boolean">true</literal></expr>;</return>
    </block_content>}</block></if> <else>else<block type="pseudo"><block_content>
      <return>return <expr><literal type="boolean">false</literal></expr>;</return></block_content></block></else></if_stmt>
  </block_content>}</block></function>
}</block></class>
<expr_stmt><expr><name>diff</name> <operator>--</operator><name>git</name> <name>a</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>analysis</name><operator>/</operator><name><name>TokenizerChain</name><operator>.</operator><name>java</name></name> <name>b</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>analysis</name><operator>/</operator><name><name>TokenizerChain</name><operator>.</operator><name>java</name></name>
<name>index</name> <name>c9f263d44d7</name><operator>..</operator><name>a5afbeccd8e</name> <literal type="number">100644</literal>
<operator>--</operator> <name>a</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>analysis</name><operator>/</operator><name><name>TokenizerChain</name><operator>.</operator><name>java</name></name>
<operator>++</operator> <name>b</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>analysis</name><operator>/</operator><name><name>TokenizerChain</name><operator>.</operator><name>java</name></name>
@@ <operator>-</operator><literal type="number">18</literal></expr><operator>,</operator><expr><literal type="number">6</literal> <operator>+</operator><literal type="number">18</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@</expr></expr_stmt> <package>package <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>analysis</name></name>;</package>
 
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>analysis</name><operator>.</operator><name>*</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>analysis</name><operator>.</operator><name>util</name><operator>.</operator><name>CharFilterFactory</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>analysis</name><operator>.</operator><name>util</name><operator>.</operator><name>MultiTermAwareComponent</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>analysis</name><operator>.</operator><name>util</name><operator>.</operator><name>TokenFilterFactory</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>analysis</name><operator>.</operator><name>util</name><operator>.</operator><name>TokenizerFactory</name></name>;</import>
 
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">83</literal></expr><operator>,</operator><expr><literal type="number">9</literal> <operator>+</operator><literal type="number">84</literal></expr><operator>,</operator><expr><literal type="number">22</literal> @@ <specifier>public</specifier> <name>final</name> <name>class</name> <name>TokenizerChain</name> extends <name>SolrAnalyzer</name> <block>{
     <return>return <expr><name>reader</name></expr>;</return>
   }</block></expr></expr_stmt>
 
  <function><annotation>@<name>Override</name></annotation>
  <type><specifier>protected</specifier> <name>Reader</name></type> <name>initReaderForNormalization</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>fieldName</name></decl></parameter>, <parameter><decl><type><name>Reader</name></type> <name>reader</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>charFilters</name> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <name><name>charFilters</name><operator>.</operator><name>length</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <for>for <control>(<init><decl><type><name>CharFilterFactory</name></type> <name>charFilter</name> <range>: <expr><name>charFilters</name></expr></range></decl></init>)</control> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>charFilter</name> <operator>instanceof</operator> <name>MultiTermAwareComponent</name></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><name>charFilter</name> <operator>=</operator> <operator>(</operator><name>CharFilterFactory</name><operator>)</operator> <operator>(</operator><operator>(</operator><name>MultiTermAwareComponent</name><operator>)</operator> <name>charFilter</name><operator>)</operator><operator>.</operator><call><name>getMultiTermComponent</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>reader</name> <operator>=</operator> <call><name><name>charFilter</name><operator>.</operator><name>create</name></name><argument_list>(<argument><expr><name>reader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>reader</name></expr>;</return>
  </block_content>}</block></function>

   <function><annotation>@<name>Override</name></annotation>
   <type><specifier>protected</specifier> <name>TokenStreamComponents</name></type> <name>createComponents</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>fieldName</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>Tokenizer</name></type> <name>tk</name> <init>= <expr><call><name><name>tokenizer</name><operator>.</operator><name>create</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Tokenizer</name></type> <name>tk</name> <init>= <expr><call><name><name>tokenizer</name><operator>.</operator><name>create</name></name><argument_list>(<argument><expr><call><name>attributeFactory</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
     <decl_stmt><decl><type><name>TokenStream</name></type> <name>ts</name> <init>= <expr><name>tk</name></expr></init></decl>;</decl_stmt>
     <for>for <control>(<init><decl><type><name>TokenFilterFactory</name></type> <name>filter</name> <range>: <expr><name>filters</name></expr></range></decl></init>)</control> <block>{<block_content>
       <expr_stmt><expr><name>ts</name> <operator>=</operator> <call><name><name>filter</name><operator>.</operator><name>create</name></name><argument_list>(<argument><expr><name>ts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">93</literal></expr><operator>,</operator><expr><literal type="number">6</literal> <operator>+</operator><literal type="number">107</literal></expr><operator>,</operator><expr><literal type="number">18</literal> @@ <specifier>public</specifier> <name>final</name> <name>class</name> <name>TokenizerChain</name> extends <name>SolrAnalyzer</name> <block>{
     <return>return <expr><operator>new</operator> <call><name>TokenStreamComponents</name><argument_list>(<argument><expr><name>tk</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>)</argument_list></call></expr>;</return>
   }</block></expr></expr_stmt>
 
  <function><annotation>@<name>Override</name></annotation>
  <type><specifier>protected</specifier> <name>TokenStream</name></type> <name>normalize</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>fieldName</name></decl></parameter>, <parameter><decl><type><name>TokenStream</name></type> <name>in</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>TokenStream</name></type> <name>result</name> <init>= <expr><name>in</name></expr></init></decl>;</decl_stmt>
    <for>for <control>(<init><decl><type><name>TokenFilterFactory</name></type> <name>filter</name> <range>: <expr><name>filters</name></expr></range></decl></init>)</control> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>filter</name> <operator>instanceof</operator> <name>MultiTermAwareComponent</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>filter</name> <operator>=</operator> <operator>(</operator><name>TokenFilterFactory</name><operator>)</operator> <operator>(</operator><operator>(</operator><name>MultiTermAwareComponent</name><operator>)</operator> <name>filter</name><operator>)</operator><operator>.</operator><call><name>getMultiTermComponent</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name><name>filter</name><operator>.</operator><name>create</name></name><argument_list>(<argument><expr><name>in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <return>return <expr><name>result</name></expr>;</return>
  </block_content>}</block></function>

   <function><annotation>@<name>Override</name></annotation>
   <type><specifier>public</specifier> <name>String</name></type> <name>toString</name><parameter_list>()</parameter_list> <block>{<block_content>
     <decl_stmt><decl><type><name>StringBuilder</name></type> <name>sb</name> <init>= <expr><operator>new</operator> <call><name>StringBuilder</name><argument_list>(<argument><expr><literal type="string">"TokenizerChain("</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><operator>-</operator> 
<literal type="number">2.19.1.windows</literal><literal type="number">.1</literal></expr></expr_stmt></block_content></block></function></block_content></block></for></block_content></block></function></block_content></block></function></block_content></block></decl></decl_stmt>

</unit>
