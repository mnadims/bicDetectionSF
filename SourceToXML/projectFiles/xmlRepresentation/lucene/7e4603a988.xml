<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" revision="1.0.0" language="Java" filename="E:/01Courses@USASK/CMPT898-HumanDrivenSoftwareEngineeringForScientificResearch/ProjectProgress/data_files/final_dataset/gen_patch_codes/filtered/lucene/7e4603a988.java"><expr_stmt><expr><name>From</name> <literal type="number">7e4603a9888847fbd01035a93173ee504fc91268</literal> <name>Mon</name> <name>Sep</name> <literal type="number">17</literal> <literal type="number">00</literal><operator>:</operator><literal type="number">00</literal><operator>:</operator><literal type="number">00</literal> <literal type="number">2001</literal>
<name>From</name><operator>:</operator> <name>Erik</name> <name><name>Hatcher</name> <argument_list type="generic">&lt;<argument><name>ehatcher</name><annotation>@<name><name>apache</name><operator>.</operator><name>org</name></name></annotation></argument>&gt;</argument_list></name>
<name>Date</name><operator>:</operator> <name>Wed</name></expr><operator>,</operator> <expr><literal type="number">13</literal> <name>Aug</name> <literal type="number">2014</literal> <literal type="number">12</literal><operator>:</operator><literal type="number">56</literal><operator>:</operator><literal type="number">13</literal> <operator>+</operator><literal type="number">0000</literal>
<name>Subject</name><operator>:</operator> <index>[<expr><name>PATCH</name></expr>]</index> <name>SOLR</name><operator>-</operator><literal type="number">6062</literal><operator>:</operator> <name>Fix</name> <name>undesirable</name> <name>edismax</name> <name>query</name> <name>parser</name> <call><name>effect</name>
 <argument_list>(<argument><expr><name>introduced</name> <name>in</name> <name>SOLR</name><operator>-</operator><literal type="number">2058</literal></expr></argument>)</argument_list></call> <name>in</name> <name>how</name> <name>phrase</name> <name>queries</name>

<name>git</name><operator>-</operator><name>svn</name><operator>-</operator><name>id</name><operator>:</operator> <name>https</name><operator>:</operator><comment type="line">//svn.apache.org/repos/asf/lucene/dev/trunk@1617719 13f79535-47bb-0310-9956-ffa450edef68</comment>
<operator>--</operator>
 <name>solr</name><operator>/</operator><name><name>CHANGES</name><operator>.</operator><name>txt</name></name>                              <operator>|</operator>  <literal type="number">3</literal> <operator>+</operator>
 <operator>...</operator><operator>/</operator><name>solr</name><operator>/</operator><name>search</name><operator>/</operator><name><name>ExtendedDismaxQParser</name><operator>.</operator><name>java</name></name>    <operator>|</operator> <literal type="number">88</literal> <operator>++</operator><operator>++</operator><operator>++</operator><operator>++</operator><operator>++</operator><operator>++</operator><operator>++</operator><operator>--</operator><operator>--</operator><operator>-</operator>
 <operator>...</operator><operator>/</operator><name>solr</name><operator>/</operator><name>search</name><operator>/</operator><name><name>TestExtendedDismaxParser</name><operator>.</operator><name>java</name></name> <operator>|</operator> <literal type="number">36</literal> <operator>++</operator><operator>++</operator><operator>+</operator><operator>--</operator><operator>-</operator>
 <literal type="number">3</literal> <name>files</name> <name>changed</name></expr><operator>,</operator> <expr><literal type="number">91</literal> <call><name>insertions</name><argument_list>(<argument><expr><operator>+</operator></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><literal type="number">36</literal> <call><name>deletions</name><argument_list>(<argument><expr><operator>-</operator></expr></argument>)</argument_list></call>

<name>diff</name> <operator>--</operator><name>git</name> <name>a</name><operator>/</operator><name>solr</name><operator>/</operator><name><name>CHANGES</name><operator>.</operator><name>txt</name></name> <name>b</name><operator>/</operator><name>solr</name><operator>/</operator><name><name>CHANGES</name><operator>.</operator><name>txt</name></name>
<name>index</name> <literal type="number">3beed7735a2</literal><operator>..</operator><literal type="number">3128a5b99e8</literal> <literal type="number">100644</literal>
<operator>--</operator> <name>a</name><operator>/</operator><name>solr</name><operator>/</operator><name><name>CHANGES</name><operator>.</operator><name>txt</name></name>
<operator>++</operator> <name>b</name><operator>/</operator><name>solr</name><operator>/</operator><name><name>CHANGES</name><operator>.</operator><name>txt</name></name>
@@ <operator>-</operator><literal type="number">262</literal></expr><operator>,</operator><expr><literal type="number">6</literal> <operator>+</operator><literal type="number">262</literal></expr><operator>,</operator><expr><literal type="number">9</literal> @@ <name>Bug</name> <name>Fixes</name>
 
 <operator>*</operator> <name>SOLR</name><operator>-</operator><literal type="number">6347</literal><operator>:</operator> <name>DELETEREPLICA</name> <throws>throws <argument><expr><name>a</name> <name>NPE</name></expr></argument></throws></expr></expr_stmt> <while>while removing the last Replica in a Custom sharded collection.
 
* SOLR-6062: Fix undesirable edismax query parser effect <condition>(<expr><name>introduced</name> <name>in</name> <name>SOLR</name><operator>-</operator><literal type="number">2058</literal></expr>)</condition><block type="pseudo"><block_content> <decl_stmt><decl><type><name>in</name> <name>how</name> <name>phrase</name> <name>queries</name>
  <name>generated</name> <name>from</name></type> <name>pf</name></decl>, <decl><type ref="prev"/><name>pf2</name></decl>, <decl><type ref="prev"/><name>and</name> <name>pf3</name> <name>are</name> <name>merged</name> <name>into</name> <name>the</name> <name>main</name> <name><name>query</name><operator>.</operator></name>  (<name>Michael</name> <name>Dodsworth</name> <name>via</name> <name>ehatcher</name></decl>)

 Optimizations
 ---------------------
 
diff --git a/solr/core/src/java/org/apache/solr/search/ExtendedDismaxQParser.java b/solr/core/src/java/org/apache/solr/search/ExtendedDismaxQParser.java
index 9d21150f070..dd014661b61 100644
-- a/solr/core/src/java/org/apache/solr/search/ExtendedDismaxQParser.java
++ b/solr/core/src/java/org/apache/solr/search/ExtendedDismaxQParser.java
@@ -17<operator>,</operator>6 +17<operator>,</operator>9 @@
 
 package org.apache.solr.search;</decl_stmt></block_content></block></while>
 
<import>import <name><name>com</name><operator>.</operator><name>google</name><operator>.</operator><name>common</name><operator>.</operator><name>base</name><operator>.</operator><name>Function</name></name>;</import>
<import>import <name><name>com</name><operator>.</operator><name>google</name><operator>.</operator><name>common</name><operator>.</operator><name>collect</name><operator>.</operator><name>Multimap</name></name>;</import>
<import>import <name><name>com</name><operator>.</operator><name>google</name><operator>.</operator><name>common</name><operator>.</operator><name>collect</name><operator>.</operator><name>Multimaps</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>analysis</name><operator>.</operator><name>Analyzer</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>analysis</name><operator>.</operator><name>core</name><operator>.</operator><name>StopFilterFactory</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>analysis</name><operator>.</operator><name>util</name><operator>.</operator><name>TokenFilterFactory</name></name>;</import>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">43</literal></expr><operator>,</operator><expr><literal type="number">10</literal> <operator>+</operator><literal type="number">46</literal></expr><operator>,</operator><expr><literal type="number">12</literal> @@</expr></expr_stmt> <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>schema</name><operator>.</operator><name>FieldType</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>util</name><operator>.</operator><name>SolrPluginUtils</name></name>;</import>
 
 <import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>ArrayList</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>Collection</name></name>;</import>
 <import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>Collections</name></name>;</import>
 <import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>HashMap</name></name>;</import>
 <import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>HashSet</name></name>;</import>
 <import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>Iterator</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>LinkedHashMap</name></name>;</import>
 <import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>LinkedList</name></name>;</import>
 <import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>List</name></name>;</import>
 <import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>Map</name></name>;</import>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">57</literal></expr><operator>,</operator><expr><literal type="number">15</literal> <operator>+</operator><literal type="number">62</literal></expr><operator>,</operator><expr><literal type="number">34</literal> @@</expr></expr_stmt> <import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>Set</name></name>;</import>
  <expr_stmt><expr><operator>*</operator> <name>See</name> <name>Wiki</name> <name>page</name> <name>http</name><operator>:</operator><comment type="line">//wiki.apache.org/solr/ExtendedDisMax</comment>
  <operator>*</operator><operator>/</operator>
 <specifier>public</specifier> <name>class</name> <name>ExtendedDismaxQParser</name> extends <name>QParser</name> <block>{
  
  

   <comment type="block" format="javadoc">/**
    * A field we can't ever find in any schema, so we can safely tell
    * DisjunctionMaxQueryParser to use it as our defaultField, and
    * map aliases from it to any field in our schema.
    */</comment>
   <expr><specifier>private</specifier> <specifier>static</specifier> <name>String</name> <name>IMPOSSIBLE_FIELD_NAME</name> <operator>=</operator> <literal type="string">"\uFFFC\uFFFC\uFFFC"</literal></expr>;
  

  <comment type="block" format="javadoc">/**
   * Helper function which returns the specified {@link FieldParams}' {@link FieldParams#getWordGrams()} value.
   */</comment>
  <expr><specifier>private</specifier> <specifier>static</specifier> <name>final</name> <name><name>Function</name><argument_list type="generic">&lt;<argument><name>FieldParams</name></argument>, <argument><name>Integer</name></argument>&gt;</argument_list></name> <name>WORD_GRAM_EXTRACTOR</name> <operator>=</operator> <operator>new</operator> <class><super><name><name>Function</name><argument_list type="generic">&lt;<argument><name>FieldParams</name></argument>, <argument><name>Integer</name></argument>&gt;</argument_list></name></super><argument_list>()</argument_list> <block>{
    <function><annotation>@<name>Override</name></annotation>
    <type><specifier>public</specifier> <name>Integer</name></type> <name>apply</name><parameter_list>(<parameter><decl><type><name>FieldParams</name></type> <name>input</name></decl></parameter>)</parameter_list> <block>{<block_content>
      <return>return <expr><call><name><name>input</name><operator>.</operator><name>getWordGrams</name></name><argument_list>()</argument_list></call></expr>;</return>
    <expr_stmt/></block_content></block></function></block></class></expr>}</block></expr></expr_stmt>
  };

  <comment type="block" format="javadoc">/**
   * Helper function which returns the specified {@link FieldParams}' {@link FieldParams#getSlop()} value.
   */</comment>
  <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name><name>Function</name><argument_list type="generic">&lt;<argument><name>FieldParams</name></argument>, <argument><name>Integer</name></argument>&gt;</argument_list></name></type> <name>PHRASE_SLOP_EXTRACTOR</name> <init>= <expr><operator>new</operator> <class><super><name><name>Function</name><argument_list type="generic">&lt;<argument><name>FieldParams</name></argument>, <argument><name>Integer</name></argument>&gt;</argument_list></name></super><argument_list>()</argument_list> <block>{
    <function><annotation>@<name>Override</name></annotation>
    <type><specifier>public</specifier> <name>Integer</name></type> <name>apply</name><parameter_list>(<parameter><decl><type><name>FieldParams</name></type> <name>input</name></decl></parameter>)</parameter_list> <block>{<block_content>
      <return>return <expr><call><name><name>input</name><operator>.</operator><name>getSlop</name></name><argument_list>()</argument_list></call></expr>;</return>
    </block_content>}</block></function>
  }</block></class></expr></init></decl>;</decl_stmt>

   <comment type="block" format="javadoc">/** shorten the class references for utilities */</comment>
   <class><specifier>private</specifier> <specifier>static</specifier> class <name>U</name> <super_list><extends>extends <super><name>SolrPluginUtils</name></super></extends></super_list> <block>{
     <comment type="block">/* :NOOP */</comment>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">212</literal></expr><operator>,</operator><expr><literal type="number">21</literal> <operator>+</operator><literal type="number">236</literal></expr><operator>,</operator><expr><literal type="number">28</literal> @@ <specifier>public</specifier> <name>class</name> <name>ExtendedDismaxQParser</name> extends <name>QParser</name> <block>{
         <if_stmt><if>if <condition>(<expr><name><name>clause</name><operator>.</operator><name>field</name></name> <operator>!=</operator> <literal type="null">null</literal> <operator>||</operator> <name><name>clause</name><operator>.</operator><name>isPhrase</name></name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt></block></expr></expr_stmt>
         <comment type="line">// check for keywords "AND,OR,TO"</comment>
         <if_stmt><if>if <condition>(<expr><call><name><name>clause</name><operator>.</operator><name>isBareWord</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
          <decl_stmt><decl><type><name>String</name></type> <name>s</name> <init>= <expr><call><name><name>clause</name><operator>.</operator><name>val</name><operator>.</operator><name>toString</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>String</name></type> <name>s</name> <init>= <expr><name><name>clause</name><operator>.</operator><name>val</name></name></expr></init></decl>;</decl_stmt>
           <comment type="line">// avoid putting explicit operators in the phrase query</comment>
           <if_stmt><if>if <condition>(<expr><literal type="string">"OR"</literal><operator>.</operator><call><name>equals</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call> <operator>||</operator> <literal type="string">"AND"</literal><operator>.</operator><call><name>equals</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call> <operator>||</operator> <literal type="string">"NOT"</literal><operator>.</operator><call><name>equals</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call> <operator>||</operator> <literal type="string">"TO"</literal><operator>.</operator><call><name>equals</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
         </block_content>}</block></if></if_stmt>
         <constructor_decl><name><name>normalClauses</name><operator>.</operator><name>add</name></name><parameter_list>(<parameter><decl><type><name>clause</name></type></decl></parameter>)</parameter_list>;</constructor_decl>
       }</block></class>
      
      <comment type="line">// full phrase and shingles</comment>
      <for>for <control>(<init><decl><type><name>FieldParams</name></type> <name>phraseField</name><range>: <expr><name>allPhraseFields</name></expr></range></decl></init>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name><name>Map</name><argument_list type="generic">&lt;<argument><name>String</name></argument>,<argument><name>Float</name></argument>&gt;</argument_list></name></type> <name>pf</name> <init>= <expr><operator>new</operator> <call><name><name>HashMap</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>pf</name><operator>.</operator><name>put</name></name><argument_list>(<argument><expr><call><name><name>phraseField</name><operator>.</operator><name>getField</name></name><argument_list>()</argument_list></call></expr></argument>,<argument><expr><call><name><name>phraseField</name><operator>.</operator><name>getBoost</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>addShingledPhraseQueries</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>normalClauses</name></expr></argument>, <argument><expr><name>pf</name></expr></argument>,   
            <argument><expr><call><name><name>phraseField</name><operator>.</operator><name>getWordGrams</name></name><argument_list>()</argument_list></call></expr></argument>,<argument><expr><name><name>config</name><operator>.</operator><name>tiebreaker</name></name></expr></argument>, <argument><expr><call><name><name>phraseField</name><operator>.</operator><name>getSlop</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="line">// create a map of {wordGram, [phraseField]}</comment>
      <decl_stmt><decl><type><name><name>Multimap</name><argument_list type="generic">&lt;<argument><name>Integer</name></argument>, <argument><name>FieldParams</name></argument>&gt;</argument_list></name></type> <name>phraseFieldsByWordGram</name> <init>= <expr><call><name><name>Multimaps</name><operator>.</operator><name>index</name></name><argument_list>(<argument><expr><name>allPhraseFields</name></expr></argument>, <argument><expr><name>WORD_GRAM_EXTRACTOR</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

      <comment type="line">// for each {wordGram, [phraseField]} entry, create and add shingled field queries to the main user query</comment>
      <for>for <control>(<init><decl><type><name><name>Map</name><operator>.</operator><name><name>Entry</name><argument_list type="generic">&lt;<argument><name>Integer</name></argument>, <argument><name><name>Collection</name><argument_list type="generic">&lt;<argument><name>FieldParams</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></name></type> <name>phraseFieldsByWordGramEntry</name> <range>: <expr><call><name><name>phraseFieldsByWordGram</name><operator>.</operator><name>asMap</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>entrySet</name><argument_list>()</argument_list></call></expr></range></decl></init>)</control> <block>{<block_content>

        <comment type="line">// group the fields within this wordGram collection by their associated slop (it's possible that the same</comment>
        <comment type="line">// field appears multiple times for the same wordGram count but with different slop values. In this case, we</comment>
        <comment type="line">// should take the *sum* of those phrase queries, rather than the max across them).</comment>
        <decl_stmt><decl><type><name><name>Multimap</name><argument_list type="generic">&lt;<argument><name>Integer</name></argument>, <argument><name>FieldParams</name></argument>&gt;</argument_list></name></type> <name>phraseFieldsBySlop</name> <init>= <expr><call><name><name>Multimaps</name><operator>.</operator><name>index</name></name><argument_list>(<argument><expr><call><name><name>phraseFieldsByWordGramEntry</name><operator>.</operator><name>getValue</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>PHRASE_SLOP_EXTRACTOR</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name><name>Map</name><operator>.</operator><name><name>Entry</name><argument_list type="generic">&lt;<argument><name>Integer</name></argument>, <argument><name><name>Collection</name><argument_list type="generic">&lt;<argument><name>FieldParams</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></name></type> <name>phraseFieldsBySlopEntry</name> <range>: <expr><call><name><name>phraseFieldsBySlop</name><operator>.</operator><name>asMap</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>entrySet</name><argument_list>()</argument_list></call></expr></range></decl></init>)</control> <block>{<block_content>
          <expr_stmt><expr><call><name>addShingledPhraseQueries</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>normalClauses</name></expr></argument>, <argument><expr><call><name><name>phraseFieldsBySlopEntry</name><operator>.</operator><name>getValue</name></name><argument_list>()</argument_list></call></expr></argument>,
              <argument><expr><call><name><name>phraseFieldsByWordGramEntry</name><operator>.</operator><name>getKey</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>config</name><operator>.</operator><name>tiebreaker</name></name></expr></argument>, <argument><expr><call><name><name>phraseFieldsBySlopEntry</name><operator>.</operator><name>getKey</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
       </block_content>}</block></for>
      
     </block_content>}</block></for>
   }
 
@<annotation>@</annotation> -<expr_stmt><expr><literal type="number">493</literal></expr><operator>,</operator><expr><literal type="number">14</literal> <operator>+</operator><literal type="number">524</literal></expr><operator>,</operator><expr><literal type="number">13</literal> @@ <specifier>public</specifier> <name>class</name> <name>ExtendedDismaxQParser</name> extends <name>QParser</name> <block>{
    <expr><operator>*</operator> @<name>param</name> <name>fields</name> <name>Field</name> <operator>=</operator><operator>&amp;</operator><name>gt</name></expr>; <expr><name>boost</name> <name>mappings</name></expr> <for>for the phrase queries
    * @param shingleSize how big the phrases should be<operator>,</operator> <expr_stmt><expr><literal type="number">0</literal> <name>means</name> <name>a</name> <name>single</name> <name>phrase</name>
    <operator>*</operator> @<name>param</name> <name>tiebreaker</name> <name>tie</name> <name>breaker</name> <name>value</name></expr></expr_stmt></for> <for>for the DisjunctionMaxQueries
   * @param slop slop value for the constructed phrases
    */
   protected void addShingledPhraseQueries<control>(<init><decl><type><specifier>final</specifier> <name>BooleanQuery</name></type> <name>mainQuery</name></decl>, 
       <decl><type ref="prev"/><name>final</name> <name><name>List</name><argument_list type="generic">&lt;<argument><name>Clause</name></argument>&gt;</argument_list></name> <name>clauses</name></decl>,
      <decl><type ref="prev"/><name>final</name> <name><name>Map</name><argument_list type="generic">&lt;<argument><name>String</name></argument>,<argument><name>Float</name></argument>&gt;</argument_list></name> <name>fields</name></decl>,
      <decl><type ref="prev"/><name>final</name> <name><name>Collection</name><argument_list type="generic">&lt;<argument><name>FieldParams</name></argument>&gt;</argument_list></name> <name>fields</name></decl>,
       <decl><type ref="prev"/><name>int</name> <name>shingleSize</name></decl>,
       <decl><type ref="prev"/><name>final</name> <name>float</name> <name>tiebreaker</name></decl>,
      <decl><type ref="prev"/><name>final</name> <name>int</name> <name>slop</name></decl></init>)</control><block type="pseudo"><block_content> 
      <expr_stmt><expr><name>final</name> <name>int</name> <name>slop</name></expr></expr_stmt></block_content></block></for>)</block>
           <throws>throws <argument><expr><name>SyntaxError</name> <block>{</block></expr></argument></throws></expr></expr_stmt>
     
     <if_stmt><if>if <condition>(<expr><literal type="null">null</literal> <operator>==</operator> <name>fields</name> <operator>||</operator> <call><name><name>fields</name><operator>.</operator><name>isEmpty</name></name><argument_list>()</argument_list></call> <operator>||</operator> 
@@ <operator>-</operator><literal type="number">509</literal></expr><operator>,</operator><expr><literal type="number">12</literal> <operator>+</operator><literal type="number">539</literal></expr><operator>,</operator><expr><literal type="number">12</literal> @@ <specifier>public</specifier> <name>class</name> <name>ExtendedDismaxQParser</name> extends <name>QParser</name></expr></condition> <block>{<block_content>
     
     <if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>==</operator> <name>shingleSize</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>shingleSize</name> <operator>=</operator> <call><name><name>clauses</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
     
    <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>goat</name> <init>= <expr><name>shingleSize</name><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt> <comment type="line">// :TODO: better name for var?</comment>
    <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>lastClauseIndex</name> <init>= <expr><name>shingleSize</name><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
     
     <decl_stmt><decl><type><name>StringBuilder</name></type> <name>userPhraseQuery</name> <init>= <expr><operator>new</operator> <call><name>StringBuilder</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name><init>=<expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name><name>clauses</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>-</operator> <name>goat</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
    <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name><init>=<expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name><name>clauses</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>-</operator> <name>lastClauseIndex</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
       <expr_stmt><expr><call><name><name>userPhraseQuery</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><literal type="char">'"'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <for>for <control>(<init><decl><type><name>int</name></type> <name>j</name><init>=<expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;=</operator> <name>goat</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
      <for>for <control>(<init><decl><type><name>int</name></type> <name>j</name><init>=<expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;=</operator> <name>lastClauseIndex</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
         <expr_stmt><expr><call><name><name>userPhraseQuery</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><call><name><name>clauses</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>i</name> <operator>+</operator> <name>j</name></expr></argument>)</argument_list></call><operator>.</operator><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
         <expr_stmt><expr><call><name><name>userPhraseQuery</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
       </block_content>}</block></for>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">524</literal></expr><operator>,</operator><expr><literal type="number">8</literal> <operator>+</operator><literal type="number">554</literal></expr><operator>,</operator><expr><literal type="number">8</literal> @@ <specifier>public</specifier> <name>class</name> <name>ExtendedDismaxQParser</name> extends <name>QParser</name> <block>{
     
     <comment type="block">/* for parsing sloppy phrases using DisjunctionMaxQueries */</comment>
     <expr><name>ExtendedSolrQueryParser</name> <name>pp</name> <operator>=</operator> <call><name>createEdismaxQueryParser</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>IMPOSSIBLE_FIELD_NAME</name></expr></argument>)</argument_list></call></expr>;
    
    <call><name><name>pp</name><operator>.</operator><name>addAlias</name></name><argument_list>(<argument><expr><name>IMPOSSIBLE_FIELD_NAME</name></expr></argument>, <argument><expr><name>tiebreaker</name></expr></argument>, <argument><expr><name>fields</name></expr></argument>)</argument_list></call></block></expr>;</expr_stmt>

    <expr_stmt><expr><call><name><name>pp</name><operator>.</operator><name>addAlias</name></name><argument_list>(<argument><expr><name>IMPOSSIBLE_FIELD_NAME</name></expr></argument>, <argument><expr><name>tiebreaker</name></expr></argument>, <argument><expr><call><name>getFieldBoosts</name><argument_list>(<argument><expr><name>fields</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
     <expr_stmt><expr><call><name><name>pp</name><operator>.</operator><name>setPhraseSlop</name></name><argument_list>(<argument><expr><name>slop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
     <expr_stmt><expr><call><name><name>pp</name><operator>.</operator><name>setRemoveStopFilter</name></name><argument_list>(<argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="line">// remove stop filter and keep stopwords</comment>
     
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">559</literal></expr><operator>,</operator><expr><literal type="number">8</literal> <operator>+</operator><literal type="number">589</literal></expr><operator>,</operator><expr><literal type="number">20</literal> @@ <specifier>public</specifier> <name>class</name> <name>ExtendedDismaxQParser</name> extends <name>QParser</name> <block>{
       <expr><call><name><name>mainQuery</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name>phrase</name></expr></argument>, <argument><expr><name><name>BooleanClause</name><operator>.</operator><name>Occur</name><operator>.</operator><name>SHOULD</name></name></expr></argument>)</argument_list></call></expr>;
     }</block></expr></expr_stmt>
   </block_content>}</block></for>
  
  

  <comment type="block" format="javadoc">/**
   * @return a {fieldName, fieldBoost} map for the given fields.
   */</comment>
  <function><type><specifier>private</specifier> <name><name>Map</name><argument_list type="generic">&lt;<argument><name>String</name></argument>, <argument><name>Float</name></argument>&gt;</argument_list></name></type> <name>getFieldBoosts</name><parameter_list>(<parameter><decl><type><name><name>Collection</name><argument_list type="generic">&lt;<argument><name>FieldParams</name></argument>&gt;</argument_list></name></type> <name>fields</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name><name>Map</name><argument_list type="generic">&lt;<argument><name>String</name></argument>, <argument><name>Float</name></argument>&gt;</argument_list></name></type> <name>fieldBoostMap</name> <init>= <expr><operator>new</operator> <call><name><name>LinkedHashMap</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>fields</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <for>for <control>(<init><decl><type><name>FieldParams</name></type> <name>field</name> <range>: <expr><name>fields</name></expr></range></decl></init>)</control> <block>{<block_content>
      <expr_stmt><expr><call><name><name>fieldBoostMap</name><operator>.</operator><name>put</name></name><argument_list>(<argument><expr><call><name><name>field</name><operator>.</operator><name>getField</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>field</name><operator>.</operator><name>getBoost</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <return>return <expr><name>fieldBoostMap</name></expr>;</return>
  </block_content>}</block></function>

   <function><annotation>@<name>Override</name></annotation>
   <type><specifier>public</specifier> <name><name>String</name><index>[]</index></name></type> <name>getDefaultHighlightFields</name><parameter_list>()</parameter_list> <block>{<block_content>
     <return>return <expr><call><name><name>config</name><operator>.</operator><name>queryFields</name><operator>.</operator><name>keySet</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>toArray</name><argument_list>(<argument><expr><operator>new</operator> <name><name>String</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">1221</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">1263</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@ <specifier>public</specifier> <name>class</name> <name>ExtendedDismaxQParser</name> extends <name>QParser</name> <block>{
         <return>return <expr><literal type="null">null</literal></expr>;</return>
       }</block></expr></expr_stmt>
     </block_content>}</block></function>
    

     <function><type><specifier>private</specifier> <name>Analyzer</name></type> <name>noStopwordFilterAnalyzer</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>fieldName</name></decl></parameter>)</parameter_list> <block>{<block_content>
       <decl_stmt><decl><type><name>FieldType</name></type> <name>ft</name> <init>= <expr><call><name><name>parser</name><operator>.</operator><name>getReq</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSchema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getFieldType</name><argument_list>(<argument><expr><name>fieldName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
       <decl_stmt><decl><type><name>Analyzer</name></type> <name>qa</name> <init>= <expr><call><name><name>ft</name><operator>.</operator><name>getQueryAnalyzer</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>diff</name> <operator>--</operator><name>git</name> <name>a</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>test</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>search</name><operator>/</operator><name><name>TestExtendedDismaxParser</name><operator>.</operator><name>java</name></name> <name>b</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>test</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>search</name><operator>/</operator><name><name>TestExtendedDismaxParser</name><operator>.</operator><name>java</name></name>
<name>index</name> <name>e4436e3771b</name><operator>..</operator><literal type="number">0fe410aac2c</literal> <literal type="number">100644</literal>
<operator>--</operator> <name>a</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>test</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>search</name><operator>/</operator><name><name>TestExtendedDismaxParser</name><operator>.</operator><name>java</name></name>
<operator>++</operator> <name>b</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>test</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>search</name><operator>/</operator><name><name>TestExtendedDismaxParser</name><operator>.</operator><name>java</name></name>
@@ <operator>-</operator><literal type="number">32</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">32</literal></expr><operator>,</operator><expr><literal type="number">6</literal> @@</expr></expr_stmt> <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>common</name><operator>.</operator><name>SolrException</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>common</name><operator>.</operator><name>params</name><operator>.</operator><name>ModifiableSolrParams</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>common</name><operator>.</operator><name>params</name><operator>.</operator><name>SolrParams</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>request</name><operator>.</operator><name>SolrQueryRequest</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>util</name><operator>.</operator><name>AbstractSolrTestCase</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>util</name><operator>.</operator><name>SolrPluginUtils</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>junit</name><operator>.</operator><name>BeforeClass</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>junit</name><operator>.</operator><name>Test</name></name>;</import>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">683</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">682</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@ <specifier>public</specifier> <name>class</name> <name>TestExtendedDismaxParser</name> extends <name>SolrTestCaseJ4</name> <block>{
     <expr><call><name>assertU</name><argument_list>(<argument><expr><call><name>adoc</name><argument_list>(<argument><expr><literal type="string">"id"</literal></expr></argument>, <argument><expr><literal type="string">"s0"</literal></expr></argument>, <argument><expr><literal type="string">"phrase_sw"</literal></expr></argument>, <argument><expr><literal type="string">"foo bar a b c"</literal></expr></argument>, <argument><expr><literal type="string">"boost_d"</literal></expr></argument>, <argument><expr><literal type="string">"1.0"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;    
     <call><name>assertU</name><argument_list>(<argument><expr><call><name>adoc</name><argument_list>(<argument><expr><literal type="string">"id"</literal></expr></argument>, <argument><expr><literal type="string">"s1"</literal></expr></argument>, <argument><expr><literal type="string">"phrase_sw"</literal></expr></argument>, <argument><expr><literal type="string">"foo a bar b c"</literal></expr></argument>, <argument><expr><literal type="string">"boost_d"</literal></expr></argument>, <argument><expr><literal type="string">"2.0"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></block></expr>;</expr_stmt>    
     <expr_stmt><expr><call><name>assertU</name><argument_list>(<argument><expr><call><name>adoc</name><argument_list>(<argument><expr><literal type="string">"id"</literal></expr></argument>, <argument><expr><literal type="string">"s2"</literal></expr></argument>, <argument><expr><literal type="string">"phrase_sw"</literal></expr></argument>, <argument><expr><literal type="string">"foo a b bar c"</literal></expr></argument>, <argument><expr><literal type="string">"boost_d"</literal></expr></argument>, <argument><expr><literal type="string">"3.0"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>    
    <expr_stmt><expr><call><name>assertU</name><argument_list>(<argument><expr><call><name>adoc</name><argument_list>(<argument><expr><literal type="string">"id"</literal></expr></argument>, <argument><expr><literal type="string">"s3"</literal></expr></argument>, <argument><expr><literal type="string">"phrase_sw"</literal></expr></argument>, <argument><expr><literal type="string">"foo a b c bar"</literal></expr></argument>, <argument><expr><literal type="string">"boost_d"</literal></expr></argument>, <argument><expr><literal type="string">"4.0"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>    
    <expr_stmt><expr><call><name>assertU</name><argument_list>(<argument><expr><call><name>adoc</name><argument_list>(<argument><expr><literal type="string">"id"</literal></expr></argument>, <argument><expr><literal type="string">"s3"</literal></expr></argument>, <argument><expr><literal type="string">"phrase_sw"</literal></expr></argument>, <argument><expr><literal type="string">"foo a b c bar"</literal></expr></argument>, <argument><expr><literal type="string">"boost_d"</literal></expr></argument>, <argument><expr><literal type="string">"4.0"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
     <expr_stmt><expr><call><name>assertU</name><argument_list>(<argument><expr><call><name>commit</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
 
     <expr_stmt><expr><call><name>assertQ</name><argument_list>(<argument><expr><literal type="string">"default order assumption wrong"</literal></expr></argument>,
<argument>@@ <expr><operator>-</operator><literal type="number">695</literal></expr></argument>,<argument><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">694</literal></expr></argument>,<argument><expr><literal type="number">7</literal> @@ <specifier>public</specifier> class <name>TestExtendedDismaxParser</name> extends <name>SolrTestCaseJ4</name> <block>{
         <expr><literal type="string">"//doc[1]/str[@name='id'][.='s3']"</literal></expr>,
         <expr><literal type="string">"//doc[2]/str[@name='id'][.='s2']"</literal></expr>,
         <expr><literal type="string">"//doc[3]/str[@name='id'][.='s1']"</literal></expr>,
        <expr><literal type="string">"//doc[4]/str[@name='id'][.='s0']"</literal></expr></block></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
        <expr_stmt><expr><literal type="string">"//doc[4]/str[@name='id'][.='s0']"</literal></expr></expr_stmt>)</block_content></block>;</function>
 
     <expr_stmt><expr><call><name>assertQ</name><argument_list>(<argument><expr><literal type="string">"pf not working"</literal></expr></argument>,
         <argument><expr><call><name>req</name><argument_list>(<argument><expr><literal type="string">"q"</literal></expr></argument>, <argument><expr><literal type="string">"foo bar"</literal></expr></argument>,
<argument>@@ <expr><operator>-</operator><literal type="number">705</literal></expr></argument>,<argument><expr><literal type="number">37</literal> <operator>+</operator><literal type="number">704</literal></expr></argument>,<argument><expr><literal type="number">37</literal> @@ <specifier>public</specifier> class <name>TestExtendedDismaxParser</name> extends <name>SolrTestCaseJ4</name> <block>{
             <expr><literal type="string">"fl"</literal></expr>, <expr><literal type="string">"score,*"</literal></expr>,
             <expr><literal type="string">"defType"</literal></expr>, <expr><literal type="string">"edismax"</literal></expr></block></expr></argument>)</argument_list></call></expr></argument>,
         <argument><expr><literal type="string">"//doc[1]/str[@name='id'][.='s0']"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    

     <expr_stmt><expr><call><name>assertQ</name><argument_list>(<argument><expr><literal type="string">"pf2 not working"</literal></expr></argument>,
        <argument><expr><call><name>req</name><argument_list>(<argument><expr><literal type="string">"q"</literal></expr></argument>,   <argument><expr><literal type="string">"foo bar"</literal></expr></argument>, 
        <argument><expr><call><name>req</name><argument_list>(<argument><expr><literal type="string">"q"</literal></expr></argument>,   <argument><expr><literal type="string">"foo bar"</literal></expr></argument>,
             <argument><expr><literal type="string">"qf"</literal></expr></argument>,  <argument><expr><literal type="string">"phrase_sw"</literal></expr></argument>,
             <argument><expr><literal type="string">"pf2"</literal></expr></argument>, <argument><expr><literal type="string">"phrase_sw^10"</literal></expr></argument>,
             <argument><expr><literal type="string">"bf"</literal></expr></argument>,  <argument><expr><literal type="string">"boost_d"</literal></expr></argument>,
             <argument><expr><literal type="string">"fl"</literal></expr></argument>,  <argument><expr><literal type="string">"score,*"</literal></expr></argument>,
             <argument><expr><literal type="string">"defType"</literal></expr></argument>, <argument><expr><literal type="string">"edismax"</literal></expr></argument>)</argument_list></call></expr></argument>,
        <argument><expr><literal type="string">"//doc[1]/str[@name='id'][.='s0']"</literal></expr></argument>)</argument_list></call></expr></argument>;</argument_list></call></expr></expr_stmt> 
        <expr_stmt><expr><literal type="string">"//doc[1]/str[@name='id'][.='s0']"</literal></expr></expr_stmt>)</block_content></block><empty_stmt>;</empty_stmt></for>
 
     <expr_stmt><expr><call><name>assertQ</name><argument_list>(<argument><expr><literal type="string">"pf3 not working"</literal></expr></argument>,
        <argument><expr><call><name>req</name><argument_list>(<argument><expr><literal type="string">"q"</literal></expr></argument>,   <argument><expr><literal type="string">"a b bar"</literal></expr></argument>, 
        <argument><expr><call><name>req</name><argument_list>(<argument><expr><literal type="string">"q"</literal></expr></argument>,   <argument><expr><literal type="string">"a b bar"</literal></expr></argument>,
             <argument><expr><literal type="string">"qf"</literal></expr></argument>,  <argument><expr><literal type="string">"phrase_sw"</literal></expr></argument>,
             <argument><expr><literal type="string">"pf3"</literal></expr></argument>, <argument><expr><literal type="string">"phrase_sw^10"</literal></expr></argument>,
             <argument><expr><literal type="string">"bf"</literal></expr></argument>,  <argument><expr><literal type="string">"boost_d"</literal></expr></argument>,
             <argument><expr><literal type="string">"fl"</literal></expr></argument>,  <argument><expr><literal type="string">"score,*"</literal></expr></argument>,
             <argument><expr><literal type="string">"defType"</literal></expr></argument>, <argument><expr><literal type="string">"edismax"</literal></expr></argument>)</argument_list></call></expr></argument>,
        <argument><expr><literal type="string">"//doc[1]/str[@name='id'][.='s2']"</literal></expr></argument>)</argument_list></call></expr></argument>;</argument_list></call></expr></expr_stmt> 
        <expr_stmt><expr><literal type="string">"//doc[1]/str[@name='id'][.='s2']"</literal></expr></expr_stmt>)</block_content></block><empty_stmt>;</empty_stmt></for>
 
     <expr_stmt><expr><call><name>assertQ</name><argument_list>(<argument><expr><literal type="string">"ps not working for pf2"</literal></expr></argument>,
        <argument><expr><call><name>req</name><argument_list>(<argument><expr><literal type="string">"q"</literal></expr></argument>,   <argument><expr><literal type="string">"bar foo"</literal></expr></argument>, 
        <argument><expr><call><name>req</name><argument_list>(<argument><expr><literal type="string">"q"</literal></expr></argument>,   <argument><expr><literal type="string">"bar foo"</literal></expr></argument>,
             <argument><expr><literal type="string">"qf"</literal></expr></argument>,  <argument><expr><literal type="string">"phrase_sw"</literal></expr></argument>,
             <argument><expr><literal type="string">"pf2"</literal></expr></argument>, <argument><expr><literal type="string">"phrase_sw^10"</literal></expr></argument>,
             <argument><expr><literal type="string">"ps"</literal></expr></argument>,  <argument><expr><literal type="string">"2"</literal></expr></argument>,
             <argument><expr><literal type="string">"bf"</literal></expr></argument>,  <argument><expr><literal type="string">"boost_d"</literal></expr></argument>,
             <argument><expr><literal type="string">"fl"</literal></expr></argument>,  <argument><expr><literal type="string">"score,*"</literal></expr></argument>,
             <argument><expr><literal type="string">"defType"</literal></expr></argument>, <argument><expr><literal type="string">"edismax"</literal></expr></argument>)</argument_list></call></expr></argument>,
        <argument><expr><literal type="string">"//doc[1]/str[@name='id'][.='s0']"</literal></expr></argument>)</argument_list></call></expr></argument>;</argument_list></call></expr></expr_stmt> 
        <expr_stmt><expr><literal type="string">"//doc[1]/str[@name='id'][.='s0']"</literal></expr></expr_stmt>)</block_content></block><empty_stmt>;</empty_stmt></if></if_stmt>
 
     <expr_stmt><expr><call><name>assertQ</name><argument_list>(<argument><expr><literal type="string">"ps not working for pf3"</literal></expr></argument>,
        <argument><expr><call><name>req</name><argument_list>(<argument><expr><literal type="string">"q"</literal></expr></argument>,   <argument><expr><literal type="string">"a bar foo"</literal></expr></argument>, 
        <argument><expr><call><name>req</name><argument_list>(<argument><expr><literal type="string">"q"</literal></expr></argument>,   <argument><expr><literal type="string">"a bar foo"</literal></expr></argument>,
             <argument><expr><literal type="string">"qf"</literal></expr></argument>,  <argument><expr><literal type="string">"phrase_sw"</literal></expr></argument>,
             <argument><expr><literal type="string">"pf3"</literal></expr></argument>, <argument><expr><literal type="string">"phrase_sw^10"</literal></expr></argument>,
             <argument><expr><literal type="string">"ps"</literal></expr></argument>,  <argument><expr><literal type="string">"3"</literal></expr></argument>,
<argument>@@ <expr><operator>-</operator><literal type="number">743</literal></expr></argument>,<argument><expr><literal type="number">8</literal> <operator>+</operator><literal type="number">742</literal></expr></argument>,<argument><expr><literal type="number">8</literal> @@ <specifier>public</specifier> class <name>TestExtendedDismaxParser</name> extends <name>SolrTestCaseJ4</name> <block>{
             <expr><literal type="string">"fl"</literal></expr>,  <expr><literal type="string">"score,*"</literal></expr>,
             <expr><literal type="string">"debugQuery"</literal></expr>,  <expr><literal type="string">"true"</literal></expr>,
             <expr><literal type="string">"defType"</literal></expr>, <expr><literal type="string">"edismax"</literal></expr></block></expr></argument>)</argument_list></call></expr></argument>,
        <argument><expr><literal type="string">"//doc[1]/str[@name='id'][.='s1']"</literal></expr></argument>)</argument_list></call></expr></argument>; 
    
        <argument><expr><literal type="string">"//doc[1]/str[@name='id'][.='s1']"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

     <expr_stmt><expr><call><name>assertQ</name><argument_list>(<argument><expr><literal type="string">"ps/ps2/ps3 with default slop overrides not working"</literal></expr></argument>,
         <argument><expr><call><name>req</name><argument_list>(<argument><expr><literal type="string">"q"</literal></expr></argument>, <argument><expr><literal type="string">"zzzz xxxx cccc vvvv"</literal></expr></argument>,
             <argument><expr><literal type="string">"qf"</literal></expr></argument>, <argument><expr><literal type="string">"phrase_sw"</literal></expr></argument>,
<argument>@@ <expr><operator>-</operator><literal type="number">809</literal></expr></argument>,<argument><expr><literal type="number">6</literal> <operator>+</operator><literal type="number">808</literal></expr></argument>,<argument><expr><literal type="number">17</literal> @@ <specifier>public</specifier> class <name>TestExtendedDismaxParser</name> extends <name>SolrTestCaseJ4</name> <block>{
         <expr><literal type="string">"//str[@name='parsedquery'][contains(.,'phrase_sw:\"zzzz xxxx\"~2^22.0')]"</literal></expr></block></expr></argument>
      )</argument_list></call></expr></argument>;
 
    <argument><expr><call><name>assertQ</name><argument_list>(<argument><expr><literal type="string">"phrase field queries spanning multiple fields should be within their own dismax queries"</literal></expr></argument>,
        <argument><expr><call><name>req</name><argument_list>(<argument><expr><literal type="string">"q"</literal></expr></argument>, <argument><expr><literal type="string">"aaaa bbbb cccc"</literal></expr></argument>,
            <argument><expr><literal type="string">"qf"</literal></expr></argument>, <argument><expr><literal type="string">"phrase_sw phrase1_sw"</literal></expr></argument>,
            <argument><expr><literal type="string">"pf2"</literal></expr></argument>, <argument><expr><literal type="string">"phrase_sw phrase1_sw"</literal></expr></argument>,
            <argument><expr><literal type="string">"pf3"</literal></expr></argument>, <argument><expr><literal type="string">"phrase_sw phrase1_sw"</literal></expr></argument>,
            <argument><expr><literal type="string">"defType"</literal></expr></argument>, <argument><expr><literal type="string">"edismax"</literal></expr></argument>,
            <argument><expr><literal type="string">"debugQuery"</literal></expr></argument>, <argument><expr><literal type="string">"true"</literal></expr></argument>)</argument_list></call></expr></argument>,
        <argument><expr><literal type="string">"//str[@name='parsedquery'][contains(.,'(phrase_sw:\"aaaa bbbb\" | phrase1_sw:\"aaaa bbbb\")')]"</literal></expr></argument>,
        <argument><expr><literal type="string">"//str[@name='parsedquery'][contains(.,'(phrase_sw:\"bbbb cccc\" | phrase1_sw:\"bbbb cccc\")')]"</literal></expr></argument>,
        <argument><expr><literal type="string">"//str[@name='parsedquery'][contains(.,'(phrase_sw:\"aaaa bbbb cccc\" | phrase1_sw:\"aaaa bbbb cccc\")')]"</literal></expr></argument>
    )</argument_list></call></expr></argument>;</argument_list></call></expr></expr_stmt>
   }
 
   <comment type="block" format="javadoc">/**
- 
2.19.1.windows.1

</comment></unit>
