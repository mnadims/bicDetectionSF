<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" revision="1.0.0" language="Java" filename="E:/01Courses@USASK/CMPT898-HumanDrivenSoftwareEngineeringForScientificResearch/ProjectProgress/data_files/final_dataset/gen_patch_codes/filtered/lucene/2d4e789d00.java"><expr_stmt><expr><name>From</name> <literal type="number">2d4e789d00ecb5dfaf73e7df01a7da4502c404a9</literal> <name>Mon</name> <name>Sep</name> <literal type="number">17</literal> <literal type="number">00</literal><operator>:</operator><literal type="number">00</literal><operator>:</operator><literal type="number">00</literal> <literal type="number">2001</literal>
<name>From</name><operator>:</operator> <name>Yonik</name> <name><name>Seeley</name> <argument_list type="generic">&lt;<argument><name>yonik</name><annotation>@<name><name>apache</name><operator>.</operator><name>org</name></name></annotation></argument>&gt;</argument_list></name>
<name>Date</name><operator>:</operator> <name>Fri</name></expr><operator>,</operator> <expr><literal type="number">23</literal> <name>Nov</name> <literal type="number">2012</literal> <literal type="number">19</literal><operator>:</operator><literal type="number">45</literal><operator>:</operator><literal type="number">50</literal> <operator>+</operator><literal type="number">0000</literal>
<name>Subject</name><operator>:</operator> <index>[<expr><name>PATCH</name></expr>]</index> <name>SOLR</name><operator>-</operator><literal type="number">4093</literal><operator>:</operator> <name>solr</name> <name>specific</name> <name>parser</name> <operator>+</operator> <name>localParams</name> <name>syntax</name>

<name>git</name><operator>-</operator><name>svn</name><operator>-</operator><name>id</name><operator>:</operator> <name>https</name><operator>:</operator><comment type="line">//svn.apache.org/repos/asf/lucene/dev/trunk@1413042 13f79535-47bb-0310-9956-ffa450edef68</comment>
<operator>--</operator>
 <name>solr</name><operator>/</operator><name><name>CHANGES</name><operator>.</operator><name>txt</name></name>                              <operator>|</operator>   <literal type="number">13</literal> <operator>+</operator>
 <name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name><name>build</name><operator>.</operator><name>xml</name></name>                           <operator>|</operator>   <literal type="number">52</literal> <operator>+</operator>
 <operator>...</operator><operator>/</operator><name>solr</name><operator>/</operator><name>handler</name><operator>/</operator><name><name>MoreLikeThisHandler</name><operator>.</operator><name>java</name></name>     <operator>|</operator>    <literal type="number">4</literal> <operator>+</operator><operator>-</operator>
 <operator>...</operator><operator>/</operator><name>solr</name><operator>/</operator><name>handler</name><operator>/</operator><name><name>RequestHandlerBase</name><operator>.</operator><name>java</name></name>      <operator>|</operator>    <literal type="number">4</literal> <operator>+</operator><operator>-</operator>
 <operator>...</operator><operator>/</operator><name>handler</name><operator>/</operator><name>component</name><operator>/</operator><name><name>FacetComponent</name><operator>.</operator><name>java</name></name>     <operator>|</operator>    <literal type="number">4</literal> <operator>+</operator><operator>-</operator>
 <operator>...</operator><operator>/</operator><name>handler</name><operator>/</operator><name>component</name><operator>/</operator><name><name>HighlightComponent</name><operator>.</operator><name>java</name></name> <operator>|</operator>    <literal type="number">4</literal> <operator>+</operator><operator>-</operator>
 <operator>...</operator><operator>/</operator><name>handler</name><operator>/</operator><name>component</name><operator>/</operator><name><name>PivotFacetHelper</name><operator>.</operator><name>java</name></name>   <operator>|</operator>    <literal type="number">4</literal> <operator>+</operator><operator>-</operator>
 <operator>...</operator><operator>/</operator><name>handler</name><operator>/</operator><name>component</name><operator>/</operator><name><name>QueryComponent</name><operator>.</operator><name>java</name></name>     <operator>|</operator>    <literal type="number">5</literal> <operator>+</operator><operator>-</operator>
 <operator>...</operator><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>parser</name><operator>/</operator><name><name>CharStream</name><operator>.</operator><name>java</name></name>    <operator>|</operator>  <literal type="number">115</literal> <operator>++</operator>
 <operator>...</operator><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>parser</name><operator>/</operator><name><name>FastCharStream</name><operator>.</operator><name>java</name></name>    <operator>|</operator>  <literal type="number">123</literal> <operator>++</operator>
 <operator>...</operator><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>parser</name><operator>/</operator><name><name>ParseException</name><operator>.</operator><name>java</name></name>    <operator>|</operator>  <literal type="number">187</literal> <operator>++</operator><operator>+</operator>
 <operator>...</operator><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>parser</name><operator>/</operator><name><name>QueryParser</name><operator>.</operator><name>java</name></name>   <operator>|</operator>  <literal type="number">701</literal> <operator>++</operator><operator>++</operator><operator>++</operator><operator>++</operator><operator>+</operator>
 <operator>...</operator><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>parser</name><operator>/</operator><name><name>QueryParser</name><operator>.</operator><name>jj</name></name>     <operator>|</operator>  <literal type="number">267</literal> <operator>++</operator><operator>++</operator>
 <operator>...</operator><operator>/</operator><name>solr</name><operator>/</operator><name>parser</name><operator>/</operator><name><name>QueryParserConstants</name><operator>.</operator><name>java</name></name>     <operator>|</operator>  <literal type="number">129</literal> <operator>++</operator>
 <operator>...</operator><operator>/</operator><name>solr</name><operator>/</operator><name>parser</name><operator>/</operator><name><name>QueryParserTokenManager</name><operator>.</operator><name>java</name></name>  <operator>|</operator> <literal type="number">1261</literal> <operator>++</operator><operator>++</operator><operator>++</operator><operator>++</operator><operator>++</operator><operator>++</operator><operator>++</operator><operator>++</operator><operator>+</operator>
 <operator>...</operator><operator>/</operator><name>solr</name><operator>/</operator><name>parser</name><operator>/</operator><name><name>SolrQueryParserBase</name><operator>.</operator><name>java</name></name>      <operator>|</operator> <literal type="number">1033</literal> <operator>++</operator><operator>++</operator><operator>++</operator><operator>++</operator><operator>++</operator><operator>++</operator><operator>++</operator>
 <operator>...</operator><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>parser</name><operator>/</operator><name><name>Token</name><operator>.</operator><name>java</name></name>    <operator>|</operator>  <literal type="number">131</literal> <operator>++</operator>
 <operator>...</operator><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>parser</name><operator>/</operator><name><name>TokenMgrError</name><operator>.</operator><name>java</name></name> <operator>|</operator>  <literal type="number">147</literal> <operator>++</operator>
 <operator>...</operator><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>request</name><operator>/</operator><name><name>SimpleFacets</name><operator>.</operator><name>java</name></name> <operator>|</operator>   <literal type="number">17</literal> <operator>+</operator><operator>-</operator>
 <operator>...</operator><operator>/</operator><name>solr</name><operator>/</operator><name>search</name><operator>/</operator><name><name>BoostQParserPlugin</name><operator>.</operator><name>java</name></name>       <operator>|</operator>    <literal type="number">5</literal> <operator>+</operator><operator>-</operator>
 <operator>...</operator><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>search</name><operator>/</operator><name><name>DisMaxQParser</name><operator>.</operator><name>java</name></name> <operator>|</operator>   <literal type="number">29</literal> <operator>+</operator><operator>-</operator>
 <operator>...</operator><operator>/</operator><name>search</name><operator>/</operator><name><name>ExtendedDismaxQParserPlugin</name><operator>.</operator><name>java</name></name>   <operator>|</operator>   <literal type="number">40</literal> <operator>+</operator><operator>-</operator>
 <operator>...</operator><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>search</name><operator>/</operator><name><name>FunctionQParser</name><operator>.</operator><name>java</name></name>   <operator>|</operator>   <literal type="number">46</literal> <operator>+</operator><operator>-</operator>
 <operator>...</operator><operator>/</operator><name>search</name><operator>/</operator><name><name>FunctionRangeQParserPlugin</name><operator>.</operator><name>java</name></name>    <operator>|</operator>   <literal type="number">10</literal> <operator>+</operator><operator>-</operator>
 <operator>...</operator><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>search</name><operator>/</operator><name><name>Grouping</name><operator>.</operator><name>java</name></name> <operator>|</operator>    <literal type="number">8</literal> <operator>+</operator><operator>-</operator>
 <operator>...</operator><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>search</name><operator>/</operator><name><name>JoinQParserPlugin</name><operator>.</operator><name>java</name></name> <operator>|</operator>    <literal type="number">3</literal> <operator>+</operator><operator>-</operator>
 <operator>...</operator><operator>/</operator><name>solr</name><operator>/</operator><name>search</name><operator>/</operator><name><name>LuceneQParserPlugin</name><operator>.</operator><name>java</name></name>      <operator>|</operator>   <literal type="number">11</literal> <operator>+</operator><operator>-</operator>
 <operator>...</operator><operator>/</operator><name>solr</name><operator>/</operator><name>search</name><operator>/</operator><name><name>NestedQParserPlugin</name><operator>.</operator><name>java</name></name>      <operator>|</operator>    <literal type="number">5</literal> <operator>+</operator><operator>-</operator>
 <operator>...</operator><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>search</name><operator>/</operator><name><name>QParser</name><operator>.</operator><name>java</name></name>  <operator>|</operator>   <literal type="number">19</literal> <operator>+</operator><operator>-</operator>
 <operator>...</operator><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>search</name><operator>/</operator><name><name>QueryParsing</name><operator>.</operator><name>java</name></name>  <operator>|</operator>   <literal type="number">39</literal> <operator>+</operator><operator>-</operator>
 <operator>...</operator><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>search</name><operator>/</operator><name><name>ReturnFields</name><operator>.</operator><name>java</name></name>  <operator>|</operator>    <literal type="number">5</literal> <operator>+</operator><operator>-</operator>
 <operator>...</operator><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>search</name><operator>/</operator><name><name>SolrQueryParser</name><operator>.</operator><name>java</name></name>   <operator>|</operator>  <literal type="number">212</literal> <operator>+</operator><operator>--</operator>
 <operator>...</operator><operator>/</operator><name>solr</name><operator>/</operator><name>search</name><operator>/</operator><name><name>SpatialFilterQParser</name><operator>.</operator><name>java</name></name>     <operator>|</operator>    <literal type="number">3</literal> <operator>+</operator><operator>-</operator>
 <operator>...</operator><operator>/</operator><name>solr</name><operator>/</operator><name>search</name><operator>/</operator><name><name>SurroundQParserPlugin</name><operator>.</operator><name>java</name></name>    <operator>|</operator>    <literal type="number">7</literal> <operator>+</operator><operator>-</operator>
 <operator>...</operator><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>search</name><operator>/</operator><name><name>SyntaxError</name><operator>.</operator><name>java</name></name>   <operator>|</operator>   <literal type="number">31</literal> <operator>+</operator>
 <operator>...</operator><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>search</name><operator>/</operator><name><name>ValueSourceParser</name><operator>.</operator><name>java</name></name> <operator>|</operator>   <literal type="number">99</literal> <operator>+</operator><operator>-</operator>
 <operator>...</operator><operator>/</operator><name>distance</name><operator>/</operator><name><name>HaversineConstFunction</name><operator>.</operator><name>java</name></name>      <operator>|</operator>   <literal type="number">24</literal> <operator>+</operator><operator>-</operator>
 <operator>...</operator><operator>/</operator><name>distributed</name><operator>/</operator><name>command</name><operator>/</operator><name><name>QueryCommand</name><operator>.</operator><name>java</name></name>     <operator>|</operator>    <literal type="number">5</literal> <operator>+</operator><operator>-</operator>
 <operator>...</operator><operator>/</operator><name>solr</name><operator>/</operator><name>update</name><operator>/</operator><name><name>DirectUpdateHandler2</name><operator>.</operator><name>java</name></name>     <operator>|</operator>    <literal type="number">4</literal> <operator>+</operator><operator>-</operator>
 <operator>...</operator><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>util</name><operator>/</operator><name><name>SolrPluginUtils</name><operator>.</operator><name>java</name></name> <operator>|</operator>   <literal type="number">16</literal> <operator>+</operator><operator>-</operator>
 <operator>...</operator><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name><name>DummyValueSourceParser</name><operator>.</operator><name>java</name></name>     <operator>|</operator>    <literal type="number">4</literal> <operator>+</operator><operator>-</operator>
 <operator>...</operator><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name><name>TestArbitraryIndexDir</name><operator>.</operator><name>java</name></name>      <operator>|</operator>    <literal type="number">3</literal> <operator>+</operator><operator>-</operator>
 <operator>...</operator><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>search</name><operator>/</operator><name><name>FooQParserPlugin</name><operator>.</operator><name>java</name></name>  <operator>|</operator>    <literal type="number">3</literal> <operator>+</operator><operator>-</operator>
 <operator>...</operator><operator>/</operator><name>solr</name><operator>/</operator><name>search</name><operator>/</operator><name><name>TestExtendedDismaxParser</name><operator>.</operator><name>java</name></name> <operator>|</operator>    <literal type="number">2</literal> <operator>+</operator><operator>-</operator>
 <operator>...</operator><operator>/</operator><name>solr</name><operator>/</operator><name>search</name><operator>/</operator><name><name>TestSolrQueryParser</name><operator>.</operator><name>java</name></name>      <operator>|</operator>   <literal type="number">37</literal> <operator>+</operator>
 <operator>...</operator><operator>/</operator><name>solr</name><operator>/</operator><name>search</name><operator>/</operator><name><name>TestValueSourceCache</name><operator>.</operator><name>java</name></name>     <operator>|</operator>   <literal type="number">11</literal> <operator>+</operator><operator>-</operator>
 <operator>...</operator><operator>/</operator><name>search</name><operator>/</operator><name>function</name><operator>/</operator><name><name>NvlValueSourceParser</name><operator>.</operator><name>java</name></name> <operator>|</operator>    <literal type="number">4</literal> <operator>+</operator><operator>-</operator>
 <operator>...</operator><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>util</name><operator>/</operator><name><name>DateMathParserTest</name><operator>.</operator><name>java</name></name>  <operator>|</operator>    <literal type="number">2</literal> <operator>+</operator><operator>-</operator>
 <literal type="number">48</literal> <name>files</name> <name>changed</name></expr><operator>,</operator> <expr><literal type="number">4436</literal> <call><name>insertions</name><argument_list>(<argument><expr><operator>+</operator></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><literal type="number">452</literal> <call><name>deletions</name><argument_list>(<argument><expr><operator>-</operator></expr></argument>)</argument_list></call>
 <name>create</name> <name>mode</name> <literal type="number">100644</literal> <name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>parser</name><operator>/</operator><name><name>CharStream</name><operator>.</operator><name>java</name></name>
 <name>create</name> <name>mode</name> <literal type="number">100644</literal> <name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>parser</name><operator>/</operator><name><name>FastCharStream</name><operator>.</operator><name>java</name></name>
 <name>create</name> <name>mode</name> <literal type="number">100644</literal> <name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>parser</name><operator>/</operator><name><name>ParseException</name><operator>.</operator><name>java</name></name>
 <name>create</name> <name>mode</name> <literal type="number">100644</literal> <name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>parser</name><operator>/</operator><name><name>QueryParser</name><operator>.</operator><name>java</name></name>
 <name>create</name> <name>mode</name> <literal type="number">100644</literal> <name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>parser</name><operator>/</operator><name><name>QueryParser</name><operator>.</operator><name>jj</name></name>
 <name>create</name> <name>mode</name> <literal type="number">100644</literal> <name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>parser</name><operator>/</operator><name><name>QueryParserConstants</name><operator>.</operator><name>java</name></name>
 <name>create</name> <name>mode</name> <literal type="number">100644</literal> <name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>parser</name><operator>/</operator><name><name>QueryParserTokenManager</name><operator>.</operator><name>java</name></name>
 <name>create</name> <name>mode</name> <literal type="number">100644</literal> <name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>parser</name><operator>/</operator><name><name>SolrQueryParserBase</name><operator>.</operator><name>java</name></name>
 <name>create</name> <name>mode</name> <literal type="number">100644</literal> <name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>parser</name><operator>/</operator><name><name>Token</name><operator>.</operator><name>java</name></name>
 <name>create</name> <name>mode</name> <literal type="number">100644</literal> <name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>parser</name><operator>/</operator><name><name>TokenMgrError</name><operator>.</operator><name>java</name></name>
 <name>create</name> <name>mode</name> <literal type="number">100644</literal> <name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>search</name><operator>/</operator><name><name>SyntaxError</name><operator>.</operator><name>java</name></name>

<name>diff</name> <operator>--</operator><name>git</name> <name>a</name><operator>/</operator><name>solr</name><operator>/</operator><name><name>CHANGES</name><operator>.</operator><name>txt</name></name> <name>b</name><operator>/</operator><name>solr</name><operator>/</operator><name><name>CHANGES</name><operator>.</operator><name>txt</name></name>
<name>index</name> <name>be074ccfdc1</name><operator>..</operator><literal type="number">48a248a78bb</literal> <literal type="number">100644</literal>
<operator>--</operator> <name>a</name><operator>/</operator><name>solr</name><operator>/</operator><name><name>CHANGES</name><operator>.</operator><name>txt</name></name>
<operator>++</operator> <name>b</name><operator>/</operator><name>solr</name><operator>/</operator><name><name>CHANGES</name><operator>.</operator><name>txt</name></name>
@@ <operator>-</operator><literal type="number">34</literal></expr><operator>,</operator><expr><literal type="number">6</literal> <operator>+</operator><literal type="number">34</literal></expr><operator>,</operator><expr><literal type="number">13</literal> @@ <name>Velocity</name> <literal type="number">1.6.4</literal> <name>and</name> <name>Velocity</name> <name>Tools</name> <literal type="number">2.0</literal>
 <name>Apache</name> <name>UIMA</name> <literal type="number">2.3.1</literal>
 <name>Apache</name> <name>ZooKeeper</name> <literal type="number">3.4.5</literal>
 
<name>Upgrading</name> <name>from</name> <name>Solr</name> <literal type="number">4.0.0</literal><operator>-</operator><name>BETA</name>
<operator>--</operator><operator>--</operator><operator>--</operator><operator>--</operator><operator>--</operator><operator>--</operator><operator>--</operator><operator>--</operator><operator>--</operator><operator>--</operator><operator>--</operator>

<name>Custom</name> <name>java</name> <name>parsing</name> <name>plugins</name> <name>need</name> <name>to</name> <name>migrade</name> <name>from</name> <name>throwing</name> <name>the</name> <name>internal</name>
<name>ParseException</name> <name>to</name> <name>throwing</name> <name><name>SyntaxError</name><operator>.</operator>


 <name>Detailed</name></name> <name>Change</name> <name>List</name>
 <operator>--</operator><operator>--</operator><operator>--</operator><operator>--</operator><operator>--</operator><operator>--</operator><operator>--</operator><operator>--</operator><operator>--</operator><operator>--</operator><operator>--</operator>
 
@@ <operator>-</operator><literal type="number">88</literal></expr><operator>,</operator><expr><literal type="number">6</literal> <operator>+</operator><literal type="number">95</literal></expr><operator>,</operator><expr><literal type="number">12</literal> @@ <name>New</name> <name>Features</name>
   <literal type="char">'storeOffsetsWithPositions'</literal> <name>flag</name> <name>on</name> <name>field</name> <name>definitions</name> <name>in</name> <name>the</name> <name><name>schema</name><operator>.</operator></name>
   (<name>Tom</name> <name>Winch</name></expr><operator>,</operator> <expr><name>Alan</name> <name>Woodward</name></expr></expr_stmt>)
 
<expr_stmt><expr><operator>*</operator> <name>SOLR</name><operator>-</operator><literal type="number">4093</literal><operator>:</operator> <name>Solr</name> <name>QParsers</name> <name>may</name> <name>now</name> <name>be</name> <name>directly</name> <name>invoked</name> <name>in</name> <name>the</name> <name>lucene</name>
  <name>query</name> <name>syntax</name> <name>without</name> <name>the</name> <name>_query_</name> <name>magic</name> <name>field</name> <name><name>hack</name><operator>.</operator>
  <name>Example</name></name><operator>:</operator>  <name>foo</name> <name>AND</name> <block>{<expr><operator>!</operator><name>term</name> <name>f</name><operator>=</operator><name>myfield</name> <name>v</name><operator>=</operator><name>$qq</name></expr>}</block>
  <operator>(</operator><name>yonik</name><operator>)</operator>


 <name>Optimizations</name>
 <operator>--</operator><operator>--</operator><operator>--</operator><operator>--</operator><operator>--</operator><operator>--</operator><operator>--</operator><operator>--</operator><operator>--</operator><operator>--</operator><operator>--</operator>
 
<name>diff</name> <operator>--</operator><name>git</name> <name>a</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name><name>build</name><operator>.</operator><name>xml</name></name> <name>b</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name><name>build</name><operator>.</operator><name>xml</name></name>
<name>index</name> <name>bff9ead936b</name><operator>..</operator><literal type="number">32462398aea</literal> <literal type="number">100644</literal>
<operator>--</operator> <name>a</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name><name>build</name><operator>.</operator><name>xml</name></name>
<operator>++</operator> <name>b</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name><name>build</name><operator>.</operator><name>xml</name></name>
@@ <operator>-</operator><literal type="number">42</literal></expr><operator>,</operator><expr><literal type="number">4</literal> <operator>+</operator><literal type="number">42</literal></expr><operator>,</operator><expr><literal type="number">56</literal> @@
   <operator>&lt;</operator><operator>/</operator><name>target</name><operator>&gt;</operator>
 
   <operator>&lt;</operator><name>target</name> <name>name</name><operator>=</operator><literal type="string">"dist-maven"</literal> <name>depends</name><operator>=</operator><literal type="string">"dist-maven-src-java"</literal><operator>/</operator><operator>&gt;</operator>




  <operator>&lt;</operator><name>target</name> <name>name</name><operator>=</operator><literal type="string">"javacc"</literal> <name>depends</name><operator>=</operator><literal type="string">"javacc-QueryParser"</literal><operator>/</operator><operator>&gt;</operator>
  <operator>&lt;</operator><name>target</name> <name>name</name><operator>=</operator><literal type="string">"javacc-QueryParser"</literal> <name>depends</name><operator>=</operator><literal type="string">"resolve-javacc"</literal><operator>&gt;</operator>
    <operator>&lt;</operator><name>sequential</name><operator>&gt;</operator>
      <operator>&lt;</operator><name>invoke</name><operator>-</operator><name>javacc</name> <name>target</name><operator>=</operator><literal type="string">"src/java/org/apache/solr/parser/QueryParser.jj"</literal>
                     <name>outputDir</name><operator>=</operator><literal type="string">"src/java/org/apache/solr/parser"</literal><operator>/</operator><operator>&gt;</operator>

      <operator>&lt;</operator><operator>!</operator><operator>--</operator> <name>Change</name> <name>the</name> <name>incorrect</name> <specifier>public</specifier> <name>ctors</name></expr></expr_stmt> <for>for QueryParser to be protected instead --&gt;
      &lt;replaceregexp file="src/java/org/apache/solr/parser/QueryParser.java"
                     byline="true"
                     match="public QueryParser\(CharStream "
                     replace="protected QueryParser(CharStream "/&gt;
      &lt;replaceregexp file="src/java/org/apache/solr/parser/QueryParser.java"
                     byline="true"
                     match="public QueryParser\(QueryParserTokenManager "
                     replace="protected QueryParser(QueryParserTokenManager "/&gt;

    &lt;/sequential&gt;
  &lt;/target&gt;
  &lt;target name="resolve-javacc" xmlns:ivy="antlib:org.apache.ivy.ant"&gt;
    &lt;!-- setup a "fake" JavaCC distribution folder in $<block>{<block_content><expr><name><name>build</name><operator>.</operator><name>dir</name></name></expr></block_content>}</block></for> <expr_stmt><expr><name>to</name> <name>make</name> <name>JavaCC</name> <name>ANT</name> <name>task</name> <name>happy</name><operator>:</operator> <operator>--</operator><operator>&gt;</operator>
    <operator>&lt;</operator><name>ivy</name><operator>:</operator><name>retrieve</name> <name>organisation</name><operator>=</operator><literal type="string">"net.java.dev.javacc"</literal> <name>module</name><operator>=</operator><literal type="string">"javacc"</literal> <name>revision</name><operator>=</operator><literal type="string">"5.0"</literal>
      <name>inline</name><operator>=</operator><literal type="string">"true"</literal> <name>conf</name><operator>=</operator><literal type="string">"default"</literal> <name>transitive</name><operator>=</operator><literal type="string">"false"</literal> <name>type</name><operator>=</operator><literal type="string">"jar"</literal> <name>sync</name><operator>=</operator><literal type="string">"true"</literal>
      <name>pattern</name><operator>=</operator><literal type="string">"${build.dir}/javacc/bin/lib/[artifact].[ext]"</literal><operator>/</operator><operator>&gt;</operator>
  <operator>&lt;</operator><operator>/</operator><name>target</name><operator>&gt;</operator>

  <operator>&lt;</operator><name>macrodef</name> <name>name</name><operator>=</operator><literal type="string">"invoke-javacc"</literal><operator>&gt;</operator>
    <operator>&lt;</operator><name>attribute</name> <name>name</name><operator>=</operator><literal type="string">"target"</literal><operator>/</operator><operator>&gt;</operator>
    <operator>&lt;</operator><name>attribute</name> <name>name</name><operator>=</operator><literal type="string">"outputDir"</literal><operator>/</operator><operator>&gt;</operator>
    <operator>&lt;</operator><name>sequential</name><operator>&gt;</operator>
      <operator>&lt;</operator><name>mkdir</name> <name>dir</name><operator>=</operator><literal type="string">"@{outputDir}"</literal><operator>/</operator><operator>&gt;</operator>
      <operator>&lt;</operator><name>delete</name><operator>&gt;</operator>
        <operator>&lt;</operator><name>fileset</name> <name>dir</name><operator>=</operator><literal type="string">"@{outputDir}"</literal> <name>includes</name><operator>=</operator><literal type="string">"*.java"</literal><operator>&gt;</operator>
          <operator>&lt;</operator><name>containsregexp</name> <name>expression</name><operator>=</operator><literal type="string">"Generated.*By.*JavaCC"</literal><operator>/</operator><operator>&gt;</operator>
        <operator>&lt;</operator><operator>/</operator><name>fileset</name><operator>&gt;</operator>
      <operator>&lt;</operator><operator>/</operator><name>delete</name><operator>&gt;</operator>
      <operator>&lt;</operator><name>javacc</name>
          <name>target</name><operator>=</operator><literal type="string">"@{target}"</literal>
          <name>outputDirectory</name><operator>=</operator><literal type="string">"@{outputDir}"</literal>
          <name>javacchome</name><operator>=</operator><literal type="string">"${build.dir}/javacc"</literal>
          <name>jdkversion</name><operator>=</operator><literal type="string">"${javac.source}"</literal>
      <operator>/</operator><operator>&gt;</operator>
      <operator>&lt;</operator><name>fixcrlf</name> <name>srcdir</name><operator>=</operator><literal type="string">"@{outputDir}"</literal> <name>includes</name><operator>=</operator><literal type="string">"*.java"</literal> <name>encoding</name><operator>=</operator><literal type="string">"UTF-8"</literal><operator>&gt;</operator>
        <operator>&lt;</operator><name>containsregexp</name> <name>expression</name><operator>=</operator><literal type="string">"Generated.*By.*JavaCC"</literal><operator>/</operator><operator>&gt;</operator>
      <operator>&lt;</operator><operator>/</operator><name>fixcrlf</name><operator>&gt;</operator>
    <operator>&lt;</operator><operator>/</operator><name>sequential</name><operator>&gt;</operator>
  <operator>&lt;</operator><operator>/</operator><name>macrodef</name><operator>&gt;</operator>


 <operator>&lt;</operator><operator>/</operator><name>project</name><operator>&gt;</operator>
<name>diff</name> <operator>--</operator><name>git</name> <name>a</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>handler</name><operator>/</operator><name><name>MoreLikeThisHandler</name><operator>.</operator><name>java</name></name> <name>b</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>handler</name><operator>/</operator><name><name>MoreLikeThisHandler</name><operator>.</operator><name>java</name></name>
<name>index</name> <name>b8411ea188f</name><operator>..</operator><literal type="number">62a406ae847</literal> <literal type="number">100644</literal>
<operator>--</operator> <name>a</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>handler</name><operator>/</operator><name><name>MoreLikeThisHandler</name><operator>.</operator><name>java</name></name>
<operator>++</operator> <name>b</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>handler</name><operator>/</operator><name><name>MoreLikeThisHandler</name><operator>.</operator><name>java</name></name>
@@ <operator>-</operator><literal type="number">29</literal></expr><operator>,</operator><expr><literal type="number">11</literal> <operator>+</operator><literal type="number">29</literal></expr><operator>,</operator><expr><literal type="number">9</literal> @@</expr></expr_stmt> <import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>List</name></name>;</import>
 <import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>Map</name></name>;</import>
 <import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>regex</name><operator>.</operator><name>Pattern</name></name>;</import>
 
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>document</name><operator>.</operator><name>Document</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>index</name><operator>.</operator><name>IndexReader</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>index</name><operator>.</operator><name>StoredDocument</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>index</name><operator>.</operator><name>Term</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>queryparser</name><operator>.</operator><name>classic</name><operator>.</operator><name>ParseException</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>search</name><operator>.</operator><name>*</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>queries</name><operator>.</operator><name>mlt</name><operator>.</operator><name>MoreLikeThis</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>common</name><operator>.</operator><name>SolrException</name></name>;</import>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">108</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">106</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@ <specifier>public</specifier> <name>class</name> <name>MoreLikeThisHandler</name> extends <name>RequestHandlerBase</name></expr></expr_stmt>
           }
         }
       }
    } <catch>catch <parameter_list>(<parameter><decl><type><name>ParseException</name></type> <name>e</name></decl></parameter>)</parameter_list> <block>{<block_content>
    </block_content>}</block></catch> <catch>catch <parameter_list>(<parameter><decl><type><name>SyntaxError</name></type> <name>e</name></decl></parameter>)</parameter_list> <block>{<block_content>
       <throw>throw <expr><operator>new</operator> <call><name>SolrException</name><argument_list>(<argument><expr><name><name>SolrException</name><operator>.</operator><name>ErrorCode</name><operator>.</operator><name>BAD_REQUEST</name></name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</throw>
     </block_content>}</block></catch>
 
<expr_stmt><expr><name>diff</name> <operator>--</operator><name>git</name> <name>a</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>handler</name><operator>/</operator><name><name>RequestHandlerBase</name><operator>.</operator><name>java</name></name> <name>b</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>handler</name><operator>/</operator><name><name>RequestHandlerBase</name><operator>.</operator><name>java</name></name>
<name>index</name> <name>d446e6852c9</name><operator>..</operator><literal type="number">3a2693d8fc6</literal> <literal type="number">100644</literal>
<operator>--</operator> <name>a</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>handler</name><operator>/</operator><name><name>RequestHandlerBase</name><operator>.</operator><name>java</name></name>
<operator>++</operator> <name>b</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>handler</name><operator>/</operator><name><name>RequestHandlerBase</name><operator>.</operator><name>java</name></name>
@@ <operator>-</operator><literal type="number">22</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">22</literal></expr><operator>,</operator><expr><literal type="number">6</literal> @@</expr></expr_stmt> <import>import <name><name>com</name><operator>.</operator><name>yammer</name><operator>.</operator><name>metrics</name><operator>.</operator><name>core</name><operator>.</operator><name>Counter</name></name>;</import>
 <import>import <name><name>com</name><operator>.</operator><name>yammer</name><operator>.</operator><name>metrics</name><operator>.</operator><name>core</name><operator>.</operator><name>Timer</name></name>;</import>
 <import>import <name><name>com</name><operator>.</operator><name>yammer</name><operator>.</operator><name>metrics</name><operator>.</operator><name>core</name><operator>.</operator><name>TimerContext</name></name>;</import>
 <import>import <name><name>com</name><operator>.</operator><name>yammer</name><operator>.</operator><name>metrics</name><operator>.</operator><name>stats</name><operator>.</operator><name>Snapshot</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>queryparser</name><operator>.</operator><name>classic</name><operator>.</operator><name>ParseException</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>common</name><operator>.</operator><name>SolrException</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>common</name><operator>.</operator><name>params</name><operator>.</operator><name>SolrParams</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>common</name><operator>.</operator><name>util</name><operator>.</operator><name>NamedList</name></name>;</import>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">32</literal></expr><operator>,</operator><expr><literal type="number">6</literal> <operator>+</operator><literal type="number">31</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@</expr></expr_stmt> <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>core</name><operator>.</operator><name>SolrInfoMBean</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>request</name><operator>.</operator><name>SolrQueryRequest</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>request</name><operator>.</operator><name>SolrRequestHandler</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>response</name><operator>.</operator><name>SolrQueryResponse</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>search</name><operator>.</operator><name>SyntaxError</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>util</name><operator>.</operator><name>SolrPluginUtils</name></name>;</import>
 
 <import>import <name><name>java</name><operator>.</operator><name>net</name><operator>.</operator><name>URL</name></name>;</import>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">163</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">163</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@ <specifier>public</specifier> <specifier>abstract</specifier> <name>class</name> <name>RequestHandlerBase</name> implements <name>SolrRequestHandler</name></expr><operator>,</operator> <expr><name>SolrInfo</name></expr></expr_stmt>
         }
       } <if_stmt><else>else <block>{<block_content>
         <expr_stmt><expr><call><name><name>SolrException</name><operator>.</operator><name>log</name></name><argument_list>(<argument><expr><name><name>SolrCore</name><operator>.</operator><name>log</name></name></expr></argument>,<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>e</name> <operator>instanceof</operator> <name>ParseException</name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>e</name> <operator>instanceof</operator> <name>SyntaxError</name></expr>)</condition> <block>{<block_content>
           <expr_stmt><expr><name>e</name> <operator>=</operator> <operator>new</operator> <call><name>SolrException</name><argument_list>(<argument><expr><name><name>SolrException</name><operator>.</operator><name>ErrorCode</name><operator>.</operator><name>BAD_REQUEST</name></name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
         </block_content>}</block></if></if_stmt>
       </block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>diff</name> <operator>--</operator><name>git</name> <name>a</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>handler</name><operator>/</operator><name>component</name><operator>/</operator><name><name>FacetComponent</name><operator>.</operator><name>java</name></name> <name>b</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>handler</name><operator>/</operator><name>component</name><operator>/</operator><name><name>FacetComponent</name><operator>.</operator><name>java</name></name>
<name>index</name> <name>b1843111c76</name><operator>..</operator><name>d3a6069f563</name> <literal type="number">100644</literal>
<operator>--</operator> <name>a</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>handler</name><operator>/</operator><name>component</name><operator>/</operator><name><name>FacetComponent</name><operator>.</operator><name>java</name></name>
<operator>++</operator> <name>b</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>handler</name><operator>/</operator><name>component</name><operator>/</operator><name><name>FacetComponent</name><operator>.</operator><name>java</name></name>
@@ <operator>-</operator><literal type="number">17</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">17</literal></expr><operator>,</operator><expr><literal type="number">6</literal> @@</expr></expr_stmt>
 
 <package>package <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>handler</name><operator>.</operator><name>component</name></name>;</package>
 
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>queryparser</name><operator>.</operator><name>classic</name><operator>.</operator><name>ParseException</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>util</name><operator>.</operator><name>OpenBitSet</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>common</name><operator>.</operator><name>SolrException</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>common</name><operator>.</operator><name>SolrException</name><operator>.</operator><name>ErrorCode</name></name>;</import>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">32</literal></expr><operator>,</operator><expr><literal type="number">6</literal> <operator>+</operator><literal type="number">31</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@</expr></expr_stmt> <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>common</name><operator>.</operator><name>util</name><operator>.</operator><name>StrUtils</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>request</name><operator>.</operator><name>SimpleFacets</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>schema</name><operator>.</operator><name>FieldType</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>search</name><operator>.</operator><name>QueryParsing</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>search</name><operator>.</operator><name>SyntaxError</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>slf4j</name><operator>.</operator><name>Logger</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>slf4j</name><operator>.</operator><name>LoggerFactory</name></name>;</import>
 
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">670</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">670</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@ <specifier>public</specifier> <name>class</name> <name>FacetComponent</name> extends <name>SearchComponent</name>
       <name><name>this</name><operator>.</operator><name>facetStr</name></name> <operator>=</operator> <name>facetStr</name></expr>;</expr_stmt>
       <try>try <block>{<block_content>
         <expr_stmt><expr><name><name>this</name><operator>.</operator><name>localParams</name></name> <operator>=</operator> <call><name><name>QueryParsing</name><operator>.</operator><name>getLocalParams</name></name><argument_list>(<argument><expr><name>facetStr</name></expr></argument>, <argument><expr><call><name><name>rb</name><operator>.</operator><name>req</name><operator>.</operator><name>getParams</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block> <catch>catch <parameter_list>(<parameter><decl><type><name>ParseException</name></type> <name>e</name></decl></parameter>)</parameter_list> <block>{<block_content>
      </block_content>}</block></catch> <catch>catch <parameter_list>(<parameter><decl><type><name>SyntaxError</name></type> <name>e</name></decl></parameter>)</parameter_list> <block>{<block_content>
         <throw>throw <expr><operator>new</operator> <call><name>SolrException</name><argument_list>(<argument><expr><name><name>SolrException</name><operator>.</operator><name>ErrorCode</name><operator>.</operator><name>BAD_REQUEST</name></name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</throw>
       </block_content>}</block></catch></try>
       <expr_stmt><expr><name><name>this</name><operator>.</operator><name>facetOn</name></name> <operator>=</operator> <name>facetStr</name></expr>;</expr_stmt>
<expr_stmt><expr><name>diff</name> <operator>--</operator><name>git</name> <name>a</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>handler</name><operator>/</operator><name>component</name><operator>/</operator><name><name>HighlightComponent</name><operator>.</operator><name>java</name></name> <name>b</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>handler</name><operator>/</operator><name>component</name><operator>/</operator><name><name>HighlightComponent</name><operator>.</operator><name>java</name></name>
<name>index</name> <literal type="number">69a3ce92540</literal><operator>..</operator><name>a1e7697fd66</name> <literal type="number">100644</literal>
<operator>--</operator> <name>a</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>handler</name><operator>/</operator><name>component</name><operator>/</operator><name><name>HighlightComponent</name><operator>.</operator><name>java</name></name>
<operator>++</operator> <name>b</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>handler</name><operator>/</operator><name>component</name><operator>/</operator><name><name>HighlightComponent</name><operator>.</operator><name>java</name></name>
@@ <operator>-</operator><literal type="number">17</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">17</literal></expr><operator>,</operator><expr><literal type="number">6</literal> @@</expr></expr_stmt>
 
 <package>package <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>handler</name><operator>.</operator><name>component</name></name>;</package>
 
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>queryparser</name><operator>.</operator><name>classic</name><operator>.</operator><name>ParseException</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>search</name><operator>.</operator><name>Query</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>common</name><operator>.</operator><name>SolrException</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>common</name><operator>.</operator><name>params</name><operator>.</operator><name>CommonParams</name></name>;</import>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">29</literal></expr><operator>,</operator><expr><literal type="number">6</literal> <operator>+</operator><literal type="number">28</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@</expr></expr_stmt> <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>highlight</name><operator>.</operator><name>SolrHighlighter</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>highlight</name><operator>.</operator><name>DefaultSolrHighlighter</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>request</name><operator>.</operator><name>SolrQueryRequest</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>search</name><operator>.</operator><name>QParser</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>search</name><operator>.</operator><name>SyntaxError</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>util</name><operator>.</operator><name>SolrPluginUtils</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>util</name><operator>.</operator><name>plugin</name><operator>.</operator><name>PluginInfoInitialized</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>util</name><operator>.</operator><name>plugin</name><operator>.</operator><name>SolrCoreAware</name></name>;</import>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">71</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">71</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@ <specifier>public</specifier> <name>class</name> <name>HighlightComponent</name> extends <name>SearchComponent</name> implements <name>PluginInfoIni</name></expr></expr_stmt>
         <try>try <block>{<block_content>
           <decl_stmt><decl><type><name>QParser</name></type> <name>parser</name> <init>= <expr><call><name><name>QParser</name><operator>.</operator><name>getParser</name></name><argument_list>(<argument><expr><name>hlq</name></expr></argument>, <argument><expr><literal type="null">null</literal></expr></argument>, <argument><expr><name><name>rb</name><operator>.</operator><name>req</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
           <expr_stmt><expr><call><name><name>rb</name><operator>.</operator><name>setHighlightQuery</name></name><argument_list>(<argument><expr><call><name><name>parser</name><operator>.</operator><name>getHighlightQuery</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block> <catch>catch <parameter_list>(<parameter><decl><type><name>ParseException</name></type> <name>e</name></decl></parameter>)</parameter_list> <block>{<block_content>
        </block_content>}</block></catch> <catch>catch <parameter_list>(<parameter><decl><type><name>SyntaxError</name></type> <name>e</name></decl></parameter>)</parameter_list> <block>{<block_content>
           <throw>throw <expr><operator>new</operator> <call><name>SolrException</name><argument_list>(<argument><expr><name><name>SolrException</name><operator>.</operator><name>ErrorCode</name><operator>.</operator><name>BAD_REQUEST</name></name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</throw>
         </block_content>}</block></catch></try>
       </block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>diff</name> <operator>--</operator><name>git</name> <name>a</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>handler</name><operator>/</operator><name>component</name><operator>/</operator><name><name>PivotFacetHelper</name><operator>.</operator><name>java</name></name> <name>b</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>handler</name><operator>/</operator><name>component</name><operator>/</operator><name><name>PivotFacetHelper</name><operator>.</operator><name>java</name></name>
<name>index</name> <literal type="number">72a0a634b2c</literal><operator>..</operator><literal type="number">7606adc332e</literal> <literal type="number">100644</literal>
<operator>--</operator> <name>a</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>handler</name><operator>/</operator><name>component</name><operator>/</operator><name><name>PivotFacetHelper</name><operator>.</operator><name>java</name></name>
<operator>++</operator> <name>b</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>handler</name><operator>/</operator><name>component</name><operator>/</operator><name><name>PivotFacetHelper</name><operator>.</operator><name>java</name></name>
@@ <operator>-</operator><literal type="number">17</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">17</literal></expr><operator>,</operator><expr><literal type="number">6</literal> @@</expr></expr_stmt>
 
 <package>package <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>handler</name><operator>.</operator><name>component</name></name>;</package>
 
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>queryparser</name><operator>.</operator><name>classic</name><operator>.</operator><name>ParseException</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>util</name><operator>.</operator><name>BytesRef</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>schema</name><operator>.</operator><name>SchemaField</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>search</name><operator>.</operator><name>SolrIndexSearcher</name></name>;</import>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">35</literal></expr><operator>,</operator><expr><literal type="number">6</literal> <operator>+</operator><literal type="number">34</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@</expr></expr_stmt> <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>search</name><operator>.</operator><name>Query</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>search</name><operator>.</operator><name>TermQuery</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>search</name><operator>.</operator><name>TermRangeQuery</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>index</name><operator>.</operator><name>Term</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>search</name><operator>.</operator><name>SyntaxError</name></name>;</import>
 
 <import>import <name><name>java</name><operator>.</operator><name>io</name><operator>.</operator><name>IOException</name></name>;</import>
 <import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>ArrayList</name></name>;</import>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">65</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">65</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@ <specifier>public</specifier> <name>class</name> <name>PivotFacetHelper</name> extends <name>SimpleFacets</name></expr></expr_stmt>
       <comment type="line">//ex: pivot == "features,cat" or even "{!ex=mytag}features,cat"</comment>
       <try>try <block>{<block_content>
         <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>parseParams</name></name><argument_list>(<argument><expr><name><name>FacetParams</name><operator>.</operator><name>FACET_PIVOT</name></name></expr></argument>, <argument><expr><name>pivot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block> <catch>catch <parameter_list>(<parameter><decl><type><name>ParseException</name></type> <name>e</name></decl></parameter>)</parameter_list> <block>{<block_content>
      </block_content>}</block></catch> <catch>catch <parameter_list>(<parameter><decl><type><name>SyntaxError</name></type> <name>e</name></decl></parameter>)</parameter_list> <block>{<block_content>
         <throw>throw <expr><operator>new</operator> <call><name>SolrException</name><argument_list>(<argument><expr><name><name>ErrorCode</name><operator>.</operator><name>BAD_REQUEST</name></name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</throw>
       </block_content>}</block></catch></try>
       <expr_stmt><expr><name>pivot</name> <operator>=</operator> <name>facetValue</name></expr>;</expr_stmt><comment type="line">//facetValue potentially modified from parseParams()</comment>
<expr_stmt><expr><name>diff</name> <operator>--</operator><name>git</name> <name>a</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>handler</name><operator>/</operator><name>component</name><operator>/</operator><name><name>QueryComponent</name><operator>.</operator><name>java</name></name> <name>b</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>handler</name><operator>/</operator><name>component</name><operator>/</operator><name><name>QueryComponent</name><operator>.</operator><name>java</name></name>
<name>index</name> <literal type="number">6ae278d8744</literal><operator>..</operator><name>a731f346f57</name> <literal type="number">100644</literal>
<operator>--</operator> <name>a</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>handler</name><operator>/</operator><name>component</name><operator>/</operator><name><name>QueryComponent</name><operator>.</operator><name>java</name></name>
<operator>++</operator> <name>b</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>handler</name><operator>/</operator><name>component</name><operator>/</operator><name><name>QueryComponent</name><operator>.</operator><name>java</name></name>
@@ <operator>-</operator><literal type="number">23</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">23</literal></expr><operator>,</operator><expr><literal type="number">6</literal> @@</expr></expr_stmt> <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>index</name><operator>.</operator><name>AtomicReaderContext</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>index</name><operator>.</operator><name>IndexReaderContext</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>index</name><operator>.</operator><name>ReaderUtil</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>index</name><operator>.</operator><name>Term</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>queryparser</name><operator>.</operator><name>classic</name><operator>.</operator><name>ParseException</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>search</name><operator>.</operator><name>*</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>search</name><operator>.</operator><name>grouping</name><operator>.</operator><name>GroupDocs</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>search</name><operator>.</operator><name>grouping</name><operator>.</operator><name>SearchGroup</name></name>;</import>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">144</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">143</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@ <specifier>public</specifier> <name>class</name> <name>QueryComponent</name> extends <name>SearchComponent</name>
           <call><name><name>rb</name><operator>.</operator><name>setFilters</name></name><argument_list>( <argument><expr><name>filters</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
         }
       }
    } catch <expr_stmt><expr><operator>(</operator><name>ParseException</name> <name>e</name><operator>)</operator> <block>{
    }</block></expr></expr_stmt> <catch>catch <parameter_list>(<parameter><decl><type><name>SyntaxError</name></type> <name>e</name></decl></parameter>)</parameter_list> <block>{<block_content>
       <throw>throw <expr><operator>new</operator> <call><name>SolrException</name><argument_list>(<argument><expr><name><name>SolrException</name><operator>.</operator><name>ErrorCode</name><operator>.</operator><name>BAD_REQUEST</name></name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</throw>
     </block_content>}</block></catch>
 
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">402</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">401</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@ <specifier>public</specifier> <name>class</name> <name>QueryComponent</name> extends <name>SearchComponent</name>
           <call><name><name>rsp</name><operator>.</operator><name>getToLog</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>add</name><argument_list>(<argument><expr><literal type="string">"hits"</literal></expr></argument>, <argument><expr><call><name><name>grouping</name><operator>.</operator><name>getCommands</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>get</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>.</operator><call><name>getMatches</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
         }
         return<empty_stmt>;</empty_stmt>
      } catch <expr_stmt><expr><operator>(</operator><name>ParseException</name> <name>e</name><operator>)</operator> <block>{
      }</block></expr></expr_stmt> <catch>catch <parameter_list>(<parameter><decl><type><name>SyntaxError</name></type> <name>e</name></decl></parameter>)</parameter_list> <block>{<block_content>
         <throw>throw <expr><operator>new</operator> <call><name>SolrException</name><argument_list>(<argument><expr><name><name>SolrException</name><operator>.</operator><name>ErrorCode</name><operator>.</operator><name>BAD_REQUEST</name></name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</throw>
       </block_content>}</block></catch>
     }
diff <expr_stmt><expr><operator>--</operator><name>git</name> <name>a</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>parser</name><operator>/</operator><name><name>CharStream</name><operator>.</operator><name>java</name></name> <name>b</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>parser</name><operator>/</operator><name><name>CharStream</name><operator>.</operator><name>java</name></name>
<operator>new</operator> <name>file</name> <name>mode</name> <literal type="number">100644</literal>
<name>index</name> <literal type="number">00000000000..0400af47e05</literal>
<operator>--</operator> <operator>/</operator><name>dev</name><operator>/</operator><literal type="null">null</literal>
<operator>++</operator> <name>b</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>parser</name><operator>/</operator><name><name>CharStream</name><operator>.</operator><name>java</name></name>
@@ <operator>-</operator><literal type="number">0</literal></expr><operator>,</operator><expr><literal type="number">0</literal> <operator>+</operator><literal type="number">1</literal></expr><operator>,</operator><expr><literal type="number">115</literal> @@</expr></expr_stmt>
<comment type="block">/* Generated By:JavaCC: Do not edit this line. CharStream.java Version 5.0 */</comment>
<comment type="block">/* JavaCCOptions:STATIC=false,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */</comment>
<package>package <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>parser</name></name>;</package>

<comment type="block" format="javadoc">/**
 * This interface describes a character stream that maintains line and
 * column number positions of the characters.  It also has the capability
 * to backup the stream to some extent.  An implementation of this
 * interface is used in the TokenManager implementation generated by
 * JavaCCParser.
 *
 * All the methods except backup can be implemented in any fashion. backup
 * needs to be implemented correctly for the correct operation of the lexer.
 * Rest of the methods are all used to get information like line number,
 * column number and the String that constitutes a token and are not used
 * by the lexer. Hence their implementation won't affect the generated lexer's
 * operation.
 */</comment>

<interface><specifier>public</specifier>
interface <name>CharStream</name> <block>{

  <comment type="block" format="javadoc">/**
   * Returns the next character from the selected input.  The method
   * of selecting the input is the responsibility of the class
   * implementing this interface.  Can throw any java.io.IOException.
   */</comment>
  <function_decl><type><name>char</name></type> <name>readChar</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name><name>java</name><operator>.</operator><name>io</name><operator>.</operator><name>IOException</name></name></expr></argument></throws>;</function_decl>

  <function_decl><annotation>@<name>Deprecated</name></annotation>
  <comment type="block" format="javadoc">/**
   * Returns the column position of the character last read.
   * @deprecated
   * @see #getEndColumn
   */</comment>
  <type><name>int</name></type> <name>getColumn</name><parameter_list>()</parameter_list>;</function_decl>

  <function_decl><annotation>@<name>Deprecated</name></annotation>
  <comment type="block" format="javadoc">/**
   * Returns the line number of the character last read.
   * @deprecated
   * @see #getEndLine
   */</comment>
  <type><name>int</name></type> <name>getLine</name><parameter_list>()</parameter_list>;</function_decl>

  <comment type="block" format="javadoc">/**
   * Returns the column number of the last character for current token (being
   * matched after the last call to BeginTOken).
   */</comment>
  <function_decl><type><name>int</name></type> <name>getEndColumn</name><parameter_list>()</parameter_list>;</function_decl>

  <comment type="block" format="javadoc">/**
   * Returns the line number of the last character for current token (being
   * matched after the last call to BeginTOken).
   */</comment>
  <function_decl><type><name>int</name></type> <name>getEndLine</name><parameter_list>()</parameter_list>;</function_decl>

  <comment type="block" format="javadoc">/**
   * Returns the column number of the first character for current token (being
   * matched after the last call to BeginTOken).
   */</comment>
  <function_decl><type><name>int</name></type> <name>getBeginColumn</name><parameter_list>()</parameter_list>;</function_decl>

  <comment type="block" format="javadoc">/**
   * Returns the line number of the first character for current token (being
   * matched after the last call to BeginTOken).
   */</comment>
  <function_decl><type><name>int</name></type> <name>getBeginLine</name><parameter_list>()</parameter_list>;</function_decl>

  <comment type="block" format="javadoc">/**
   * Backs up the input stream by amount steps. Lexer calls this method if it
   * had already read some characters, but could not use them to match a
   * (longer) token. So, they will be used again as the prefix of the next
   * token and it is the implemetation's responsibility to do this right.
   */</comment>
  <function_decl><type><name>void</name></type> <name>backup</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>amount</name></decl></parameter>)</parameter_list>;</function_decl>

  <comment type="block" format="javadoc">/**
   * Returns the next character that marks the beginning of the next token.
   * All characters must remain in the buffer between two successive calls
   * to this method to implement backup correctly.
   */</comment>
  <function_decl><type><name>char</name></type> <name>BeginToken</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name><name>java</name><operator>.</operator><name>io</name><operator>.</operator><name>IOException</name></name></expr></argument></throws>;</function_decl>

  <comment type="block" format="javadoc">/**
   * Returns a string made up of characters from the marked token beginning
   * to the current buffer position. Implementations have the choice of returning
   * anything that they want to. For example, for efficiency, one might decide
   * to just return null, which is a valid implementation.
   */</comment>
  <function_decl><type><name>String</name></type> <name>GetImage</name><parameter_list>()</parameter_list>;</function_decl>

  <comment type="block" format="javadoc">/**
   * Returns an array of characters that make up the suffix of length 'len' for
   * the currently matched token. This is used to build up the matched string
   * for use in actions in the case of MORE. A simple and inefficient
   * implementation of this is as follows :
   *
   *   {
   *      String t = GetImage();
   *      return t.substring(t.length() - len, t.length()).toCharArray();
   *   }
   */</comment>
  <function_decl><type><name><name>char</name><index>[]</index></name></type> <name>GetSuffix</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>;</function_decl>

  <comment type="block" format="javadoc">/**
   * The lexer calls this function to indicate that it is done with the stream
   * and hence implementations can free any resources held by this class.
   * Again, the body of this function can be just empty and it will not
   * affect the lexer's operation.
   */</comment>
  <function_decl><type><name>void</name></type> <name>Done</name><parameter_list>()</parameter_list>;</function_decl>

}</block></interface>
<comment type="block">/* JavaCC - OriginalChecksum=48b70e7c01825c8f301c7362bf1028d8 (do not edit this line) */</comment>
<expr_stmt><expr><name>diff</name> <operator>--</operator><name>git</name> <name>a</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>parser</name><operator>/</operator><name><name>FastCharStream</name><operator>.</operator><name>java</name></name> <name>b</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>parser</name><operator>/</operator><name><name>FastCharStream</name><operator>.</operator><name>java</name></name>
<operator>new</operator> <name>file</name> <name>mode</name> <literal type="number">100644</literal>
<name>index</name> <literal type="number">00000000000..38b3a7898cc</literal>
<operator>--</operator> <operator>/</operator><name>dev</name><operator>/</operator><literal type="null">null</literal>
<operator>++</operator> <name>b</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>parser</name><operator>/</operator><name><name>FastCharStream</name><operator>.</operator><name>java</name></name>
@@ <operator>-</operator><literal type="number">0</literal></expr><operator>,</operator><expr><literal type="number">0</literal> <operator>+</operator><literal type="number">1</literal></expr><operator>,</operator><expr><literal type="number">123</literal> @@</expr></expr_stmt>
<comment type="line">// FastCharStream.java</comment>
<package>package <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>parser</name></name>;</package>

<comment type="block">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *  
 */</comment>

<import>import <name><name>java</name><operator>.</operator><name>io</name><operator>.</operator><name>*</name></name>;</import>

<comment type="block" format="javadoc">/** An efficient implementation of JavaCC's CharStream interface.  &lt;p&gt;Note that
 * this does not do line-number counting, but instead keeps track of the
 * character position of the token in the input, as required by Lucene's {@link
 * org.apache.lucene.analysis.Token} API. 
 * */</comment>
<class><specifier>public</specifier> <specifier>final</specifier> class <name>FastCharStream</name> <super_list><implements>implements <super><name>CharStream</name></super></implements></super_list> <block>{
  <decl_stmt><decl><type><name><name>char</name><index>[]</index></name></type> <name>buffer</name> <init>= <expr><literal type="null">null</literal></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>int</name></type> <name>bufferLength</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>          <comment type="line">// end of valid chars</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>bufferPosition</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>        <comment type="line">// next char to read</comment>

  <decl_stmt><decl><type><name>int</name></type> <name>tokenStart</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>          <comment type="line">// offset in buffer</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>bufferStart</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>          <comment type="line">// position in file of buffer</comment>

  <decl_stmt><decl><type><name>Reader</name></type> <name>input</name></decl>;</decl_stmt>            <comment type="line">// source of chars</comment>

  <comment type="block" format="javadoc">/** Constructs from a Reader. */</comment>
  <constructor><specifier>public</specifier> <name>FastCharStream</name><parameter_list>(<parameter><decl><type><name>Reader</name></type> <name>r</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><name>input</name> <operator>=</operator> <name>r</name></expr>;</expr_stmt>
  </block_content>}</block></constructor>

  <function><type><specifier>public</specifier> <specifier>final</specifier> <name>char</name></type> <name>readChar</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>bufferPosition</name> <operator>&gt;=</operator> <name>bufferLength</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>refill</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><name><name>buffer</name><index>[<expr><name>bufferPosition</name><operator>++</operator></expr>]</index></name></expr>;</return>
  </block_content>}</block></function>

  <function><type><specifier>private</specifier> <specifier>final</specifier> <name>void</name></type> <name>refill</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>newPosition</name> <init>= <expr><name>bufferLength</name> <operator>-</operator> <name>tokenStart</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>tokenStart</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>        <comment type="line">// token won't fit in buffer</comment>
      <if_stmt><if>if <condition>(<expr><name>buffer</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>        <comment type="line">// first time: alloc buffer</comment>
  <expr_stmt><expr><name>buffer</name> <operator>=</operator> <operator>new</operator> <name><name>char</name><index>[<expr><literal type="number">2048</literal></expr>]</index></name></expr>;</expr_stmt>
      </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>bufferLength</name> <operator>==</operator> <name><name>buffer</name><operator>.</operator><name>length</name></name></expr>)</condition> <block>{<block_content> <comment type="line">// grow buffer</comment>
  <decl_stmt><decl><type><name><name>char</name><index>[]</index></name></type> <name>newBuffer</name> <init>= <expr><operator>new</operator> <name><name>char</name><index>[<expr><name><name>buffer</name><operator>.</operator><name>length</name></name><operator>*</operator><literal type="number">2</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name><name>System</name><operator>.</operator><name>arraycopy</name></name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>newBuffer</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>bufferLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>buffer</name> <operator>=</operator> <name>newBuffer</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>            <comment type="line">// shift token to front</comment>
      <expr_stmt><expr><call><name><name>System</name><operator>.</operator><name>arraycopy</name></name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>tokenStart</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>newPosition</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><name>bufferLength</name> <operator>=</operator> <name>newPosition</name></expr>;</expr_stmt>        <comment type="line">// update state</comment>
    <expr_stmt><expr><name>bufferPosition</name> <operator>=</operator> <name>newPosition</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>bufferStart</name> <operator>+=</operator> <name>tokenStart</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>tokenStart</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>int</name></type> <name>charsRead</name> <init>=          <comment type="line">// fill space in buffer</comment>
      <expr><call><name><name>input</name><operator>.</operator><name>read</name></name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>newPosition</name></expr></argument>, <argument><expr><name><name>buffer</name><operator>.</operator><name>length</name></name><operator>-</operator><name>newPosition</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>charsRead</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
      <throw>throw <expr><operator>new</operator> <call><name>IOException</name><argument_list>(<argument><expr><literal type="string">"read past eof"</literal></expr></argument>)</argument_list></call></expr>;</throw></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
      <expr_stmt><expr><name>bufferLength</name> <operator>+=</operator> <name>charsRead</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
  </block_content>}</block></function>

  <function><type><specifier>public</specifier> <specifier>final</specifier> <name>char</name></type> <name>BeginToken</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws> <block>{<block_content>
    <expr_stmt><expr><name>tokenStart</name> <operator>=</operator> <name>bufferPosition</name></expr>;</expr_stmt>
    <return>return <expr><call><name>readChar</name><argument_list>()</argument_list></call></expr>;</return>
  </block_content>}</block></function>

  <function><type><specifier>public</specifier> <specifier>final</specifier> <name>void</name></type> <name>backup</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>amount</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><name>bufferPosition</name> <operator>-=</operator> <name>amount</name></expr>;</expr_stmt>
  </block_content>}</block></function>

  <function><type><specifier>public</specifier> <specifier>final</specifier> <name>String</name></type> <name>GetImage</name><parameter_list>()</parameter_list> <block>{<block_content>
    <return>return <expr><operator>new</operator> <call><name>String</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>tokenStart</name></expr></argument>, <argument><expr><name>bufferPosition</name> <operator>-</operator> <name>tokenStart</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></function>

  <function><type><specifier>public</specifier> <specifier>final</specifier> <name><name>char</name><index>[]</index></name></type> <name>GetSuffix</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name><name>char</name><index>[]</index></name></type> <name>value</name> <init>= <expr><operator>new</operator> <name><name>char</name><index>[<expr><name>len</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>System</name><operator>.</operator><name>arraycopy</name></name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>bufferPosition</name> <operator>-</operator> <name>len</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>value</name></expr>;</return>
  </block_content>}</block></function>

  <function><type><specifier>public</specifier> <specifier>final</specifier> <name>void</name></type> <name>Done</name><parameter_list>()</parameter_list> <block>{<block_content>
    <try>try <block>{<block_content>
      <expr_stmt><expr><call><name><name>input</name><operator>.</operator><name>close</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block> <catch>catch <parameter_list>(<parameter><decl><type><name>IOException</name></type> <name>e</name></decl></parameter>)</parameter_list> <block>{<block_content>
    </block_content>}</block></catch></try>
  </block_content>}</block></function>

  <function><type><specifier>public</specifier> <specifier>final</specifier> <name>int</name></type> <name>getColumn</name><parameter_list>()</parameter_list> <block>{<block_content>
    <return>return <expr><name>bufferStart</name> <operator>+</operator> <name>bufferPosition</name></expr>;</return>
  </block_content>}</block></function>
  <function><type><specifier>public</specifier> <specifier>final</specifier> <name>int</name></type> <name>getLine</name><parameter_list>()</parameter_list> <block>{<block_content>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></function>
  <function><type><specifier>public</specifier> <specifier>final</specifier> <name>int</name></type> <name>getEndColumn</name><parameter_list>()</parameter_list> <block>{<block_content>
    <return>return <expr><name>bufferStart</name> <operator>+</operator> <name>bufferPosition</name></expr>;</return>
  </block_content>}</block></function>
  <function><type><specifier>public</specifier> <specifier>final</specifier> <name>int</name></type> <name>getEndLine</name><parameter_list>()</parameter_list> <block>{<block_content>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></function>
  <function><type><specifier>public</specifier> <specifier>final</specifier> <name>int</name></type> <name>getBeginColumn</name><parameter_list>()</parameter_list> <block>{<block_content>
    <return>return <expr><name>bufferStart</name> <operator>+</operator> <name>tokenStart</name></expr>;</return>
  </block_content>}</block></function>
  <function><type><specifier>public</specifier> <specifier>final</specifier> <name>int</name></type> <name>getBeginLine</name><parameter_list>()</parameter_list> <block>{<block_content>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></function>
}</block></class>
<expr_stmt><expr><name>diff</name> <operator>--</operator><name>git</name> <name>a</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>parser</name><operator>/</operator><name><name>ParseException</name><operator>.</operator><name>java</name></name> <name>b</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>parser</name><operator>/</operator><name><name>ParseException</name><operator>.</operator><name>java</name></name>
<operator>new</operator> <name>file</name> <name>mode</name> <literal type="number">100644</literal>
<name>index</name> <literal type="number">00000000000..df1910443bc</literal>
<operator>--</operator> <operator>/</operator><name>dev</name><operator>/</operator><literal type="null">null</literal>
<operator>++</operator> <name>b</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>parser</name><operator>/</operator><name><name>ParseException</name><operator>.</operator><name>java</name></name>
@@ <operator>-</operator><literal type="number">0</literal></expr><operator>,</operator><expr><literal type="number">0</literal> <operator>+</operator><literal type="number">1</literal></expr><operator>,</operator><expr><literal type="number">187</literal> @@</expr></expr_stmt>
<comment type="block">/* Generated By:JavaCC: Do not edit this line. ParseException.java Version 5.0 */</comment>
<comment type="block">/* JavaCCOptions:KEEP_LINE_COL=null */</comment>
<package>package <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>parser</name></name>;</package>

<comment type="block" format="javadoc">/**
 * This exception is thrown when parse errors are encountered.
 * You can explicitly create objects of this exception type by
 * calling the method generateParseException in the generated
 * parser.
 *
 * You can modify this class to customize your error reporting
 * mechanisms so long as you retain the public fields.
 */</comment>
<class><specifier>public</specifier> class <name>ParseException</name> <super_list><extends>extends <super><name>Exception</name></super></extends></super_list> <block>{

  <comment type="block" format="javadoc">/**
   * The version identifier for this Serializable class.
   * Increment only if the &lt;i&gt;serialized&lt;/i&gt; form of the
   * class changes.
   */</comment>
  <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>long</name></type> <name>serialVersionUID</name> <init>= <expr><literal type="number">1L</literal></expr></init></decl>;</decl_stmt>

  <comment type="block" format="javadoc">/**
   * This constructor is used by the method "generateParseException"
   * in the generated parser.  Calling this constructor generates
   * a new object of this type with the fields "currentToken",
   * "expectedTokenSequences", and "tokenImage" set.
   */</comment>
  <constructor><specifier>public</specifier> <name>ParseException</name><parameter_list>(<parameter><decl><type><name>Token</name></type> <name>currentTokenVal</name></decl></parameter>,
                        <parameter><decl><type><name><name>int</name><index>[]</index><index>[]</index></name></type> <name>expectedTokenSequencesVal</name></decl></parameter>,
                        <parameter><decl><type><name><name>String</name><index>[]</index></name></type> <name>tokenImageVal</name></decl></parameter>
                       )</parameter_list>
  <block>{<block_content>
    <expr_stmt><expr><call><name>super</name><argument_list>(<argument><expr><call><name>initialise</name><argument_list>(<argument><expr><name>currentTokenVal</name></expr></argument>, <argument><expr><name>expectedTokenSequencesVal</name></expr></argument>, <argument><expr><name>tokenImageVal</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>currentToken</name> <operator>=</operator> <name>currentTokenVal</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>expectedTokenSequences</name> <operator>=</operator> <name>expectedTokenSequencesVal</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>tokenImage</name> <operator>=</operator> <name>tokenImageVal</name></expr>;</expr_stmt>
  </block_content>}</block></constructor>

  <comment type="block" format="javadoc">/**
   * The following constructors are for use by you for whatever
   * purpose you can think of.  Constructing the exception in this
   * manner makes the exception behave in the normal way - i.e., as
   * documented in the class "Throwable".  The fields "errorToken",
   * "expectedTokenSequences", and "tokenImage" do not contain
   * relevant information.  The JavaCC generated code does not use
   * these constructors.
   */</comment>

  <constructor><specifier>public</specifier> <name>ParseException</name><parameter_list>()</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>super</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></constructor>

  <comment type="block" format="javadoc">/** Constructor with message. */</comment>
  <constructor><specifier>public</specifier> <name>ParseException</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>message</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>super</name><argument_list>(<argument><expr><name>message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></constructor>


  <comment type="block" format="javadoc">/**
   * This is the last token that has been consumed successfully.  If
   * this object has been created due to a parse error, the token
   * followng this token will (therefore) be the first error token.
   */</comment>
  <decl_stmt><decl><type><specifier>public</specifier> <name>Token</name></type> <name>currentToken</name></decl>;</decl_stmt>

  <comment type="block" format="javadoc">/**
   * Each entry in this array is an array of integers.  Each array
   * of integers represents a sequence of tokens (by their ordinal
   * values) that is expected at this point of the parse.
   */</comment>
  <decl_stmt><decl><type><specifier>public</specifier> <name><name>int</name><index>[]</index><index>[]</index></name></type> <name>expectedTokenSequences</name></decl>;</decl_stmt>

  <comment type="block" format="javadoc">/**
   * This is a reference to the "tokenImage" array of the generated
   * parser within which the parse error occurred.  This array is
   * defined in the generated ...Constants interface.
   */</comment>
  <decl_stmt><decl><type><specifier>public</specifier> <name><name>String</name><index>[]</index></name></type> <name>tokenImage</name></decl>;</decl_stmt>

  <comment type="block" format="javadoc">/**
   * It uses "currentToken" and "expectedTokenSequences" to generate a parse
   * error message and returns it.  If this object has been created
   * due to a parse error, and you do not catch it (it gets thrown
   * from the parser) the correct error message
   * gets displayed.
   */</comment>
  <function><type><specifier>private</specifier> <specifier>static</specifier> <name>String</name></type> <name>initialise</name><parameter_list>(<parameter><decl><type><name>Token</name></type> <name>currentToken</name></decl></parameter>,
                           <parameter><decl><type><name><name>int</name><index>[]</index><index>[]</index></name></type> <name>expectedTokenSequences</name></decl></parameter>,
                           <parameter><decl><type><name><name>String</name><index>[]</index></name></type> <name>tokenImage</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>String</name></type> <name>eol</name> <init>= <expr><call><name><name>System</name><operator>.</operator><name>getProperty</name></name><argument_list>(<argument><expr><literal type="string">"line.separator"</literal></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>StringBuffer</name></type> <name>expected</name> <init>= <expr><operator>new</operator> <call><name>StringBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>maxSize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>expectedTokenSequences</name><operator>.</operator><name>length</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>maxSize</name> <operator>&lt;</operator> <name><name>expectedTokenSequences</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>length</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>maxSize</name> <operator>=</operator> <name><name>expectedTokenSequences</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>length</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>expectedTokenSequences</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>length</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <expr_stmt><expr><call><name><name>expected</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name><name>tokenImage</name><index>[<expr><name><name>expectedTokenSequences</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>j</name></expr>]</index></name></expr>]</index></name></expr></argument>)</argument_list></call><operator>.</operator><call><name>append</name><argument_list>(<argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
      <if_stmt><if>if <condition>(<expr><name><name>expectedTokenSequences</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name><name>expectedTokenSequences</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>length</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name><name>expected</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><literal type="string">"..."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name><name>expected</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>eol</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>append</name><argument_list>(<argument><expr><literal type="string">"    "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <decl_stmt><decl><type><name>String</name></type> <name>retval</name> <init>= <expr><literal type="string">"Encountered \""</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Token</name></type> <name>tok</name> <init>= <expr><name><name>currentToken</name><operator>.</operator><name>next</name></name></expr></init></decl>;</decl_stmt>
    <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>maxSize</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>i</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>retval</name> <operator>+=</operator> <literal type="string">" "</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><name><name>tok</name><operator>.</operator><name>kind</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>retval</name> <operator>+=</operator> <name><name>tokenImage</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>retval</name> <operator>+=</operator> <literal type="string">" "</literal> <operator>+</operator> <name><name>tokenImage</name><index>[<expr><name><name>tok</name><operator>.</operator><name>kind</name></name></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>retval</name> <operator>+=</operator> <literal type="string">" \""</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>retval</name> <operator>+=</operator> <call><name>add_escapes</name><argument_list>(<argument><expr><name><name>tok</name><operator>.</operator><name>image</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>retval</name> <operator>+=</operator> <literal type="string">" \""</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>tok</name> <operator>=</operator> <name><name>tok</name><operator>.</operator><name>next</name></name></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><name>retval</name> <operator>+=</operator> <literal type="string">"\" at line "</literal> <operator>+</operator> <name><name>currentToken</name><operator>.</operator><name>next</name><operator>.</operator><name>beginLine</name></name> <operator>+</operator> <literal type="string">", column "</literal> <operator>+</operator> <name><name>currentToken</name><operator>.</operator><name>next</name><operator>.</operator><name>beginColumn</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>retval</name> <operator>+=</operator> <literal type="string">"."</literal> <operator>+</operator> <name>eol</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>expectedTokenSequences</name><operator>.</operator><name>length</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>retval</name> <operator>+=</operator> <literal type="string">"Was expecting:"</literal> <operator>+</operator> <name>eol</name> <operator>+</operator> <literal type="string">"    "</literal></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><name>retval</name> <operator>+=</operator> <literal type="string">"Was expecting one of:"</literal> <operator>+</operator> <name>eol</name> <operator>+</operator> <literal type="string">"    "</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name>retval</name> <operator>+=</operator> <call><name><name>expected</name><operator>.</operator><name>toString</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>retval</name></expr>;</return>
  </block_content>}</block></function>

  <comment type="block" format="javadoc">/**
   * The end of line string for this machine.
   */</comment>
  <decl_stmt><decl><type><specifier>protected</specifier> <name>String</name></type> <name>eol</name> <init>= <expr><call><name><name>System</name><operator>.</operator><name>getProperty</name></name><argument_list>(<argument><expr><literal type="string">"line.separator"</literal></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <comment type="block" format="javadoc">/**
   * Used to convert raw characters to their escaped version
   * when these raw version cannot be used as part of an ASCII
   * string literal.
   */</comment>
  <function><type><specifier>static</specifier> <name>String</name></type> <name>add_escapes</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>str</name></decl></parameter>)</parameter_list> <block>{<block_content>
      <decl_stmt><decl><type><name>StringBuffer</name></type> <name>retval</name> <init>= <expr><operator>new</operator> <call><name>StringBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>char</name></type> <name>ch</name></decl>;</decl_stmt>
      <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name><name>str</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <switch>switch <condition>(<expr><call><name><name>str</name><operator>.</operator><name>charAt</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
           <case>case <expr><literal type="number">0</literal></expr> :</case>
              <continue>continue;</continue>
           <case>case <expr><literal type="char">'\b'</literal></expr>:</case>
              <expr_stmt><expr><call><name><name>retval</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><literal type="string">"\\b"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <continue>continue;</continue>
           <case>case <expr><literal type="char">'\t'</literal></expr>:</case>
              <expr_stmt><expr><call><name><name>retval</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><literal type="string">"\\t"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <continue>continue;</continue>
           <case>case <expr><literal type="char">'\n'</literal></expr>:</case>
              <expr_stmt><expr><call><name><name>retval</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><literal type="string">"\\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <continue>continue;</continue>
           <case>case <expr><literal type="char">'\f'</literal></expr>:</case>
              <expr_stmt><expr><call><name><name>retval</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><literal type="string">"\\f"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <continue>continue;</continue>
           <case>case <expr><literal type="char">'\r'</literal></expr>:</case>
              <expr_stmt><expr><call><name><name>retval</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><literal type="string">"\\r"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <continue>continue;</continue>
           <case>case <expr><literal type="char">'\"'</literal></expr>:</case>
              <expr_stmt><expr><call><name><name>retval</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><literal type="string">"\\\""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <continue>continue;</continue>
           <case>case <expr><literal type="char">'\''</literal></expr>:</case>
              <expr_stmt><expr><call><name><name>retval</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><literal type="string">"\\\'"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <continue>continue;</continue>
           <case>case <expr><literal type="char">'\\'</literal></expr>:</case>
              <expr_stmt><expr><call><name><name>retval</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><literal type="string">"\\\\"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <continue>continue;</continue>
           <default>default:</default>
              <if_stmt><if>if <condition>(<expr><operator>(</operator><name>ch</name> <operator>=</operator> <call><name><name>str</name><operator>.</operator><name>charAt</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0x20</literal> <operator>||</operator> <name>ch</name> <operator>&gt;</operator> <literal type="number">0x7e</literal></expr>)</condition> <block>{<block_content>
                 <decl_stmt><decl><type><name>String</name></type> <name>s</name> <init>= <expr><literal type="string">"0000"</literal> <operator>+</operator> <call><name><name>Integer</name><operator>.</operator><name>toString</name></name><argument_list>(<argument><expr><name>ch</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                 <expr_stmt><expr><call><name><name>retval</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><literal type="string">"\\u"</literal> <operator>+</operator> <call><name><name>s</name><operator>.</operator><name>substring</name></name><argument_list>(<argument><expr><call><name><name>s</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call> <operator>-</operator> <literal type="number">4</literal></expr></argument>, <argument><expr><call><name><name>s</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              </block_content>}</block></if> <else>else <block>{<block_content>
                 <expr_stmt><expr><call><name><name>retval</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              </block_content>}</block></else></if_stmt>
              <continue>continue;</continue>
        </block_content>}</block></switch>
      </block_content>}</block></for>
      <return>return <expr><call><name><name>retval</name><operator>.</operator><name>toString</name></name><argument_list>()</argument_list></call></expr>;</return>
   </block_content>}</block></function>

}</block></class>
<comment type="block">/* JavaCC - OriginalChecksum=25e1ae9ad9614c4ce31c4b83f8a7397b (do not edit this line) */</comment>
<expr_stmt><expr><name>diff</name> <operator>--</operator><name>git</name> <name>a</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>parser</name><operator>/</operator><name><name>QueryParser</name><operator>.</operator><name>java</name></name> <name>b</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>parser</name><operator>/</operator><name><name>QueryParser</name><operator>.</operator><name>java</name></name>
<operator>new</operator> <name>file</name> <name>mode</name> <literal type="number">100644</literal>
<name>index</name> <literal type="number">00000000000..7e7b95da157</literal>
<operator>--</operator> <operator>/</operator><name>dev</name><operator>/</operator><literal type="null">null</literal>
<operator>++</operator> <name>b</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>parser</name><operator>/</operator><name><name>QueryParser</name><operator>.</operator><name>java</name></name>
@@ <operator>-</operator><literal type="number">0</literal></expr><operator>,</operator><expr><literal type="number">0</literal> <operator>+</operator><literal type="number">1</literal></expr><operator>,</operator><expr><literal type="number">701</literal> @@</expr></expr_stmt>
<comment type="block">/* Generated By:JavaCC: Do not edit this line. QueryParser.java */</comment>
<package>package <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>parser</name></name>;</package>

<import>import <name><name>java</name><operator>.</operator><name>io</name><operator>.</operator><name>StringReader</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>ArrayList</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>List</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>Locale</name></name>;</import>

<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>analysis</name><operator>.</operator><name>Analyzer</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>document</name><operator>.</operator><name>DateTools</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>search</name><operator>.</operator><name>BooleanClause</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>search</name><operator>.</operator><name>Query</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>search</name><operator>.</operator><name>TermRangeQuery</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>search</name><operator>.</operator><name>TermQuery</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>util</name><operator>.</operator><name>Version</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>search</name><operator>.</operator><name>SyntaxError</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>search</name><operator>.</operator><name>QParser</name></name>;</import>


<class><specifier>public</specifier> class <name>QueryParser</name> <super_list><extends>extends <super><name>SolrQueryParserBase</name></super></extends> <implements>implements <super><name>QueryParserConstants</name></super></implements></super_list> <block>{
  <comment type="block" format="javadoc">/** The default operator for parsing queries.
   * Use {@link QueryParserBase#setDefaultOperator} to change it.
   */</comment>
  <enum><specifier>static</specifier> <specifier>public</specifier> enum <name>Operator</name> <block>{ <decl><name>OR</name></decl>, <decl><name>AND</name></decl> }</block></enum>

  <comment type="block" format="javadoc">/** Create a query parser.
   *  @param matchVersion  Lucene version to match. See &lt;a href="#version"&gt;above&lt;/a&gt;.
   *  @param defaultField  the default field for query terms.
   *  @param a   used to find terms in the query text.
   */</comment>
   <constructor><specifier>public</specifier> <name>QueryParser</name><parameter_list>(<parameter><decl><type><name>Version</name></type> <name>matchVersion</name></decl></parameter>, <parameter><decl><type><name>String</name></type> <name>defaultField</name></decl></parameter>, <parameter><decl><type><name>QParser</name></type> <name>parser</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>this</name><argument_list>(<argument><expr><operator>new</operator> <call><name>FastCharStream</name><argument_list>(<argument><expr><operator>new</operator> <call><name>StringReader</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>init</name><argument_list>(<argument><expr><name>matchVersion</name></expr></argument>, <argument><expr><name>defaultField</name></expr></argument>, <argument><expr><name>parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></constructor>

<comment type="line">// *   Query  ::= ( Clause )*</comment>
<comment type="line">// *   Clause ::= ["+", "-"] [&lt;TERM&gt; ":"] ( &lt;TERM&gt; | "(" Query ")" )</comment>
  <function><type><specifier>final</specifier> <specifier>public</specifier> <name>int</name></type> <name>Conjunction</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>ParseException</name></expr></argument></throws> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><name>CONJ_NONE</name></expr></init></decl>;</decl_stmt>
    <switch>switch <condition>(<expr><ternary><condition><expr><operator>(</operator><name>jj_ntk</name><operator>==</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>?</condition><then><expr><call><name>jj_ntk</name><argument_list>()</argument_list></call></expr></then><else>:<expr><name>jj_ntk</name></expr></else></ternary></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>AND</name></expr>:</case>
    <case>case <expr><name>OR</name></expr>:</case>
      <switch>switch <condition>(<expr><ternary><condition><expr><operator>(</operator><name>jj_ntk</name><operator>==</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>?</condition><then><expr><call><name>jj_ntk</name><argument_list>()</argument_list></call></expr></then><else>:<expr><name>jj_ntk</name></expr></else></ternary></expr>)</condition> <block>{<block_content>
      <case>case <expr><name>AND</name></expr>:</case>
        <expr_stmt><expr><call><name>jj_consume_token</name><argument_list>(<argument><expr><name>AND</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>ret</name> <operator>=</operator> <name>CONJ_AND</name></expr>;</expr_stmt>
        <break>break;</break>
      <case>case <expr><name>OR</name></expr>:</case>
        <expr_stmt><expr><call><name>jj_consume_token</name><argument_list>(<argument><expr><name>OR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><name>ret</name> <operator>=</operator> <name>CONJ_OR</name></expr>;</expr_stmt>
        <break>break;</break>
      <default>default:</default>
        <expr_stmt><expr><name><name>jj_la1</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>jj_gen</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>jj_consume_token</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <throw>throw <expr><operator>new</operator> <call><name>ParseException</name><argument_list>()</argument_list></call></expr>;</throw>
      </block_content>}</block></switch>
      <break>break;</break>
    <default>default:</default>
      <expr_stmt><expr><name><name>jj_la1</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>jj_gen</name></expr>;</expr_stmt>
      <empty_stmt>;</empty_stmt>
    </block_content>}</block></switch>
    <block>{<block_content><if_stmt><if>if <condition>(<expr><literal type="boolean">true</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt></block_content>}</block>
    <throw>throw <expr><operator>new</operator> <call><name>Error</name><argument_list>(<argument><expr><literal type="string">"Missing return statement in function"</literal></expr></argument>)</argument_list></call></expr>;</throw>
  </block_content>}</block></function>

  <function><type><specifier>final</specifier> <specifier>public</specifier> <name>int</name></type> <name>Modifiers</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>ParseException</name></expr></argument></throws> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><name>MOD_NONE</name></expr></init></decl>;</decl_stmt>
    <switch>switch <condition>(<expr><ternary><condition><expr><operator>(</operator><name>jj_ntk</name><operator>==</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>?</condition><then><expr><call><name>jj_ntk</name><argument_list>()</argument_list></call></expr></then><else>:<expr><name>jj_ntk</name></expr></else></ternary></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>NOT</name></expr>:</case>
    <case>case <expr><name>PLUS</name></expr>:</case>
    <case>case <expr><name>MINUS</name></expr>:</case>
      <switch>switch <condition>(<expr><ternary><condition><expr><operator>(</operator><name>jj_ntk</name><operator>==</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>?</condition><then><expr><call><name>jj_ntk</name><argument_list>()</argument_list></call></expr></then><else>:<expr><name>jj_ntk</name></expr></else></ternary></expr>)</condition> <block>{<block_content>
      <case>case <expr><name>PLUS</name></expr>:</case>
        <expr_stmt><expr><call><name>jj_consume_token</name><argument_list>(<argument><expr><name>PLUS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><name>ret</name> <operator>=</operator> <name>MOD_REQ</name></expr>;</expr_stmt>
        <break>break;</break>
      <case>case <expr><name>MINUS</name></expr>:</case>
        <expr_stmt><expr><call><name>jj_consume_token</name><argument_list>(<argument><expr><name>MINUS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                 <expr_stmt><expr><name>ret</name> <operator>=</operator> <name>MOD_NOT</name></expr>;</expr_stmt>
        <break>break;</break>
      <case>case <expr><name>NOT</name></expr>:</case>
        <expr_stmt><expr><call><name>jj_consume_token</name><argument_list>(<argument><expr><name>NOT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
               <expr_stmt><expr><name>ret</name> <operator>=</operator> <name>MOD_NOT</name></expr>;</expr_stmt>
        <break>break;</break>
      <default>default:</default>
        <expr_stmt><expr><name><name>jj_la1</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>jj_gen</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>jj_consume_token</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <throw>throw <expr><operator>new</operator> <call><name>ParseException</name><argument_list>()</argument_list></call></expr>;</throw>
      </block_content>}</block></switch>
      <break>break;</break>
    <default>default:</default>
      <expr_stmt><expr><name><name>jj_la1</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name>jj_gen</name></expr>;</expr_stmt>
      <empty_stmt>;</empty_stmt>
    </block_content>}</block></switch>
    <block>{<block_content><if_stmt><if>if <condition>(<expr><literal type="boolean">true</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt></block_content>}</block>
    <throw>throw <expr><operator>new</operator> <call><name>Error</name><argument_list>(<argument><expr><literal type="string">"Missing return statement in function"</literal></expr></argument>)</argument_list></call></expr>;</throw>
  </block_content>}</block></function>

<comment type="line">// This makes sure that there is no garbage after the query string</comment>
  <function><type><specifier>final</specifier> <specifier>public</specifier> <name>Query</name></type> <name>TopLevelQuery</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>field</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>ParseException</name></expr></argument>, <argument><expr><name>SyntaxError</name></expr></argument></throws> <block>{<block_content>
  <decl_stmt><decl><type><name>Query</name></type> <name>q</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>q</name> <operator>=</operator> <call><name>Query</name><argument_list>(<argument><expr><name>field</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>jj_consume_token</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <block>{<block_content><if_stmt><if>if <condition>(<expr><literal type="boolean">true</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>q</name></expr>;</return></block_content></block></if></if_stmt></block_content>}</block>
    <throw>throw <expr><operator>new</operator> <call><name>Error</name><argument_list>(<argument><expr><literal type="string">"Missing return statement in function"</literal></expr></argument>)</argument_list></call></expr>;</throw>
  </block_content>}</block></function>

  <function><type><specifier>final</specifier> <specifier>public</specifier> <name>Query</name></type> <name>Query</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>field</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>ParseException</name></expr></argument>, <argument><expr><name>SyntaxError</name></expr></argument></throws> <block>{<block_content>
  <decl_stmt><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name>BooleanClause</name></argument>&gt;</argument_list></name></type> <name>clauses</name> <init>= <expr><operator>new</operator> <call><name><name>ArrayList</name><argument_list type="generic">&lt;<argument><name>BooleanClause</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Query</name></type> <name>q</name></decl>, <decl><type ref="prev"/><name>firstQuery</name><init>=<expr><literal type="null">null</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>conj</name></decl>, <decl><type ref="prev"/><name>mods</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>mods</name> <operator>=</operator> <call><name>Modifiers</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>q</name> <operator>=</operator> <call><name>Clause</name><argument_list>(<argument><expr><name>field</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>addClause</name><argument_list>(<argument><expr><name>clauses</name></expr></argument>, <argument><expr><name>CONJ_NONE</name></expr></argument>, <argument><expr><name>mods</name></expr></argument>, <argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>mods</name> <operator>==</operator> <name>MOD_NONE</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>firstQuery</name><operator>=</operator><name>q</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <label><name>label_1</name>:</label>
    <while>while <condition>(<expr><literal type="boolean">true</literal></expr>)</condition> <block>{<block_content>
      <switch>switch <condition>(<expr><ternary><condition><expr><operator>(</operator><name>jj_ntk</name><operator>==</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>?</condition><then><expr><call><name>jj_ntk</name><argument_list>()</argument_list></call></expr></then><else>:<expr><name>jj_ntk</name></expr></else></ternary></expr>)</condition> <block>{<block_content>
      <case>case <expr><name>AND</name></expr>:</case>
      <case>case <expr><name>OR</name></expr>:</case>
      <case>case <expr><name>NOT</name></expr>:</case>
      <case>case <expr><name>PLUS</name></expr>:</case>
      <case>case <expr><name>MINUS</name></expr>:</case>
      <case>case <expr><name>BAREOPER</name></expr>:</case>
      <case>case <expr><name>LPAREN</name></expr>:</case>
      <case>case <expr><name>STAR</name></expr>:</case>
      <case>case <expr><name>QUOTED</name></expr>:</case>
      <case>case <expr><name>TERM</name></expr>:</case>
      <case>case <expr><name>PREFIXTERM</name></expr>:</case>
      <case>case <expr><name>WILDTERM</name></expr>:</case>
      <case>case <expr><name>REGEXPTERM</name></expr>:</case>
      <case>case <expr><name>RANGEIN_START</name></expr>:</case>
      <case>case <expr><name>RANGEEX_START</name></expr>:</case>
      <case>case <expr><name>LPARAMS</name></expr>:</case>
      <case>case <expr><name>NUMBER</name></expr>:</case>
        <empty_stmt>;</empty_stmt>
        <break>break;</break>
      <default>default:</default>
        <expr_stmt><expr><name><name>jj_la1</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <name>jj_gen</name></expr>;</expr_stmt>
        <break>break <name>label_1</name>;</break>
      </block_content>}</block></switch>
      <expr_stmt><expr><name>conj</name> <operator>=</operator> <call><name>Conjunction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>mods</name> <operator>=</operator> <call><name>Modifiers</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>q</name> <operator>=</operator> <call><name>Clause</name><argument_list>(<argument><expr><name>field</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>addClause</name><argument_list>(<argument><expr><name>clauses</name></expr></argument>, <argument><expr><name>conj</name></expr></argument>, <argument><expr><name>mods</name></expr></argument>, <argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
      <if_stmt><if>if <condition>(<expr><call><name><name>clauses</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>firstQuery</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition>
        <block>{<block_content><if_stmt><if>if <condition>(<expr><literal type="boolean">true</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>firstQuery</name></expr>;</return></block_content></block></if></if_stmt></block_content>}</block></if>
      <else>else <block>{<block_content>
  <block>{<block_content><if_stmt><if>if <condition>(<expr><literal type="boolean">true</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>getBooleanQuery</name><argument_list>(<argument><expr><name>clauses</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block_content>}</block>
      </block_content>}</block></else></if_stmt>
    <throw>throw <expr><operator>new</operator> <call><name>Error</name><argument_list>(<argument><expr><literal type="string">"Missing return statement in function"</literal></expr></argument>)</argument_list></call></expr>;</throw>
  </block_content>}</block></function>

  <function><type><specifier>final</specifier> <specifier>public</specifier> <name>Query</name></type> <name>Clause</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>field</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>ParseException</name></expr></argument>, <argument><expr><name>SyntaxError</name></expr></argument></throws> <block>{<block_content>
  <decl_stmt><decl><type><name>Query</name></type> <name>q</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Token</name></type> <name>fieldToken</name><init>=<expr><literal type="null">null</literal></expr></init></decl>, <decl><type ref="prev"/><name>boost</name><init>=<expr><literal type="null">null</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Token</name></type> <name>localParams</name><init>=<expr><literal type="null">null</literal></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>jj_2_1</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <switch>switch <condition>(<expr><ternary><condition><expr><operator>(</operator><name>jj_ntk</name><operator>==</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>?</condition><then><expr><call><name>jj_ntk</name><argument_list>()</argument_list></call></expr></then><else>:<expr><name>jj_ntk</name></expr></else></ternary></expr>)</condition> <block>{<block_content>
      <case>case <expr><name>TERM</name></expr>:</case>
        <expr_stmt><expr><name>fieldToken</name> <operator>=</operator> <call><name>jj_consume_token</name><argument_list>(<argument><expr><name>TERM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>jj_consume_token</name><argument_list>(<argument><expr><name>COLON</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                               <expr_stmt><expr><name>field</name><operator>=</operator><call><name>discardEscapeChar</name><argument_list>(<argument><expr><name><name>fieldToken</name><operator>.</operator><name>image</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      <case>case <expr><name>STAR</name></expr>:</case>
        <expr_stmt><expr><call><name>jj_consume_token</name><argument_list>(<argument><expr><name>STAR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>jj_consume_token</name><argument_list>(<argument><expr><name>COLON</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                      <expr_stmt><expr><name>field</name><operator>=</operator><literal type="string">"*"</literal></expr>;</expr_stmt>
        <break>break;</break>
      <default>default:</default>
        <expr_stmt><expr><name><name>jj_la1</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>=</operator> <name>jj_gen</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>jj_consume_token</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <throw>throw <expr><operator>new</operator> <call><name>ParseException</name><argument_list>()</argument_list></call></expr>;</throw>
      </block_content>}</block></switch>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <empty_stmt>;</empty_stmt>
    </block_content>}</block></else></if_stmt>
    <switch>switch <condition>(<expr><ternary><condition><expr><operator>(</operator><name>jj_ntk</name><operator>==</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>?</condition><then><expr><call><name>jj_ntk</name><argument_list>()</argument_list></call></expr></then><else>:<expr><name>jj_ntk</name></expr></else></ternary></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>BAREOPER</name></expr>:</case>
    <case>case <expr><name>STAR</name></expr>:</case>
    <case>case <expr><name>QUOTED</name></expr>:</case>
    <case>case <expr><name>TERM</name></expr>:</case>
    <case>case <expr><name>PREFIXTERM</name></expr>:</case>
    <case>case <expr><name>WILDTERM</name></expr>:</case>
    <case>case <expr><name>REGEXPTERM</name></expr>:</case>
    <case>case <expr><name>RANGEIN_START</name></expr>:</case>
    <case>case <expr><name>RANGEEX_START</name></expr>:</case>
    <case>case <expr><name>NUMBER</name></expr>:</case>
      <expr_stmt><expr><name>q</name> <operator>=</operator> <call><name>Term</name><argument_list>(<argument><expr><name>field</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>LPAREN</name></expr>:</case>
      <expr_stmt><expr><call><name>jj_consume_token</name><argument_list>(<argument><expr><name>LPAREN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>q</name> <operator>=</operator> <call><name>Query</name><argument_list>(<argument><expr><name>field</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>jj_consume_token</name><argument_list>(<argument><expr><name>RPAREN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <switch>switch <condition>(<expr><ternary><condition><expr><operator>(</operator><name>jj_ntk</name><operator>==</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>?</condition><then><expr><call><name>jj_ntk</name><argument_list>()</argument_list></call></expr></then><else>:<expr><name>jj_ntk</name></expr></else></ternary></expr>)</condition> <block>{<block_content>
      <case>case <expr><name>CARAT</name></expr>:</case>
        <expr_stmt><expr><call><name>jj_consume_token</name><argument_list>(<argument><expr><name>CARAT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>boost</name> <operator>=</operator> <call><name>jj_consume_token</name><argument_list>(<argument><expr><name>NUMBER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      <default>default:</default>
        <expr_stmt><expr><name><name>jj_la1</name><index>[<expr><literal type="number">6</literal></expr>]</index></name> <operator>=</operator> <name>jj_gen</name></expr>;</expr_stmt>
        <empty_stmt>;</empty_stmt>
      </block_content>}</block></switch>
      <break>break;</break>
    <case>case <expr><name>LPARAMS</name></expr>:</case>
      <expr_stmt><expr><name>localParams</name> <operator>=</operator> <call><name>jj_consume_token</name><argument_list>(<argument><expr><name>LPARAMS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <switch>switch <condition>(<expr><ternary><condition><expr><operator>(</operator><name>jj_ntk</name><operator>==</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>?</condition><then><expr><call><name>jj_ntk</name><argument_list>()</argument_list></call></expr></then><else>:<expr><name>jj_ntk</name></expr></else></ternary></expr>)</condition> <block>{<block_content>
      <case>case <expr><name>CARAT</name></expr>:</case>
        <expr_stmt><expr><call><name>jj_consume_token</name><argument_list>(<argument><expr><name>CARAT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>boost</name> <operator>=</operator> <call><name>jj_consume_token</name><argument_list>(<argument><expr><name>NUMBER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      <default>default:</default>
        <expr_stmt><expr><name><name>jj_la1</name><index>[<expr><literal type="number">7</literal></expr>]</index></name> <operator>=</operator> <name>jj_gen</name></expr>;</expr_stmt>
        <empty_stmt>;</empty_stmt>
      </block_content>}</block></switch>
                                                          <expr_stmt><expr><name>q</name><operator>=</operator><call><name>getLocalParams</name><argument_list>(<argument><expr><name>field</name></expr></argument>, <argument><expr><name><name>localParams</name><operator>.</operator><name>image</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    <default>default:</default>
      <expr_stmt><expr><name><name>jj_la1</name><index>[<expr><literal type="number">8</literal></expr>]</index></name> <operator>=</operator> <name>jj_gen</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>jj_consume_token</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <throw>throw <expr><operator>new</operator> <call><name>ParseException</name><argument_list>()</argument_list></call></expr>;</throw>
    </block_content>}</block></switch>
       <block>{<block_content><if_stmt><if>if <condition>(<expr><literal type="boolean">true</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>handleBoost</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name>boost</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block_content>}</block>
    <throw>throw <expr><operator>new</operator> <call><name>Error</name><argument_list>(<argument><expr><literal type="string">"Missing return statement in function"</literal></expr></argument>)</argument_list></call></expr>;</throw>
  </block_content>}</block></function>

  <function><type><specifier>final</specifier> <specifier>public</specifier> <name>Query</name></type> <name>Term</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>field</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>ParseException</name></expr></argument>, <argument><expr><name>SyntaxError</name></expr></argument></throws> <block>{<block_content>
  <decl_stmt><decl><type><name>Token</name></type> <name>term</name></decl>, <decl><type ref="prev"/><name>boost</name><init>=<expr><literal type="null">null</literal></expr></init></decl>, <decl><type ref="prev"/><name>fuzzySlop</name><init>=<expr><literal type="null">null</literal></expr></init></decl>, <decl><type ref="prev"/><name>goop1</name></decl>, <decl><type ref="prev"/><name>goop2</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>boolean</name></type> <name>prefix</name> <init>= <expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>boolean</name></type> <name>wildcard</name> <init>= <expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>boolean</name></type> <name>fuzzy</name> <init>= <expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>boolean</name></type> <name>regexp</name> <init>= <expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>boolean</name></type> <name>startInc</name><init>=<expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>boolean</name></type> <name>endInc</name><init>=<expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Query</name></type> <name>q</name></decl>;</decl_stmt>
    <switch>switch <condition>(<expr><ternary><condition><expr><operator>(</operator><name>jj_ntk</name><operator>==</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>?</condition><then><expr><call><name>jj_ntk</name><argument_list>()</argument_list></call></expr></then><else>:<expr><name>jj_ntk</name></expr></else></ternary></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>BAREOPER</name></expr>:</case>
    <case>case <expr><name>STAR</name></expr>:</case>
    <case>case <expr><name>TERM</name></expr>:</case>
    <case>case <expr><name>PREFIXTERM</name></expr>:</case>
    <case>case <expr><name>WILDTERM</name></expr>:</case>
    <case>case <expr><name>REGEXPTERM</name></expr>:</case>
    <case>case <expr><name>NUMBER</name></expr>:</case>
      <switch>switch <condition>(<expr><ternary><condition><expr><operator>(</operator><name>jj_ntk</name><operator>==</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>?</condition><then><expr><call><name>jj_ntk</name><argument_list>()</argument_list></call></expr></then><else>:<expr><name>jj_ntk</name></expr></else></ternary></expr>)</condition> <block>{<block_content>
      <case>case <expr><name>TERM</name></expr>:</case>
        <expr_stmt><expr><name>term</name> <operator>=</operator> <call><name>jj_consume_token</name><argument_list>(<argument><expr><name>TERM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      <case>case <expr><name>STAR</name></expr>:</case>
        <expr_stmt><expr><name>term</name> <operator>=</operator> <call><name>jj_consume_token</name><argument_list>(<argument><expr><name>STAR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                      <expr_stmt><expr><name>wildcard</name><operator>=</operator><literal type="boolean">true</literal></expr>;</expr_stmt>
        <break>break;</break>
      <case>case <expr><name>PREFIXTERM</name></expr>:</case>
        <expr_stmt><expr><name>term</name> <operator>=</operator> <call><name>jj_consume_token</name><argument_list>(<argument><expr><name>PREFIXTERM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><name>prefix</name><operator>=</operator><literal type="boolean">true</literal></expr>;</expr_stmt>
        <break>break;</break>
      <case>case <expr><name>WILDTERM</name></expr>:</case>
        <expr_stmt><expr><name>term</name> <operator>=</operator> <call><name>jj_consume_token</name><argument_list>(<argument><expr><name>WILDTERM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                          <expr_stmt><expr><name>wildcard</name><operator>=</operator><literal type="boolean">true</literal></expr>;</expr_stmt>
        <break>break;</break>
      <case>case <expr><name>REGEXPTERM</name></expr>:</case>
        <expr_stmt><expr><name>term</name> <operator>=</operator> <call><name>jj_consume_token</name><argument_list>(<argument><expr><name>REGEXPTERM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><name>regexp</name><operator>=</operator><literal type="boolean">true</literal></expr>;</expr_stmt>
        <break>break;</break>
      <case>case <expr><name>NUMBER</name></expr>:</case>
        <expr_stmt><expr><name>term</name> <operator>=</operator> <call><name>jj_consume_token</name><argument_list>(<argument><expr><name>NUMBER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      <case>case <expr><name>BAREOPER</name></expr>:</case>
        <expr_stmt><expr><name>term</name> <operator>=</operator> <call><name>jj_consume_token</name><argument_list>(<argument><expr><name>BAREOPER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                          <expr_stmt><expr><name><name>term</name><operator>.</operator><name>image</name></name> <operator>=</operator> <call><name><name>term</name><operator>.</operator><name>image</name><operator>.</operator><name>substring</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      <default>default:</default>
        <expr_stmt><expr><name><name>jj_la1</name><index>[<expr><literal type="number">9</literal></expr>]</index></name> <operator>=</operator> <name>jj_gen</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>jj_consume_token</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <throw>throw <expr><operator>new</operator> <call><name>ParseException</name><argument_list>()</argument_list></call></expr>;</throw>
      </block_content>}</block></switch>
      <switch>switch <condition>(<expr><ternary><condition><expr><operator>(</operator><name>jj_ntk</name><operator>==</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>?</condition><then><expr><call><name>jj_ntk</name><argument_list>()</argument_list></call></expr></then><else>:<expr><name>jj_ntk</name></expr></else></ternary></expr>)</condition> <block>{<block_content>
      <case>case <expr><name>FUZZY_SLOP</name></expr>:</case>
        <expr_stmt><expr><name>fuzzySlop</name> <operator>=</operator> <call><name>jj_consume_token</name><argument_list>(<argument><expr><name>FUZZY_SLOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                               <expr_stmt><expr><name>fuzzy</name><operator>=</operator><literal type="boolean">true</literal></expr>;</expr_stmt>
        <break>break;</break>
      <default>default:</default>
        <expr_stmt><expr><name><name>jj_la1</name><index>[<expr><literal type="number">10</literal></expr>]</index></name> <operator>=</operator> <name>jj_gen</name></expr>;</expr_stmt>
        <empty_stmt>;</empty_stmt>
      </block_content>}</block></switch>
      <switch>switch <condition>(<expr><ternary><condition><expr><operator>(</operator><name>jj_ntk</name><operator>==</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>?</condition><then><expr><call><name>jj_ntk</name><argument_list>()</argument_list></call></expr></then><else>:<expr><name>jj_ntk</name></expr></else></ternary></expr>)</condition> <block>{<block_content>
      <case>case <expr><name>CARAT</name></expr>:</case>
        <expr_stmt><expr><call><name>jj_consume_token</name><argument_list>(<argument><expr><name>CARAT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>boost</name> <operator>=</operator> <call><name>jj_consume_token</name><argument_list>(<argument><expr><name>NUMBER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <switch>switch <condition>(<expr><ternary><condition><expr><operator>(</operator><name>jj_ntk</name><operator>==</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>?</condition><then><expr><call><name>jj_ntk</name><argument_list>()</argument_list></call></expr></then><else>:<expr><name>jj_ntk</name></expr></else></ternary></expr>)</condition> <block>{<block_content>
        <case>case <expr><name>FUZZY_SLOP</name></expr>:</case>
          <expr_stmt><expr><name>fuzzySlop</name> <operator>=</operator> <call><name>jj_consume_token</name><argument_list>(<argument><expr><name>FUZZY_SLOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                                        <expr_stmt><expr><name>fuzzy</name><operator>=</operator><literal type="boolean">true</literal></expr>;</expr_stmt>
          <break>break;</break>
        <default>default:</default>
          <expr_stmt><expr><name><name>jj_la1</name><index>[<expr><literal type="number">11</literal></expr>]</index></name> <operator>=</operator> <name>jj_gen</name></expr>;</expr_stmt>
          <empty_stmt>;</empty_stmt>
        </block_content>}</block></switch>
        <break>break;</break>
      <default>default:</default>
        <expr_stmt><expr><name><name>jj_la1</name><index>[<expr><literal type="number">12</literal></expr>]</index></name> <operator>=</operator> <name>jj_gen</name></expr>;</expr_stmt>
        <empty_stmt>;</empty_stmt>
      </block_content>}</block></switch>
      <expr_stmt><expr><name>q</name> <operator>=</operator> <call><name>handleBareTokenQuery</name><argument_list>(<argument><expr><call><name>getField</name><argument_list>(<argument><expr><name>field</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>term</name></expr></argument>, <argument><expr><name>fuzzySlop</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>wildcard</name></expr></argument>, <argument><expr><name>fuzzy</name></expr></argument>, <argument><expr><name>regexp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>RANGEIN_START</name></expr>:</case>
    <case>case <expr><name>RANGEEX_START</name></expr>:</case>
      <switch>switch <condition>(<expr><ternary><condition><expr><operator>(</operator><name>jj_ntk</name><operator>==</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>?</condition><then><expr><call><name>jj_ntk</name><argument_list>()</argument_list></call></expr></then><else>:<expr><name>jj_ntk</name></expr></else></ternary></expr>)</condition> <block>{<block_content>
      <case>case <expr><name>RANGEIN_START</name></expr>:</case>
        <expr_stmt><expr><call><name>jj_consume_token</name><argument_list>(<argument><expr><name>RANGEIN_START</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                           <expr_stmt><expr><name>startInc</name><operator>=</operator><literal type="boolean">true</literal></expr>;</expr_stmt>
        <break>break;</break>
      <case>case <expr><name>RANGEEX_START</name></expr>:</case>
        <expr_stmt><expr><call><name>jj_consume_token</name><argument_list>(<argument><expr><name>RANGEEX_START</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      <default>default:</default>
        <expr_stmt><expr><name><name>jj_la1</name><index>[<expr><literal type="number">13</literal></expr>]</index></name> <operator>=</operator> <name>jj_gen</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>jj_consume_token</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <throw>throw <expr><operator>new</operator> <call><name>ParseException</name><argument_list>()</argument_list></call></expr>;</throw>
      </block_content>}</block></switch>
      <switch>switch <condition>(<expr><ternary><condition><expr><operator>(</operator><name>jj_ntk</name><operator>==</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>?</condition><then><expr><call><name>jj_ntk</name><argument_list>()</argument_list></call></expr></then><else>:<expr><name>jj_ntk</name></expr></else></ternary></expr>)</condition> <block>{<block_content>
      <case>case <expr><name>RANGE_GOOP</name></expr>:</case>
        <expr_stmt><expr><name>goop1</name> <operator>=</operator> <call><name>jj_consume_token</name><argument_list>(<argument><expr><name>RANGE_GOOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      <case>case <expr><name>RANGE_QUOTED</name></expr>:</case>
        <expr_stmt><expr><name>goop1</name> <operator>=</operator> <call><name>jj_consume_token</name><argument_list>(<argument><expr><name>RANGE_QUOTED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      <default>default:</default>
        <expr_stmt><expr><name><name>jj_la1</name><index>[<expr><literal type="number">14</literal></expr>]</index></name> <operator>=</operator> <name>jj_gen</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>jj_consume_token</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <throw>throw <expr><operator>new</operator> <call><name>ParseException</name><argument_list>()</argument_list></call></expr>;</throw>
      </block_content>}</block></switch>
      <switch>switch <condition>(<expr><ternary><condition><expr><operator>(</operator><name>jj_ntk</name><operator>==</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>?</condition><then><expr><call><name>jj_ntk</name><argument_list>()</argument_list></call></expr></then><else>:<expr><name>jj_ntk</name></expr></else></ternary></expr>)</condition> <block>{<block_content>
      <case>case <expr><name>RANGE_TO</name></expr>:</case>
        <expr_stmt><expr><call><name>jj_consume_token</name><argument_list>(<argument><expr><name>RANGE_TO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      <default>default:</default>
        <expr_stmt><expr><name><name>jj_la1</name><index>[<expr><literal type="number">15</literal></expr>]</index></name> <operator>=</operator> <name>jj_gen</name></expr>;</expr_stmt>
        <empty_stmt>;</empty_stmt>
      </block_content>}</block></switch>
      <switch>switch <condition>(<expr><ternary><condition><expr><operator>(</operator><name>jj_ntk</name><operator>==</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>?</condition><then><expr><call><name>jj_ntk</name><argument_list>()</argument_list></call></expr></then><else>:<expr><name>jj_ntk</name></expr></else></ternary></expr>)</condition> <block>{<block_content>
      <case>case <expr><name>RANGE_GOOP</name></expr>:</case>
        <expr_stmt><expr><name>goop2</name> <operator>=</operator> <call><name>jj_consume_token</name><argument_list>(<argument><expr><name>RANGE_GOOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      <case>case <expr><name>RANGE_QUOTED</name></expr>:</case>
        <expr_stmt><expr><name>goop2</name> <operator>=</operator> <call><name>jj_consume_token</name><argument_list>(<argument><expr><name>RANGE_QUOTED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      <default>default:</default>
        <expr_stmt><expr><name><name>jj_la1</name><index>[<expr><literal type="number">16</literal></expr>]</index></name> <operator>=</operator> <name>jj_gen</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>jj_consume_token</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <throw>throw <expr><operator>new</operator> <call><name>ParseException</name><argument_list>()</argument_list></call></expr>;</throw>
      </block_content>}</block></switch>
      <switch>switch <condition>(<expr><ternary><condition><expr><operator>(</operator><name>jj_ntk</name><operator>==</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>?</condition><then><expr><call><name>jj_ntk</name><argument_list>()</argument_list></call></expr></then><else>:<expr><name>jj_ntk</name></expr></else></ternary></expr>)</condition> <block>{<block_content>
      <case>case <expr><name>RANGEIN_END</name></expr>:</case>
        <expr_stmt><expr><call><name>jj_consume_token</name><argument_list>(<argument><expr><name>RANGEIN_END</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                         <expr_stmt><expr><name>endInc</name><operator>=</operator><literal type="boolean">true</literal></expr>;</expr_stmt>
        <break>break;</break>
      <case>case <expr><name>RANGEEX_END</name></expr>:</case>
        <expr_stmt><expr><call><name>jj_consume_token</name><argument_list>(<argument><expr><name>RANGEEX_END</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      <default>default:</default>
        <expr_stmt><expr><name><name>jj_la1</name><index>[<expr><literal type="number">17</literal></expr>]</index></name> <operator>=</operator> <name>jj_gen</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>jj_consume_token</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <throw>throw <expr><operator>new</operator> <call><name>ParseException</name><argument_list>()</argument_list></call></expr>;</throw>
      </block_content>}</block></switch>
      <switch>switch <condition>(<expr><ternary><condition><expr><operator>(</operator><name>jj_ntk</name><operator>==</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>?</condition><then><expr><call><name>jj_ntk</name><argument_list>()</argument_list></call></expr></then><else>:<expr><name>jj_ntk</name></expr></else></ternary></expr>)</condition> <block>{<block_content>
      <case>case <expr><name>CARAT</name></expr>:</case>
        <expr_stmt><expr><call><name>jj_consume_token</name><argument_list>(<argument><expr><name>CARAT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>boost</name> <operator>=</operator> <call><name>jj_consume_token</name><argument_list>(<argument><expr><name>NUMBER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      <default>default:</default>
        <expr_stmt><expr><name><name>jj_la1</name><index>[<expr><literal type="number">18</literal></expr>]</index></name> <operator>=</operator> <name>jj_gen</name></expr>;</expr_stmt>
        <empty_stmt>;</empty_stmt>
      </block_content>}</block></switch>
         <decl_stmt><decl><type><name>boolean</name></type> <name>startOpen</name><init>=<expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt>
         <decl_stmt><decl><type><name>boolean</name></type> <name>endOpen</name><init>=<expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt>
         <if_stmt><if>if <condition>(<expr><name><name>goop1</name><operator>.</operator><name>kind</name></name> <operator>==</operator> <name>RANGE_QUOTED</name></expr>)</condition> <block>{<block_content>
           <expr_stmt><expr><name><name>goop1</name><operator>.</operator><name>image</name></name> <operator>=</operator> <call><name><name>goop1</name><operator>.</operator><name>image</name><operator>.</operator><name>substring</name></name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name><name>goop1</name><operator>.</operator><name>image</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
         </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><literal type="string">"*"</literal><operator>.</operator><call><name>equals</name><argument_list>(<argument><expr><name><name>goop1</name><operator>.</operator><name>image</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
           <expr_stmt><expr><name>startOpen</name><operator>=</operator><literal type="boolean">true</literal></expr>;</expr_stmt>
         </block_content>}</block></if></if_stmt>
         <if_stmt><if>if <condition>(<expr><name><name>goop2</name><operator>.</operator><name>kind</name></name> <operator>==</operator> <name>RANGE_QUOTED</name></expr>)</condition> <block>{<block_content>
           <expr_stmt><expr><name><name>goop2</name><operator>.</operator><name>image</name></name> <operator>=</operator> <call><name><name>goop2</name><operator>.</operator><name>image</name><operator>.</operator><name>substring</name></name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name><name>goop2</name><operator>.</operator><name>image</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
         </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><literal type="string">"*"</literal><operator>.</operator><call><name>equals</name><argument_list>(<argument><expr><name><name>goop2</name><operator>.</operator><name>image</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
           <expr_stmt><expr><name>endOpen</name><operator>=</operator><literal type="boolean">true</literal></expr>;</expr_stmt>
         </block_content>}</block></if></if_stmt>
         <expr_stmt><expr><name>q</name> <operator>=</operator> <call><name>getRangeQuery</name><argument_list>(<argument><expr><call><name>getField</name><argument_list>(<argument><expr><name>field</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><ternary><condition><expr><name>startOpen</name></expr> ?</condition><then> <expr><literal type="null">null</literal></expr> </then><else>: <expr><call><name>discardEscapeChar</name><argument_list>(<argument><expr><name><name>goop1</name><operator>.</operator><name>image</name></name></expr></argument>)</argument_list></call></expr></else></ternary></expr></argument>, <argument><expr><ternary><condition><expr><name>endOpen</name></expr> ?</condition><then> <expr><literal type="null">null</literal></expr> </then><else>: <expr><call><name>discardEscapeChar</name><argument_list>(<argument><expr><name><name>goop2</name><operator>.</operator><name>image</name></name></expr></argument>)</argument_list></call></expr></else></ternary></expr></argument>, <argument><expr><name>startInc</name></expr></argument>, <argument><expr><name>endInc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>QUOTED</name></expr>:</case>
      <expr_stmt><expr><name>term</name> <operator>=</operator> <call><name>jj_consume_token</name><argument_list>(<argument><expr><name>QUOTED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <switch>switch <condition>(<expr><ternary><condition><expr><operator>(</operator><name>jj_ntk</name><operator>==</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>?</condition><then><expr><call><name>jj_ntk</name><argument_list>()</argument_list></call></expr></then><else>:<expr><name>jj_ntk</name></expr></else></ternary></expr>)</condition> <block>{<block_content>
      <case>case <expr><name>FUZZY_SLOP</name></expr>:</case>
        <expr_stmt><expr><name>fuzzySlop</name> <operator>=</operator> <call><name>jj_consume_token</name><argument_list>(<argument><expr><name>FUZZY_SLOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      <default>default:</default>
        <expr_stmt><expr><name><name>jj_la1</name><index>[<expr><literal type="number">19</literal></expr>]</index></name> <operator>=</operator> <name>jj_gen</name></expr>;</expr_stmt>
        <empty_stmt>;</empty_stmt>
      </block_content>}</block></switch>
      <switch>switch <condition>(<expr><ternary><condition><expr><operator>(</operator><name>jj_ntk</name><operator>==</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>?</condition><then><expr><call><name>jj_ntk</name><argument_list>()</argument_list></call></expr></then><else>:<expr><name>jj_ntk</name></expr></else></ternary></expr>)</condition> <block>{<block_content>
      <case>case <expr><name>CARAT</name></expr>:</case>
        <expr_stmt><expr><call><name>jj_consume_token</name><argument_list>(<argument><expr><name>CARAT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>boost</name> <operator>=</operator> <call><name>jj_consume_token</name><argument_list>(<argument><expr><name>NUMBER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      <default>default:</default>
        <expr_stmt><expr><name><name>jj_la1</name><index>[<expr><literal type="number">20</literal></expr>]</index></name> <operator>=</operator> <name>jj_gen</name></expr>;</expr_stmt>
        <empty_stmt>;</empty_stmt>
      </block_content>}</block></switch>
        <expr_stmt><expr><name>q</name> <operator>=</operator> <call><name>handleQuotedTerm</name><argument_list>(<argument><expr><call><name>getField</name><argument_list>(<argument><expr><name>field</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>term</name></expr></argument>, <argument><expr><name>fuzzySlop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    <default>default:</default>
      <expr_stmt><expr><name><name>jj_la1</name><index>[<expr><literal type="number">21</literal></expr>]</index></name> <operator>=</operator> <name>jj_gen</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>jj_consume_token</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <throw>throw <expr><operator>new</operator> <call><name>ParseException</name><argument_list>()</argument_list></call></expr>;</throw>
    </block_content>}</block></switch>
    <block>{<block_content><if_stmt><if>if <condition>(<expr><literal type="boolean">true</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>handleBoost</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name>boost</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block_content>}</block>
    <throw>throw <expr><operator>new</operator> <call><name>Error</name><argument_list>(<argument><expr><literal type="string">"Missing return statement in function"</literal></expr></argument>)</argument_list></call></expr>;</throw>
  </block_content>}</block></function>

  <function><type><specifier>private</specifier> <name>boolean</name></type> <name>jj_2_1</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>xla</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><name>jj_la</name> <operator>=</operator> <name>xla</name></expr>;</expr_stmt> <expr_stmt><expr><name>jj_lastpos</name> <operator>=</operator> <name>jj_scanpos</name> <operator>=</operator> <name>token</name></expr>;</expr_stmt>
    <try>try <block>{<block_content> <return>return <expr><operator>!</operator><call><name>jj_3_1</name><argument_list>()</argument_list></call></expr>;</return> </block_content>}</block>
    <catch>catch<parameter_list>(<parameter><decl><type><name>LookaheadSuccess</name></type> <name>ls</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><literal type="boolean">true</literal></expr>;</return> </block_content>}</block></catch>
    <finally>finally <block>{<block_content> <expr_stmt><expr><call><name>jj_save</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>xla</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></finally></try>
  </block_content>}</block></function>

  <function><type><specifier>private</specifier> <name>boolean</name></type> <name>jj_3R_3</name><parameter_list>()</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>jj_scan_token</name><argument_list>(<argument><expr><name>STAR</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="boolean">true</literal></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>jj_scan_token</name><argument_list>(<argument><expr><name>COLON</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="boolean">true</literal></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><literal type="boolean">false</literal></expr>;</return>
  </block_content>}</block></function>

  <function><type><specifier>private</specifier> <name>boolean</name></type> <name>jj_3R_2</name><parameter_list>()</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>jj_scan_token</name><argument_list>(<argument><expr><name>TERM</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="boolean">true</literal></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>jj_scan_token</name><argument_list>(<argument><expr><name>COLON</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="boolean">true</literal></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><literal type="boolean">false</literal></expr>;</return>
  </block_content>}</block></function>

  <function><type><specifier>private</specifier> <name>boolean</name></type> <name>jj_3_1</name><parameter_list>()</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>Token</name></type> <name>xsp</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>xsp</name> <operator>=</operator> <name>jj_scanpos</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>jj_3R_2</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>jj_scanpos</name> <operator>=</operator> <name>xsp</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>jj_3R_3</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="boolean">true</literal></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><literal type="boolean">false</literal></expr>;</return>
  </block_content>}</block></function>

  <comment type="block" format="javadoc">/** Generated Token Manager. */</comment>
  <decl_stmt><decl><type><specifier>public</specifier> <name>QueryParserTokenManager</name></type> <name>token_source</name></decl>;</decl_stmt>
  <comment type="block" format="javadoc">/** Current token. */</comment>
  <decl_stmt><decl><type><specifier>public</specifier> <name>Token</name></type> <name>token</name></decl>;</decl_stmt>
  <comment type="block" format="javadoc">/** Next token. */</comment>
  <decl_stmt><decl><type><specifier>public</specifier> <name>Token</name></type> <name>jj_nt</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>private</specifier> <name>int</name></type> <name>jj_ntk</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>private</specifier> <name>Token</name></type> <name>jj_scanpos</name></decl>, <decl><type ref="prev"/><name>jj_lastpos</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>private</specifier> <name>int</name></type> <name>jj_la</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>private</specifier> <name>int</name></type> <name>jj_gen</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>final</specifier> <specifier>private</specifier> <name><name>int</name><index>[]</index></name></type> <name>jj_la1</name> <init>= <expr><operator>new</operator> <name><name>int</name><index>[<expr><literal type="number">22</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>static</specifier> <specifier>private</specifier> <name><name>int</name><index>[]</index></name></type> <name>jj_la1_0</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>static</specifier> <specifier>private</specifier> <name><name>int</name><index>[]</index></name></type> <name>jj_la1_1</name></decl>;</decl_stmt>
  <static>static <block>{<block_content>
      <expr_stmt><expr><call><name>jj_la1_init_0</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>jj_la1_init_1</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
   </block_content>}</block></static>
   <function><type><specifier>private</specifier> <specifier>static</specifier> <name>void</name></type> <name>jj_la1_init_0</name><parameter_list>()</parameter_list> <block>{<block_content>
      <expr_stmt><expr><name>jj_la1_0</name> <operator>=</operator> <operator>new</operator> <name><name>int</name><index>[]</index></name> <block>{<expr><literal type="number">0x600</literal></expr>,<expr><literal type="number">0x600</literal></expr>,<expr><literal type="number">0x3800</literal></expr>,<expr><literal type="number">0x3800</literal></expr>,<expr><literal type="number">0x7f54fe00</literal></expr>,<expr><literal type="number">0x440000</literal></expr>,<expr><literal type="number">0x80000</literal></expr>,<expr><literal type="number">0x80000</literal></expr>,<expr><literal type="number">0x7f54c000</literal></expr>,<expr><literal type="number">0x47444000</literal></expr>,<expr><literal type="number">0x800000</literal></expr>,<expr><literal type="number">0x800000</literal></expr>,<expr><literal type="number">0x80000</literal></expr>,<expr><literal type="number">0x18000000</literal></expr>,<expr><literal type="number">0x0</literal></expr>,<expr><literal type="number">0x80000000</literal></expr>,<expr><literal type="number">0x0</literal></expr>,<expr><literal type="number">0x0</literal></expr>,<expr><literal type="number">0x80000</literal></expr>,<expr><literal type="number">0x800000</literal></expr>,<expr><literal type="number">0x80000</literal></expr>,<expr><literal type="number">0x5f544000</literal></expr>,}</block></expr>;</expr_stmt>
   </block_content>}</block></function>
   <function><type><specifier>private</specifier> <specifier>static</specifier> <name>void</name></type> <name>jj_la1_init_1</name><parameter_list>()</parameter_list> <block>{<block_content>
      <expr_stmt><expr><name>jj_la1_1</name> <operator>=</operator> <operator>new</operator> <name><name>int</name><index>[]</index></name> <block>{<expr><literal type="number">0x0</literal></expr>,<expr><literal type="number">0x0</literal></expr>,<expr><literal type="number">0x0</literal></expr>,<expr><literal type="number">0x0</literal></expr>,<expr><literal type="number">0x0</literal></expr>,<expr><literal type="number">0x0</literal></expr>,<expr><literal type="number">0x0</literal></expr>,<expr><literal type="number">0x0</literal></expr>,<expr><literal type="number">0x0</literal></expr>,<expr><literal type="number">0x0</literal></expr>,<expr><literal type="number">0x0</literal></expr>,<expr><literal type="number">0x0</literal></expr>,<expr><literal type="number">0x0</literal></expr>,<expr><literal type="number">0x0</literal></expr>,<expr><literal type="number">0xc</literal></expr>,<expr><literal type="number">0x0</literal></expr>,<expr><literal type="number">0xc</literal></expr>,<expr><literal type="number">0x3</literal></expr>,<expr><literal type="number">0x0</literal></expr>,<expr><literal type="number">0x0</literal></expr>,<expr><literal type="number">0x0</literal></expr>,<expr><literal type="number">0x0</literal></expr>,}</block></expr>;</expr_stmt>
   </block_content>}</block></function>
  <decl_stmt><decl><type><specifier>final</specifier> <specifier>private</specifier> <name><name>JJCalls</name><index>[]</index></name></type> <name>jj_2_rtns</name> <init>= <expr><operator>new</operator> <name><name>JJCalls</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>private</specifier> <name>boolean</name></type> <name>jj_rescan</name> <init>= <expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>private</specifier> <name>int</name></type> <name>jj_gc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <comment type="block" format="javadoc">/** Constructor with user supplied CharStream. */</comment>
  <constructor><specifier>protected</specifier> <name>QueryParser</name><parameter_list>(<parameter><decl><type><name>CharStream</name></type> <name>stream</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><name>token_source</name> <operator>=</operator> <operator>new</operator> <call><name>QueryParserTokenManager</name><argument_list>(<argument><expr><name>stream</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>token</name> <operator>=</operator> <operator>new</operator> <call><name>Token</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>jj_ntk</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>jj_gen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">22</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name><name>jj_la1</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></for>
    <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>jj_2_rtns</name><operator>.</operator><name>length</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name><name>jj_2_rtns</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>new</operator> <call><name>JJCalls</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></for>
  </block_content>}</block></constructor>

  <comment type="block" format="javadoc">/** Reinitialise. */</comment>
  <function><type><specifier>public</specifier> <name>void</name></type> <name>ReInit</name><parameter_list>(<parameter><decl><type><name>CharStream</name></type> <name>stream</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name><name>token_source</name><operator>.</operator><name>ReInit</name></name><argument_list>(<argument><expr><name>stream</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>token</name> <operator>=</operator> <operator>new</operator> <call><name>Token</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>jj_ntk</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>jj_gen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">22</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name><name>jj_la1</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></for>
    <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>jj_2_rtns</name><operator>.</operator><name>length</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name><name>jj_2_rtns</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>new</operator> <call><name>JJCalls</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></for>
  </block_content>}</block></function>

  <comment type="block" format="javadoc">/** Constructor with generated Token Manager. */</comment>
  <constructor><specifier>protected</specifier> <name>QueryParser</name><parameter_list>(<parameter><decl><type><name>QueryParserTokenManager</name></type> <name>tm</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><name>token_source</name> <operator>=</operator> <name>tm</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>token</name> <operator>=</operator> <operator>new</operator> <call><name>Token</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>jj_ntk</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>jj_gen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">22</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name><name>jj_la1</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></for>
    <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>jj_2_rtns</name><operator>.</operator><name>length</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name><name>jj_2_rtns</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>new</operator> <call><name>JJCalls</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></for>
  </block_content>}</block></constructor>

  <comment type="block" format="javadoc">/** Reinitialise. */</comment>
  <function><type><specifier>public</specifier> <name>void</name></type> <name>ReInit</name><parameter_list>(<parameter><decl><type><name>QueryParserTokenManager</name></type> <name>tm</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><name>token_source</name> <operator>=</operator> <name>tm</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>token</name> <operator>=</operator> <operator>new</operator> <call><name>Token</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>jj_ntk</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>jj_gen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">22</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name><name>jj_la1</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></for>
    <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>jj_2_rtns</name><operator>.</operator><name>length</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name><name>jj_2_rtns</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>new</operator> <call><name>JJCalls</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></for>
  </block_content>}</block></function>

  <function><type><specifier>private</specifier> <name>Token</name></type> <name>jj_consume_token</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>kind</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>ParseException</name></expr></argument></throws> <block>{<block_content>
    <decl_stmt><decl><type><name>Token</name></type> <name>oldToken</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>oldToken</name> <operator>=</operator> <name>token</name><operator>)</operator><operator>.</operator><name>next</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>token</name> <operator>=</operator> <name><name>token</name><operator>.</operator><name>next</name></name></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content> <expr_stmt><expr><name>token</name> <operator>=</operator> <name><name>token</name><operator>.</operator><name>next</name></name> <operator>=</operator> <call><name><name>token_source</name><operator>.</operator><name>getNextToken</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <expr_stmt><expr><name>jj_ntk</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>token</name><operator>.</operator><name>kind</name></name> <operator>==</operator> <name>kind</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>jj_gen</name><operator>++</operator></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><operator>++</operator><name>jj_gc</name> <operator>&gt;</operator> <literal type="number">100</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>jj_gc</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>jj_2_rtns</name><operator>.</operator><name>length</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
          <decl_stmt><decl><type><name>JJCalls</name></type> <name>c</name> <init>= <expr><name><name>jj_2_rtns</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
          <while>while <condition>(<expr><name>c</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>c</name><operator>.</operator><name>gen</name></name> <operator>&lt;</operator> <name>jj_gen</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>c</name><operator>.</operator><name>first</name></name> <operator>=</operator> <literal type="null">null</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>c</name> <operator>=</operator> <name><name>c</name><operator>.</operator><name>next</name></name></expr>;</expr_stmt>
          </block_content>}</block></while>
        </block_content>}</block></for>
      </block_content>}</block></if></if_stmt>
      <return>return <expr><name>token</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>token</name> <operator>=</operator> <name>oldToken</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>jj_kind</name> <operator>=</operator> <name>kind</name></expr>;</expr_stmt>
    <throw>throw <expr><call><name>generateParseException</name><argument_list>()</argument_list></call></expr>;</throw>
  </block_content>}</block></function>

  <class><specifier>static</specifier> <specifier>private</specifier> <specifier>final</specifier> class <name>LookaheadSuccess</name> <super_list><extends>extends <super><name><name>java</name><operator>.</operator><name>lang</name><operator>.</operator><name>Error</name></name></super></extends></super_list> <block>{ }</block></class>
  <decl_stmt><decl><type><specifier>final</specifier> <specifier>private</specifier> <name>LookaheadSuccess</name></type> <name>jj_ls</name> <init>= <expr><operator>new</operator> <call><name>LookaheadSuccess</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <function><type><specifier>private</specifier> <name>boolean</name></type> <name>jj_scan_token</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>kind</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>jj_scanpos</name> <operator>==</operator> <name>jj_lastpos</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>jj_la</name><operator>--</operator></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name><name>jj_scanpos</name><operator>.</operator><name>next</name></name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>jj_lastpos</name> <operator>=</operator> <name>jj_scanpos</name> <operator>=</operator> <name><name>jj_scanpos</name><operator>.</operator><name>next</name></name> <operator>=</operator> <call><name><name>token_source</name><operator>.</operator><name>getNextToken</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><name>jj_lastpos</name> <operator>=</operator> <name>jj_scanpos</name> <operator>=</operator> <name><name>jj_scanpos</name><operator>.</operator><name>next</name></name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><name>jj_scanpos</name> <operator>=</operator> <name><name>jj_scanpos</name><operator>.</operator><name>next</name></name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>jj_rescan</name></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <decl_stmt><decl><type><name>Token</name></type> <name>tok</name> <init>= <expr><name>token</name></expr></init></decl>;</decl_stmt>
      <while>while <condition>(<expr><name>tok</name> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <name>tok</name> <operator>!=</operator> <name>jj_scanpos</name></expr>)</condition> <block>{<block_content> <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt> <expr_stmt><expr><name>tok</name> <operator>=</operator> <name><name>tok</name><operator>.</operator><name>next</name></name></expr>;</expr_stmt> </block_content>}</block></while>
      <if_stmt><if>if <condition>(<expr><name>tok</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>jj_add_error_token</name><argument_list>(<argument><expr><name>kind</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>jj_scanpos</name><operator>.</operator><name>kind</name></name> <operator>!=</operator> <name>kind</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="boolean">true</literal></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>jj_la</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>jj_scanpos</name> <operator>==</operator> <name>jj_lastpos</name></expr>)</condition><block type="pseudo"><block_content> <throw>throw <expr><name>jj_ls</name></expr>;</throw></block_content></block></if></if_stmt>
    <return>return <expr><literal type="boolean">false</literal></expr>;</return>
  </block_content>}</block></function>


<comment type="block" format="javadoc">/** Get the next Token. */</comment>
  <function><type><specifier>final</specifier> <specifier>public</specifier> <name>Token</name></type> <name>getNextToken</name><parameter_list>()</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>token</name><operator>.</operator><name>next</name></name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>token</name> <operator>=</operator> <name><name>token</name><operator>.</operator><name>next</name></name></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content> <expr_stmt><expr><name>token</name> <operator>=</operator> <name><name>token</name><operator>.</operator><name>next</name></name> <operator>=</operator> <call><name><name>token_source</name><operator>.</operator><name>getNextToken</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <expr_stmt><expr><name>jj_ntk</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>jj_gen</name><operator>++</operator></expr>;</expr_stmt>
    <return>return <expr><name>token</name></expr>;</return>
  </block_content>}</block></function>

<comment type="block" format="javadoc">/** Get the specific Token. */</comment>
  <function><type><specifier>final</specifier> <specifier>public</specifier> <name>Token</name></type> <name>getToken</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>index</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>Token</name></type> <name>t</name> <init>= <expr><name>token</name></expr></init></decl>;</decl_stmt>
    <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>index</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name><name>t</name><operator>.</operator><name>next</name></name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>t</name> <operator>=</operator> <name><name>t</name><operator>.</operator><name>next</name></name></expr>;</expr_stmt></block_content></block></if>
      <else>else<block type="pseudo"><block_content> <expr_stmt><expr><name>t</name> <operator>=</operator> <name><name>t</name><operator>.</operator><name>next</name></name> <operator>=</operator> <call><name><name>token_source</name><operator>.</operator><name>getNextToken</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></for>
    <return>return <expr><name>t</name></expr>;</return>
  </block_content>}</block></function>

  <function><type><specifier>private</specifier> <name>int</name></type> <name>jj_ntk</name><parameter_list>()</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>jj_nt</name><operator>=</operator><name><name>token</name><operator>.</operator><name>next</name></name><operator>)</operator> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><block type="pseudo"><block_content>
      <return>return <expr><operator>(</operator><name>jj_ntk</name> <operator>=</operator> <operator>(</operator><name><name>token</name><operator>.</operator><name>next</name></name><operator>=</operator><call><name><name>token_source</name><operator>.</operator><name>getNextToken</name></name><argument_list>()</argument_list></call><operator>)</operator><operator>.</operator><name>kind</name><operator>)</operator></expr>;</return></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
      <return>return <expr><operator>(</operator><name>jj_ntk</name> <operator>=</operator> <name><name>jj_nt</name><operator>.</operator><name>kind</name></name><operator>)</operator></expr>;</return></block_content></block></else></if_stmt>
  </block_content>}</block></function>

  <decl_stmt><decl><type><specifier>private</specifier> <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name><name>List</name><argument_list type="generic">&lt;<argument><name><name>int</name><index>[]</index></name></argument>&gt;</argument_list></name></name></type> <name>jj_expentries</name> <init>= <expr><operator>new</operator> <call><name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name><name>ArrayList</name><argument_list type="generic">&lt;<argument><name><name>int</name><index>[]</index></name></argument>&gt;</argument_list></name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>private</specifier> <name><name>int</name><index>[]</index></name></type> <name>jj_expentry</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>private</specifier> <name>int</name></type> <name>jj_kind</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>private</specifier> <name><name>int</name><index>[]</index></name></type> <name>jj_lasttokens</name> <init>= <expr><operator>new</operator> <name><name>int</name><index>[<expr><literal type="number">100</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>private</specifier> <name>int</name></type> <name>jj_endpos</name></decl>;</decl_stmt>

  <function><type><specifier>private</specifier> <name>void</name></type> <name>jj_add_error_token</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>kind</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pos</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>pos</name> <operator>&gt;=</operator> <literal type="number">100</literal></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>pos</name> <operator>==</operator> <name>jj_endpos</name> <operator>+</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name><name>jj_lasttokens</name><index>[<expr><name>jj_endpos</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>kind</name></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>jj_endpos</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>jj_expentry</name> <operator>=</operator> <operator>new</operator> <name><name>int</name><index>[<expr><name>jj_endpos</name></expr>]</index></name></expr>;</expr_stmt>
      <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>jj_endpos</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <expr_stmt><expr><name><name>jj_expentry</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>jj_lasttokens</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
      </block_content>}</block></for>
      <label><name>jj_entries_loop</name>:</label> <for>for <control>(<init><decl><type><name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name><name>Iterator</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name></name></type> <name>it</name> <init>= <expr><call><name><name>jj_expentries</name><operator>.</operator><name>iterator</name></name><argument_list>()</argument_list></call></expr></init></decl>;</init> <condition><expr><call><name><name>it</name><operator>.</operator><name>hasNext</name></name><argument_list>()</argument_list></call></expr>;</condition><incr/>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name><name>int</name><index>[]</index></name></type> <name>oldentry</name> <init>= <expr><operator>(</operator><name><name>int</name><index>[]</index></name><operator>)</operator><operator>(</operator><call><name><name>it</name><operator>.</operator><name>next</name></name><argument_list>()</argument_list></call><operator>)</operator></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>oldentry</name><operator>.</operator><name>length</name></name> <operator>==</operator> <name><name>jj_expentry</name><operator>.</operator><name>length</name></name></expr>)</condition> <block>{<block_content>
          <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>jj_expentry</name><operator>.</operator><name>length</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>oldentry</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name><name>jj_expentry</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition> <block>{<block_content>
              <continue>continue <name>jj_entries_loop</name>;</continue>
            </block_content>}</block></if></if_stmt>
          </block_content>}</block></for>
          <expr_stmt><expr><call><name><name>jj_expentries</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name>jj_expentry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <break>break <name>jj_entries_loop</name>;</break>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></for>
      <if_stmt><if>if <condition>(<expr><name>pos</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>jj_lasttokens</name><index>[<expr><operator>(</operator><name>jj_endpos</name> <operator>=</operator> <name>pos</name><operator>)</operator> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>kind</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></function>

  <comment type="block" format="javadoc">/** Generate ParseException. */</comment>
  <function><type><specifier>public</specifier> <name>ParseException</name></type> <name>generateParseException</name><parameter_list>()</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name><name>jj_expentries</name><operator>.</operator><name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name><name>boolean</name><index>[]</index></name></type> <name>la1tokens</name> <init>= <expr><operator>new</operator> <name><name>boolean</name><index>[<expr><literal type="number">36</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>jj_kind</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name><name>la1tokens</name><index>[<expr><name>jj_kind</name></expr>]</index></name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>jj_kind</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">22</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name><name>jj_la1</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>jj_gen</name></expr>)</condition> <block>{<block_content>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <literal type="number">32</literal></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>jj_la1_0</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;</operator> <operator>(</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><name>j</name><operator>)</operator><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>la1tokens</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
          <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>jj_la1_1</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;</operator> <operator>(</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><name>j</name><operator>)</operator><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>la1tokens</name><index>[<expr><literal type="number">32</literal><operator>+</operator><name>j</name></expr>]</index></name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">36</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name><name>la1tokens</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>jj_expentry</name> <operator>=</operator> <operator>new</operator> <name><name>int</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>jj_expentry</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>jj_expentries</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name>jj_expentry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><name>jj_endpos</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>jj_rescan_token</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>jj_add_error_token</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name><name>int</name><index>[]</index><index>[]</index></name></type> <name>exptokseq</name> <init>= <expr><operator>new</operator> <name><name>int</name><index>[<expr><call><name><name>jj_expentries</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>]</index><index>[]</index></name></expr></init></decl>;</decl_stmt>
    <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name><name>jj_expentries</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
      <expr_stmt><expr><name><name>exptokseq</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name><name>jj_expentries</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <return>return <expr><operator>new</operator> <call><name>ParseException</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name>exptokseq</name></expr></argument>, <argument><expr><name>tokenImage</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></function>

  <comment type="block" format="javadoc">/** Enable tracing. */</comment>
  <function><type><specifier>final</specifier> <specifier>public</specifier> <name>void</name></type> <name>enable_tracing</name><parameter_list>()</parameter_list> <block>{<block_content>
  </block_content>}</block></function>

  <comment type="block" format="javadoc">/** Disable tracing. */</comment>
  <function><type><specifier>final</specifier> <specifier>public</specifier> <name>void</name></type> <name>disable_tracing</name><parameter_list>()</parameter_list> <block>{<block_content>
  </block_content>}</block></function>

  <function><type><specifier>private</specifier> <name>void</name></type> <name>jj_rescan_token</name><parameter_list>()</parameter_list> <block>{<block_content>
    <expr_stmt><expr><name>jj_rescan</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
    <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
    <try>try <block>{<block_content>
      <decl_stmt><decl><type><name>JJCalls</name></type> <name>p</name> <init>= <expr><name><name>jj_2_rtns</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <do>do <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>p</name><operator>.</operator><name>gen</name></name> <operator>&gt;</operator> <name>jj_gen</name></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><name>jj_la</name> <operator>=</operator> <name><name>p</name><operator>.</operator><name>arg</name></name></expr>;</expr_stmt> <expr_stmt><expr><name>jj_lastpos</name> <operator>=</operator> <name>jj_scanpos</name> <operator>=</operator> <name><name>p</name><operator>.</operator><name>first</name></name></expr>;</expr_stmt>
          <switch>switch <condition>(<expr><name>i</name></expr>)</condition> <block>{<block_content>
            <case>case <expr><literal type="number">0</literal></expr>:</case> <expr_stmt><expr><call><name>jj_3_1</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <break>break;</break>
          </block_content>}</block></switch>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>p</name><operator>.</operator><name>next</name></name></expr>;</expr_stmt>
      </block_content>}</block> while <condition>(<expr><name>p</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition>;</do>
      </block_content>}</block> <catch>catch<parameter_list>(<parameter><decl><type><name>LookaheadSuccess</name></type> <name>ls</name></decl></parameter>)</parameter_list> <block>{<block_content> </block_content>}</block></catch></try>
    </block_content>}</block></for>
    <expr_stmt><expr><name>jj_rescan</name> <operator>=</operator> <literal type="boolean">false</literal></expr>;</expr_stmt>
  </block_content>}</block></function>

  <function><type><specifier>private</specifier> <name>void</name></type> <name>jj_save</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>xla</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>JJCalls</name></type> <name>p</name> <init>= <expr><name><name>jj_2_rtns</name><index>[<expr><name>index</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <while>while <condition>(<expr><name><name>p</name><operator>.</operator><name>gen</name></name> <operator>&gt;</operator> <name>jj_gen</name></expr>)</condition> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name><name>p</name><operator>.</operator><name>next</name></name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content> <expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>p</name><operator>.</operator><name>next</name></name> <operator>=</operator> <operator>new</operator> <call><name>JJCalls</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <break>break;</break> </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>p</name><operator>.</operator><name>next</name></name></expr>;</expr_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><name><name>p</name><operator>.</operator><name>gen</name></name> <operator>=</operator> <name>jj_gen</name> <operator>+</operator> <name>xla</name> <operator>-</operator> <name>jj_la</name></expr>;</expr_stmt> <expr_stmt><expr><name><name>p</name><operator>.</operator><name>first</name></name> <operator>=</operator> <name>token</name></expr>;</expr_stmt> <expr_stmt><expr><name><name>p</name><operator>.</operator><name>arg</name></name> <operator>=</operator> <name>xla</name></expr>;</expr_stmt>
  </block_content>}</block></function>

  <class><specifier>static</specifier> <specifier>final</specifier> class <name>JJCalls</name> <block>{
    <decl_stmt><decl><type><name>int</name></type> <name>gen</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Token</name></type> <name>first</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>arg</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JJCalls</name></type> <name>next</name></decl>;</decl_stmt>
  }</block></class>

}</block></class>
<expr_stmt><expr><name>diff</name> <operator>--</operator><name>git</name> <name>a</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>parser</name><operator>/</operator><name><name>QueryParser</name><operator>.</operator><name>jj</name></name> <name>b</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>parser</name><operator>/</operator><name><name>QueryParser</name><operator>.</operator><name>jj</name></name>
<operator>new</operator> <name>file</name> <name>mode</name> <literal type="number">100644</literal>
<name>index</name> <literal type="number">00000000000..697c99d51ef</literal>
<operator>--</operator> <operator>/</operator><name>dev</name><operator>/</operator><literal type="null">null</literal>
<operator>++</operator> <name>b</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>parser</name><operator>/</operator><name><name>QueryParser</name><operator>.</operator><name>jj</name></name>
@@ <operator>-</operator><literal type="number">0</literal></expr><operator>,</operator><expr><literal type="number">0</literal> <operator>+</operator><literal type="number">1</literal></expr><operator>,</operator><expr><literal type="number">267</literal> @@
<comment type="block" format="javadoc">/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</comment>

<name>options</name> <block>{
  <expr><name>STATIC</name><operator>=</operator><literal type="boolean">false</literal></expr>;
  <expr><name>JAVA_UNICODE_ESCAPE</name><operator>=</operator><literal type="boolean">true</literal></expr>;
  <expr><name>USER_CHAR_STREAM</name><operator>=</operator><literal type="boolean">true</literal></expr>;
}</block>

<call><name>PARSER_BEGIN</name><argument_list>(<argument><expr><name>QueryParser</name></expr></argument>)</argument_list></call></expr></expr_stmt>

<package>package <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>parser</name></name>;</package>

<import>import <name><name>java</name><operator>.</operator><name>io</name><operator>.</operator><name>StringReader</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>ArrayList</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>List</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>Locale</name></name>;</import>

<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>analysis</name><operator>.</operator><name>Analyzer</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>document</name><operator>.</operator><name>DateTools</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>search</name><operator>.</operator><name>BooleanClause</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>search</name><operator>.</operator><name>Query</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>search</name><operator>.</operator><name>TermRangeQuery</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>search</name><operator>.</operator><name>TermQuery</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>util</name><operator>.</operator><name>Version</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>search</name><operator>.</operator><name>SyntaxError</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>search</name><operator>.</operator><name>QParser</name></name>;</import>


<class><specifier>public</specifier> class <name>QueryParser</name> <super_list><extends>extends <super><name>SolrQueryParserBase</name></super></extends></super_list> <block>{
  <comment type="block" format="javadoc">/** The default operator for parsing queries.
   * Use {@link QueryParserBase#setDefaultOperator} to change it.
   */</comment>
  <enum><specifier>static</specifier> <specifier>public</specifier> enum <name>Operator</name> <block>{ <decl><name>OR</name></decl>, <decl><name>AND</name></decl> }</block></enum>
  
  <comment type="block" format="javadoc">/** Create a query parser.
   *  @param matchVersion  Lucene version to match. See &lt;a href="#version"&gt;above&lt;/a&gt;.
   *  @param defaultField  the default field for query terms.
   *  @param a   used to find terms in the query text.
   */</comment>
   <constructor><specifier>public</specifier> <name>QueryParser</name><parameter_list>(<parameter><decl><type><name>Version</name></type> <name>matchVersion</name></decl></parameter>, <parameter><decl><type><name>String</name></type> <name>defaultField</name></decl></parameter>, <parameter><decl><type><name>QParser</name></type> <name>parser</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>this</name><argument_list>(<argument><expr><operator>new</operator> <call><name>FastCharStream</name><argument_list>(<argument><expr><operator>new</operator> <call><name>StringReader</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>init</name><argument_list>(<argument><expr><name>matchVersion</name></expr></argument>, <argument><expr><name>defaultField</name></expr></argument>, <argument><expr><name>parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></constructor>
}</block></class>

<expr_stmt><expr><call><name>PARSER_END</name><argument_list>(<argument><expr><name>QueryParser</name></expr></argument>)</argument_list></call>

<comment type="block">/* ***************** */</comment>
<comment type="block">/* Token Definitions */</comment>
<comment type="block">/* ***************** */</comment>

<operator>&lt;</operator><operator>*</operator><operator>&gt;</operator> <name>TOKEN</name> <operator>:</operator> <block>{
  <expr><operator>&lt;</operator><operator>#</operator><name>_NUM_CHAR</name><operator>:</operator>   <index>[<expr><literal type="string">"0"</literal><operator>-</operator><literal type="string">"9"</literal></expr>]</index> <operator>&gt;</operator>
 <comment type="line">// every character that follows a backslash is considered as an escaped character</comment>
 <operator>|</operator> <operator>&lt;</operator><operator>#</operator><name>_ESCAPED_CHAR</name><operator>:</operator> <literal type="string">"\\"</literal> <operator>~</operator><index>[]</index> <operator>&gt;</operator>
 <operator>|</operator> <operator>&lt;</operator><operator>#</operator><name>_TERM_START_CHAR</name><operator>:</operator> <operator>(</operator> <operator>~</operator><index>[ <expr><literal type="string">" "</literal></expr><operator>,</operator> <literal type="string">"\t"</literal><operator>,</operator> <literal type="string">"\n"</literal><operator>,</operator> <literal type="string">"\r"</literal><operator>,</operator> <literal type="string">"\u3000"</literal><operator>,</operator> <literal type="string">"+"</literal><operator>,</operator> <literal type="string">"-"</literal><operator>,</operator> <literal type="string">"!"</literal><operator>,</operator> <literal type="string">"("</literal><operator>,</operator> <literal type="string">")"</literal><operator>,</operator> <literal type="string">":"</literal><operator>,</operator> <literal type="string">"^"</literal><operator>,</operator>
                      <literal type="string">"["</literal><operator>,</operator> <literal type="string">"]"</literal><operator>,</operator> <literal type="string">"\""</literal><operator>,</operator> <literal type="string">"{"</literal><operator>,</operator> <literal type="string">"}"</literal><operator>,</operator> <literal type="string">"~"</literal><operator>,</operator> <literal type="string">"*"</literal><operator>,</operator> <literal type="string">"?"</literal><operator>,</operator> <literal type="string">"\\"</literal><operator>,</operator> <literal type="string">"/"</literal> ]</index>
                      <operator>|</operator> <operator>&lt;</operator><name>_ESCAPED_CHAR</name><operator>&gt;</operator> <operator>)</operator> <operator>&gt;</operator>
 <operator>|</operator> <operator>&lt;</operator><operator>#</operator><name>_TERM_CHAR</name><operator>:</operator> <operator>(</operator> <operator>&lt;</operator><name>_TERM_START_CHAR</name><operator>&gt;</operator>
                       <operator>|</operator> <operator>&lt;</operator><name>_ESCAPED_CHAR</name><operator>&gt;</operator> <operator>|</operator> <literal type="string">"-"</literal> <operator>|</operator> <literal type="string">"+"</literal> <operator>|</operator> <literal type="string">"/"</literal> <operator>)</operator> <operator>&gt;</operator>
 <operator>|</operator> <operator>&lt;</operator><operator>#</operator><name>_WHITESPACE</name><operator>:</operator>  <operator>(</operator> <literal type="string">" "</literal> <operator>|</operator> <literal type="string">"\t"</literal> <operator>|</operator> <literal type="string">"\n"</literal> <operator>|</operator> <literal type="string">"\r"</literal> <operator>|</operator> <literal type="string">"\u3000"</literal><operator>)</operator> <operator>&gt;</operator>
 <operator>|</operator> <operator>&lt;</operator><operator>#</operator><name>_QUOTED_CHAR</name><operator>:</operator>  <operator>(</operator> <operator>~</operator><index>[ <expr><literal type="string">"\""</literal></expr><operator>,</operator> <literal type="string">"\\"</literal> ]</index> <operator>|</operator> <operator>&lt;</operator><name>_ESCAPED_CHAR</name><operator>&gt;</operator> <operator>)</operator> <operator>&gt;</operator>
 <operator>|</operator> <operator>&lt;</operator><operator>#</operator><name>_SQUOTED_CHAR</name><operator>:</operator>  <operator>(</operator> <operator>~</operator><index>[ <expr><literal type="string">"'"</literal></expr><operator>,</operator> <literal type="string">"\\"</literal> ]</index> <operator>|</operator> <operator>&lt;</operator><name>_ESCAPED_CHAR</name><operator>&gt;</operator> <operator>)</operator> <operator>&gt;</operator></expr>
}</block>

<operator>&lt;</operator><name>DEFAULT</name></expr><operator>,</operator> <expr><name>Range</name><operator>&gt;</operator> <name>SKIP</name> <operator>:</operator> <block>{
  <expr><operator>&lt;</operator> <operator>&lt;</operator><name>_WHITESPACE</name><operator>&gt;&gt;</operator></expr>
}</block>

<operator>&lt;</operator><name>DEFAULT</name><operator>&gt;</operator> <name>TOKEN</name> <operator>:</operator> <block>{
  <expr><operator>&lt;</operator><name>AND</name><operator>:</operator>       <operator>(</operator><literal type="string">"AND"</literal> <operator>|</operator> <literal type="string">"&amp;&amp;"</literal><operator>)</operator> <operator>&gt;</operator>
 <operator>|</operator> <operator>&lt;</operator><name>OR</name><operator>:</operator>        <operator>(</operator><literal type="string">"OR"</literal> <operator>|</operator> <literal type="string">"||"</literal><operator>)</operator> <operator>&gt;</operator>
 <operator>|</operator> <operator>&lt;</operator><name>NOT</name><operator>:</operator>       <operator>(</operator><literal type="string">"NOT"</literal> <operator>|</operator> <literal type="string">"!"</literal><operator>)</operator> <operator>&gt;</operator>
 <operator>|</operator> <operator>&lt;</operator><name>PLUS</name><operator>:</operator>      <literal type="string">"+"</literal> <operator>&gt;</operator>
 <operator>|</operator> <operator>&lt;</operator><name>MINUS</name><operator>:</operator>     <literal type="string">"-"</literal> <operator>&gt;</operator>
 <operator>|</operator> <operator>&lt;</operator><name>BAREOPER</name><operator>:</operator>    <operator>(</operator><literal type="string">"+"</literal><operator>|</operator><literal type="string">"-"</literal><operator>|</operator><literal type="string">"!"</literal><operator>)</operator> <operator>&lt;</operator><name>_WHITESPACE</name><operator>&gt;</operator> &gt;
 <operator>|</operator> <operator>&lt;</operator><name>LPAREN</name><operator>:</operator>    <literal type="string">"("</literal> <operator>&gt;</operator>
 <operator>|</operator> <operator>&lt;</operator><name>RPAREN</name><operator>:</operator>    <literal type="string">")"</literal> <operator>&gt;</operator>
 <operator>|</operator> <operator>&lt;</operator><name>COLON</name><operator>:</operator>     <literal type="string">":"</literal> <operator>&gt;</operator>
 <operator>|</operator> <operator>&lt;</operator><name>STAR</name><operator>:</operator>      <literal type="string">"*"</literal> <operator>&gt;</operator>
 <operator>|</operator> <operator>&lt;</operator><name>CARAT</name><operator>:</operator>     <literal type="string">"^"</literal> <operator>&gt;</operator> <operator>:</operator> <name>Boost</name>
 <operator>|</operator> <operator>&lt;</operator><name>QUOTED</name><operator>:</operator>     <literal type="string">"\""</literal> <operator>(</operator><operator>&lt;</operator><name>_QUOTED_CHAR</name><operator>&gt;</operator><operator>)</operator><operator>*</operator> <literal type="string">"\""</literal><operator>&gt;</operator>
 <operator>|</operator> <operator>&lt;</operator><name>SQUOTED</name><operator>:</operator>     <literal type="string">"'"</literal> <operator>(</operator><operator>&lt;</operator><name>_SQUOTED_CHAR</name><operator>&gt;</operator><operator>)</operator><operator>*</operator> <literal type="string">"'"</literal><operator>&gt;</operator>
 <operator>|</operator> <operator>&lt;</operator><name>TERM</name><operator>:</operator>      <call><argument_list type="generic">&lt;<argument><name>_TERM_START_CHAR</name></argument>&gt;</argument_list> <argument_list>(<argument><expr><operator>&lt;</operator><name>_TERM_CHAR</name><operator>&gt;</operator></expr></argument>)</argument_list></call><operator>*</operator>  <operator>&gt;</operator>
 <operator>|</operator> <operator>&lt;</operator><name>FUZZY_SLOP</name><operator>:</operator>     <literal type="string">"~"</literal> <operator>(</operator> <operator>(</operator><operator>&lt;</operator><name>_NUM_CHAR</name><operator>&gt;</operator><operator>)</operator><operator>+</operator> <operator>(</operator> <literal type="string">"."</literal> <operator>(</operator><operator>&lt;</operator><name>_NUM_CHAR</name><operator>&gt;</operator><operator>)</operator><operator>+</operator> <operator>)</operator><operator>?</operator> <operator>)</operator><operator>?</operator> <operator>&gt;</operator>
 <operator>|</operator> <operator>&lt;</operator><name>PREFIXTERM</name><operator>:</operator>  <operator>(</operator><literal type="string">"*"</literal><operator>)</operator> <operator>|</operator> <operator>(</operator> <call><argument_list type="generic">&lt;<argument><name>_TERM_START_CHAR</name></argument>&gt;</argument_list> <argument_list>(<argument><expr><operator>&lt;</operator><name>_TERM_CHAR</name><operator>&gt;</operator></expr></argument>)</argument_list></call><operator>*</operator> <literal type="string">"*"</literal> <operator>)</operator> <operator>&gt;</operator>
 <operator>|</operator> <operator>&lt;</operator><name>WILDTERM</name><operator>:</operator>  <operator>(</operator><operator>&lt;</operator><name>_TERM_START_CHAR</name><operator>&gt;</operator> <operator>|</operator> <index>[ <expr><literal type="string">"*"</literal></expr><operator>,</operator> <literal type="string">"?"</literal> ]</index><operator>)</operator> <operator>(</operator><operator>&lt;</operator><name>_TERM_CHAR</name><operator>&gt;</operator> <operator>|</operator> <operator>(</operator> <index>[ <expr><literal type="string">"*"</literal></expr><operator>,</operator> <literal type="string">"?"</literal> ]</index> <operator>)</operator><operator>)</operator><operator>*</operator> <operator>&gt;</operator>
 <operator>|</operator> <operator>&lt;</operator><name>REGEXPTERM</name><operator>:</operator> <literal type="string">"/"</literal> <operator>(</operator><operator>~</operator><index>[ <expr><literal type="string">"/"</literal></expr> ]</index> <operator>|</operator> <literal type="string">"\\/"</literal> <operator>)</operator><operator>*</operator> <literal type="string">"/"</literal> <operator>&gt;</operator>
 <operator>|</operator> <operator>&lt;</operator><name>RANGEIN_START</name><operator>:</operator> <literal type="string">"["</literal> <operator>&gt;</operator> <operator>:</operator> <name>Range</name>
 <operator>|</operator> <operator>&lt;</operator><name>RANGEEX_START</name><operator>:</operator> <literal type="string">"{"</literal> <operator>&gt;</operator> <operator>:</operator> <name>Range</name>
 <operator>|</operator> <operator>&lt;</operator><name>LPARAMS</name><operator>:</operator>     <operator>(</operator><literal type="string">"{!"</literal> <operator>(</operator> <operator>(</operator><operator>&lt;</operator><name>_WHITESPACE</name><operator>&gt;</operator><operator>)</operator><operator>*</operator> <operator>(</operator><operator>~</operator><index>[<expr><literal type="string">"="</literal></expr><operator>,</operator><literal type="string">"}"</literal>]</index><operator>)</operator><operator>+</operator> <operator>(</operator> <literal type="string">"="</literal> <operator>(</operator><operator>&lt;</operator><name>QUOTED</name><operator>&gt;</operator> <operator>|</operator> <operator>&lt;</operator><name>SQUOTED</name><operator>&gt;</operator> <operator>|</operator> <operator>(</operator><operator>~</operator><index>[<expr><literal type="string">" "</literal></expr><operator>,</operator><literal type="string">"}"</literal>]</index><operator>)</operator><operator>+</operator> <operator>)</operator><operator>?</operator> <operator>)</operator><operator>?</operator> <operator>)</operator><operator>*</operator> <literal type="string">"}"</literal><operator>)</operator><operator>+</operator>  <operator>(</operator><operator>~</operator><index>[<expr><literal type="string">")"</literal></expr><operator>,</operator><literal type="string">" "</literal><operator>,</operator><literal type="string">"\t"</literal><operator>,</operator><literal type="string">"\n"</literal><operator>,</operator><literal type="string">"{"</literal><operator>,</operator><literal type="string">"^"</literal>]</index><operator>)</operator><operator>*</operator>  <operator>&gt;</operator></expr>
}</block>

<operator>&lt;</operator><name>Boost</name><operator>&gt;</operator> <name>TOKEN</name> <operator>:</operator> <block>{
 <expr><operator>&lt;</operator><name>NUMBER</name><operator>:</operator>    <operator>(</operator><literal type="string">"-"</literal><operator>)</operator><operator>?</operator> <operator>(</operator><operator>&lt;</operator><name>_NUM_CHAR</name><operator>&gt;</operator><operator>)</operator><operator>+</operator> <operator>(</operator> <literal type="string">"."</literal> <operator>(</operator><operator>&lt;</operator><name>_NUM_CHAR</name><operator>&gt;</operator><operator>)</operator><operator>+</operator> <operator>)</operator><operator>?</operator> <operator>&gt;</operator> <operator>:</operator> <name>DEFAULT</name></expr>
}</block>

<operator>&lt;</operator><name>Range</name><operator>&gt;</operator> <name>TOKEN</name> <operator>:</operator> <block>{
 <expr><operator>&lt;</operator><name>RANGE_TO</name><operator>:</operator> <literal type="string">"TO"</literal><operator>&gt;</operator>
 <operator>|</operator> <operator>&lt;</operator><name>RANGEIN_END</name><operator>:</operator> <literal type="string">"]"</literal><operator>&gt;</operator> <operator>:</operator> <name>DEFAULT</name>
 <operator>|</operator> <operator>&lt;</operator><name>RANGEEX_END</name><operator>:</operator> <literal type="string">"}"</literal><operator>&gt;</operator> <operator>:</operator> <name>DEFAULT</name>
 <operator>|</operator> <operator>&lt;</operator><name>RANGE_QUOTED</name><operator>:</operator> <literal type="string">"\""</literal> <operator>(</operator><operator>~</operator><index>[<expr><literal type="string">"\""</literal></expr>]</index> <operator>|</operator> <literal type="string">"\\\""</literal><operator>)</operator><operator>+</operator> <literal type="string">"\""</literal><operator>&gt;</operator>
 <operator>|</operator> <operator>&lt;</operator><name>RANGE_GOOP</name><operator>:</operator> <operator>(</operator><operator>~</operator><index>[ <expr><literal type="string">" "</literal></expr><operator>,</operator> <literal type="string">"]"</literal><operator>,</operator> <literal type="string">"}"</literal> ]</index><operator>)</operator><operator>+</operator> <operator>&gt;</operator></expr>
}</block>

<comment type="line">// *   Query  ::= ( Clause )*</comment>
<comment type="line">// *   Clause ::= ["+", "-"] [&lt;TERM&gt; ":"] ( &lt;TERM&gt; | "(" Query ")" )</comment>

<name>int</name> <call><name>Conjunction</name><argument_list>()</argument_list></call> <operator>:</operator> <block>{
  <expr><name>int</name> <name>ret</name> <operator>=</operator> <name>CONJ_NONE</name></expr>;
}</block>
<block>{
  <expr><index>[
    <expr><operator>&lt;</operator><name>AND</name><operator>&gt;</operator> <block>{ <expr><name>ret</name> <operator>=</operator> <name>CONJ_AND</name></expr></block></expr></index>;</expr> }</block>
    <operator>|</operator> <operator>&lt;</operator><name>OR</name><operator>&gt;</operator>  <block>{ <expr><name>ret</name> <operator>=</operator> <name>CONJ_OR</name></expr>; }</block>
  ]
  <block>{ <return>return <expr><name>ret</name></expr>;</return> }</block></expr></expr_stmt>
}

int <expr_stmt><expr><call><name>Modifiers</name><argument_list>()</argument_list></call> <operator>:</operator> <block>{
  <expr><name>int</name> <name>ret</name> <operator>=</operator> <name>MOD_NONE</name></expr>;
}</block>
<block>{
  <expr><index>[
     <expr><operator>&lt;</operator><name>PLUS</name><operator>&gt;</operator> <block>{ <expr><name>ret</name> <operator>=</operator> <name>MOD_REQ</name></expr></block></expr></index>;</expr> }</block>
     <operator>|</operator> <operator>&lt;</operator><name>MINUS</name><operator>&gt;</operator> <block>{ <expr><name>ret</name> <operator>=</operator> <name>MOD_NOT</name></expr>; }</block>
     <operator>|</operator> <operator>&lt;</operator><name>NOT</name><operator>&gt;</operator> <block>{ <expr><name>ret</name> <operator>=</operator> <name>MOD_NOT</name></expr>; }</block>
  ]
  <block>{ <return>return <expr><name>ret</name></expr>;</return> }</block></expr></expr_stmt>
}

<comment type="line">// This makes sure that there is no garbage after the query string</comment>
Query <expr_stmt><expr><call><name>TopLevelQuery</name><argument_list>(<argument><expr><name>String</name> <name>field</name></expr></argument>)</argument_list></call> <throws>throws <argument><expr><name>SyntaxError</name></expr></argument></throws> <operator>:</operator>
<block>{
  <expr><name>Query</name> <name>q</name></expr>;
}</block>
<block>{
  <expr><name>q</name><operator>=</operator><call><name>Query</name><argument_list>(<argument><expr><name>field</name></expr></argument>)</argument_list></call> <operator>&lt;</operator><name>EOF</name><operator>&gt;</operator>
  <block>{
    <return>return <expr><name>q</name></expr>;</return></block></expr>
  }</block></expr></expr_stmt>
}

Query <expr_stmt><expr><call><name>Query</name><argument_list>(<argument><expr><name>String</name> <name>field</name></expr></argument>)</argument_list></call> <throws>throws <argument><expr><name>SyntaxError</name></expr></argument></throws> <operator>:</operator>
<block>{
  <expr><name><name>List</name><argument_list type="generic">&lt;<argument><name>BooleanClause</name></argument>&gt;</argument_list></name> <name>clauses</name> <operator>=</operator> <operator>new</operator> <call><name><name>ArrayList</name><argument_list type="generic">&lt;<argument><name>BooleanClause</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;
  <expr><name>Query</name> <name>q</name></expr>, <expr><name>firstQuery</name><operator>=</operator><literal type="null">null</literal></expr>;
  <expr><name>int</name> <name>conj</name></expr>, <expr><name>mods</name></expr>;
}</block>
<block>{
  <expr><name>mods</name><operator>=</operator><call><name>Modifiers</name><argument_list>()</argument_list></call> <name>q</name><operator>=</operator><call><name>Clause</name><argument_list>(<argument><expr><name>field</name></expr></argument>)</argument_list></call>
  <block>{
    <expr><call><name>addClause</name><argument_list>(<argument><expr><name>clauses</name></expr></argument>, <argument><expr><name>CONJ_NONE</name></expr></argument>, <argument><expr><name>mods</name></expr></argument>, <argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;
    <if_stmt><if>if <condition>(<expr><name>mods</name> <operator>==</operator> <name>MOD_NONE</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>firstQuery</name><operator>=</operator><name>q</name></expr>;</expr_stmt></block_content></block></if></if_stmt></block></expr>
  }</block>
  <operator>(</operator>
    <name>conj</name><operator>=</operator><call><name>Conjunction</name><argument_list>()</argument_list></call> <name>mods</name><operator>=</operator><call><name>Modifiers</name><argument_list>()</argument_list></call> <name>q</name><operator>=</operator><call><name>Clause</name><argument_list>(<argument><expr><name>field</name></expr></argument>)</argument_list></call>
    <block>{ <expr><call><name>addClause</name><argument_list>(<argument><expr><name>clauses</name></expr></argument>, <argument><expr><name>conj</name></expr></argument>, <argument><expr><name>mods</name></expr></argument>, <argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>; }</block>
  <operator>)</operator><operator>*</operator>
    <block>{
      <if_stmt><if>if <condition>(<expr><call><name><name>clauses</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>firstQuery</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>firstQuery</name></expr>;</return></block_content></block></if>
      <else>else <block>{<block_content>
  <return>return <expr><call><name>getBooleanQuery</name><argument_list>(<argument><expr><name>clauses</name></expr></argument>)</argument_list></call></expr>;</return>
      <expr_stmt/></block_content></block></else></if_stmt>}</block></expr></expr_stmt>
    }
}

<macro><name>Query</name></macro> <expr_stmt><expr><call><name>Clause</name><argument_list>(<argument><expr><name>String</name> <name>field</name></expr></argument>)</argument_list></call> <throws>throws <argument><expr><name>SyntaxError</name></expr></argument></throws> <operator>:</operator> <block>{
  <expr><name>Query</name> <name>q</name></expr>;
  <expr><name>Token</name> <name>fieldToken</name><operator>=</operator><literal type="null">null</literal></expr>, <expr><name>boost</name><operator>=</operator><literal type="null">null</literal></expr>;
  <expr><name>Token</name> <name>localParams</name><operator>=</operator><literal type="null">null</literal></expr>;
}</block>
<block>{
 
  <expr><index>[
    <expr><call><name>LOOKAHEAD</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call>
    <operator>(</operator>
    <name>fieldToken</name><operator>=</operator><operator>&lt;</operator><name>TERM</name><operator>&gt;</operator> <operator>&lt;</operator><name>COLON</name><operator>&gt;</operator> <block>{<expr><name>field</name><operator>=</operator><call><name>discardEscapeChar</name><argument_list>(<argument><expr><name><name>fieldToken</name><operator>.</operator><name>image</name></name></expr></argument>)</argument_list></call></expr></block></expr></index>;</expr>}</block>
    <operator>|</operator> <operator>&lt;</operator><name>STAR</name><operator>&gt;</operator> <operator>&lt;</operator><name>COLON</name><operator>&gt;</operator> <block>{<expr><name>field</name><operator>=</operator><literal type="string">"*"</literal></expr>;}</block></expr></expr_stmt>
    )
  ]


  <expr_stmt><expr><operator>(</operator>
   <name>q</name><operator>=</operator><call><name>Term</name><argument_list>(<argument><expr><name>field</name></expr></argument>)</argument_list></call>
   <operator>|</operator> <operator>&lt;</operator><name>LPAREN</name><operator>&gt;</operator> <name>q</name><operator>=</operator><ternary><condition><expr><call><name>Query</name><argument_list>(<argument><expr><name>field</name></expr></argument>)</argument_list></call> <call><argument_list type="generic">&lt;<argument><name>RPAREN</name></argument>&gt;</argument_list> <argument_list>(<argument><expr><operator>&lt;</operator><name>CARAT</name><operator>&gt;</operator> <name>boost</name><operator>=</operator><operator>&lt;</operator><name>NUMBER</name><operator>&gt;</operator></expr></argument>)</argument_list></call></expr>?</condition><then>
   <operator>|</operator> <expr><operator>(</operator><name>localParams</name> <operator>=</operator> <ternary><condition><expr><call><argument_list type="generic">&lt;<argument><name>LPARAMS</name></argument>&gt;</argument_list> <argument_list>(<argument><expr><operator>&lt;</operator><name>CARAT</name><operator>&gt;</operator> <name>boost</name><operator>=</operator><operator>&lt;</operator><name>NUMBER</name><operator>&gt;</operator></expr></argument>)</argument_list></call></expr>?</condition><then> <expr><block>{ <expr><name>q</name><operator>=</operator><call><name>getLocalParams</name><argument_list>(<argument><expr><name>field</name></expr></argument>, <argument><expr><name><name>localParams</name><operator>.</operator><name>image</name></name></expr></argument>)</argument_list></call></expr>; }</block></expr></then></ternary>  <operator>)</operator></expr></then></ternary>
  <operator>)</operator>
    <block>{  <return>return <expr><call><name>handleBoost</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name>boost</name></expr></argument>)</argument_list></call></expr>;</return> }</block></expr></expr_stmt>
}


Query <expr_stmt><expr><call><name>Term</name><argument_list>(<argument><expr><name>String</name> <name>field</name></expr></argument>)</argument_list></call> <throws>throws <argument><expr><name>SyntaxError</name></expr></argument></throws> <operator>:</operator> <block>{
  <expr><name>Token</name> <name>term</name></expr>, <expr><name>boost</name><operator>=</operator><literal type="null">null</literal></expr>, <expr><name>fuzzySlop</name><operator>=</operator><literal type="null">null</literal></expr>, <expr><name>goop1</name></expr>, <expr><name>goop2</name></expr>;
  <expr><name>boolean</name> <name>prefix</name> <operator>=</operator> <literal type="boolean">false</literal></expr>;
  <expr><name>boolean</name> <name>wildcard</name> <operator>=</operator> <literal type="boolean">false</literal></expr>;
  <expr><name>boolean</name> <name>fuzzy</name> <operator>=</operator> <literal type="boolean">false</literal></expr>;
  <expr><name>boolean</name> <name>regexp</name> <operator>=</operator> <literal type="boolean">false</literal></expr>;
  <expr><name>boolean</name> <name>startInc</name><operator>=</operator><literal type="boolean">false</literal></expr>;
  <expr><name>boolean</name> <name>endInc</name><operator>=</operator><literal type="boolean">false</literal></expr>;
  <expr><name>Query</name> <name>q</name></expr>;
}</block>
<block>{
  <expr><operator>(</operator>
    <operator>(</operator>
      <name>term</name><operator>=</operator><operator>&lt;</operator><name>TERM</name><operator>&gt;</operator>
      <operator>|</operator> <name>term</name><operator>=</operator><operator>&lt;</operator><name>STAR</name><operator>&gt;</operator> <block>{ <expr><name>wildcard</name><operator>=</operator><literal type="boolean">true</literal></expr>; }</block>
      <operator>|</operator> <name>term</name><operator>=</operator><operator>&lt;</operator><name>PREFIXTERM</name><operator>&gt;</operator> <block>{ <expr><name>prefix</name><operator>=</operator><literal type="boolean">true</literal></expr>; }</block>
      <operator>|</operator> <name>term</name><operator>=</operator><operator>&lt;</operator><name>WILDTERM</name><operator>&gt;</operator> <block>{ <expr><name>wildcard</name><operator>=</operator><literal type="boolean">true</literal></expr>; }</block>
      <operator>|</operator> <name>term</name><operator>=</operator><operator>&lt;</operator><name>REGEXPTERM</name><operator>&gt;</operator> <block>{ <expr><name>regexp</name><operator>=</operator><literal type="boolean">true</literal></expr>; }</block>
      <operator>|</operator> <name>term</name><operator>=</operator><operator>&lt;</operator><name>NUMBER</name><operator>&gt;</operator>
      <operator>|</operator> <name>term</name><operator>=</operator><operator>&lt;</operator><name>BAREOPER</name><operator>&gt;</operator> <block>{ <expr><name><name>term</name><operator>.</operator><name>image</name></name> <operator>=</operator> <call><name><name>term</name><operator>.</operator><name>image</name><operator>.</operator><name>substring</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>; }</block>
    <operator>)</operator>
    <index>[ <expr><name>fuzzySlop</name><operator>=</operator><operator>&lt;</operator><name>FUZZY_SLOP</name><operator>&gt;</operator> <block>{ <expr><name>fuzzy</name><operator>=</operator><literal type="boolean">true</literal></expr></block></expr></index>;</expr> }</block> ]
    <index>[ <expr><operator>&lt;</operator><name>CARAT</name><operator>&gt;</operator> <name>boost</name><operator>=</operator><operator>&lt;</operator><name>NUMBER</name><operator>&gt;</operator> <index>[ <expr><name>fuzzySlop</name><operator>=</operator><operator>&lt;</operator><name>FUZZY_SLOP</name><operator>&gt;</operator> <block>{ <expr><name>fuzzy</name><operator>=</operator><literal type="boolean">true</literal></expr></block></expr></index></expr></index>;</expr></expr_stmt> } ] ]
    <block>{<block_content>
      <expr_stmt><expr><name>q</name> <operator>=</operator> <call><name>handleBareTokenQuery</name><argument_list>(<argument><expr><call><name>getField</name><argument_list>(<argument><expr><name>field</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>term</name></expr></argument>, <argument><expr><name>fuzzySlop</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>wildcard</name></expr></argument>, <argument><expr><name>fuzzy</name></expr></argument>, <argument><expr><name>regexp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    <operator>|</operator> <expr_stmt><expr><operator>(</operator> <operator>(</operator> <operator>&lt;</operator><name>RANGEIN_START</name><operator>&gt;</operator> <block>{<expr><name>startInc</name><operator>=</operator><literal type="boolean">true</literal></expr>;}</block> <operator>|</operator> <operator>&lt;</operator><name>RANGEEX_START</name><operator>&gt;</operator> <operator>)</operator>
        <operator>(</operator> <name>goop1</name><operator>=</operator><operator>&lt;</operator><name>RANGE_GOOP</name><operator>&gt;</operator><operator>|</operator><name>goop1</name><operator>=</operator><operator>&lt;</operator><name>RANGE_QUOTED</name><operator>&gt;</operator> <operator>)</operator>
        <index>[ <expr><operator>&lt;</operator><name>RANGE_TO</name><operator>&gt;</operator></expr> ]</index>
        <operator>(</operator> <name>goop2</name><operator>=</operator><operator>&lt;</operator><name>RANGE_GOOP</name><operator>&gt;</operator><operator>|</operator><name>goop2</name><operator>=</operator><operator>&lt;</operator><name>RANGE_QUOTED</name><operator>&gt;</operator> <operator>)</operator>
        <operator>(</operator> <operator>&lt;</operator><name>RANGEIN_END</name><operator>&gt;</operator> <block>{<expr><name>endInc</name><operator>=</operator><literal type="boolean">true</literal></expr>;}</block> <operator>|</operator> <operator>&lt;</operator><name>RANGEEX_END</name><operator>&gt;</operator><operator>)</operator><operator>)</operator>
      <index>[ <expr><operator>&lt;</operator><name>CARAT</name><operator>&gt;</operator> <name>boost</name><operator>=</operator><operator>&lt;</operator><name>NUMBER</name><operator>&gt;</operator></expr> ]</index>
       <block>{
         <expr><name>boolean</name> <name>startOpen</name><operator>=</operator><literal type="boolean">false</literal></expr>;
         <expr><name>boolean</name> <name>endOpen</name><operator>=</operator><literal type="boolean">false</literal></expr>;
         <if_stmt><if>if <condition>(<expr><name><name>goop1</name><operator>.</operator><name>kind</name></name> <operator>==</operator> <name>RANGE_QUOTED</name></expr>)</condition> <block>{<block_content>
           <expr_stmt><expr><name><name>goop1</name><operator>.</operator><name>image</name></name> <operator>=</operator> <call><name><name>goop1</name><operator>.</operator><name>image</name><operator>.</operator><name>substring</name></name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name><name>goop1</name><operator>.</operator><name>image</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
         <expr_stmt/></block_content></block></if></if_stmt>}</block></expr></expr_stmt> <if_stmt><if type="elseif">else if <condition>(<expr><literal type="string">"*"</literal><operator>.</operator><call><name>equals</name><argument_list>(<argument><expr><name><name>goop1</name><operator>.</operator><name>image</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
           <expr_stmt><expr><name>startOpen</name><operator>=</operator><literal type="boolean">true</literal></expr>;</expr_stmt>
         </block_content>}</block></if></if_stmt>
         <if_stmt><if>if <condition>(<expr><name><name>goop2</name><operator>.</operator><name>kind</name></name> <operator>==</operator> <name>RANGE_QUOTED</name></expr>)</condition> <block>{<block_content>
           <expr_stmt><expr><name><name>goop2</name><operator>.</operator><name>image</name></name> <operator>=</operator> <call><name><name>goop2</name><operator>.</operator><name>image</name><operator>.</operator><name>substring</name></name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name><name>goop2</name><operator>.</operator><name>image</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
         </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><literal type="string">"*"</literal><operator>.</operator><call><name>equals</name><argument_list>(<argument><expr><name><name>goop2</name><operator>.</operator><name>image</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
           <expr_stmt><expr><name>endOpen</name><operator>=</operator><literal type="boolean">true</literal></expr>;</expr_stmt>
         </block_content>}</block></if></if_stmt>
         <expr_stmt><expr><name>q</name> <operator>=</operator> <call><name>getRangeQuery</name><argument_list>(<argument><expr><call><name>getField</name><argument_list>(<argument><expr><name>field</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><ternary><condition><expr><name>startOpen</name></expr> ?</condition><then> <expr><literal type="null">null</literal></expr> </then><else>: <expr><call><name>discardEscapeChar</name><argument_list>(<argument><expr><name><name>goop1</name><operator>.</operator><name>image</name></name></expr></argument>)</argument_list></call></expr></else></ternary></expr></argument>, <argument><expr><ternary><condition><expr><name>endOpen</name></expr> ?</condition><then> <expr><literal type="null">null</literal></expr> </then><else>: <expr><call><name>discardEscapeChar</name><argument_list>(<argument><expr><name><name>goop2</name><operator>.</operator><name>image</name></name></expr></argument>)</argument_list></call></expr></else></ternary></expr></argument>, <argument><expr><name>startInc</name></expr></argument>, <argument><expr><name>endInc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
       }
    | <expr_stmt><expr><name>term</name><operator>=</operator><operator>&lt;</operator><name>QUOTED</name><operator>&gt;</operator>
      <index>[ <expr><name>fuzzySlop</name><operator>=</operator><operator>&lt;</operator><name>FUZZY_SLOP</name><operator>&gt;</operator></expr> ]</index>
      <index>[ <expr><operator>&lt;</operator><name>CARAT</name><operator>&gt;</operator> <name>boost</name><operator>=</operator><operator>&lt;</operator><name>NUMBER</name><operator>&gt;</operator></expr> ]</index>
      <block>{
        <expr><name>q</name> <operator>=</operator> <call><name>handleQuotedTerm</name><argument_list>(<argument><expr><call><name>getField</name><argument_list>(<argument><expr><name>field</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>term</name></expr></argument>, <argument><expr><name>fuzzySlop</name></expr></argument>)</argument_list></call></expr>;
      }</block></expr></expr_stmt>
  )
  <block>{<block_content>
    <return>return <expr><call><name>handleBoost</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name>boost</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block>
}
diff <expr_stmt><expr><operator>--</operator><name>git</name> <name>a</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>parser</name><operator>/</operator><name><name>QueryParserConstants</name><operator>.</operator><name>java</name></name> <name>b</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>parser</name><operator>/</operator><name><name>QueryParserConstants</name><operator>.</operator><name>java</name></name>
<operator>new</operator> <name>file</name> <name>mode</name> <literal type="number">100644</literal>
<name>index</name> <literal type="number">00000000000..2bb3d75a52f</literal>
<operator>--</operator> <operator>/</operator><name>dev</name><operator>/</operator><literal type="null">null</literal>
<operator>++</operator> <name>b</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>parser</name><operator>/</operator><name><name>QueryParserConstants</name><operator>.</operator><name>java</name></name>
@@ <operator>-</operator><literal type="number">0</literal></expr><operator>,</operator><expr><literal type="number">0</literal> <operator>+</operator><literal type="number">1</literal></expr><operator>,</operator><expr><literal type="number">129</literal> @@</expr></expr_stmt>
<comment type="block">/* Generated By:JavaCC: Do not edit this line. QueryParserConstants.java */</comment>
<package>package <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>parser</name></name>;</package>


<comment type="block" format="javadoc">/**
 * Token literal values and constants.
 * Generated by org.javacc.parser.OtherFilesGen#start()
 */</comment>
<interface><specifier>public</specifier> interface <name>QueryParserConstants</name> <block>{

  <comment type="block" format="javadoc">/** End of File. */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>EOF</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <comment type="block" format="javadoc">/** RegularExpression Id. */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>_NUM_CHAR</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <comment type="block" format="javadoc">/** RegularExpression Id. */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>_ESCAPED_CHAR</name> <init>= <expr><literal type="number">2</literal></expr></init></decl>;</decl_stmt>
  <comment type="block" format="javadoc">/** RegularExpression Id. */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>_TERM_START_CHAR</name> <init>= <expr><literal type="number">3</literal></expr></init></decl>;</decl_stmt>
  <comment type="block" format="javadoc">/** RegularExpression Id. */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>_TERM_CHAR</name> <init>= <expr><literal type="number">4</literal></expr></init></decl>;</decl_stmt>
  <comment type="block" format="javadoc">/** RegularExpression Id. */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>_WHITESPACE</name> <init>= <expr><literal type="number">5</literal></expr></init></decl>;</decl_stmt>
  <comment type="block" format="javadoc">/** RegularExpression Id. */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>_QUOTED_CHAR</name> <init>= <expr><literal type="number">6</literal></expr></init></decl>;</decl_stmt>
  <comment type="block" format="javadoc">/** RegularExpression Id. */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>_SQUOTED_CHAR</name> <init>= <expr><literal type="number">7</literal></expr></init></decl>;</decl_stmt>
  <comment type="block" format="javadoc">/** RegularExpression Id. */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>AND</name> <init>= <expr><literal type="number">9</literal></expr></init></decl>;</decl_stmt>
  <comment type="block" format="javadoc">/** RegularExpression Id. */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>OR</name> <init>= <expr><literal type="number">10</literal></expr></init></decl>;</decl_stmt>
  <comment type="block" format="javadoc">/** RegularExpression Id. */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>NOT</name> <init>= <expr><literal type="number">11</literal></expr></init></decl>;</decl_stmt>
  <comment type="block" format="javadoc">/** RegularExpression Id. */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>PLUS</name> <init>= <expr><literal type="number">12</literal></expr></init></decl>;</decl_stmt>
  <comment type="block" format="javadoc">/** RegularExpression Id. */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>MINUS</name> <init>= <expr><literal type="number">13</literal></expr></init></decl>;</decl_stmt>
  <comment type="block" format="javadoc">/** RegularExpression Id. */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>BAREOPER</name> <init>= <expr><literal type="number">14</literal></expr></init></decl>;</decl_stmt>
  <comment type="block" format="javadoc">/** RegularExpression Id. */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>LPAREN</name> <init>= <expr><literal type="number">15</literal></expr></init></decl>;</decl_stmt>
  <comment type="block" format="javadoc">/** RegularExpression Id. */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>RPAREN</name> <init>= <expr><literal type="number">16</literal></expr></init></decl>;</decl_stmt>
  <comment type="block" format="javadoc">/** RegularExpression Id. */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>COLON</name> <init>= <expr><literal type="number">17</literal></expr></init></decl>;</decl_stmt>
  <comment type="block" format="javadoc">/** RegularExpression Id. */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>STAR</name> <init>= <expr><literal type="number">18</literal></expr></init></decl>;</decl_stmt>
  <comment type="block" format="javadoc">/** RegularExpression Id. */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>CARAT</name> <init>= <expr><literal type="number">19</literal></expr></init></decl>;</decl_stmt>
  <comment type="block" format="javadoc">/** RegularExpression Id. */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>QUOTED</name> <init>= <expr><literal type="number">20</literal></expr></init></decl>;</decl_stmt>
  <comment type="block" format="javadoc">/** RegularExpression Id. */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>SQUOTED</name> <init>= <expr><literal type="number">21</literal></expr></init></decl>;</decl_stmt>
  <comment type="block" format="javadoc">/** RegularExpression Id. */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>TERM</name> <init>= <expr><literal type="number">22</literal></expr></init></decl>;</decl_stmt>
  <comment type="block" format="javadoc">/** RegularExpression Id. */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>FUZZY_SLOP</name> <init>= <expr><literal type="number">23</literal></expr></init></decl>;</decl_stmt>
  <comment type="block" format="javadoc">/** RegularExpression Id. */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>PREFIXTERM</name> <init>= <expr><literal type="number">24</literal></expr></init></decl>;</decl_stmt>
  <comment type="block" format="javadoc">/** RegularExpression Id. */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>WILDTERM</name> <init>= <expr><literal type="number">25</literal></expr></init></decl>;</decl_stmt>
  <comment type="block" format="javadoc">/** RegularExpression Id. */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>REGEXPTERM</name> <init>= <expr><literal type="number">26</literal></expr></init></decl>;</decl_stmt>
  <comment type="block" format="javadoc">/** RegularExpression Id. */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>RANGEIN_START</name> <init>= <expr><literal type="number">27</literal></expr></init></decl>;</decl_stmt>
  <comment type="block" format="javadoc">/** RegularExpression Id. */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>RANGEEX_START</name> <init>= <expr><literal type="number">28</literal></expr></init></decl>;</decl_stmt>
  <comment type="block" format="javadoc">/** RegularExpression Id. */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>LPARAMS</name> <init>= <expr><literal type="number">29</literal></expr></init></decl>;</decl_stmt>
  <comment type="block" format="javadoc">/** RegularExpression Id. */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>NUMBER</name> <init>= <expr><literal type="number">30</literal></expr></init></decl>;</decl_stmt>
  <comment type="block" format="javadoc">/** RegularExpression Id. */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>RANGE_TO</name> <init>= <expr><literal type="number">31</literal></expr></init></decl>;</decl_stmt>
  <comment type="block" format="javadoc">/** RegularExpression Id. */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>RANGEIN_END</name> <init>= <expr><literal type="number">32</literal></expr></init></decl>;</decl_stmt>
  <comment type="block" format="javadoc">/** RegularExpression Id. */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>RANGEEX_END</name> <init>= <expr><literal type="number">33</literal></expr></init></decl>;</decl_stmt>
  <comment type="block" format="javadoc">/** RegularExpression Id. */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>RANGE_QUOTED</name> <init>= <expr><literal type="number">34</literal></expr></init></decl>;</decl_stmt>
  <comment type="block" format="javadoc">/** RegularExpression Id. */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>RANGE_GOOP</name> <init>= <expr><literal type="number">35</literal></expr></init></decl>;</decl_stmt>

  <comment type="block" format="javadoc">/** Lexical state. */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>Boost</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <comment type="block" format="javadoc">/** Lexical state. */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>Range</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <comment type="block" format="javadoc">/** Lexical state. */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>DEFAULT</name> <init>= <expr><literal type="number">2</literal></expr></init></decl>;</decl_stmt>

  <comment type="block" format="javadoc">/** Literal token values. */</comment>
  <decl_stmt><decl><type><name><name>String</name><index>[]</index></name></type> <name>tokenImage</name> <init>= <expr><block>{
    <expr><literal type="string">"&lt;EOF&gt;"</literal></expr>,
    <expr><literal type="string">"&lt;_NUM_CHAR&gt;"</literal></expr>,
    <expr><literal type="string">"&lt;_ESCAPED_CHAR&gt;"</literal></expr>,
    <expr><literal type="string">"&lt;_TERM_START_CHAR&gt;"</literal></expr>,
    <expr><literal type="string">"&lt;_TERM_CHAR&gt;"</literal></expr>,
    <expr><literal type="string">"&lt;_WHITESPACE&gt;"</literal></expr>,
    <expr><literal type="string">"&lt;_QUOTED_CHAR&gt;"</literal></expr>,
    <expr><literal type="string">"&lt;_SQUOTED_CHAR&gt;"</literal></expr>,
    <expr><literal type="string">"&lt;token of kind 8&gt;"</literal></expr>,
    <expr><literal type="string">"&lt;AND&gt;"</literal></expr>,
    <expr><literal type="string">"&lt;OR&gt;"</literal></expr>,
    <expr><literal type="string">"&lt;NOT&gt;"</literal></expr>,
    <expr><literal type="string">"\"+\""</literal></expr>,
    <expr><literal type="string">"\"-\""</literal></expr>,
    <expr><literal type="string">"&lt;BAREOPER&gt;"</literal></expr>,
    <expr><literal type="string">"\"(\""</literal></expr>,
    <expr><literal type="string">"\")\""</literal></expr>,
    <expr><literal type="string">"\":\""</literal></expr>,
    <expr><literal type="string">"\"*\""</literal></expr>,
    <expr><literal type="string">"\"^\""</literal></expr>,
    <expr><literal type="string">"&lt;QUOTED&gt;"</literal></expr>,
    <expr><literal type="string">"&lt;SQUOTED&gt;"</literal></expr>,
    <expr><literal type="string">"&lt;TERM&gt;"</literal></expr>,
    <expr><literal type="string">"&lt;FUZZY_SLOP&gt;"</literal></expr>,
    <expr><literal type="string">"&lt;PREFIXTERM&gt;"</literal></expr>,
    <expr><literal type="string">"&lt;WILDTERM&gt;"</literal></expr>,
    <expr><literal type="string">"&lt;REGEXPTERM&gt;"</literal></expr>,
    <expr><literal type="string">"\"[\""</literal></expr>,
    <expr><literal type="string">"\"{\""</literal></expr>,
    <expr><literal type="string">"&lt;LPARAMS&gt;"</literal></expr>,
    <expr><literal type="string">"&lt;NUMBER&gt;"</literal></expr>,
    <expr><literal type="string">"\"TO\""</literal></expr>,
    <expr><literal type="string">"\"]\""</literal></expr>,
    <expr><literal type="string">"\"}\""</literal></expr>,
    <expr><literal type="string">"&lt;RANGE_QUOTED&gt;"</literal></expr>,
    <expr><literal type="string">"&lt;RANGE_GOOP&gt;"</literal></expr>,
  }</block></expr></init></decl>;</decl_stmt>

}</block></interface>
<expr_stmt><expr><name>diff</name> <operator>--</operator><name>git</name> <name>a</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>parser</name><operator>/</operator><name><name>QueryParserTokenManager</name><operator>.</operator><name>java</name></name> <name>b</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>parser</name><operator>/</operator><name><name>QueryParserTokenManager</name><operator>.</operator><name>java</name></name>
<operator>new</operator> <name>file</name> <name>mode</name> <literal type="number">100644</literal>
<name>index</name> <literal type="number">00000000000..0f6c1529a03</literal>
<operator>--</operator> <operator>/</operator><name>dev</name><operator>/</operator><literal type="null">null</literal>
<operator>++</operator> <name>b</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>parser</name><operator>/</operator><name><name>QueryParserTokenManager</name><operator>.</operator><name>java</name></name>
@@ <operator>-</operator><literal type="number">0</literal></expr><operator>,</operator><expr><literal type="number">0</literal> <operator>+</operator><literal type="number">1</literal></expr><operator>,</operator><expr><literal type="number">1261</literal> @@</expr></expr_stmt>
<comment type="block">/* Generated By:JavaCC: Do not edit this line. QueryParserTokenManager.java */</comment>
<package>package <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>parser</name></name>;</package>
<import>import <name><name>java</name><operator>.</operator><name>io</name><operator>.</operator><name>StringReader</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>ArrayList</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>List</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>Locale</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>analysis</name><operator>.</operator><name>Analyzer</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>document</name><operator>.</operator><name>DateTools</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>search</name><operator>.</operator><name>BooleanClause</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>search</name><operator>.</operator><name>Query</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>search</name><operator>.</operator><name>TermRangeQuery</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>search</name><operator>.</operator><name>TermQuery</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>util</name><operator>.</operator><name>Version</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>search</name><operator>.</operator><name>SyntaxError</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>search</name><operator>.</operator><name>QParser</name></name>;</import>

<comment type="block" format="javadoc">/** Token Manager. */</comment>
<class><specifier>public</specifier> class <name>QueryParserTokenManager</name> <super_list><implements>implements <super><name>QueryParserConstants</name></super></implements></super_list>
<block>{

  <comment type="block" format="javadoc">/** Debug output. */</comment>
  <decl_stmt><decl><type><specifier>public</specifier>  <name><name>java</name><operator>.</operator><name>io</name><operator>.</operator><name>PrintStream</name></name></type> <name>debugStream</name> <init>= <expr><name><name>System</name><operator>.</operator><name>out</name></name></expr></init></decl>;</decl_stmt>
  <comment type="block" format="javadoc">/** Set debug output. */</comment>
  <function><type><specifier>public</specifier>  <name>void</name></type> <name>setDebugStream</name><parameter_list>(<parameter><decl><type><name><name>java</name><operator>.</operator><name>io</name><operator>.</operator><name>PrintStream</name></name></type> <name>ds</name></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><name>debugStream</name> <operator>=</operator> <name>ds</name></expr>;</expr_stmt> </block_content>}</block></function>
<function><type><specifier>private</specifier> <specifier>final</specifier> <name>int</name></type> <name>jjStopStringLiteralDfa_2</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>pos</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>active0</name></decl></parameter>)</parameter_list>
<block>{<block_content>
   <switch>switch <condition>(<expr><name>pos</name></expr>)</condition>
   <block>{<block_content>
      <default>default :</default>
         <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
   </block_content>}</block></switch>
</block_content>}</block></function>
<function><type><specifier>private</specifier> <specifier>final</specifier> <name>int</name></type> <name>jjStartNfa_2</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>pos</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>active0</name></decl></parameter>)</parameter_list>
<block>{<block_content>
   <return>return <expr><call><name>jjMoveNfa_2</name><argument_list>(<argument><expr><call><name>jjStopStringLiteralDfa_2</name><argument_list>(<argument><expr><name>pos</name></expr></argument>, <argument><expr><name>active0</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pos</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>private</specifier> <name>int</name></type> <name>jjStopAtPos</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>pos</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>kind</name></decl></parameter>)</parameter_list>
<block>{<block_content>
   <expr_stmt><expr><name>jjmatchedKind</name> <operator>=</operator> <name>kind</name></expr>;</expr_stmt>
   <expr_stmt><expr><name>jjmatchedPos</name> <operator>=</operator> <name>pos</name></expr>;</expr_stmt>
   <return>return <expr><name>pos</name> <operator>+</operator> <literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>private</specifier> <name>int</name></type> <name>jjMoveStringLiteralDfa0_2</name><parameter_list>()</parameter_list>
<block>{<block_content>
   <switch>switch<condition>(<expr><name>curChar</name></expr>)</condition>
   <block>{<block_content>
      <case>case <expr><literal type="number">40</literal></expr>:</case>
         <return>return <expr><call><name>jjStopAtPos</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">15</literal></expr></argument>)</argument_list></call></expr>;</return>
      <case>case <expr><literal type="number">41</literal></expr>:</case>
         <return>return <expr><call><name>jjStopAtPos</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</return>
      <case>case <expr><literal type="number">42</literal></expr>:</case>
         <return>return <expr><call><name>jjStartNfaWithStates_2</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">18</literal></expr></argument>, <argument><expr><literal type="number">66</literal></expr></argument>)</argument_list></call></expr>;</return>
      <case>case <expr><literal type="number">43</literal></expr>:</case>
         <return>return <expr><call><name>jjStartNfaWithStates_2</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">12</literal></expr></argument>, <argument><expr><literal type="number">15</literal></expr></argument>)</argument_list></call></expr>;</return>
      <case>case <expr><literal type="number">45</literal></expr>:</case>
         <return>return <expr><call><name>jjStartNfaWithStates_2</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">13</literal></expr></argument>, <argument><expr><literal type="number">15</literal></expr></argument>)</argument_list></call></expr>;</return>
      <case>case <expr><literal type="number">58</literal></expr>:</case>
         <return>return <expr><call><name>jjStopAtPos</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">17</literal></expr></argument>)</argument_list></call></expr>;</return>
      <case>case <expr><literal type="number">91</literal></expr>:</case>
         <return>return <expr><call><name>jjStopAtPos</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">27</literal></expr></argument>)</argument_list></call></expr>;</return>
      <case>case <expr><literal type="number">94</literal></expr>:</case>
         <return>return <expr><call><name>jjStopAtPos</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">19</literal></expr></argument>)</argument_list></call></expr>;</return>
      <case>case <expr><literal type="number">123</literal></expr>:</case>
         <return>return <expr><call><name>jjStartNfaWithStates_2</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">28</literal></expr></argument>, <argument><expr><literal type="number">40</literal></expr></argument>)</argument_list></call></expr>;</return>
      <default>default :</default>
         <return>return <expr><call><name>jjMoveNfa_2</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
   </block_content>}</block></switch>
</block_content>}</block></function>
<function><type><specifier>private</specifier> <name>int</name></type> <name>jjStartNfaWithStates_2</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>pos</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>kind</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
   <expr_stmt><expr><name>jjmatchedKind</name> <operator>=</operator> <name>kind</name></expr>;</expr_stmt>
   <expr_stmt><expr><name>jjmatchedPos</name> <operator>=</operator> <name>pos</name></expr>;</expr_stmt>
   <try>try <block>{<block_content> <expr_stmt><expr><name>curChar</name> <operator>=</operator> <call><name><name>input_stream</name><operator>.</operator><name>readChar</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt> </block_content>}</block>
   <catch>catch<parameter_list>(<parameter><decl><type><name><name>java</name><operator>.</operator><name>io</name><operator>.</operator><name>IOException</name></name></type> <name>e</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><name>pos</name> <operator>+</operator> <literal type="number">1</literal></expr>;</return> </block_content>}</block></catch></try>
   <return>return <expr><call><name>jjMoveNfa_2</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>pos</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>final</specifier> <name><name>long</name><index>[]</index></name></type> <name>jjbitVec0</name> <init>= <expr><block>{
   <expr><literal type="number">0x1L</literal></expr>, <expr><literal type="number">0x0L</literal></expr>, <expr><literal type="number">0x0L</literal></expr>, <expr><literal type="number">0x0L</literal></expr>
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>final</specifier> <name><name>long</name><index>[]</index></name></type> <name>jjbitVec1</name> <init>= <expr><block>{
   <expr><literal type="number">0xfffffffffffffffeL</literal></expr>, <expr><literal type="number">0xffffffffffffffffL</literal></expr>, <expr><literal type="number">0xffffffffffffffffL</literal></expr>, <expr><literal type="number">0xffffffffffffffffL</literal></expr>
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>final</specifier> <name><name>long</name><index>[]</index></name></type> <name>jjbitVec3</name> <init>= <expr><block>{
   <expr><literal type="number">0x0L</literal></expr>, <expr><literal type="number">0x0L</literal></expr>, <expr><literal type="number">0xffffffffffffffffL</literal></expr>, <expr><literal type="number">0xffffffffffffffffL</literal></expr>
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>final</specifier> <name><name>long</name><index>[]</index></name></type> <name>jjbitVec4</name> <init>= <expr><block>{
   <expr><literal type="number">0xfffefffffffffffeL</literal></expr>, <expr><literal type="number">0xffffffffffffffffL</literal></expr>, <expr><literal type="number">0xffffffffffffffffL</literal></expr>, <expr><literal type="number">0xffffffffffffffffL</literal></expr>
}</block></expr></init></decl>;</decl_stmt>
<function><type><specifier>private</specifier> <name>int</name></type> <name>jjMoveNfa_2</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>startState</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>curPos</name></decl></parameter>)</parameter_list>
<block>{<block_content>
   <decl_stmt><decl><type><name>int</name></type> <name>startsAt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
   <expr_stmt><expr><name>jjnewStateCnt</name> <operator>=</operator> <literal type="number">66</literal></expr>;</expr_stmt>
   <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
   <expr_stmt><expr><name><name>jjstateSet</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>startState</name></expr>;</expr_stmt>
   <decl_stmt><decl><type><name>int</name></type> <name>kind</name> <init>= <expr><literal type="number">0x7fffffff</literal></expr></init></decl>;</decl_stmt>
   <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
   <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><operator>++</operator><name>jjround</name> <operator>==</operator> <literal type="number">0x7fffffff</literal></expr>)</condition><block type="pseudo"><block_content>
         <expr_stmt><expr><call><name>ReInitRounds</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><name>curChar</name> <operator>&lt;</operator> <literal type="number">64</literal></expr>)</condition>
      <block>{<block_content>
         <decl_stmt><decl><type><name>long</name></type> <name>l</name> <init>= <expr><literal type="number">1L</literal> <operator>&lt;&lt;</operator> <name>curChar</name></expr></init></decl>;</decl_stmt>
         <do>do
         <block>{<block_content>
            <switch>switch<condition>(<expr><name><name>jjstateSet</name><index>[<expr><operator>--</operator><name>i</name></expr>]</index></name></expr>)</condition>
            <block>{<block_content>
               <case>case <expr><literal type="number">66</literal></expr>:</case>
               <case>case <expr><literal type="number">32</literal></expr>:</case>
                  <if_stmt><if>if <condition>(<expr><operator>(</operator><literal type="number">0xfbfffcf8ffffd9ffL</literal> <operator>&amp;</operator> <name>l</name><operator>)</operator> <operator>==</operator> <literal type="number">0L</literal></expr>)</condition><block type="pseudo"><block_content>
                     <break>break;</break></block_content></block></if></if_stmt>
                  <if_stmt><if>if <condition>(<expr><name>kind</name> <operator>&gt;</operator> <literal type="number">25</literal></expr>)</condition><block type="pseudo"><block_content>
                     <expr_stmt><expr><name>kind</name> <operator>=</operator> <literal type="number">25</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
                  <expr_stmt><expr><call><name>jjCheckNAddTwoStates</name><argument_list>(<argument><expr><literal type="number">32</literal></expr></argument>, <argument><expr><literal type="number">33</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                  <break>break;</break>
               <case>case <expr><literal type="number">0</literal></expr>:</case>
                  <if_stmt><if>if <condition>(<expr><operator>(</operator><literal type="number">0xfbff54f8ffffd9ffL</literal> <operator>&amp;</operator> <name>l</name><operator>)</operator> <operator>!=</operator> <literal type="number">0L</literal></expr>)</condition>
                  <block>{<block_content>
                     <if_stmt><if>if <condition>(<expr><name>kind</name> <operator>&gt;</operator> <literal type="number">25</literal></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><name>kind</name> <operator>=</operator> <literal type="number">25</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
                     <expr_stmt><expr><call><name>jjCheckNAddTwoStates</name><argument_list>(<argument><expr><literal type="number">32</literal></expr></argument>, <argument><expr><literal type="number">33</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                  </block_content>}</block></if>
                  <if type="elseif">else if <condition>(<expr><operator>(</operator><literal type="number">0x100002600L</literal> <operator>&amp;</operator> <name>l</name><operator>)</operator> <operator>!=</operator> <literal type="number">0L</literal></expr>)</condition>
                  <block>{<block_content>
                     <if_stmt><if>if <condition>(<expr><name>kind</name> <operator>&gt;</operator> <literal type="number">8</literal></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><name>kind</name> <operator>=</operator> <literal type="number">8</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
                  </block_content>}</block></if>
                  <if type="elseif">else if <condition>(<expr><operator>(</operator><literal type="number">0x280200000000L</literal> <operator>&amp;</operator> <name>l</name><operator>)</operator> <operator>!=</operator> <literal type="number">0L</literal></expr>)</condition><block type="pseudo"><block_content>
                     <expr_stmt><expr><name><name>jjstateSet</name><index>[<expr><name>jjnewStateCnt</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="number">15</literal></expr>;</expr_stmt></block_content></block></if>
                  <if type="elseif">else if <condition>(<expr><name>curChar</name> <operator>==</operator> <literal type="number">47</literal></expr>)</condition><block type="pseudo"><block_content>
                     <expr_stmt><expr><call><name>jjCheckNAddStates</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                  <if type="elseif">else if <condition>(<expr><name>curChar</name> <operator>==</operator> <literal type="number">34</literal></expr>)</condition><block type="pseudo"><block_content>
                     <expr_stmt><expr><call><name>jjCheckNAddStates</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                  <if_stmt><if>if <condition>(<expr><operator>(</operator><literal type="number">0x7bff50f8ffffd9ffL</literal> <operator>&amp;</operator> <name>l</name><operator>)</operator> <operator>!=</operator> <literal type="number">0L</literal></expr>)</condition>
                  <block>{<block_content>
                     <if_stmt><if>if <condition>(<expr><name>kind</name> <operator>&gt;</operator> <literal type="number">22</literal></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><name>kind</name> <operator>=</operator> <literal type="number">22</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
                     <expr_stmt><expr><call><name>jjCheckNAddStates</name><argument_list>(<argument><expr><literal type="number">6</literal></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                  </block_content>}</block></if>
                  <if type="elseif">else if <condition>(<expr><name>curChar</name> <operator>==</operator> <literal type="number">42</literal></expr>)</condition>
                  <block>{<block_content>
                     <if_stmt><if>if <condition>(<expr><name>kind</name> <operator>&gt;</operator> <literal type="number">24</literal></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><name>kind</name> <operator>=</operator> <literal type="number">24</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
                  </block_content>}</block></if>
                  <if type="elseif">else if <condition>(<expr><name>curChar</name> <operator>==</operator> <literal type="number">33</literal></expr>)</condition>
                  <block>{<block_content>
                     <if_stmt><if>if <condition>(<expr><name>kind</name> <operator>&gt;</operator> <literal type="number">11</literal></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><name>kind</name> <operator>=</operator> <literal type="number">11</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
                  </block_content>}</block></if></if_stmt>
                  <if_stmt><if>if <condition>(<expr><name>curChar</name> <operator>==</operator> <literal type="number">39</literal></expr>)</condition><block type="pseudo"><block_content>
                     <expr_stmt><expr><call><name>jjCheckNAddStates</name><argument_list>(<argument><expr><literal type="number">11</literal></expr></argument>, <argument><expr><literal type="number">13</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                  <if type="elseif">else if <condition>(<expr><name>curChar</name> <operator>==</operator> <literal type="number">38</literal></expr>)</condition><block type="pseudo"><block_content>
                     <expr_stmt><expr><name><name>jjstateSet</name><index>[<expr><name>jjnewStateCnt</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
                  <break>break;</break>
               <case>case <expr><literal type="number">4</literal></expr>:</case>
                  <if_stmt><if>if <condition>(<expr><name>curChar</name> <operator>==</operator> <literal type="number">38</literal> <operator>&amp;&amp;</operator> <name>kind</name> <operator>&gt;</operator> <literal type="number">9</literal></expr>)</condition><block type="pseudo"><block_content>
                     <expr_stmt><expr><name>kind</name> <operator>=</operator> <literal type="number">9</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
                  <break>break;</break>
               <case>case <expr><literal type="number">5</literal></expr>:</case>
                  <if_stmt><if>if <condition>(<expr><name>curChar</name> <operator>==</operator> <literal type="number">38</literal></expr>)</condition><block type="pseudo"><block_content>
                     <expr_stmt><expr><name><name>jjstateSet</name><index>[<expr><name>jjnewStateCnt</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
                  <break>break;</break>
               <case>case <expr><literal type="number">13</literal></expr>:</case>
                  <if_stmt><if>if <condition>(<expr><name>curChar</name> <operator>==</operator> <literal type="number">33</literal> <operator>&amp;&amp;</operator> <name>kind</name> <operator>&gt;</operator> <literal type="number">11</literal></expr>)</condition><block type="pseudo"><block_content>
                     <expr_stmt><expr><name>kind</name> <operator>=</operator> <literal type="number">11</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
                  <break>break;</break>
               <case>case <expr><literal type="number">14</literal></expr>:</case>
                  <if_stmt><if>if <condition>(<expr><operator>(</operator><literal type="number">0x280200000000L</literal> <operator>&amp;</operator> <name>l</name><operator>)</operator> <operator>!=</operator> <literal type="number">0L</literal></expr>)</condition><block type="pseudo"><block_content>
                     <expr_stmt><expr><name><name>jjstateSet</name><index>[<expr><name>jjnewStateCnt</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="number">15</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
                  <break>break;</break>
               <case>case <expr><literal type="number">15</literal></expr>:</case>
                  <if_stmt><if>if <condition>(<expr><operator>(</operator><literal type="number">0x100002600L</literal> <operator>&amp;</operator> <name>l</name><operator>)</operator> <operator>!=</operator> <literal type="number">0L</literal> <operator>&amp;&amp;</operator> <name>kind</name> <operator>&gt;</operator> <literal type="number">14</literal></expr>)</condition><block type="pseudo"><block_content>
                     <expr_stmt><expr><name>kind</name> <operator>=</operator> <literal type="number">14</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
                  <break>break;</break>
               <case>case <expr><literal type="number">16</literal></expr>:</case>
                  <if_stmt><if>if <condition>(<expr><name>curChar</name> <operator>==</operator> <literal type="number">34</literal></expr>)</condition><block type="pseudo"><block_content>
                     <expr_stmt><expr><call><name>jjCheckNAddStates</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                  <break>break;</break>
               <case>case <expr><literal type="number">17</literal></expr>:</case>
                  <if_stmt><if>if <condition>(<expr><operator>(</operator><literal type="number">0xfffffffbffffffffL</literal> <operator>&amp;</operator> <name>l</name><operator>)</operator> <operator>!=</operator> <literal type="number">0L</literal></expr>)</condition><block type="pseudo"><block_content>
                     <expr_stmt><expr><call><name>jjCheckNAddStates</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                  <break>break;</break>
               <case>case <expr><literal type="number">19</literal></expr>:</case>
                  <expr_stmt><expr><call><name>jjCheckNAddStates</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                  <break>break;</break>
               <case>case <expr><literal type="number">20</literal></expr>:</case>
                  <if_stmt><if>if <condition>(<expr><name>curChar</name> <operator>==</operator> <literal type="number">34</literal> <operator>&amp;&amp;</operator> <name>kind</name> <operator>&gt;</operator> <literal type="number">20</literal></expr>)</condition><block type="pseudo"><block_content>
                     <expr_stmt><expr><name>kind</name> <operator>=</operator> <literal type="number">20</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
                  <break>break;</break>
               <case>case <expr><literal type="number">21</literal></expr>:</case>
                  <if_stmt><if>if <condition>(<expr><name>curChar</name> <operator>==</operator> <literal type="number">39</literal></expr>)</condition><block type="pseudo"><block_content>
                     <expr_stmt><expr><call><name>jjCheckNAddStates</name><argument_list>(<argument><expr><literal type="number">11</literal></expr></argument>, <argument><expr><literal type="number">13</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                  <break>break;</break>
               <case>case <expr><literal type="number">22</literal></expr>:</case>
                  <if_stmt><if>if <condition>(<expr><operator>(</operator><literal type="number">0xffffff7fffffffffL</literal> <operator>&amp;</operator> <name>l</name><operator>)</operator> <operator>!=</operator> <literal type="number">0L</literal></expr>)</condition><block type="pseudo"><block_content>
                     <expr_stmt><expr><call><name>jjCheckNAddStates</name><argument_list>(<argument><expr><literal type="number">11</literal></expr></argument>, <argument><expr><literal type="number">13</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                  <break>break;</break>
               <case>case <expr><literal type="number">24</literal></expr>:</case>
                  <expr_stmt><expr><call><name>jjCheckNAddStates</name><argument_list>(<argument><expr><literal type="number">11</literal></expr></argument>, <argument><expr><literal type="number">13</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                  <break>break;</break>
               <case>case <expr><literal type="number">25</literal></expr>:</case>
                  <if_stmt><if>if <condition>(<expr><name>curChar</name> <operator>==</operator> <literal type="number">39</literal> <operator>&amp;&amp;</operator> <name>kind</name> <operator>&gt;</operator> <literal type="number">21</literal></expr>)</condition><block type="pseudo"><block_content>
                     <expr_stmt><expr><name>kind</name> <operator>=</operator> <literal type="number">21</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
                  <break>break;</break>
               <case>case <expr><literal type="number">27</literal></expr>:</case>
                  <if_stmt><if>if <condition>(<expr><operator>(</operator><literal type="number">0x3ff000000000000L</literal> <operator>&amp;</operator> <name>l</name><operator>)</operator> <operator>==</operator> <literal type="number">0L</literal></expr>)</condition><block type="pseudo"><block_content>
                     <break>break;</break></block_content></block></if></if_stmt>
                  <if_stmt><if>if <condition>(<expr><name>kind</name> <operator>&gt;</operator> <literal type="number">23</literal></expr>)</condition><block type="pseudo"><block_content>
                     <expr_stmt><expr><name>kind</name> <operator>=</operator> <literal type="number">23</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
                  <expr_stmt><expr><call><name>jjAddStates</name><argument_list>(<argument><expr><literal type="number">14</literal></expr></argument>, <argument><expr><literal type="number">15</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                  <break>break;</break>
               <case>case <expr><literal type="number">28</literal></expr>:</case>
                  <if_stmt><if>if <condition>(<expr><name>curChar</name> <operator>==</operator> <literal type="number">46</literal></expr>)</condition><block type="pseudo"><block_content>
                     <expr_stmt><expr><call><name>jjCheckNAdd</name><argument_list>(<argument><expr><literal type="number">29</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                  <break>break;</break>
               <case>case <expr><literal type="number">29</literal></expr>:</case>
                  <if_stmt><if>if <condition>(<expr><operator>(</operator><literal type="number">0x3ff000000000000L</literal> <operator>&amp;</operator> <name>l</name><operator>)</operator> <operator>==</operator> <literal type="number">0L</literal></expr>)</condition><block type="pseudo"><block_content>
                     <break>break;</break></block_content></block></if></if_stmt>
                  <if_stmt><if>if <condition>(<expr><name>kind</name> <operator>&gt;</operator> <literal type="number">23</literal></expr>)</condition><block type="pseudo"><block_content>
                     <expr_stmt><expr><name>kind</name> <operator>=</operator> <literal type="number">23</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
                  <expr_stmt><expr><call><name>jjCheckNAdd</name><argument_list>(<argument><expr><literal type="number">29</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                  <break>break;</break>
               <case>case <expr><literal type="number">30</literal></expr>:</case>
                  <if_stmt><if>if <condition>(<expr><name>curChar</name> <operator>==</operator> <literal type="number">42</literal> <operator>&amp;&amp;</operator> <name>kind</name> <operator>&gt;</operator> <literal type="number">24</literal></expr>)</condition><block type="pseudo"><block_content>
                     <expr_stmt><expr><name>kind</name> <operator>=</operator> <literal type="number">24</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
                  <break>break;</break>
               <case>case <expr><literal type="number">31</literal></expr>:</case>
                  <if_stmt><if>if <condition>(<expr><operator>(</operator><literal type="number">0xfbff54f8ffffd9ffL</literal> <operator>&amp;</operator> <name>l</name><operator>)</operator> <operator>==</operator> <literal type="number">0L</literal></expr>)</condition><block type="pseudo"><block_content>
                     <break>break;</break></block_content></block></if></if_stmt>
                  <if_stmt><if>if <condition>(<expr><name>kind</name> <operator>&gt;</operator> <literal type="number">25</literal></expr>)</condition><block type="pseudo"><block_content>
                     <expr_stmt><expr><name>kind</name> <operator>=</operator> <literal type="number">25</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
                  <expr_stmt><expr><call><name>jjCheckNAddTwoStates</name><argument_list>(<argument><expr><literal type="number">32</literal></expr></argument>, <argument><expr><literal type="number">33</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                  <break>break;</break>
               <case>case <expr><literal type="number">34</literal></expr>:</case>
                  <if_stmt><if>if <condition>(<expr><name>kind</name> <operator>&gt;</operator> <literal type="number">25</literal></expr>)</condition><block type="pseudo"><block_content>
                     <expr_stmt><expr><name>kind</name> <operator>=</operator> <literal type="number">25</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
                  <expr_stmt><expr><call><name>jjCheckNAddTwoStates</name><argument_list>(<argument><expr><literal type="number">32</literal></expr></argument>, <argument><expr><literal type="number">33</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                  <break>break;</break>
               <case>case <expr><literal type="number">35</literal></expr>:</case>
               <case>case <expr><literal type="number">37</literal></expr>:</case>
                  <if_stmt><if>if <condition>(<expr><name>curChar</name> <operator>==</operator> <literal type="number">47</literal></expr>)</condition><block type="pseudo"><block_content>
                     <expr_stmt><expr><call><name>jjCheckNAddStates</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                  <break>break;</break>
               <case>case <expr><literal type="number">36</literal></expr>:</case>
                  <if_stmt><if>if <condition>(<expr><operator>(</operator><literal type="number">0xffff7fffffffffffL</literal> <operator>&amp;</operator> <name>l</name><operator>)</operator> <operator>!=</operator> <literal type="number">0L</literal></expr>)</condition><block type="pseudo"><block_content>
                     <expr_stmt><expr><call><name>jjCheckNAddStates</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                  <break>break;</break>
               <case>case <expr><literal type="number">39</literal></expr>:</case>
                  <if_stmt><if>if <condition>(<expr><name>curChar</name> <operator>==</operator> <literal type="number">47</literal> <operator>&amp;&amp;</operator> <name>kind</name> <operator>&gt;</operator> <literal type="number">26</literal></expr>)</condition><block type="pseudo"><block_content>
                     <expr_stmt><expr><name>kind</name> <operator>=</operator> <literal type="number">26</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
                  <break>break;</break>
               <case>case <expr><literal type="number">40</literal></expr>:</case>
                  <if_stmt><if>if <condition>(<expr><name>curChar</name> <operator>==</operator> <literal type="number">33</literal></expr>)</condition><block type="pseudo"><block_content>
                     <expr_stmt><expr><call><name>jjCheckNAddStates</name><argument_list>(<argument><expr><literal type="number">16</literal></expr></argument>, <argument><expr><literal type="number">18</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                  <break>break;</break>
               <case>case <expr><literal type="number">41</literal></expr>:</case>
                  <if_stmt><if>if <condition>(<expr><operator>(</operator><literal type="number">0x100002600L</literal> <operator>&amp;</operator> <name>l</name><operator>)</operator> <operator>!=</operator> <literal type="number">0L</literal></expr>)</condition><block type="pseudo"><block_content>
                     <expr_stmt><expr><call><name>jjCheckNAddTwoStates</name><argument_list>(<argument><expr><literal type="number">41</literal></expr></argument>, <argument><expr><literal type="number">42</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                  <break>break;</break>
               <case>case <expr><literal type="number">42</literal></expr>:</case>
                  <if_stmt><if>if <condition>(<expr><operator>(</operator><literal type="number">0xdfffffffffffffffL</literal> <operator>&amp;</operator> <name>l</name><operator>)</operator> <operator>!=</operator> <literal type="number">0L</literal></expr>)</condition><block type="pseudo"><block_content>
                     <expr_stmt><expr><call><name>jjCheckNAddStates</name><argument_list>(<argument><expr><literal type="number">19</literal></expr></argument>, <argument><expr><literal type="number">22</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                  <break>break;</break>
               <case>case <expr><literal type="number">43</literal></expr>:</case>
                  <if_stmt><if>if <condition>(<expr><name>curChar</name> <operator>==</operator> <literal type="number">61</literal></expr>)</condition><block type="pseudo"><block_content>
                     <expr_stmt><expr><call><name>jjCheckNAddStates</name><argument_list>(<argument><expr><literal type="number">23</literal></expr></argument>, <argument><expr><literal type="number">28</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                  <break>break;</break>
               <case>case <expr><literal type="number">44</literal></expr>:</case>
                  <if_stmt><if>if <condition>(<expr><name>curChar</name> <operator>==</operator> <literal type="number">34</literal></expr>)</condition><block type="pseudo"><block_content>
                     <expr_stmt><expr><call><name>jjCheckNAddStates</name><argument_list>(<argument><expr><literal type="number">29</literal></expr></argument>, <argument><expr><literal type="number">31</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                  <break>break;</break>
               <case>case <expr><literal type="number">45</literal></expr>:</case>
                  <if_stmt><if>if <condition>(<expr><operator>(</operator><literal type="number">0xfffffffbffffffffL</literal> <operator>&amp;</operator> <name>l</name><operator>)</operator> <operator>!=</operator> <literal type="number">0L</literal></expr>)</condition><block type="pseudo"><block_content>
                     <expr_stmt><expr><call><name>jjCheckNAddStates</name><argument_list>(<argument><expr><literal type="number">29</literal></expr></argument>, <argument><expr><literal type="number">31</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                  <break>break;</break>
               <case>case <expr><literal type="number">47</literal></expr>:</case>
                  <expr_stmt><expr><call><name>jjCheckNAddStates</name><argument_list>(<argument><expr><literal type="number">29</literal></expr></argument>, <argument><expr><literal type="number">31</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                  <break>break;</break>
               <case>case <expr><literal type="number">48</literal></expr>:</case>
                  <if_stmt><if>if <condition>(<expr><name>curChar</name> <operator>==</operator> <literal type="number">34</literal></expr>)</condition><block type="pseudo"><block_content>
                     <expr_stmt><expr><call><name>jjCheckNAddStates</name><argument_list>(<argument><expr><literal type="number">16</literal></expr></argument>, <argument><expr><literal type="number">18</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                  <break>break;</break>
               <case>case <expr><literal type="number">51</literal></expr>:</case>
                  <if_stmt><if>if <condition>(<expr><operator>(</operator><literal type="number">0xfffffdfefffff9ffL</literal> <operator>&amp;</operator> <name>l</name><operator>)</operator> <operator>==</operator> <literal type="number">0L</literal></expr>)</condition><block type="pseudo"><block_content>
                     <break>break;</break></block_content></block></if></if_stmt>
                  <if_stmt><if>if <condition>(<expr><name>kind</name> <operator>&gt;</operator> <literal type="number">29</literal></expr>)</condition><block type="pseudo"><block_content>
                     <expr_stmt><expr><name>kind</name> <operator>=</operator> <literal type="number">29</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
                  <expr_stmt><expr><name><name>jjstateSet</name><index>[<expr><name>jjnewStateCnt</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="number">51</literal></expr>;</expr_stmt>
                  <break>break;</break>
               <case>case <expr><literal type="number">52</literal></expr>:</case>
                  <if_stmt><if>if <condition>(<expr><name>curChar</name> <operator>==</operator> <literal type="number">39</literal></expr>)</condition><block type="pseudo"><block_content>
                     <expr_stmt><expr><call><name>jjCheckNAddStates</name><argument_list>(<argument><expr><literal type="number">32</literal></expr></argument>, <argument><expr><literal type="number">34</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                  <break>break;</break>
               <case>case <expr><literal type="number">53</literal></expr>:</case>
                  <if_stmt><if>if <condition>(<expr><operator>(</operator><literal type="number">0xffffff7fffffffffL</literal> <operator>&amp;</operator> <name>l</name><operator>)</operator> <operator>!=</operator> <literal type="number">0L</literal></expr>)</condition><block type="pseudo"><block_content>
                     <expr_stmt><expr><call><name>jjCheckNAddStates</name><argument_list>(<argument><expr><literal type="number">32</literal></expr></argument>, <argument><expr><literal type="number">34</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                  <break>break;</break>
               <case>case <expr><literal type="number">55</literal></expr>:</case>
                  <expr_stmt><expr><call><name>jjCheckNAddStates</name><argument_list>(<argument><expr><literal type="number">32</literal></expr></argument>, <argument><expr><literal type="number">34</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                  <break>break;</break>
               <case>case <expr><literal type="number">56</literal></expr>:</case>
                  <if_stmt><if>if <condition>(<expr><name>curChar</name> <operator>==</operator> <literal type="number">39</literal></expr>)</condition><block type="pseudo"><block_content>
                     <expr_stmt><expr><call><name>jjCheckNAddStates</name><argument_list>(<argument><expr><literal type="number">16</literal></expr></argument>, <argument><expr><literal type="number">18</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                  <break>break;</break>
               <case>case <expr><literal type="number">57</literal></expr>:</case>
                  <if_stmt><if>if <condition>(<expr><operator>(</operator><literal type="number">0xfffffffeffffffffL</literal> <operator>&amp;</operator> <name>l</name><operator>)</operator> <operator>!=</operator> <literal type="number">0L</literal></expr>)</condition><block type="pseudo"><block_content>
                     <expr_stmt><expr><call><name>jjCheckNAddStates</name><argument_list>(<argument><expr><literal type="number">35</literal></expr></argument>, <argument><expr><literal type="number">38</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                  <break>break;</break>
               <case>case <expr><literal type="number">58</literal></expr>:</case>
                  <if_stmt><if>if <condition>(<expr><operator>(</operator><literal type="number">0x7bff50f8ffffd9ffL</literal> <operator>&amp;</operator> <name>l</name><operator>)</operator> <operator>==</operator> <literal type="number">0L</literal></expr>)</condition><block type="pseudo"><block_content>
                     <break>break;</break></block_content></block></if></if_stmt>
                  <if_stmt><if>if <condition>(<expr><name>kind</name> <operator>&gt;</operator> <literal type="number">22</literal></expr>)</condition><block type="pseudo"><block_content>
                     <expr_stmt><expr><name>kind</name> <operator>=</operator> <literal type="number">22</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
                  <expr_stmt><expr><call><name>jjCheckNAddStates</name><argument_list>(<argument><expr><literal type="number">6</literal></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                  <break>break;</break>
               <case>case <expr><literal type="number">59</literal></expr>:</case>
                  <if_stmt><if>if <condition>(<expr><operator>(</operator><literal type="number">0x7bfff8f8ffffd9ffL</literal> <operator>&amp;</operator> <name>l</name><operator>)</operator> <operator>==</operator> <literal type="number">0L</literal></expr>)</condition><block type="pseudo"><block_content>
                     <break>break;</break></block_content></block></if></if_stmt>
                  <if_stmt><if>if <condition>(<expr><name>kind</name> <operator>&gt;</operator> <literal type="number">22</literal></expr>)</condition><block type="pseudo"><block_content>
                     <expr_stmt><expr><name>kind</name> <operator>=</operator> <literal type="number">22</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
                  <expr_stmt><expr><call><name>jjCheckNAddTwoStates</name><argument_list>(<argument><expr><literal type="number">59</literal></expr></argument>, <argument><expr><literal type="number">60</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                  <break>break;</break>
               <case>case <expr><literal type="number">61</literal></expr>:</case>
                  <if_stmt><if>if <condition>(<expr><name>kind</name> <operator>&gt;</operator> <literal type="number">22</literal></expr>)</condition><block type="pseudo"><block_content>
                     <expr_stmt><expr><name>kind</name> <operator>=</operator> <literal type="number">22</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
                  <expr_stmt><expr><call><name>jjCheckNAddTwoStates</name><argument_list>(<argument><expr><literal type="number">59</literal></expr></argument>, <argument><expr><literal type="number">60</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                  <break>break;</break>
               <case>case <expr><literal type="number">62</literal></expr>:</case>
                  <if_stmt><if>if <condition>(<expr><operator>(</operator><literal type="number">0x7bfff8f8ffffd9ffL</literal> <operator>&amp;</operator> <name>l</name><operator>)</operator> <operator>!=</operator> <literal type="number">0L</literal></expr>)</condition><block type="pseudo"><block_content>
                     <expr_stmt><expr><call><name>jjCheckNAddStates</name><argument_list>(<argument><expr><literal type="number">39</literal></expr></argument>, <argument><expr><literal type="number">41</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                  <break>break;</break>
               <case>case <expr><literal type="number">64</literal></expr>:</case>
                  <expr_stmt><expr><call><name>jjCheckNAddStates</name><argument_list>(<argument><expr><literal type="number">39</literal></expr></argument>, <argument><expr><literal type="number">41</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                  <break>break;</break>
               <default>default :</default> <break>break;</break>
            </block_content>}</block></switch>
         </block_content>}</block> while<condition>(<expr><name>i</name> <operator>!=</operator> <name>startsAt</name></expr>)</condition>;</do>
      </block_content>}</block></if>
      <if type="elseif">else if <condition>(<expr><name>curChar</name> <operator>&lt;</operator> <literal type="number">128</literal></expr>)</condition>
      <block>{<block_content>
         <decl_stmt><decl><type><name>long</name></type> <name>l</name> <init>= <expr><literal type="number">1L</literal> <operator>&lt;&lt;</operator> <operator>(</operator><name>curChar</name> <operator>&amp;</operator> <literal type="number">077</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
         <do>do
         <block>{<block_content>
            <switch>switch<condition>(<expr><name><name>jjstateSet</name><index>[<expr><operator>--</operator><name>i</name></expr>]</index></name></expr>)</condition>
            <block>{<block_content>
               <case>case <expr><literal type="number">66</literal></expr>:</case>
                  <if_stmt><if>if <condition>(<expr><operator>(</operator><literal type="number">0x97ffffff87ffffffL</literal> <operator>&amp;</operator> <name>l</name><operator>)</operator> <operator>!=</operator> <literal type="number">0L</literal></expr>)</condition>
                  <block>{<block_content>
                     <if_stmt><if>if <condition>(<expr><name>kind</name> <operator>&gt;</operator> <literal type="number">25</literal></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><name>kind</name> <operator>=</operator> <literal type="number">25</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
                     <expr_stmt><expr><call><name>jjCheckNAddTwoStates</name><argument_list>(<argument><expr><literal type="number">32</literal></expr></argument>, <argument><expr><literal type="number">33</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                  </block_content>}</block></if>
                  <if type="elseif">else if <condition>(<expr><name>curChar</name> <operator>==</operator> <literal type="number">92</literal></expr>)</condition><block type="pseudo"><block_content>
                     <expr_stmt><expr><call><name>jjCheckNAddTwoStates</name><argument_list>(<argument><expr><literal type="number">34</literal></expr></argument>, <argument><expr><literal type="number">34</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                  <break>break;</break>
               <case>case <expr><literal type="number">0</literal></expr>:</case>
                  <if_stmt><if>if <condition>(<expr><operator>(</operator><literal type="number">0x97ffffff87ffffffL</literal> <operator>&amp;</operator> <name>l</name><operator>)</operator> <operator>!=</operator> <literal type="number">0L</literal></expr>)</condition>
                  <block>{<block_content>
                     <if_stmt><if>if <condition>(<expr><name>kind</name> <operator>&gt;</operator> <literal type="number">22</literal></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><name>kind</name> <operator>=</operator> <literal type="number">22</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
                     <expr_stmt><expr><call><name>jjCheckNAddStates</name><argument_list>(<argument><expr><literal type="number">6</literal></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                  </block_content>}</block></if>
                  <if type="elseif">else if <condition>(<expr><name>curChar</name> <operator>==</operator> <literal type="number">92</literal></expr>)</condition><block type="pseudo"><block_content>
                     <expr_stmt><expr><call><name>jjCheckNAddStates</name><argument_list>(<argument><expr><literal type="number">42</literal></expr></argument>, <argument><expr><literal type="number">44</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                  <if type="elseif">else if <condition>(<expr><name>curChar</name> <operator>==</operator> <literal type="number">123</literal></expr>)</condition><block type="pseudo"><block_content>
                     <expr_stmt><expr><name><name>jjstateSet</name><index>[<expr><name>jjnewStateCnt</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="number">40</literal></expr>;</expr_stmt></block_content></block></if>
                  <if type="elseif">else if <condition>(<expr><name>curChar</name> <operator>==</operator> <literal type="number">126</literal></expr>)</condition>
                  <block>{<block_content>
                     <if_stmt><if>if <condition>(<expr><name>kind</name> <operator>&gt;</operator> <literal type="number">23</literal></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><name>kind</name> <operator>=</operator> <literal type="number">23</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
                     <expr_stmt><expr><name><name>jjstateSet</name><index>[<expr><name>jjnewStateCnt</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="number">27</literal></expr>;</expr_stmt>
                  </block_content>}</block></if></if_stmt>
                  <if_stmt><if>if <condition>(<expr><operator>(</operator><literal type="number">0x97ffffff87ffffffL</literal> <operator>&amp;</operator> <name>l</name><operator>)</operator> <operator>!=</operator> <literal type="number">0L</literal></expr>)</condition>
                  <block>{<block_content>
                     <if_stmt><if>if <condition>(<expr><name>kind</name> <operator>&gt;</operator> <literal type="number">25</literal></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><name>kind</name> <operator>=</operator> <literal type="number">25</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
                     <expr_stmt><expr><call><name>jjCheckNAddTwoStates</name><argument_list>(<argument><expr><literal type="number">32</literal></expr></argument>, <argument><expr><literal type="number">33</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                  </block_content>}</block></if></if_stmt>
                  <if_stmt><if>if <condition>(<expr><name>curChar</name> <operator>==</operator> <literal type="number">78</literal></expr>)</condition><block type="pseudo"><block_content>
                     <expr_stmt><expr><name><name>jjstateSet</name><index>[<expr><name>jjnewStateCnt</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="number">11</literal></expr>;</expr_stmt></block_content></block></if>
                  <if type="elseif">else if <condition>(<expr><name>curChar</name> <operator>==</operator> <literal type="number">124</literal></expr>)</condition><block type="pseudo"><block_content>
                     <expr_stmt><expr><name><name>jjstateSet</name><index>[<expr><name>jjnewStateCnt</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="number">8</literal></expr>;</expr_stmt></block_content></block></if>
                  <if type="elseif">else if <condition>(<expr><name>curChar</name> <operator>==</operator> <literal type="number">79</literal></expr>)</condition><block type="pseudo"><block_content>
                     <expr_stmt><expr><name><name>jjstateSet</name><index>[<expr><name>jjnewStateCnt</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="number">6</literal></expr>;</expr_stmt></block_content></block></if>
                  <if type="elseif">else if <condition>(<expr><name>curChar</name> <operator>==</operator> <literal type="number">65</literal></expr>)</condition><block type="pseudo"><block_content>
                     <expr_stmt><expr><name><name>jjstateSet</name><index>[<expr><name>jjnewStateCnt</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
                  <break>break;</break>
               <case>case <expr><literal type="number">1</literal></expr>:</case>
                  <if_stmt><if>if <condition>(<expr><name>curChar</name> <operator>==</operator> <literal type="number">68</literal> <operator>&amp;&amp;</operator> <name>kind</name> <operator>&gt;</operator> <literal type="number">9</literal></expr>)</condition><block type="pseudo"><block_content>
                     <expr_stmt><expr><name>kind</name> <operator>=</operator> <literal type="number">9</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
                  <break>break;</break>
               <case>case <expr><literal type="number">2</literal></expr>:</case>
                  <if_stmt><if>if <condition>(<expr><name>curChar</name> <operator>==</operator> <literal type="number">78</literal></expr>)</condition><block type="pseudo"><block_content>
                     <expr_stmt><expr><name><name>jjstateSet</name><index>[<expr><name>jjnewStateCnt</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
                  <break>break;</break>
               <case>case <expr><literal type="number">3</literal></expr>:</case>
                  <if_stmt><if>if <condition>(<expr><name>curChar</name> <operator>==</operator> <literal type="number">65</literal></expr>)</condition><block type="pseudo"><block_content>
                     <expr_stmt><expr><name><name>jjstateSet</name><index>[<expr><name>jjnewStateCnt</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
                  <break>break;</break>
               <case>case <expr><literal type="number">6</literal></expr>:</case>
                  <if_stmt><if>if <condition>(<expr><name>curChar</name> <operator>==</operator> <literal type="number">82</literal> <operator>&amp;&amp;</operator> <name>kind</name> <operator>&gt;</operator> <literal type="number">10</literal></expr>)</condition><block type="pseudo"><block_content>
                     <expr_stmt><expr><name>kind</name> <operator>=</operator> <literal type="number">10</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
                  <break>break;</break>
               <case>case <expr><literal type="number">7</literal></expr>:</case>
                  <if_stmt><if>if <condition>(<expr><name>curChar</name> <operator>==</operator> <literal type="number">79</literal></expr>)</condition><block type="pseudo"><block_content>
                     <expr_stmt><expr><name><name>jjstateSet</name><index>[<expr><name>jjnewStateCnt</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="number">6</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
                  <break>break;</break>
               <case>case <expr><literal type="number">8</literal></expr>:</case>
                  <if_stmt><if>if <condition>(<expr><name>curChar</name> <operator>==</operator> <literal type="number">124</literal> <operator>&amp;&amp;</operator> <name>kind</name> <operator>&gt;</operator> <literal type="number">10</literal></expr>)</condition><block type="pseudo"><block_content>
                     <expr_stmt><expr><name>kind</name> <operator>=</operator> <literal type="number">10</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
                  <break>break;</break>
               <case>case <expr><literal type="number">9</literal></expr>:</case>
                  <if_stmt><if>if <condition>(<expr><name>curChar</name> <operator>==</operator> <literal type="number">124</literal></expr>)</condition><block type="pseudo"><block_content>
                     <expr_stmt><expr><name><name>jjstateSet</name><index>[<expr><name>jjnewStateCnt</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="number">8</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
                  <break>break;</break>
               <case>case <expr><literal type="number">10</literal></expr>:</case>
                  <if_stmt><if>if <condition>(<expr><name>curChar</name> <operator>==</operator> <literal type="number">84</literal> <operator>&amp;&amp;</operator> <name>kind</name> <operator>&gt;</operator> <literal type="number">11</literal></expr>)</condition><block type="pseudo"><block_content>
                     <expr_stmt><expr><name>kind</name> <operator>=</operator> <literal type="number">11</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
                  <break>break;</break>
               <case>case <expr><literal type="number">11</literal></expr>:</case>
                  <if_stmt><if>if <condition>(<expr><name>curChar</name> <operator>==</operator> <literal type="number">79</literal></expr>)</condition><block type="pseudo"><block_content>
                     <expr_stmt><expr><name><name>jjstateSet</name><index>[<expr><name>jjnewStateCnt</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="number">10</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
                  <break>break;</break>
               <case>case <expr><literal type="number">12</literal></expr>:</case>
                  <if_stmt><if>if <condition>(<expr><name>curChar</name> <operator>==</operator> <literal type="number">78</literal></expr>)</condition><block type="pseudo"><block_content>
                     <expr_stmt><expr><name><name>jjstateSet</name><index>[<expr><name>jjnewStateCnt</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="number">11</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
                  <break>break;</break>
               <case>case <expr><literal type="number">17</literal></expr>:</case>
                  <if_stmt><if>if <condition>(<expr><operator>(</operator><literal type="number">0xffffffffefffffffL</literal> <operator>&amp;</operator> <name>l</name><operator>)</operator> <operator>!=</operator> <literal type="number">0L</literal></expr>)</condition><block type="pseudo"><block_content>
                     <expr_stmt><expr><call><name>jjCheckNAddStates</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                  <break>break;</break>
               <case>case <expr><literal type="number">18</literal></expr>:</case>
                  <if_stmt><if>if <condition>(<expr><name>curChar</name> <operator>==</operator> <literal type="number">92</literal></expr>)</condition><block type="pseudo"><block_content>
                     <expr_stmt><expr><name><name>jjstateSet</name><index>[<expr><name>jjnewStateCnt</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="number">19</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
                  <break>break;</break>
               <case>case <expr><literal type="number">19</literal></expr>:</case>
                  <expr_stmt><expr><call><name>jjCheckNAddStates</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                  <break>break;</break>
               <case>case <expr><literal type="number">22</literal></expr>:</case>
                  <if_stmt><if>if <condition>(<expr><operator>(</operator><literal type="number">0xffffffffefffffffL</literal> <operator>&amp;</operator> <name>l</name><operator>)</operator> <operator>!=</operator> <literal type="number">0L</literal></expr>)</condition><block type="pseudo"><block_content>
                     <expr_stmt><expr><call><name>jjCheckNAddStates</name><argument_list>(<argument><expr><literal type="number">11</literal></expr></argument>, <argument><expr><literal type="number">13</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                  <break>break;</break>
               <case>case <expr><literal type="number">23</literal></expr>:</case>
                  <if_stmt><if>if <condition>(<expr><name>curChar</name> <operator>==</operator> <literal type="number">92</literal></expr>)</condition><block type="pseudo"><block_content>
                     <expr_stmt><expr><name><name>jjstateSet</name><index>[<expr><name>jjnewStateCnt</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="number">24</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
                  <break>break;</break>
               <case>case <expr><literal type="number">24</literal></expr>:</case>
                  <expr_stmt><expr><call><name>jjCheckNAddStates</name><argument_list>(<argument><expr><literal type="number">11</literal></expr></argument>, <argument><expr><literal type="number">13</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                  <break>break;</break>
               <case>case <expr><literal type="number">26</literal></expr>:</case>
                  <if_stmt><if>if <condition>(<expr><name>curChar</name> <operator>!=</operator> <literal type="number">126</literal></expr>)</condition><block type="pseudo"><block_content>
                     <break>break;</break></block_content></block></if></if_stmt>
                  <if_stmt><if>if <condition>(<expr><name>kind</name> <operator>&gt;</operator> <literal type="number">23</literal></expr>)</condition><block type="pseudo"><block_content>
                     <expr_stmt><expr><name>kind</name> <operator>=</operator> <literal type="number">23</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
                  <expr_stmt><expr><name><name>jjstateSet</name><index>[<expr><name>jjnewStateCnt</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="number">27</literal></expr>;</expr_stmt>
                  <break>break;</break>
               <case>case <expr><literal type="number">31</literal></expr>:</case>
                  <if_stmt><if>if <condition>(<expr><operator>(</operator><literal type="number">0x97ffffff87ffffffL</literal> <operator>&amp;</operator> <name>l</name><operator>)</operator> <operator>==</operator> <literal type="number">0L</literal></expr>)</condition><block type="pseudo"><block_content>
                     <break>break;</break></block_content></block></if></if_stmt>
                  <if_stmt><if>if <condition>(<expr><name>kind</name> <operator>&gt;</operator> <literal type="number">25</literal></expr>)</condition><block type="pseudo"><block_content>
                     <expr_stmt><expr><name>kind</name> <operator>=</operator> <literal type="number">25</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
                  <expr_stmt><expr><call><name>jjCheckNAddTwoStates</name><argument_list>(<argument><expr><literal type="number">32</literal></expr></argument>, <argument><expr><literal type="number">33</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                  <break>break;</break>
               <case>case <expr><literal type="number">32</literal></expr>:</case>
                  <if_stmt><if>if <condition>(<expr><operator>(</operator><literal type="number">0x97ffffff87ffffffL</literal> <operator>&amp;</operator> <name>l</name><operator>)</operator> <operator>==</operator> <literal type="number">0L</literal></expr>)</condition><block type="pseudo"><block_content>
                     <break>break;</break></block_content></block></if></if_stmt>
                  <if_stmt><if>if <condition>(<expr><name>kind</name> <operator>&gt;</operator> <literal type="number">25</literal></expr>)</condition><block type="pseudo"><block_content>
                     <expr_stmt><expr><name>kind</name> <operator>=</operator> <literal type="number">25</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
                  <expr_stmt><expr><call><name>jjCheckNAddTwoStates</name><argument_list>(<argument><expr><literal type="number">32</literal></expr></argument>, <argument><expr><literal type="number">33</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                  <break>break;</break>
               <case>case <expr><literal type="number">33</literal></expr>:</case>
                  <if_stmt><if>if <condition>(<expr><name>curChar</name> <operator>==</operator> <literal type="number">92</literal></expr>)</condition><block type="pseudo"><block_content>
                     <expr_stmt><expr><call><name>jjCheckNAddTwoStates</name><argument_list>(<argument><expr><literal type="number">34</literal></expr></argument>, <argument><expr><literal type="number">34</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                  <break>break;</break>
               <case>case <expr><literal type="number">34</literal></expr>:</case>
                  <if_stmt><if>if <condition>(<expr><name>kind</name> <operator>&gt;</operator> <literal type="number">25</literal></expr>)</condition><block type="pseudo"><block_content>
                     <expr_stmt><expr><name>kind</name> <operator>=</operator> <literal type="number">25</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
                  <expr_stmt><expr><call><name>jjCheckNAddTwoStates</name><argument_list>(<argument><expr><literal type="number">32</literal></expr></argument>, <argument><expr><literal type="number">33</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                  <break>break;</break>
               <case>case <expr><literal type="number">36</literal></expr>:</case>
                  <expr_stmt><expr><call><name>jjAddStates</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                  <break>break;</break>
               <case>case <expr><literal type="number">38</literal></expr>:</case>
                  <if_stmt><if>if <condition>(<expr><name>curChar</name> <operator>==</operator> <literal type="number">92</literal></expr>)</condition><block type="pseudo"><block_content>
                     <expr_stmt><expr><name><name>jjstateSet</name><index>[<expr><name>jjnewStateCnt</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="number">37</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
                  <break>break;</break>
               <case>case <expr><literal type="number">42</literal></expr>:</case>
                  <if_stmt><if>if <condition>(<expr><operator>(</operator><literal type="number">0xdfffffffffffffffL</literal> <operator>&amp;</operator> <name>l</name><operator>)</operator> <operator>!=</operator> <literal type="number">0L</literal></expr>)</condition><block type="pseudo"><block_content>
                     <expr_stmt><expr><call><name>jjCheckNAddStates</name><argument_list>(<argument><expr><literal type="number">19</literal></expr></argument>, <argument><expr><literal type="number">22</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                  <break>break;</break>
               <case>case <expr><literal type="number">45</literal></expr>:</case>
                  <if_stmt><if>if <condition>(<expr><operator>(</operator><literal type="number">0xffffffffefffffffL</literal> <operator>&amp;</operator> <name>l</name><operator>)</operator> <operator>!=</operator> <literal type="number">0L</literal></expr>)</condition><block type="pseudo"><block_content>
                     <expr_stmt><expr><call><name>jjCheckNAddStates</name><argument_list>(<argument><expr><literal type="number">29</literal></expr></argument>, <argument><expr><literal type="number">31</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                  <break>break;</break>
               <case>case <expr><literal type="number">46</literal></expr>:</case>
                  <if_stmt><if>if <condition>(<expr><name>curChar</name> <operator>==</operator> <literal type="number">92</literal></expr>)</condition><block type="pseudo"><block_content>
                     <expr_stmt><expr><name><name>jjstateSet</name><index>[<expr><name>jjnewStateCnt</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="number">47</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
                  <break>break;</break>
               <case>case <expr><literal type="number">47</literal></expr>:</case>
                  <expr_stmt><expr><call><name>jjCheckNAddStates</name><argument_list>(<argument><expr><literal type="number">29</literal></expr></argument>, <argument><expr><literal type="number">31</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                  <break>break;</break>
               <case>case <expr><literal type="number">49</literal></expr>:</case>
                  <if_stmt><if>if <condition>(<expr><name>curChar</name> <operator>!=</operator> <literal type="number">125</literal></expr>)</condition><block type="pseudo"><block_content>
                     <break>break;</break></block_content></block></if></if_stmt>
                  <if_stmt><if>if <condition>(<expr><name>kind</name> <operator>&gt;</operator> <literal type="number">29</literal></expr>)</condition><block type="pseudo"><block_content>
                     <expr_stmt><expr><name>kind</name> <operator>=</operator> <literal type="number">29</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
                  <expr_stmt><expr><call><name>jjCheckNAddTwoStates</name><argument_list>(<argument><expr><literal type="number">50</literal></expr></argument>, <argument><expr><literal type="number">51</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                  <break>break;</break>
               <case>case <expr><literal type="number">50</literal></expr>:</case>
                  <if_stmt><if>if <condition>(<expr><name>curChar</name> <operator>==</operator> <literal type="number">123</literal></expr>)</condition><block type="pseudo"><block_content>
                     <expr_stmt><expr><name><name>jjstateSet</name><index>[<expr><name>jjnewStateCnt</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="number">40</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
                  <break>break;</break>
               <case>case <expr><literal type="number">51</literal></expr>:</case>
                  <if_stmt><if>if <condition>(<expr><operator>(</operator><literal type="number">0xf7ffffffbfffffffL</literal> <operator>&amp;</operator> <name>l</name><operator>)</operator> <operator>==</operator> <literal type="number">0L</literal></expr>)</condition><block type="pseudo"><block_content>
                     <break>break;</break></block_content></block></if></if_stmt>
                  <if_stmt><if>if <condition>(<expr><name>kind</name> <operator>&gt;</operator> <literal type="number">29</literal></expr>)</condition><block type="pseudo"><block_content>
                     <expr_stmt><expr><name>kind</name> <operator>=</operator> <literal type="number">29</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
                  <expr_stmt><expr><call><name>jjCheckNAdd</name><argument_list>(<argument><expr><literal type="number">51</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                  <break>break;</break>
               <case>case <expr><literal type="number">53</literal></expr>:</case>
                  <if_stmt><if>if <condition>(<expr><operator>(</operator><literal type="number">0xffffffffefffffffL</literal> <operator>&amp;</operator> <name>l</name><operator>)</operator> <operator>!=</operator> <literal type="number">0L</literal></expr>)</condition><block type="pseudo"><block_content>
                     <expr_stmt><expr><call><name>jjCheckNAddStates</name><argument_list>(<argument><expr><literal type="number">32</literal></expr></argument>, <argument><expr><literal type="number">34</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                  <break>break;</break>
               <case>case <expr><literal type="number">54</literal></expr>:</case>
                  <if_stmt><if>if <condition>(<expr><name>curChar</name> <operator>==</operator> <literal type="number">92</literal></expr>)</condition><block type="pseudo"><block_content>
                     <expr_stmt><expr><name><name>jjstateSet</name><index>[<expr><name>jjnewStateCnt</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="number">55</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
                  <break>break;</break>
               <case>case <expr><literal type="number">55</literal></expr>:</case>
                  <expr_stmt><expr><call><name>jjCheckNAddStates</name><argument_list>(<argument><expr><literal type="number">32</literal></expr></argument>, <argument><expr><literal type="number">34</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                  <break>break;</break>
               <case>case <expr><literal type="number">57</literal></expr>:</case>
                  <if_stmt><if>if <condition>(<expr><operator>(</operator><literal type="number">0xdfffffffffffffffL</literal> <operator>&amp;</operator> <name>l</name><operator>)</operator> <operator>!=</operator> <literal type="number">0L</literal></expr>)</condition><block type="pseudo"><block_content>
                     <expr_stmt><expr><call><name>jjCheckNAddStates</name><argument_list>(<argument><expr><literal type="number">35</literal></expr></argument>, <argument><expr><literal type="number">38</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                  <break>break;</break>
               <case>case <expr><literal type="number">58</literal></expr>:</case>
                  <if_stmt><if>if <condition>(<expr><operator>(</operator><literal type="number">0x97ffffff87ffffffL</literal> <operator>&amp;</operator> <name>l</name><operator>)</operator> <operator>==</operator> <literal type="number">0L</literal></expr>)</condition><block type="pseudo"><block_content>
                     <break>break;</break></block_content></block></if></if_stmt>
                  <if_stmt><if>if <condition>(<expr><name>kind</name> <operator>&gt;</operator> <literal type="number">22</literal></expr>)</condition><block type="pseudo"><block_content>
                     <expr_stmt><expr><name>kind</name> <operator>=</operator> <literal type="number">22</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
                  <expr_stmt><expr><call><name>jjCheckNAddStates</name><argument_list>(<argument><expr><literal type="number">6</literal></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                  <break>break;</break>
               <case>case <expr><literal type="number">59</literal></expr>:</case>
                  <if_stmt><if>if <condition>(<expr><operator>(</operator><literal type="number">0x97ffffff87ffffffL</literal> <operator>&amp;</operator> <name>l</name><operator>)</operator> <operator>==</operator> <literal type="number">0L</literal></expr>)</condition><block type="pseudo"><block_content>
                     <break>break;</break></block_content></block></if></if_stmt>
                  <if_stmt><if>if <condition>(<expr><name>kind</name> <operator>&gt;</operator> <literal type="number">22</literal></expr>)</condition><block type="pseudo"><block_content>
                     <expr_stmt><expr><name>kind</name> <operator>=</operator> <literal type="number">22</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
                  <expr_stmt><expr><call><name>jjCheckNAddTwoStates</name><argument_list>(<argument><expr><literal type="number">59</literal></expr></argument>, <argument><expr><literal type="number">60</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                  <break>break;</break>
               <case>case <expr><literal type="number">60</literal></expr>:</case>
                  <if_stmt><if>if <condition>(<expr><name>curChar</name> <operator>==</operator> <literal type="number">92</literal></expr>)</condition><block type="pseudo"><block_content>
                     <expr_stmt><expr><call><name>jjCheckNAddTwoStates</name><argument_list>(<argument><expr><literal type="number">61</literal></expr></argument>, <argument><expr><literal type="number">61</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                  <break>break;</break>
               <case>case <expr><literal type="number">61</literal></expr>:</case>
                  <if_stmt><if>if <condition>(<expr><name>kind</name> <operator>&gt;</operator> <literal type="number">22</literal></expr>)</condition><block type="pseudo"><block_content>
                     <expr_stmt><expr><name>kind</name> <operator>=</operator> <literal type="number">22</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
                  <expr_stmt><expr><call><name>jjCheckNAddTwoStates</name><argument_list>(<argument><expr><literal type="number">59</literal></expr></argument>, <argument><expr><literal type="number">60</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                  <break>break;</break>
               <case>case <expr><literal type="number">62</literal></expr>:</case>
                  <if_stmt><if>if <condition>(<expr><operator>(</operator><literal type="number">0x97ffffff87ffffffL</literal> <operator>&amp;</operator> <name>l</name><operator>)</operator> <operator>!=</operator> <literal type="number">0L</literal></expr>)</condition><block type="pseudo"><block_content>
                     <expr_stmt><expr><call><name>jjCheckNAddStates</name><argument_list>(<argument><expr><literal type="number">39</literal></expr></argument>, <argument><expr><literal type="number">41</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                  <break>break;</break>
               <case>case <expr><literal type="number">63</literal></expr>:</case>
                  <if_stmt><if>if <condition>(<expr><name>curChar</name> <operator>==</operator> <literal type="number">92</literal></expr>)</condition><block type="pseudo"><block_content>
                     <expr_stmt><expr><call><name>jjCheckNAddTwoStates</name><argument_list>(<argument><expr><literal type="number">64</literal></expr></argument>, <argument><expr><literal type="number">64</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                  <break>break;</break>
               <case>case <expr><literal type="number">64</literal></expr>:</case>
                  <expr_stmt><expr><call><name>jjCheckNAddStates</name><argument_list>(<argument><expr><literal type="number">39</literal></expr></argument>, <argument><expr><literal type="number">41</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                  <break>break;</break>
               <case>case <expr><literal type="number">65</literal></expr>:</case>
                  <if_stmt><if>if <condition>(<expr><name>curChar</name> <operator>==</operator> <literal type="number">92</literal></expr>)</condition><block type="pseudo"><block_content>
                     <expr_stmt><expr><call><name>jjCheckNAddStates</name><argument_list>(<argument><expr><literal type="number">42</literal></expr></argument>, <argument><expr><literal type="number">44</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                  <break>break;</break>
               <default>default :</default> <break>break;</break>
            </block_content>}</block></switch>
         </block_content>}</block> while<condition>(<expr><name>i</name> <operator>!=</operator> <name>startsAt</name></expr>)</condition>;</do>
      </block_content>}</block></if>
      <else>else
      <block>{<block_content>
         <decl_stmt><decl><type><name>int</name></type> <name>hiByte</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>curChar</name> <operator>&gt;&gt;</operator> <literal type="number">8</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
         <decl_stmt><decl><type><name>int</name></type> <name>i1</name> <init>= <expr><name>hiByte</name> <operator>&gt;&gt;</operator> <literal type="number">6</literal></expr></init></decl>;</decl_stmt>
         <decl_stmt><decl><type><name>long</name></type> <name>l1</name> <init>= <expr><literal type="number">1L</literal> <operator>&lt;&lt;</operator> <operator>(</operator><name>hiByte</name> <operator>&amp;</operator> <literal type="number">077</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
         <decl_stmt><decl><type><name>int</name></type> <name>i2</name> <init>= <expr><operator>(</operator><name>curChar</name> <operator>&amp;</operator> <literal type="number">0xff</literal><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">6</literal></expr></init></decl>;</decl_stmt>
         <decl_stmt><decl><type><name>long</name></type> <name>l2</name> <init>= <expr><literal type="number">1L</literal> <operator>&lt;&lt;</operator> <operator>(</operator><name>curChar</name> <operator>&amp;</operator> <literal type="number">077</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
         <do>do
         <block>{<block_content>
            <switch>switch<condition>(<expr><name><name>jjstateSet</name><index>[<expr><operator>--</operator><name>i</name></expr>]</index></name></expr>)</condition>
            <block>{<block_content>
               <case>case <expr><literal type="number">66</literal></expr>:</case>
               <case>case <expr><literal type="number">32</literal></expr>:</case>
                  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>jjCanMove_2</name><argument_list>(<argument><expr><name>hiByte</name></expr></argument>, <argument><expr><name>i1</name></expr></argument>, <argument><expr><name>i2</name></expr></argument>, <argument><expr><name>l1</name></expr></argument>, <argument><expr><name>l2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                     <break>break;</break></block_content></block></if></if_stmt>
                  <if_stmt><if>if <condition>(<expr><name>kind</name> <operator>&gt;</operator> <literal type="number">25</literal></expr>)</condition><block type="pseudo"><block_content>
                     <expr_stmt><expr><name>kind</name> <operator>=</operator> <literal type="number">25</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
                  <expr_stmt><expr><call><name>jjCheckNAddTwoStates</name><argument_list>(<argument><expr><literal type="number">32</literal></expr></argument>, <argument><expr><literal type="number">33</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                  <break>break;</break>
               <case>case <expr><literal type="number">0</literal></expr>:</case>
                  <if_stmt><if>if <condition>(<expr><call><name>jjCanMove_0</name><argument_list>(<argument><expr><name>hiByte</name></expr></argument>, <argument><expr><name>i1</name></expr></argument>, <argument><expr><name>i2</name></expr></argument>, <argument><expr><name>l1</name></expr></argument>, <argument><expr><name>l2</name></expr></argument>)</argument_list></call></expr>)</condition>
                  <block>{<block_content>
                     <if_stmt><if>if <condition>(<expr><name>kind</name> <operator>&gt;</operator> <literal type="number">8</literal></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><name>kind</name> <operator>=</operator> <literal type="number">8</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
                  </block_content>}</block></if></if_stmt>
                  <if_stmt><if>if <condition>(<expr><call><name>jjCanMove_2</name><argument_list>(<argument><expr><name>hiByte</name></expr></argument>, <argument><expr><name>i1</name></expr></argument>, <argument><expr><name>i2</name></expr></argument>, <argument><expr><name>l1</name></expr></argument>, <argument><expr><name>l2</name></expr></argument>)</argument_list></call></expr>)</condition>
                  <block>{<block_content>
                     <if_stmt><if>if <condition>(<expr><name>kind</name> <operator>&gt;</operator> <literal type="number">25</literal></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><name>kind</name> <operator>=</operator> <literal type="number">25</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
                     <expr_stmt><expr><call><name>jjCheckNAddTwoStates</name><argument_list>(<argument><expr><literal type="number">32</literal></expr></argument>, <argument><expr><literal type="number">33</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                  </block_content>}</block></if></if_stmt>
                  <if_stmt><if>if <condition>(<expr><call><name>jjCanMove_2</name><argument_list>(<argument><expr><name>hiByte</name></expr></argument>, <argument><expr><name>i1</name></expr></argument>, <argument><expr><name>i2</name></expr></argument>, <argument><expr><name>l1</name></expr></argument>, <argument><expr><name>l2</name></expr></argument>)</argument_list></call></expr>)</condition>
                  <block>{<block_content>
                     <if_stmt><if>if <condition>(<expr><name>kind</name> <operator>&gt;</operator> <literal type="number">22</literal></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><name>kind</name> <operator>=</operator> <literal type="number">22</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
                     <expr_stmt><expr><call><name>jjCheckNAddStates</name><argument_list>(<argument><expr><literal type="number">6</literal></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                  </block_content>}</block></if></if_stmt>
                  <break>break;</break>
               <case>case <expr><literal type="number">15</literal></expr>:</case>
                  <if_stmt><if>if <condition>(<expr><call><name>jjCanMove_0</name><argument_list>(<argument><expr><name>hiByte</name></expr></argument>, <argument><expr><name>i1</name></expr></argument>, <argument><expr><name>i2</name></expr></argument>, <argument><expr><name>l1</name></expr></argument>, <argument><expr><name>l2</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>kind</name> <operator>&gt;</operator> <literal type="number">14</literal></expr>)</condition><block type="pseudo"><block_content>
                     <expr_stmt><expr><name>kind</name> <operator>=</operator> <literal type="number">14</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
                  <break>break;</break>
               <case>case <expr><literal type="number">17</literal></expr>:</case>
               <case>case <expr><literal type="number">19</literal></expr>:</case>
                  <if_stmt><if>if <condition>(<expr><call><name>jjCanMove_1</name><argument_list>(<argument><expr><name>hiByte</name></expr></argument>, <argument><expr><name>i1</name></expr></argument>, <argument><expr><name>i2</name></expr></argument>, <argument><expr><name>l1</name></expr></argument>, <argument><expr><name>l2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                     <expr_stmt><expr><call><name>jjCheckNAddStates</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                  <break>break;</break>
               <case>case <expr><literal type="number">22</literal></expr>:</case>
               <case>case <expr><literal type="number">24</literal></expr>:</case>
                  <if_stmt><if>if <condition>(<expr><call><name>jjCanMove_1</name><argument_list>(<argument><expr><name>hiByte</name></expr></argument>, <argument><expr><name>i1</name></expr></argument>, <argument><expr><name>i2</name></expr></argument>, <argument><expr><name>l1</name></expr></argument>, <argument><expr><name>l2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                     <expr_stmt><expr><call><name>jjCheckNAddStates</name><argument_list>(<argument><expr><literal type="number">11</literal></expr></argument>, <argument><expr><literal type="number">13</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                  <break>break;</break>
               <case>case <expr><literal type="number">31</literal></expr>:</case>
                  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>jjCanMove_2</name><argument_list>(<argument><expr><name>hiByte</name></expr></argument>, <argument><expr><name>i1</name></expr></argument>, <argument><expr><name>i2</name></expr></argument>, <argument><expr><name>l1</name></expr></argument>, <argument><expr><name>l2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                     <break>break;</break></block_content></block></if></if_stmt>
                  <if_stmt><if>if <condition>(<expr><name>kind</name> <operator>&gt;</operator> <literal type="number">25</literal></expr>)</condition><block type="pseudo"><block_content>
                     <expr_stmt><expr><name>kind</name> <operator>=</operator> <literal type="number">25</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
                  <expr_stmt><expr><call><name>jjCheckNAddTwoStates</name><argument_list>(<argument><expr><literal type="number">32</literal></expr></argument>, <argument><expr><literal type="number">33</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                  <break>break;</break>
               <case>case <expr><literal type="number">34</literal></expr>:</case>
                  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>jjCanMove_1</name><argument_list>(<argument><expr><name>hiByte</name></expr></argument>, <argument><expr><name>i1</name></expr></argument>, <argument><expr><name>i2</name></expr></argument>, <argument><expr><name>l1</name></expr></argument>, <argument><expr><name>l2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                     <break>break;</break></block_content></block></if></if_stmt>
                  <if_stmt><if>if <condition>(<expr><name>kind</name> <operator>&gt;</operator> <literal type="number">25</literal></expr>)</condition><block type="pseudo"><block_content>
                     <expr_stmt><expr><name>kind</name> <operator>=</operator> <literal type="number">25</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
                  <expr_stmt><expr><call><name>jjCheckNAddTwoStates</name><argument_list>(<argument><expr><literal type="number">32</literal></expr></argument>, <argument><expr><literal type="number">33</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                  <break>break;</break>
               <case>case <expr><literal type="number">36</literal></expr>:</case>
                  <if_stmt><if>if <condition>(<expr><call><name>jjCanMove_1</name><argument_list>(<argument><expr><name>hiByte</name></expr></argument>, <argument><expr><name>i1</name></expr></argument>, <argument><expr><name>i2</name></expr></argument>, <argument><expr><name>l1</name></expr></argument>, <argument><expr><name>l2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                     <expr_stmt><expr><call><name>jjAddStates</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                  <break>break;</break>
               <case>case <expr><literal type="number">41</literal></expr>:</case>
                  <if_stmt><if>if <condition>(<expr><call><name>jjCanMove_0</name><argument_list>(<argument><expr><name>hiByte</name></expr></argument>, <argument><expr><name>i1</name></expr></argument>, <argument><expr><name>i2</name></expr></argument>, <argument><expr><name>l1</name></expr></argument>, <argument><expr><name>l2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                     <expr_stmt><expr><call><name>jjCheckNAddTwoStates</name><argument_list>(<argument><expr><literal type="number">41</literal></expr></argument>, <argument><expr><literal type="number">42</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                  <break>break;</break>
               <case>case <expr><literal type="number">42</literal></expr>:</case>
                  <if_stmt><if>if <condition>(<expr><call><name>jjCanMove_1</name><argument_list>(<argument><expr><name>hiByte</name></expr></argument>, <argument><expr><name>i1</name></expr></argument>, <argument><expr><name>i2</name></expr></argument>, <argument><expr><name>l1</name></expr></argument>, <argument><expr><name>l2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                     <expr_stmt><expr><call><name>jjCheckNAddStates</name><argument_list>(<argument><expr><literal type="number">19</literal></expr></argument>, <argument><expr><literal type="number">22</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                  <break>break;</break>
               <case>case <expr><literal type="number">45</literal></expr>:</case>
               <case>case <expr><literal type="number">47</literal></expr>:</case>
                  <if_stmt><if>if <condition>(<expr><call><name>jjCanMove_1</name><argument_list>(<argument><expr><name>hiByte</name></expr></argument>, <argument><expr><name>i1</name></expr></argument>, <argument><expr><name>i2</name></expr></argument>, <argument><expr><name>l1</name></expr></argument>, <argument><expr><name>l2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                     <expr_stmt><expr><call><name>jjCheckNAddStates</name><argument_list>(<argument><expr><literal type="number">29</literal></expr></argument>, <argument><expr><literal type="number">31</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                  <break>break;</break>
               <case>case <expr><literal type="number">51</literal></expr>:</case>
                  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>jjCanMove_1</name><argument_list>(<argument><expr><name>hiByte</name></expr></argument>, <argument><expr><name>i1</name></expr></argument>, <argument><expr><name>i2</name></expr></argument>, <argument><expr><name>l1</name></expr></argument>, <argument><expr><name>l2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                     <break>break;</break></block_content></block></if></if_stmt>
                  <if_stmt><if>if <condition>(<expr><name>kind</name> <operator>&gt;</operator> <literal type="number">29</literal></expr>)</condition><block type="pseudo"><block_content>
                     <expr_stmt><expr><name>kind</name> <operator>=</operator> <literal type="number">29</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
                  <expr_stmt><expr><name><name>jjstateSet</name><index>[<expr><name>jjnewStateCnt</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="number">51</literal></expr>;</expr_stmt>
                  <break>break;</break>
               <case>case <expr><literal type="number">53</literal></expr>:</case>
               <case>case <expr><literal type="number">55</literal></expr>:</case>
                  <if_stmt><if>if <condition>(<expr><call><name>jjCanMove_1</name><argument_list>(<argument><expr><name>hiByte</name></expr></argument>, <argument><expr><name>i1</name></expr></argument>, <argument><expr><name>i2</name></expr></argument>, <argument><expr><name>l1</name></expr></argument>, <argument><expr><name>l2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                     <expr_stmt><expr><call><name>jjCheckNAddStates</name><argument_list>(<argument><expr><literal type="number">32</literal></expr></argument>, <argument><expr><literal type="number">34</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                  <break>break;</break>
               <case>case <expr><literal type="number">57</literal></expr>:</case>
                  <if_stmt><if>if <condition>(<expr><call><name>jjCanMove_1</name><argument_list>(<argument><expr><name>hiByte</name></expr></argument>, <argument><expr><name>i1</name></expr></argument>, <argument><expr><name>i2</name></expr></argument>, <argument><expr><name>l1</name></expr></argument>, <argument><expr><name>l2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                     <expr_stmt><expr><call><name>jjCheckNAddStates</name><argument_list>(<argument><expr><literal type="number">35</literal></expr></argument>, <argument><expr><literal type="number">38</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                  <break>break;</break>
               <case>case <expr><literal type="number">58</literal></expr>:</case>
                  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>jjCanMove_2</name><argument_list>(<argument><expr><name>hiByte</name></expr></argument>, <argument><expr><name>i1</name></expr></argument>, <argument><expr><name>i2</name></expr></argument>, <argument><expr><name>l1</name></expr></argument>, <argument><expr><name>l2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                     <break>break;</break></block_content></block></if></if_stmt>
                  <if_stmt><if>if <condition>(<expr><name>kind</name> <operator>&gt;</operator> <literal type="number">22</literal></expr>)</condition><block type="pseudo"><block_content>
                     <expr_stmt><expr><name>kind</name> <operator>=</operator> <literal type="number">22</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
                  <expr_stmt><expr><call><name>jjCheckNAddStates</name><argument_list>(<argument><expr><literal type="number">6</literal></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                  <break>break;</break>
               <case>case <expr><literal type="number">59</literal></expr>:</case>
                  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>jjCanMove_2</name><argument_list>(<argument><expr><name>hiByte</name></expr></argument>, <argument><expr><name>i1</name></expr></argument>, <argument><expr><name>i2</name></expr></argument>, <argument><expr><name>l1</name></expr></argument>, <argument><expr><name>l2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                     <break>break;</break></block_content></block></if></if_stmt>
                  <if_stmt><if>if <condition>(<expr><name>kind</name> <operator>&gt;</operator> <literal type="number">22</literal></expr>)</condition><block type="pseudo"><block_content>
                     <expr_stmt><expr><name>kind</name> <operator>=</operator> <literal type="number">22</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
                  <expr_stmt><expr><call><name>jjCheckNAddTwoStates</name><argument_list>(<argument><expr><literal type="number">59</literal></expr></argument>, <argument><expr><literal type="number">60</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                  <break>break;</break>
               <case>case <expr><literal type="number">61</literal></expr>:</case>
                  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>jjCanMove_1</name><argument_list>(<argument><expr><name>hiByte</name></expr></argument>, <argument><expr><name>i1</name></expr></argument>, <argument><expr><name>i2</name></expr></argument>, <argument><expr><name>l1</name></expr></argument>, <argument><expr><name>l2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                     <break>break;</break></block_content></block></if></if_stmt>
                  <if_stmt><if>if <condition>(<expr><name>kind</name> <operator>&gt;</operator> <literal type="number">22</literal></expr>)</condition><block type="pseudo"><block_content>
                     <expr_stmt><expr><name>kind</name> <operator>=</operator> <literal type="number">22</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
                  <expr_stmt><expr><call><name>jjCheckNAddTwoStates</name><argument_list>(<argument><expr><literal type="number">59</literal></expr></argument>, <argument><expr><literal type="number">60</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                  <break>break;</break>
               <case>case <expr><literal type="number">62</literal></expr>:</case>
                  <if_stmt><if>if <condition>(<expr><call><name>jjCanMove_2</name><argument_list>(<argument><expr><name>hiByte</name></expr></argument>, <argument><expr><name>i1</name></expr></argument>, <argument><expr><name>i2</name></expr></argument>, <argument><expr><name>l1</name></expr></argument>, <argument><expr><name>l2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                     <expr_stmt><expr><call><name>jjCheckNAddStates</name><argument_list>(<argument><expr><literal type="number">39</literal></expr></argument>, <argument><expr><literal type="number">41</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                  <break>break;</break>
               <case>case <expr><literal type="number">64</literal></expr>:</case>
                  <if_stmt><if>if <condition>(<expr><call><name>jjCanMove_1</name><argument_list>(<argument><expr><name>hiByte</name></expr></argument>, <argument><expr><name>i1</name></expr></argument>, <argument><expr><name>i2</name></expr></argument>, <argument><expr><name>l1</name></expr></argument>, <argument><expr><name>l2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                     <expr_stmt><expr><call><name>jjCheckNAddStates</name><argument_list>(<argument><expr><literal type="number">39</literal></expr></argument>, <argument><expr><literal type="number">41</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                  <break>break;</break>
               <default>default :</default> <break>break;</break>
            </block_content>}</block></switch>
         </block_content>}</block> while<condition>(<expr><name>i</name> <operator>!=</operator> <name>startsAt</name></expr>)</condition>;</do>
      </block_content>}</block></else></if_stmt>
      <if_stmt><if>if <condition>(<expr><name>kind</name> <operator>!=</operator> <literal type="number">0x7fffffff</literal></expr>)</condition>
      <block>{<block_content>
         <expr_stmt><expr><name>jjmatchedKind</name> <operator>=</operator> <name>kind</name></expr>;</expr_stmt>
         <expr_stmt><expr><name>jjmatchedPos</name> <operator>=</operator> <name>curPos</name></expr>;</expr_stmt>
         <expr_stmt><expr><name>kind</name> <operator>=</operator> <literal type="number">0x7fffffff</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><operator>++</operator><name>curPos</name></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><operator>(</operator><name>i</name> <operator>=</operator> <name>jjnewStateCnt</name><operator>)</operator> <operator>==</operator> <operator>(</operator><name>startsAt</name> <operator>=</operator> <literal type="number">66</literal> <operator>-</operator> <operator>(</operator><name>jjnewStateCnt</name> <operator>=</operator> <name>startsAt</name><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
         <return>return <expr><name>curPos</name></expr>;</return></block_content></block></if></if_stmt>
      <try>try <block>{<block_content> <expr_stmt><expr><name>curChar</name> <operator>=</operator> <call><name><name>input_stream</name><operator>.</operator><name>readChar</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt> </block_content>}</block>
      <catch>catch<parameter_list>(<parameter><decl><type><name><name>java</name><operator>.</operator><name>io</name><operator>.</operator><name>IOException</name></name></type> <name>e</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><name>curPos</name></expr>;</return> </block_content>}</block></catch></try>
   </block_content>}</block></for>
</block_content>}</block></function>
<function><type><specifier>private</specifier> <name>int</name></type> <name>jjMoveStringLiteralDfa0_0</name><parameter_list>()</parameter_list>
<block>{<block_content>
   <return>return <expr><call><name>jjMoveNfa_0</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>private</specifier> <name>int</name></type> <name>jjMoveNfa_0</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>startState</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>curPos</name></decl></parameter>)</parameter_list>
<block>{<block_content>
   <decl_stmt><decl><type><name>int</name></type> <name>startsAt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
   <expr_stmt><expr><name>jjnewStateCnt</name> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
   <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
   <expr_stmt><expr><name><name>jjstateSet</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>startState</name></expr>;</expr_stmt>
   <decl_stmt><decl><type><name>int</name></type> <name>kind</name> <init>= <expr><literal type="number">0x7fffffff</literal></expr></init></decl>;</decl_stmt>
   <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
   <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><operator>++</operator><name>jjround</name> <operator>==</operator> <literal type="number">0x7fffffff</literal></expr>)</condition><block type="pseudo"><block_content>
         <expr_stmt><expr><call><name>ReInitRounds</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><name>curChar</name> <operator>&lt;</operator> <literal type="number">64</literal></expr>)</condition>
      <block>{<block_content>
         <decl_stmt><decl><type><name>long</name></type> <name>l</name> <init>= <expr><literal type="number">1L</literal> <operator>&lt;&lt;</operator> <name>curChar</name></expr></init></decl>;</decl_stmt>
         <do>do
         <block>{<block_content>
            <switch>switch<condition>(<expr><name><name>jjstateSet</name><index>[<expr><operator>--</operator><name>i</name></expr>]</index></name></expr>)</condition>
            <block>{<block_content>
               <case>case <expr><literal type="number">0</literal></expr>:</case>
                  <if_stmt><if>if <condition>(<expr><operator>(</operator><literal type="number">0x3ff000000000000L</literal> <operator>&amp;</operator> <name>l</name><operator>)</operator> <operator>!=</operator> <literal type="number">0L</literal></expr>)</condition>
                  <block>{<block_content>
                     <if_stmt><if>if <condition>(<expr><name>kind</name> <operator>&gt;</operator> <literal type="number">30</literal></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><name>kind</name> <operator>=</operator> <literal type="number">30</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
                     <expr_stmt><expr><call><name>jjCheckNAddTwoStates</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                  </block_content>}</block></if>
                  <if type="elseif">else if <condition>(<expr><name>curChar</name> <operator>==</operator> <literal type="number">45</literal></expr>)</condition><block type="pseudo"><block_content>
                     <expr_stmt><expr><call><name>jjCheckNAdd</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                  <break>break;</break>
               <case>case <expr><literal type="number">1</literal></expr>:</case>
                  <if_stmt><if>if <condition>(<expr><operator>(</operator><literal type="number">0x3ff000000000000L</literal> <operator>&amp;</operator> <name>l</name><operator>)</operator> <operator>==</operator> <literal type="number">0L</literal></expr>)</condition><block type="pseudo"><block_content>
                     <break>break;</break></block_content></block></if></if_stmt>
                  <if_stmt><if>if <condition>(<expr><name>kind</name> <operator>&gt;</operator> <literal type="number">30</literal></expr>)</condition><block type="pseudo"><block_content>
                     <expr_stmt><expr><name>kind</name> <operator>=</operator> <literal type="number">30</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
                  <expr_stmt><expr><call><name>jjCheckNAddTwoStates</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                  <break>break;</break>
               <case>case <expr><literal type="number">2</literal></expr>:</case>
                  <if_stmt><if>if <condition>(<expr><name>curChar</name> <operator>==</operator> <literal type="number">46</literal></expr>)</condition><block type="pseudo"><block_content>
                     <expr_stmt><expr><call><name>jjCheckNAdd</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                  <break>break;</break>
               <case>case <expr><literal type="number">3</literal></expr>:</case>
                  <if_stmt><if>if <condition>(<expr><operator>(</operator><literal type="number">0x3ff000000000000L</literal> <operator>&amp;</operator> <name>l</name><operator>)</operator> <operator>==</operator> <literal type="number">0L</literal></expr>)</condition><block type="pseudo"><block_content>
                     <break>break;</break></block_content></block></if></if_stmt>
                  <if_stmt><if>if <condition>(<expr><name>kind</name> <operator>&gt;</operator> <literal type="number">30</literal></expr>)</condition><block type="pseudo"><block_content>
                     <expr_stmt><expr><name>kind</name> <operator>=</operator> <literal type="number">30</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
                  <expr_stmt><expr><call><name>jjCheckNAdd</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                  <break>break;</break>
               <default>default :</default> <break>break;</break>
            </block_content>}</block></switch>
         </block_content>}</block> while<condition>(<expr><name>i</name> <operator>!=</operator> <name>startsAt</name></expr>)</condition>;</do>
      </block_content>}</block></if>
      <if type="elseif">else if <condition>(<expr><name>curChar</name> <operator>&lt;</operator> <literal type="number">128</literal></expr>)</condition>
      <block>{<block_content>
         <decl_stmt><decl><type><name>long</name></type> <name>l</name> <init>= <expr><literal type="number">1L</literal> <operator>&lt;&lt;</operator> <operator>(</operator><name>curChar</name> <operator>&amp;</operator> <literal type="number">077</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
         <do>do
         <block>{<block_content>
            <switch>switch<condition>(<expr><name><name>jjstateSet</name><index>[<expr><operator>--</operator><name>i</name></expr>]</index></name></expr>)</condition>
            <block>{<block_content>
               <default>default :</default> <break>break;</break>
            </block_content>}</block></switch>
         </block_content>}</block> while<condition>(<expr><name>i</name> <operator>!=</operator> <name>startsAt</name></expr>)</condition>;</do>
      </block_content>}</block></if>
      <else>else
      <block>{<block_content>
         <decl_stmt><decl><type><name>int</name></type> <name>hiByte</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>curChar</name> <operator>&gt;&gt;</operator> <literal type="number">8</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
         <decl_stmt><decl><type><name>int</name></type> <name>i1</name> <init>= <expr><name>hiByte</name> <operator>&gt;&gt;</operator> <literal type="number">6</literal></expr></init></decl>;</decl_stmt>
         <decl_stmt><decl><type><name>long</name></type> <name>l1</name> <init>= <expr><literal type="number">1L</literal> <operator>&lt;&lt;</operator> <operator>(</operator><name>hiByte</name> <operator>&amp;</operator> <literal type="number">077</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
         <decl_stmt><decl><type><name>int</name></type> <name>i2</name> <init>= <expr><operator>(</operator><name>curChar</name> <operator>&amp;</operator> <literal type="number">0xff</literal><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">6</literal></expr></init></decl>;</decl_stmt>
         <decl_stmt><decl><type><name>long</name></type> <name>l2</name> <init>= <expr><literal type="number">1L</literal> <operator>&lt;&lt;</operator> <operator>(</operator><name>curChar</name> <operator>&amp;</operator> <literal type="number">077</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
         <do>do
         <block>{<block_content>
            <switch>switch<condition>(<expr><name><name>jjstateSet</name><index>[<expr><operator>--</operator><name>i</name></expr>]</index></name></expr>)</condition>
            <block>{<block_content>
               <default>default :</default> <break>break;</break>
            </block_content>}</block></switch>
         </block_content>}</block> while<condition>(<expr><name>i</name> <operator>!=</operator> <name>startsAt</name></expr>)</condition>;</do>
      </block_content>}</block></else></if_stmt>
      <if_stmt><if>if <condition>(<expr><name>kind</name> <operator>!=</operator> <literal type="number">0x7fffffff</literal></expr>)</condition>
      <block>{<block_content>
         <expr_stmt><expr><name>jjmatchedKind</name> <operator>=</operator> <name>kind</name></expr>;</expr_stmt>
         <expr_stmt><expr><name>jjmatchedPos</name> <operator>=</operator> <name>curPos</name></expr>;</expr_stmt>
         <expr_stmt><expr><name>kind</name> <operator>=</operator> <literal type="number">0x7fffffff</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><operator>++</operator><name>curPos</name></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><operator>(</operator><name>i</name> <operator>=</operator> <name>jjnewStateCnt</name><operator>)</operator> <operator>==</operator> <operator>(</operator><name>startsAt</name> <operator>=</operator> <literal type="number">4</literal> <operator>-</operator> <operator>(</operator><name>jjnewStateCnt</name> <operator>=</operator> <name>startsAt</name><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
         <return>return <expr><name>curPos</name></expr>;</return></block_content></block></if></if_stmt>
      <try>try <block>{<block_content> <expr_stmt><expr><name>curChar</name> <operator>=</operator> <call><name><name>input_stream</name><operator>.</operator><name>readChar</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt> </block_content>}</block>
      <catch>catch<parameter_list>(<parameter><decl><type><name><name>java</name><operator>.</operator><name>io</name><operator>.</operator><name>IOException</name></name></type> <name>e</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><name>curPos</name></expr>;</return> </block_content>}</block></catch></try>
   </block_content>}</block></for>
</block_content>}</block></function>
<function><type><specifier>private</specifier> <specifier>final</specifier> <name>int</name></type> <name>jjStopStringLiteralDfa_1</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>pos</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>active0</name></decl></parameter>)</parameter_list>
<block>{<block_content>
   <switch>switch <condition>(<expr><name>pos</name></expr>)</condition>
   <block>{<block_content>
      <case>case <expr><literal type="number">0</literal></expr>:</case>
         <if_stmt><if>if <condition>(<expr><operator>(</operator><name>active0</name> <operator>&amp;</operator> <literal type="number">0x80000000L</literal><operator>)</operator> <operator>!=</operator> <literal type="number">0L</literal></expr>)</condition>
         <block>{<block_content>
            <expr_stmt><expr><name>jjmatchedKind</name> <operator>=</operator> <literal type="number">35</literal></expr>;</expr_stmt>
            <return>return <expr><literal type="number">6</literal></expr>;</return>
         </block_content>}</block></if></if_stmt>
         <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
      <default>default :</default>
         <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
   </block_content>}</block></switch>
</block_content>}</block></function>
<function><type><specifier>private</specifier> <specifier>final</specifier> <name>int</name></type> <name>jjStartNfa_1</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>pos</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>active0</name></decl></parameter>)</parameter_list>
<block>{<block_content>
   <return>return <expr><call><name>jjMoveNfa_1</name><argument_list>(<argument><expr><call><name>jjStopStringLiteralDfa_1</name><argument_list>(<argument><expr><name>pos</name></expr></argument>, <argument><expr><name>active0</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pos</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>private</specifier> <name>int</name></type> <name>jjMoveStringLiteralDfa0_1</name><parameter_list>()</parameter_list>
<block>{<block_content>
   <switch>switch<condition>(<expr><name>curChar</name></expr>)</condition>
   <block>{<block_content>
      <case>case <expr><literal type="number">84</literal></expr>:</case>
         <return>return <expr><call><name>jjMoveStringLiteralDfa1_1</name><argument_list>(<argument><expr><literal type="number">0x80000000L</literal></expr></argument>)</argument_list></call></expr>;</return>
      <case>case <expr><literal type="number">93</literal></expr>:</case>
         <return>return <expr><call><name>jjStopAtPos</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</return>
      <case>case <expr><literal type="number">125</literal></expr>:</case>
         <return>return <expr><call><name>jjStopAtPos</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">33</literal></expr></argument>)</argument_list></call></expr>;</return>
      <default>default :</default>
         <return>return <expr><call><name>jjMoveNfa_1</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
   </block_content>}</block></switch>
</block_content>}</block></function>
<function><type><specifier>private</specifier> <name>int</name></type> <name>jjMoveStringLiteralDfa1_1</name><parameter_list>(<parameter><decl><type><name>long</name></type> <name>active0</name></decl></parameter>)</parameter_list>
<block>{<block_content>
   <try>try <block>{<block_content> <expr_stmt><expr><name>curChar</name> <operator>=</operator> <call><name><name>input_stream</name><operator>.</operator><name>readChar</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt> </block_content>}</block>
   <catch>catch<parameter_list>(<parameter><decl><type><name><name>java</name><operator>.</operator><name>io</name><operator>.</operator><name>IOException</name></name></type> <name>e</name></decl></parameter>)</parameter_list> <block>{<block_content>
      <expr_stmt><expr><call><name>jjStopStringLiteralDfa_1</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>active0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><literal type="number">1</literal></expr>;</return>
   </block_content>}</block></catch></try>
   <switch>switch<condition>(<expr><name>curChar</name></expr>)</condition>
   <block>{<block_content>
      <case>case <expr><literal type="number">79</literal></expr>:</case>
         <if_stmt><if>if <condition>(<expr><operator>(</operator><name>active0</name> <operator>&amp;</operator> <literal type="number">0x80000000L</literal><operator>)</operator> <operator>!=</operator> <literal type="number">0L</literal></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><call><name>jjStartNfaWithStates_1</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">31</literal></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
         <break>break;</break>
      <default>default :</default>
         <break>break;</break>
   </block_content>}</block></switch>
   <return>return <expr><call><name>jjStartNfa_1</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>active0</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>private</specifier> <name>int</name></type> <name>jjStartNfaWithStates_1</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>pos</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>kind</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
   <expr_stmt><expr><name>jjmatchedKind</name> <operator>=</operator> <name>kind</name></expr>;</expr_stmt>
   <expr_stmt><expr><name>jjmatchedPos</name> <operator>=</operator> <name>pos</name></expr>;</expr_stmt>
   <try>try <block>{<block_content> <expr_stmt><expr><name>curChar</name> <operator>=</operator> <call><name><name>input_stream</name><operator>.</operator><name>readChar</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt> </block_content>}</block>
   <catch>catch<parameter_list>(<parameter><decl><type><name><name>java</name><operator>.</operator><name>io</name><operator>.</operator><name>IOException</name></name></type> <name>e</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><name>pos</name> <operator>+</operator> <literal type="number">1</literal></expr>;</return> </block_content>}</block></catch></try>
   <return>return <expr><call><name>jjMoveNfa_1</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>pos</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>private</specifier> <name>int</name></type> <name>jjMoveNfa_1</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>startState</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>curPos</name></decl></parameter>)</parameter_list>
<block>{<block_content>
   <decl_stmt><decl><type><name>int</name></type> <name>startsAt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
   <expr_stmt><expr><name>jjnewStateCnt</name> <operator>=</operator> <literal type="number">7</literal></expr>;</expr_stmt>
   <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
   <expr_stmt><expr><name><name>jjstateSet</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>startState</name></expr>;</expr_stmt>
   <decl_stmt><decl><type><name>int</name></type> <name>kind</name> <init>= <expr><literal type="number">0x7fffffff</literal></expr></init></decl>;</decl_stmt>
   <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
   <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><operator>++</operator><name>jjround</name> <operator>==</operator> <literal type="number">0x7fffffff</literal></expr>)</condition><block type="pseudo"><block_content>
         <expr_stmt><expr><call><name>ReInitRounds</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><name>curChar</name> <operator>&lt;</operator> <literal type="number">64</literal></expr>)</condition>
      <block>{<block_content>
         <decl_stmt><decl><type><name>long</name></type> <name>l</name> <init>= <expr><literal type="number">1L</literal> <operator>&lt;&lt;</operator> <name>curChar</name></expr></init></decl>;</decl_stmt>
         <do>do
         <block>{<block_content>
            <switch>switch<condition>(<expr><name><name>jjstateSet</name><index>[<expr><operator>--</operator><name>i</name></expr>]</index></name></expr>)</condition>
            <block>{<block_content>
               <case>case <expr><literal type="number">0</literal></expr>:</case>
                  <if_stmt><if>if <condition>(<expr><operator>(</operator><literal type="number">0xfffffffeffffffffL</literal> <operator>&amp;</operator> <name>l</name><operator>)</operator> <operator>!=</operator> <literal type="number">0L</literal></expr>)</condition>
                  <block>{<block_content>
                     <if_stmt><if>if <condition>(<expr><name>kind</name> <operator>&gt;</operator> <literal type="number">35</literal></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><name>kind</name> <operator>=</operator> <literal type="number">35</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
                     <expr_stmt><expr><call><name>jjCheckNAdd</name><argument_list>(<argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                  </block_content>}</block></if></if_stmt>
                  <if_stmt><if>if <condition>(<expr><operator>(</operator><literal type="number">0x100002600L</literal> <operator>&amp;</operator> <name>l</name><operator>)</operator> <operator>!=</operator> <literal type="number">0L</literal></expr>)</condition>
                  <block>{<block_content>
                     <if_stmt><if>if <condition>(<expr><name>kind</name> <operator>&gt;</operator> <literal type="number">8</literal></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><name>kind</name> <operator>=</operator> <literal type="number">8</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
                  </block_content>}</block></if>
                  <if type="elseif">else if <condition>(<expr><name>curChar</name> <operator>==</operator> <literal type="number">34</literal></expr>)</condition><block type="pseudo"><block_content>
                     <expr_stmt><expr><call><name>jjCheckNAddTwoStates</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                  <break>break;</break>
               <case>case <expr><literal type="number">1</literal></expr>:</case>
                  <if_stmt><if>if <condition>(<expr><name>curChar</name> <operator>==</operator> <literal type="number">34</literal></expr>)</condition><block type="pseudo"><block_content>
                     <expr_stmt><expr><call><name>jjCheckNAddTwoStates</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                  <break>break;</break>
               <case>case <expr><literal type="number">2</literal></expr>:</case>
                  <if_stmt><if>if <condition>(<expr><operator>(</operator><literal type="number">0xfffffffbffffffffL</literal> <operator>&amp;</operator> <name>l</name><operator>)</operator> <operator>!=</operator> <literal type="number">0L</literal></expr>)</condition><block type="pseudo"><block_content>
                     <expr_stmt><expr><call><name>jjCheckNAddStates</name><argument_list>(<argument><expr><literal type="number">45</literal></expr></argument>, <argument><expr><literal type="number">47</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                  <break>break;</break>
               <case>case <expr><literal type="number">3</literal></expr>:</case>
                  <if_stmt><if>if <condition>(<expr><name>curChar</name> <operator>==</operator> <literal type="number">34</literal></expr>)</condition><block type="pseudo"><block_content>
                     <expr_stmt><expr><call><name>jjCheckNAddStates</name><argument_list>(<argument><expr><literal type="number">45</literal></expr></argument>, <argument><expr><literal type="number">47</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                  <break>break;</break>
               <case>case <expr><literal type="number">5</literal></expr>:</case>
                  <if_stmt><if>if <condition>(<expr><name>curChar</name> <operator>==</operator> <literal type="number">34</literal> <operator>&amp;&amp;</operator> <name>kind</name> <operator>&gt;</operator> <literal type="number">34</literal></expr>)</condition><block type="pseudo"><block_content>
                     <expr_stmt><expr><name>kind</name> <operator>=</operator> <literal type="number">34</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
                  <break>break;</break>
               <case>case <expr><literal type="number">6</literal></expr>:</case>
                  <if_stmt><if>if <condition>(<expr><operator>(</operator><literal type="number">0xfffffffeffffffffL</literal> <operator>&amp;</operator> <name>l</name><operator>)</operator> <operator>==</operator> <literal type="number">0L</literal></expr>)</condition><block type="pseudo"><block_content>
                     <break>break;</break></block_content></block></if></if_stmt>
                  <if_stmt><if>if <condition>(<expr><name>kind</name> <operator>&gt;</operator> <literal type="number">35</literal></expr>)</condition><block type="pseudo"><block_content>
                     <expr_stmt><expr><name>kind</name> <operator>=</operator> <literal type="number">35</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
                  <expr_stmt><expr><call><name>jjCheckNAdd</name><argument_list>(<argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                  <break>break;</break>
               <default>default :</default> <break>break;</break>
            </block_content>}</block></switch>
         </block_content>}</block> while<condition>(<expr><name>i</name> <operator>!=</operator> <name>startsAt</name></expr>)</condition>;</do>
      </block_content>}</block></if>
      <if type="elseif">else if <condition>(<expr><name>curChar</name> <operator>&lt;</operator> <literal type="number">128</literal></expr>)</condition>
      <block>{<block_content>
         <decl_stmt><decl><type><name>long</name></type> <name>l</name> <init>= <expr><literal type="number">1L</literal> <operator>&lt;&lt;</operator> <operator>(</operator><name>curChar</name> <operator>&amp;</operator> <literal type="number">077</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
         <do>do
         <block>{<block_content>
            <switch>switch<condition>(<expr><name><name>jjstateSet</name><index>[<expr><operator>--</operator><name>i</name></expr>]</index></name></expr>)</condition>
            <block>{<block_content>
               <case>case <expr><literal type="number">0</literal></expr>:</case>
               <case>case <expr><literal type="number">6</literal></expr>:</case>
                  <if_stmt><if>if <condition>(<expr><operator>(</operator><literal type="number">0xdfffffffdfffffffL</literal> <operator>&amp;</operator> <name>l</name><operator>)</operator> <operator>==</operator> <literal type="number">0L</literal></expr>)</condition><block type="pseudo"><block_content>
                     <break>break;</break></block_content></block></if></if_stmt>
                  <if_stmt><if>if <condition>(<expr><name>kind</name> <operator>&gt;</operator> <literal type="number">35</literal></expr>)</condition><block type="pseudo"><block_content>
                     <expr_stmt><expr><name>kind</name> <operator>=</operator> <literal type="number">35</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
                  <expr_stmt><expr><call><name>jjCheckNAdd</name><argument_list>(<argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                  <break>break;</break>
               <case>case <expr><literal type="number">2</literal></expr>:</case>
                  <expr_stmt><expr><call><name>jjAddStates</name><argument_list>(<argument><expr><literal type="number">45</literal></expr></argument>, <argument><expr><literal type="number">47</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                  <break>break;</break>
               <case>case <expr><literal type="number">4</literal></expr>:</case>
                  <if_stmt><if>if <condition>(<expr><name>curChar</name> <operator>==</operator> <literal type="number">92</literal></expr>)</condition><block type="pseudo"><block_content>
                     <expr_stmt><expr><name><name>jjstateSet</name><index>[<expr><name>jjnewStateCnt</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
                  <break>break;</break>
               <default>default :</default> <break>break;</break>
            </block_content>}</block></switch>
         </block_content>}</block> while<condition>(<expr><name>i</name> <operator>!=</operator> <name>startsAt</name></expr>)</condition>;</do>
      </block_content>}</block></if>
      <else>else
      <block>{<block_content>
         <decl_stmt><decl><type><name>int</name></type> <name>hiByte</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>curChar</name> <operator>&gt;&gt;</operator> <literal type="number">8</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
         <decl_stmt><decl><type><name>int</name></type> <name>i1</name> <init>= <expr><name>hiByte</name> <operator>&gt;&gt;</operator> <literal type="number">6</literal></expr></init></decl>;</decl_stmt>
         <decl_stmt><decl><type><name>long</name></type> <name>l1</name> <init>= <expr><literal type="number">1L</literal> <operator>&lt;&lt;</operator> <operator>(</operator><name>hiByte</name> <operator>&amp;</operator> <literal type="number">077</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
         <decl_stmt><decl><type><name>int</name></type> <name>i2</name> <init>= <expr><operator>(</operator><name>curChar</name> <operator>&amp;</operator> <literal type="number">0xff</literal><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">6</literal></expr></init></decl>;</decl_stmt>
         <decl_stmt><decl><type><name>long</name></type> <name>l2</name> <init>= <expr><literal type="number">1L</literal> <operator>&lt;&lt;</operator> <operator>(</operator><name>curChar</name> <operator>&amp;</operator> <literal type="number">077</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
         <do>do
         <block>{<block_content>
            <switch>switch<condition>(<expr><name><name>jjstateSet</name><index>[<expr><operator>--</operator><name>i</name></expr>]</index></name></expr>)</condition>
            <block>{<block_content>
               <case>case <expr><literal type="number">0</literal></expr>:</case>
                  <if_stmt><if>if <condition>(<expr><call><name>jjCanMove_0</name><argument_list>(<argument><expr><name>hiByte</name></expr></argument>, <argument><expr><name>i1</name></expr></argument>, <argument><expr><name>i2</name></expr></argument>, <argument><expr><name>l1</name></expr></argument>, <argument><expr><name>l2</name></expr></argument>)</argument_list></call></expr>)</condition>
                  <block>{<block_content>
                     <if_stmt><if>if <condition>(<expr><name>kind</name> <operator>&gt;</operator> <literal type="number">8</literal></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><name>kind</name> <operator>=</operator> <literal type="number">8</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
                  </block_content>}</block></if></if_stmt>
                  <if_stmt><if>if <condition>(<expr><call><name>jjCanMove_1</name><argument_list>(<argument><expr><name>hiByte</name></expr></argument>, <argument><expr><name>i1</name></expr></argument>, <argument><expr><name>i2</name></expr></argument>, <argument><expr><name>l1</name></expr></argument>, <argument><expr><name>l2</name></expr></argument>)</argument_list></call></expr>)</condition>
                  <block>{<block_content>
                     <if_stmt><if>if <condition>(<expr><name>kind</name> <operator>&gt;</operator> <literal type="number">35</literal></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><name>kind</name> <operator>=</operator> <literal type="number">35</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
                     <expr_stmt><expr><call><name>jjCheckNAdd</name><argument_list>(<argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                  </block_content>}</block></if></if_stmt>
                  <break>break;</break>
               <case>case <expr><literal type="number">2</literal></expr>:</case>
                  <if_stmt><if>if <condition>(<expr><call><name>jjCanMove_1</name><argument_list>(<argument><expr><name>hiByte</name></expr></argument>, <argument><expr><name>i1</name></expr></argument>, <argument><expr><name>i2</name></expr></argument>, <argument><expr><name>l1</name></expr></argument>, <argument><expr><name>l2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                     <expr_stmt><expr><call><name>jjAddStates</name><argument_list>(<argument><expr><literal type="number">45</literal></expr></argument>, <argument><expr><literal type="number">47</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                  <break>break;</break>
               <case>case <expr><literal type="number">6</literal></expr>:</case>
                  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>jjCanMove_1</name><argument_list>(<argument><expr><name>hiByte</name></expr></argument>, <argument><expr><name>i1</name></expr></argument>, <argument><expr><name>i2</name></expr></argument>, <argument><expr><name>l1</name></expr></argument>, <argument><expr><name>l2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                     <break>break;</break></block_content></block></if></if_stmt>
                  <if_stmt><if>if <condition>(<expr><name>kind</name> <operator>&gt;</operator> <literal type="number">35</literal></expr>)</condition><block type="pseudo"><block_content>
                     <expr_stmt><expr><name>kind</name> <operator>=</operator> <literal type="number">35</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
                  <expr_stmt><expr><call><name>jjCheckNAdd</name><argument_list>(<argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                  <break>break;</break>
               <default>default :</default> <break>break;</break>
            </block_content>}</block></switch>
         </block_content>}</block> while<condition>(<expr><name>i</name> <operator>!=</operator> <name>startsAt</name></expr>)</condition>;</do>
      </block_content>}</block></else></if_stmt>
      <if_stmt><if>if <condition>(<expr><name>kind</name> <operator>!=</operator> <literal type="number">0x7fffffff</literal></expr>)</condition>
      <block>{<block_content>
         <expr_stmt><expr><name>jjmatchedKind</name> <operator>=</operator> <name>kind</name></expr>;</expr_stmt>
         <expr_stmt><expr><name>jjmatchedPos</name> <operator>=</operator> <name>curPos</name></expr>;</expr_stmt>
         <expr_stmt><expr><name>kind</name> <operator>=</operator> <literal type="number">0x7fffffff</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><operator>++</operator><name>curPos</name></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><operator>(</operator><name>i</name> <operator>=</operator> <name>jjnewStateCnt</name><operator>)</operator> <operator>==</operator> <operator>(</operator><name>startsAt</name> <operator>=</operator> <literal type="number">7</literal> <operator>-</operator> <operator>(</operator><name>jjnewStateCnt</name> <operator>=</operator> <name>startsAt</name><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
         <return>return <expr><name>curPos</name></expr>;</return></block_content></block></if></if_stmt>
      <try>try <block>{<block_content> <expr_stmt><expr><name>curChar</name> <operator>=</operator> <call><name><name>input_stream</name><operator>.</operator><name>readChar</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt> </block_content>}</block>
      <catch>catch<parameter_list>(<parameter><decl><type><name><name>java</name><operator>.</operator><name>io</name><operator>.</operator><name>IOException</name></name></type> <name>e</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><name>curPos</name></expr>;</return> </block_content>}</block></catch></try>
   </block_content>}</block></for>
</block_content>}</block></function>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>final</specifier> <name><name>int</name><index>[]</index></name></type> <name>jjnextStates</name> <init>= <expr><block>{
   <expr><literal type="number">36</literal></expr>, <expr><literal type="number">38</literal></expr>, <expr><literal type="number">39</literal></expr>, <expr><literal type="number">17</literal></expr>, <expr><literal type="number">18</literal></expr>, <expr><literal type="number">20</literal></expr>, <expr><literal type="number">59</literal></expr>, <expr><literal type="number">62</literal></expr>, <expr><literal type="number">30</literal></expr>, <expr><literal type="number">63</literal></expr>, <expr><literal type="number">60</literal></expr>, <expr><literal type="number">22</literal></expr>, <expr><literal type="number">23</literal></expr>, <expr><literal type="number">25</literal></expr>, <expr><literal type="number">27</literal></expr>, <expr><literal type="number">28</literal></expr>, 
   <expr><literal type="number">41</literal></expr>, <expr><literal type="number">42</literal></expr>, <expr><literal type="number">49</literal></expr>, <expr><literal type="number">41</literal></expr>, <expr><literal type="number">42</literal></expr>, <expr><literal type="number">43</literal></expr>, <expr><literal type="number">49</literal></expr>, <expr><literal type="number">41</literal></expr>, <expr><literal type="number">42</literal></expr>, <expr><literal type="number">44</literal></expr>, <expr><literal type="number">52</literal></expr>, <expr><literal type="number">57</literal></expr>, <expr><literal type="number">49</literal></expr>, <expr><literal type="number">45</literal></expr>, <expr><literal type="number">46</literal></expr>, <expr><literal type="number">48</literal></expr>, 
   <expr><literal type="number">53</literal></expr>, <expr><literal type="number">54</literal></expr>, <expr><literal type="number">56</literal></expr>, <expr><literal type="number">41</literal></expr>, <expr><literal type="number">42</literal></expr>, <expr><literal type="number">57</literal></expr>, <expr><literal type="number">49</literal></expr>, <expr><literal type="number">62</literal></expr>, <expr><literal type="number">30</literal></expr>, <expr><literal type="number">63</literal></expr>, <expr><literal type="number">61</literal></expr>, <expr><literal type="number">64</literal></expr>, <expr><literal type="number">34</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><literal type="number">5</literal></expr>, 
}</block></expr></init></decl>;</decl_stmt>
<function><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>boolean</name></type> <name>jjCanMove_0</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>hiByte</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>i1</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>i2</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>l1</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>l2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
   <switch>switch<condition>(<expr><name>hiByte</name></expr>)</condition>
   <block>{<block_content>
      <case>case <expr><literal type="number">48</literal></expr>:</case>
         <return>return <expr><operator>(</operator><operator>(</operator><name><name>jjbitVec0</name><index>[<expr><name>i2</name></expr>]</index></name> <operator>&amp;</operator> <name>l2</name><operator>)</operator> <operator>!=</operator> <literal type="number">0L</literal><operator>)</operator></expr>;</return>
      <default>default :</default>
         <return>return <expr><literal type="boolean">false</literal></expr>;</return>
   </block_content>}</block></switch>
</block_content>}</block></function>
<function><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>boolean</name></type> <name>jjCanMove_1</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>hiByte</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>i1</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>i2</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>l1</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>l2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
   <switch>switch<condition>(<expr><name>hiByte</name></expr>)</condition>
   <block>{<block_content>
      <case>case <expr><literal type="number">0</literal></expr>:</case>
         <return>return <expr><operator>(</operator><operator>(</operator><name><name>jjbitVec3</name><index>[<expr><name>i2</name></expr>]</index></name> <operator>&amp;</operator> <name>l2</name><operator>)</operator> <operator>!=</operator> <literal type="number">0L</literal><operator>)</operator></expr>;</return>
      <default>default :</default>
         <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>jjbitVec1</name><index>[<expr><name>i1</name></expr>]</index></name> <operator>&amp;</operator> <name>l1</name><operator>)</operator> <operator>!=</operator> <literal type="number">0L</literal></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><literal type="boolean">true</literal></expr>;</return></block_content></block></if></if_stmt>
         <return>return <expr><literal type="boolean">false</literal></expr>;</return>
   </block_content>}</block></switch>
</block_content>}</block></function>
<function><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>boolean</name></type> <name>jjCanMove_2</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>hiByte</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>i1</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>i2</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>l1</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>l2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
   <switch>switch<condition>(<expr><name>hiByte</name></expr>)</condition>
   <block>{<block_content>
      <case>case <expr><literal type="number">0</literal></expr>:</case>
         <return>return <expr><operator>(</operator><operator>(</operator><name><name>jjbitVec3</name><index>[<expr><name>i2</name></expr>]</index></name> <operator>&amp;</operator> <name>l2</name><operator>)</operator> <operator>!=</operator> <literal type="number">0L</literal><operator>)</operator></expr>;</return>
      <case>case <expr><literal type="number">48</literal></expr>:</case>
         <return>return <expr><operator>(</operator><operator>(</operator><name><name>jjbitVec1</name><index>[<expr><name>i2</name></expr>]</index></name> <operator>&amp;</operator> <name>l2</name><operator>)</operator> <operator>!=</operator> <literal type="number">0L</literal><operator>)</operator></expr>;</return>
      <default>default :</default>
         <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>jjbitVec4</name><index>[<expr><name>i1</name></expr>]</index></name> <operator>&amp;</operator> <name>l1</name><operator>)</operator> <operator>!=</operator> <literal type="number">0L</literal></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><literal type="boolean">true</literal></expr>;</return></block_content></block></if></if_stmt>
         <return>return <expr><literal type="boolean">false</literal></expr>;</return>
   </block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block" format="javadoc">/** Token literal values. */</comment>
<decl_stmt><decl><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name><name>String</name><index>[]</index></name></type> <name>jjstrLiteralImages</name> <init>= <expr><block>{
<expr><literal type="string">""</literal></expr>, <expr><literal type="null">null</literal></expr>, <expr><literal type="null">null</literal></expr>, <expr><literal type="null">null</literal></expr>, <expr><literal type="null">null</literal></expr>, <expr><literal type="null">null</literal></expr>, <expr><literal type="null">null</literal></expr>, <expr><literal type="null">null</literal></expr>, <expr><literal type="null">null</literal></expr>, <expr><literal type="null">null</literal></expr>, <expr><literal type="null">null</literal></expr>, <expr><literal type="null">null</literal></expr>, <expr><literal type="string">"\53"</literal></expr>, 
<expr><literal type="string">"\55"</literal></expr>, <expr><literal type="null">null</literal></expr>, <expr><literal type="string">"\50"</literal></expr>, <expr><literal type="string">"\51"</literal></expr>, <expr><literal type="string">"\72"</literal></expr>, <expr><literal type="string">"\52"</literal></expr>, <expr><literal type="string">"\136"</literal></expr>, <expr><literal type="null">null</literal></expr>, <expr><literal type="null">null</literal></expr>, <expr><literal type="null">null</literal></expr>, <expr><literal type="null">null</literal></expr>, <expr><literal type="null">null</literal></expr>, <expr><literal type="null">null</literal></expr>, 
<expr><literal type="null">null</literal></expr>, <expr><literal type="string">"\133"</literal></expr>, <expr><literal type="string">"\173"</literal></expr>, <expr><literal type="null">null</literal></expr>, <expr><literal type="null">null</literal></expr>, <expr><literal type="string">"\124\117"</literal></expr>, <expr><literal type="string">"\135"</literal></expr>, <expr><literal type="string">"\175"</literal></expr>, <expr><literal type="null">null</literal></expr>, <expr><literal type="null">null</literal></expr>, }</block></expr></init></decl>;</decl_stmt>

<comment type="block" format="javadoc">/** Lexer state names. */</comment>
<decl_stmt><decl><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name><name>String</name><index>[]</index></name></type> <name>lexStateNames</name> <init>= <expr><block>{
   <expr><literal type="string">"Boost"</literal></expr>,
   <expr><literal type="string">"Range"</literal></expr>,
   <expr><literal type="string">"DEFAULT"</literal></expr>,
}</block></expr></init></decl>;</decl_stmt>

<comment type="block" format="javadoc">/** Lex State array. */</comment>
<decl_stmt><decl><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name><name>int</name><index>[]</index></name></type> <name>jjnewLexState</name> <init>= <expr><block>{
   <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, 
   <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, 
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>final</specifier> <name><name>long</name><index>[]</index></name></type> <name>jjtoToken</name> <init>= <expr><block>{
   <expr><literal type="number">0xffffffe01L</literal></expr>, 
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>final</specifier> <name><name>long</name><index>[]</index></name></type> <name>jjtoSkip</name> <init>= <expr><block>{
   <expr><literal type="number">0x100L</literal></expr>, 
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>protected</specifier> <name>CharStream</name></type> <name>input_stream</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name><name>int</name><index>[]</index></name></type> <name>jjrounds</name> <init>= <expr><operator>new</operator> <name><name>int</name><index>[<expr><literal type="number">66</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name><name>int</name><index>[]</index></name></type> <name>jjstateSet</name> <init>= <expr><operator>new</operator> <name><name>int</name><index>[<expr><literal type="number">132</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>protected</specifier> <name>char</name></type> <name>curChar</name></decl>;</decl_stmt>
<comment type="block" format="javadoc">/** Constructor. */</comment>
<constructor><specifier>public</specifier> <name>QueryParserTokenManager</name><parameter_list>(<parameter><decl><type><name>CharStream</name></type> <name>stream</name></decl></parameter>)</parameter_list><block>{<block_content>
   <expr_stmt><expr><name>input_stream</name> <operator>=</operator> <name>stream</name></expr>;</expr_stmt>
</block_content>}</block></constructor>

<comment type="block" format="javadoc">/** Constructor. */</comment>
<constructor><specifier>public</specifier> <name>QueryParserTokenManager</name><parameter_list>(<parameter><decl><type><name>CharStream</name></type> <name>stream</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>lexState</name></decl></parameter>)</parameter_list><block>{<block_content>
   <expr_stmt><expr><call><name>this</name><argument_list>(<argument><expr><name>stream</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
   <expr_stmt><expr><call><name>SwitchTo</name><argument_list>(<argument><expr><name>lexState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></constructor>

<comment type="block" format="javadoc">/** Reinitialise parser. */</comment>
<function><type><specifier>public</specifier> <name>void</name></type> <name>ReInit</name><parameter_list>(<parameter><decl><type><name>CharStream</name></type> <name>stream</name></decl></parameter>)</parameter_list>
<block>{<block_content>
   <expr_stmt><expr><name>jjmatchedPos</name> <operator>=</operator> <name>jjnewStateCnt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
   <expr_stmt><expr><name>curLexState</name> <operator>=</operator> <name>defaultLexState</name></expr>;</expr_stmt>
   <expr_stmt><expr><name>input_stream</name> <operator>=</operator> <name>stream</name></expr>;</expr_stmt>
   <expr_stmt><expr><call><name>ReInitRounds</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>private</specifier> <name>void</name></type> <name>ReInitRounds</name><parameter_list>()</parameter_list>
<block>{<block_content>
   <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
   <expr_stmt><expr><name>jjround</name> <operator>=</operator> <literal type="number">0x80000001</literal></expr>;</expr_stmt>
   <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">66</literal></expr>;</init> <condition><expr><name>i</name><operator>--</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</condition><incr/>)</control><block type="pseudo"><block_content>
      <expr_stmt><expr><name><name>jjrounds</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0x80000000</literal></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></function>

<comment type="block" format="javadoc">/** Reinitialise parser. */</comment>
<function><type><specifier>public</specifier> <name>void</name></type> <name>ReInit</name><parameter_list>(<parameter><decl><type><name>CharStream</name></type> <name>stream</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>lexState</name></decl></parameter>)</parameter_list>
<block>{<block_content>
   <expr_stmt><expr><call><name>ReInit</name><argument_list>(<argument><expr><name>stream</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
   <expr_stmt><expr><call><name>SwitchTo</name><argument_list>(<argument><expr><name>lexState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="javadoc">/** Switch to specified lex state. */</comment>
<function><type><specifier>public</specifier> <name>void</name></type> <name>SwitchTo</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>lexState</name></decl></parameter>)</parameter_list>
<block>{<block_content>
   <if_stmt><if>if <condition>(<expr><name>lexState</name> <operator>&gt;=</operator> <literal type="number">3</literal> <operator>||</operator> <name>lexState</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
      <throw>throw <expr><operator>new</operator> <call><name>TokenMgrError</name><argument_list>(<argument><expr><literal type="string">"Error: Ignoring invalid lexical state : "</literal> <operator>+</operator> <name>lexState</name> <operator>+</operator> <literal type="string">". State unchanged."</literal></expr></argument>, <argument><expr><name><name>TokenMgrError</name><operator>.</operator><name>INVALID_LEXICAL_STATE</name></name></expr></argument>)</argument_list></call></expr>;</throw></block_content></block></if>
   <else>else<block type="pseudo"><block_content>
      <expr_stmt><expr><name>curLexState</name> <operator>=</operator> <name>lexState</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>protected</specifier> <name>Token</name></type> <name>jjFillToken</name><parameter_list>()</parameter_list>
<block>{<block_content>
   <decl_stmt><decl><type><specifier>final</specifier> <name>Token</name></type> <name>t</name></decl>;</decl_stmt>
   <decl_stmt><decl><type><specifier>final</specifier> <name>String</name></type> <name>curTokenImage</name></decl>;</decl_stmt>
   <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>beginLine</name></decl>;</decl_stmt>
   <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>endLine</name></decl>;</decl_stmt>
   <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>beginColumn</name></decl>;</decl_stmt>
   <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>endColumn</name></decl>;</decl_stmt>
   <decl_stmt><decl><type><name>String</name></type> <name>im</name> <init>= <expr><name><name>jjstrLiteralImages</name><index>[<expr><name>jjmatchedKind</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
   <expr_stmt><expr><name>curTokenImage</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>im</name> <operator>==</operator> <literal type="null">null</literal><operator>)</operator></expr> ?</condition><then> <expr><call><name><name>input_stream</name><operator>.</operator><name>GetImage</name></name><argument_list>()</argument_list></call></expr> </then><else>: <expr><name>im</name></expr></else></ternary></expr>;</expr_stmt>
   <expr_stmt><expr><name>beginLine</name> <operator>=</operator> <call><name><name>input_stream</name><operator>.</operator><name>getBeginLine</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
   <expr_stmt><expr><name>beginColumn</name> <operator>=</operator> <call><name><name>input_stream</name><operator>.</operator><name>getBeginColumn</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
   <expr_stmt><expr><name>endLine</name> <operator>=</operator> <call><name><name>input_stream</name><operator>.</operator><name>getEndLine</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
   <expr_stmt><expr><name>endColumn</name> <operator>=</operator> <call><name><name>input_stream</name><operator>.</operator><name>getEndColumn</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
   <expr_stmt><expr><name>t</name> <operator>=</operator> <call><name><name>Token</name><operator>.</operator><name>newToken</name></name><argument_list>(<argument><expr><name>jjmatchedKind</name></expr></argument>, <argument><expr><name>curTokenImage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

   <expr_stmt><expr><name><name>t</name><operator>.</operator><name>beginLine</name></name> <operator>=</operator> <name>beginLine</name></expr>;</expr_stmt>
   <expr_stmt><expr><name><name>t</name><operator>.</operator><name>endLine</name></name> <operator>=</operator> <name>endLine</name></expr>;</expr_stmt>
   <expr_stmt><expr><name><name>t</name><operator>.</operator><name>beginColumn</name></name> <operator>=</operator> <name>beginColumn</name></expr>;</expr_stmt>
   <expr_stmt><expr><name><name>t</name><operator>.</operator><name>endColumn</name></name> <operator>=</operator> <name>endColumn</name></expr>;</expr_stmt>

   <return>return <expr><name>t</name></expr>;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><name>int</name></type> <name>curLexState</name> <init>= <expr><literal type="number">2</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>defaultLexState</name> <init>= <expr><literal type="number">2</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>jjnewStateCnt</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>jjround</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>jjmatchedPos</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>jjmatchedKind</name></decl>;</decl_stmt>

<comment type="block" format="javadoc">/** Get the next Token. */</comment>
<function><type><specifier>public</specifier> <name>Token</name></type> <name>getNextToken</name><parameter_list>()</parameter_list> 
<block>{<block_content>
  <decl_stmt><decl><type><name>Token</name></type> <name>matchedToken</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>curPos</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <label><name>EOFLoop</name> :</label>
  <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
  <block>{<block_content>
   <try>try
   <block>{<block_content>
      <expr_stmt><expr><name>curChar</name> <operator>=</operator> <call><name><name>input_stream</name><operator>.</operator><name>BeginToken</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
   </block_content>}</block>
   <catch>catch<parameter_list>(<parameter><decl><type><name><name>java</name><operator>.</operator><name>io</name><operator>.</operator><name>IOException</name></name></type> <name>e</name></decl></parameter>)</parameter_list>
   <block>{<block_content>
      <expr_stmt><expr><name>jjmatchedKind</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>matchedToken</name> <operator>=</operator> <call><name>jjFillToken</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>matchedToken</name></expr>;</return>
   </block_content>}</block></catch></try>

   <switch>switch<condition>(<expr><name>curLexState</name></expr>)</condition>
   <block>{<block_content>
     <case>case <expr><literal type="number">0</literal></expr>:</case>
       <expr_stmt><expr><name>jjmatchedKind</name> <operator>=</operator> <literal type="number">0x7fffffff</literal></expr>;</expr_stmt>
       <expr_stmt><expr><name>jjmatchedPos</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
       <expr_stmt><expr><name>curPos</name> <operator>=</operator> <call><name>jjMoveStringLiteralDfa0_0</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
       <break>break;</break>
     <case>case <expr><literal type="number">1</literal></expr>:</case>
       <expr_stmt><expr><name>jjmatchedKind</name> <operator>=</operator> <literal type="number">0x7fffffff</literal></expr>;</expr_stmt>
       <expr_stmt><expr><name>jjmatchedPos</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
       <expr_stmt><expr><name>curPos</name> <operator>=</operator> <call><name>jjMoveStringLiteralDfa0_1</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
       <break>break;</break>
     <case>case <expr><literal type="number">2</literal></expr>:</case>
       <expr_stmt><expr><name>jjmatchedKind</name> <operator>=</operator> <literal type="number">0x7fffffff</literal></expr>;</expr_stmt>
       <expr_stmt><expr><name>jjmatchedPos</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
       <expr_stmt><expr><name>curPos</name> <operator>=</operator> <call><name>jjMoveStringLiteralDfa0_2</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
       <break>break;</break>
   </block_content>}</block></switch>
     <if_stmt><if>if <condition>(<expr><name>jjmatchedKind</name> <operator>!=</operator> <literal type="number">0x7fffffff</literal></expr>)</condition>
     <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>jjmatchedPos</name> <operator>+</operator> <literal type="number">1</literal> <operator>&lt;</operator> <name>curPos</name></expr>)</condition><block type="pseudo"><block_content>
           <expr_stmt><expr><call><name><name>input_stream</name><operator>.</operator><name>backup</name></name><argument_list>(<argument><expr><name>curPos</name> <operator>-</operator> <name>jjmatchedPos</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>jjtoToken</name><index>[<expr><name>jjmatchedKind</name> <operator>&gt;&gt;</operator> <literal type="number">6</literal></expr>]</index></name> <operator>&amp;</operator> <operator>(</operator><literal type="number">1L</literal> <operator>&lt;&lt;</operator> <operator>(</operator><name>jjmatchedKind</name> <operator>&amp;</operator> <literal type="number">077</literal><operator>)</operator><operator>)</operator><operator>)</operator> <operator>!=</operator> <literal type="number">0L</literal></expr>)</condition>
        <block>{<block_content>
           <expr_stmt><expr><name>matchedToken</name> <operator>=</operator> <call><name>jjFillToken</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
       <if_stmt><if>if <condition>(<expr><name><name>jjnewLexState</name><index>[<expr><name>jjmatchedKind</name></expr>]</index></name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
         <expr_stmt><expr><name>curLexState</name> <operator>=</operator> <name><name>jjnewLexState</name><index>[<expr><name>jjmatchedKind</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
           <return>return <expr><name>matchedToken</name></expr>;</return>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
         <if_stmt><if>if <condition>(<expr><name><name>jjnewLexState</name><index>[<expr><name>jjmatchedKind</name></expr>]</index></name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
           <expr_stmt><expr><name>curLexState</name> <operator>=</operator> <name><name>jjnewLexState</name><index>[<expr><name>jjmatchedKind</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
           <continue>continue <name>EOFLoop</name>;</continue>
        </block_content>}</block></else></if_stmt>
     </block_content>}</block></if></if_stmt>
     <decl_stmt><decl><type><name>int</name></type> <name>error_line</name> <init>= <expr><call><name><name>input_stream</name><operator>.</operator><name>getEndLine</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
     <decl_stmt><decl><type><name>int</name></type> <name>error_column</name> <init>= <expr><call><name><name>input_stream</name><operator>.</operator><name>getEndColumn</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
     <decl_stmt><decl><type><name>String</name></type> <name>error_after</name> <init>= <expr><literal type="null">null</literal></expr></init></decl>;</decl_stmt>
     <decl_stmt><decl><type><name>boolean</name></type> <name>EOFSeen</name> <init>= <expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt>
     <try>try <block>{<block_content> <expr_stmt><expr><call><name><name>input_stream</name><operator>.</operator><name>readChar</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name><name>input_stream</name><operator>.</operator><name>backup</name></name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block>
     <catch>catch <parameter_list>(<parameter><decl><type><name><name>java</name><operator>.</operator><name>io</name><operator>.</operator><name>IOException</name></name></type> <name>e1</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <expr_stmt><expr><name>EOFSeen</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>error_after</name> <operator>=</operator> <ternary><condition><expr><name>curPos</name> <operator>&lt;=</operator> <literal type="number">1</literal></expr> ?</condition><then> <expr><literal type="string">""</literal></expr> </then><else>: <expr><call><name><name>input_stream</name><operator>.</operator><name>GetImage</name></name><argument_list>()</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>curChar</name> <operator>==</operator> <literal type="char">'\n'</literal> <operator>||</operator> <name>curChar</name> <operator>==</operator> <literal type="char">'\r'</literal></expr>)</condition> <block>{<block_content>
           <expr_stmt><expr><name>error_line</name><operator>++</operator></expr>;</expr_stmt>
           <expr_stmt><expr><name>error_column</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
           <expr_stmt><expr><name>error_column</name><operator>++</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>
     </block_content>}</block></catch></try>
     <if_stmt><if>if <condition>(<expr><operator>!</operator><name>EOFSeen</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name><name>input_stream</name><operator>.</operator><name>backup</name></name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>error_after</name> <operator>=</operator> <ternary><condition><expr><name>curPos</name> <operator>&lt;=</operator> <literal type="number">1</literal></expr> ?</condition><then> <expr><literal type="string">""</literal></expr> </then><else>: <expr><call><name><name>input_stream</name><operator>.</operator><name>GetImage</name></name><argument_list>()</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
     </block_content>}</block></if></if_stmt>
     <throw>throw <expr><operator>new</operator> <call><name>TokenMgrError</name><argument_list>(<argument><expr><name>EOFSeen</name></expr></argument>, <argument><expr><name>curLexState</name></expr></argument>, <argument><expr><name>error_line</name></expr></argument>, <argument><expr><name>error_column</name></expr></argument>, <argument><expr><name>error_after</name></expr></argument>, <argument><expr><name>curChar</name></expr></argument>, <argument><expr><name><name>TokenMgrError</name><operator>.</operator><name>LEXICAL_ERROR</name></name></expr></argument>)</argument_list></call></expr>;</throw>
  </block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>private</specifier> <name>void</name></type> <name>jjCheckNAdd</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
   <if_stmt><if>if <condition>(<expr><name><name>jjrounds</name><index>[<expr><name>state</name></expr>]</index></name> <operator>!=</operator> <name>jjround</name></expr>)</condition>
   <block>{<block_content>
      <expr_stmt><expr><name><name>jjstateSet</name><index>[<expr><name>jjnewStateCnt</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>state</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>jjrounds</name><index>[<expr><name>state</name></expr>]</index></name> <operator>=</operator> <name>jjround</name></expr>;</expr_stmt>
   </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<function><type><specifier>private</specifier> <name>void</name></type> <name>jjAddStates</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>start</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>end</name></decl></parameter>)</parameter_list>
<block>{<block_content>
   <do>do <block>{<block_content>
      <expr_stmt><expr><name><name>jjstateSet</name><index>[<expr><name>jjnewStateCnt</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>jjnextStates</name><index>[<expr><name>start</name></expr>]</index></name></expr>;</expr_stmt>
   </block_content>}</block> while <condition>(<expr><name>start</name><operator>++</operator> <operator>!=</operator> <name>end</name></expr>)</condition>;</do>
</block_content>}</block></function>
<function><type><specifier>private</specifier> <name>void</name></type> <name>jjCheckNAddTwoStates</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>state1</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>state2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
   <expr_stmt><expr><call><name>jjCheckNAdd</name><argument_list>(<argument><expr><name>state1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
   <expr_stmt><expr><call><name>jjCheckNAdd</name><argument_list>(<argument><expr><name>state2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>private</specifier> <name>void</name></type> <name>jjCheckNAddStates</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>start</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>end</name></decl></parameter>)</parameter_list>
<block>{<block_content>
   <do>do <block>{<block_content>
      <expr_stmt><expr><call><name>jjCheckNAdd</name><argument_list>(<argument><expr><name><name>jjnextStates</name><index>[<expr><name>start</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
   </block_content>}</block> while <condition>(<expr><name>start</name><operator>++</operator> <operator>!=</operator> <name>end</name></expr>)</condition>;</do>
</block_content>}</block></function>

}</block></class>
<expr_stmt><expr><name>diff</name> <operator>--</operator><name>git</name> <name>a</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>parser</name><operator>/</operator><name><name>SolrQueryParserBase</name><operator>.</operator><name>java</name></name> <name>b</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>parser</name><operator>/</operator><name><name>SolrQueryParserBase</name><operator>.</operator><name>java</name></name>
<operator>new</operator> <name>file</name> <name>mode</name> <literal type="number">100644</literal>
<name>index</name> <literal type="number">00000000000..92b4e9ba5cf</literal>
<operator>--</operator> <operator>/</operator><name>dev</name><operator>/</operator><literal type="null">null</literal>
<operator>++</operator> <name>b</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>parser</name><operator>/</operator><name><name>SolrQueryParserBase</name><operator>.</operator><name>java</name></name>
@@ <operator>-</operator><literal type="number">0</literal></expr><operator>,</operator><expr><literal type="number">0</literal> <operator>+</operator><literal type="number">1</literal></expr><operator>,</operator><expr><literal type="number">1033</literal> @@</expr></expr_stmt>
<comment type="block">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</comment>

<package>package <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>parser</name></name>;</package>

<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>analysis</name><operator>.</operator><name>Analyzer</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>analysis</name><operator>.</operator><name>CachingTokenFilter</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>analysis</name><operator>.</operator><name>TokenStream</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>analysis</name><operator>.</operator><name>tokenattributes</name><operator>.</operator><name>PositionIncrementAttribute</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>analysis</name><operator>.</operator><name>tokenattributes</name><operator>.</operator><name>TermToBytesRefAttribute</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>analysis</name><operator>.</operator><name>util</name><operator>.</operator><name>TokenFilterFactory</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>index</name><operator>.</operator><name>Term</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>search</name><operator>.</operator><name>AutomatonQuery</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>search</name><operator>.</operator><name>BooleanClause</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>search</name><operator>.</operator><name>BooleanQuery</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>search</name><operator>.</operator><name>FuzzyQuery</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>search</name><operator>.</operator><name>MatchAllDocsQuery</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>search</name><operator>.</operator><name>MultiPhraseQuery</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>search</name><operator>.</operator><name>MultiTermQuery</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>search</name><operator>.</operator><name>PhraseQuery</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>search</name><operator>.</operator><name>PrefixQuery</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>search</name><operator>.</operator><name>Query</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>search</name><operator>.</operator><name>RegexpQuery</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>search</name><operator>.</operator><name>TermQuery</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>search</name><operator>.</operator><name>WildcardQuery</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>util</name><operator>.</operator><name>BytesRef</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>util</name><operator>.</operator><name>ToStringUtils</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>util</name><operator>.</operator><name>Version</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>util</name><operator>.</operator><name>automaton</name><operator>.</operator><name>Automaton</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>util</name><operator>.</operator><name>automaton</name><operator>.</operator><name>BasicAutomata</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>util</name><operator>.</operator><name>automaton</name><operator>.</operator><name>BasicOperations</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>util</name><operator>.</operator><name>automaton</name><operator>.</operator><name>SpecialOperations</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>analysis</name><operator>.</operator><name>ReversedWildcardFilterFactory</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>analysis</name><operator>.</operator><name>TokenizerChain</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>common</name><operator>.</operator><name>SolrException</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>parser</name><operator>.</operator><name>QueryParser</name><operator>.</operator><name>Operator</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>schema</name><operator>.</operator><name>FieldType</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>schema</name><operator>.</operator><name>IndexSchema</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>schema</name><operator>.</operator><name>SchemaField</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>schema</name><operator>.</operator><name>TextField</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>search</name><operator>.</operator><name>QParser</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>search</name><operator>.</operator><name>SyntaxError</name></name>;</import>

<import>import <name><name>java</name><operator>.</operator><name>io</name><operator>.</operator><name>IOException</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>io</name><operator>.</operator><name>StringReader</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>ArrayList</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>EnumSet</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>HashMap</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>List</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>Map</name></name>;</import>

<comment type="block" format="javadoc">/** This class is overridden by QueryParser in QueryParser.jj
 * and acts to separate the majority of the Java code from the .jj grammar file. 
 */</comment>
<class><specifier>public</specifier> <specifier>abstract</specifier> class <name>SolrQueryParserBase</name> <block>{


  <decl_stmt><decl><type><specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>CONJ_NONE</name>   <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>CONJ_AND</name>    <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>CONJ_OR</name>     <init>= <expr><literal type="number">2</literal></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>MOD_NONE</name>    <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>MOD_NOT</name>     <init>= <expr><literal type="number">10</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>MOD_REQ</name>     <init>= <expr><literal type="number">11</literal></expr></init></decl>;</decl_stmt>

  <comment type="line">// make it possible to call setDefaultOperator() without accessing</comment>
  <comment type="line">// the nested class:</comment>
  <comment type="block" format="javadoc">/** Alternative form of QueryParser.Operator.AND */</comment>
  <decl_stmt><decl><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>Operator</name></type> <name>AND_OPERATOR</name> <init>= <expr><name><name>Operator</name><operator>.</operator><name>AND</name></name></expr></init></decl>;</decl_stmt>
  <comment type="block" format="javadoc">/** Alternative form of QueryParser.Operator.OR */</comment>
  <decl_stmt><decl><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>Operator</name></type> <name>OR_OPERATOR</name> <init>= <expr><name><name>Operator</name><operator>.</operator><name>OR</name></name></expr></init></decl>;</decl_stmt>

  <comment type="block" format="javadoc">/** The default operator that parser uses to combine query terms */</comment>
  <decl_stmt><decl><type><name>Operator</name></type> <name>operator</name> <init>= <expr><name>OR_OPERATOR</name></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name><name>MultiTermQuery</name><operator>.</operator><name>RewriteMethod</name></name></type> <name>multiTermRewriteMethod</name> <init>= <expr><name><name>MultiTermQuery</name><operator>.</operator><name>CONSTANT_SCORE_AUTO_REWRITE_DEFAULT</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>boolean</name></type> <name>allowLeadingWildcard</name> <init>= <expr><literal type="boolean">true</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>boolean</name></type> <name>enablePositionIncrements</name> <init>= <expr><literal type="boolean">true</literal></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>String</name></type> <name>defaultField</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>phraseSlop</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>     <comment type="line">// default slop for phrase queries</comment>
  <decl_stmt><decl><type><name>float</name></type> <name>fuzzyMinSim</name> <init>= <expr><name><name>FuzzyQuery</name><operator>.</operator><name>defaultMinSimilarity</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>fuzzyPrefixLength</name> <init>= <expr><name><name>FuzzyQuery</name><operator>.</operator><name>defaultPrefixLength</name></name></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>boolean</name></type> <name>autoGeneratePhraseQueries</name> <init>= <expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt>


  <decl_stmt><decl><type><specifier>protected</specifier> <name>IndexSchema</name></type> <name>schema</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>protected</specifier> <name>QParser</name></type> <name>parser</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>protected</specifier> <name>Analyzer</name></type> <name>analyzer</name></decl>;</decl_stmt>

  <comment type="line">// implementation detail - caching ReversedWildcardFilterFactory based on type</comment>
  <decl_stmt><decl><type><specifier>private</specifier> <name><name>Map</name><argument_list type="generic">&lt;<argument><name>FieldType</name></argument>, <argument><name>ReversedWildcardFilterFactory</name></argument>&gt;</argument_list></name></type> <name>leadingWildcards</name></decl>;</decl_stmt>

  <comment type="block" format="javadoc">/**
   * Identifies the list of all known "magic fields" that trigger
   * special parsing behavior
   */</comment>
  <enum><specifier>public</specifier> <specifier>static</specifier> enum <name>MagicFieldName</name> <block>{
    <decl><name>VAL</name><argument_list>(<argument><expr><literal type="string">"_val_"</literal></expr></argument>, <argument><expr><literal type="string">"func"</literal></expr></argument>)</argument_list></decl>, <decl><name>QUERY</name><argument_list>(<argument><expr><literal type="string">"_query_"</literal></expr></argument>, <argument><expr><literal type="null">null</literal></expr></argument>)</argument_list></decl>;

    <decl_stmt><decl><type><specifier>public</specifier> <specifier>final</specifier> <name>String</name></type> <name>field</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>public</specifier> <specifier>final</specifier> <name>String</name></type> <name>subParser</name></decl>;</decl_stmt>
    <constructor><name>MagicFieldName</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>field</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>subParser</name></decl></parameter>)</parameter_list> <block>{<block_content>
      <expr_stmt><expr><name><name>this</name><operator>.</operator><name>field</name></name> <operator>=</operator> <name>field</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>this</name><operator>.</operator><name>subParser</name></name> <operator>=</operator> <name>subParser</name></expr>;</expr_stmt>
    </block_content>}</block></constructor>
    <function><type><specifier>public</specifier> <name>String</name></type> <name>toString</name><parameter_list>()</parameter_list> <block>{<block_content>
      <return>return <expr><name>field</name></expr>;</return>
    </block_content>}</block></function>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <specifier>static</specifier> <name><name>Map</name><argument_list type="generic">&lt;<argument><name>String</name></argument>,<argument><name>MagicFieldName</name></argument>&gt;</argument_list></name></type> <name>lookup</name>
        <init>= <expr><operator>new</operator> <call><name><name>HashMap</name><argument_list type="generic">&lt;<argument><name>String</name></argument>,<argument><name>MagicFieldName</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <static>static <block>{<block_content>
      <for>for<control>(<init><decl><type><name>MagicFieldName</name></type> <name>s</name> <range>: <expr><call><name><name>EnumSet</name><operator>.</operator><name>allOf</name></name><argument_list>(<argument><expr><name><name>MagicFieldName</name><operator>.</operator><name>class</name></name></expr></argument>)</argument_list></call></expr></range></decl></init>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name><name>lookup</name><operator>.</operator><name>put</name></name><argument_list>(<argument><expr><call><name><name>s</name><operator>.</operator><name>toString</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
    </block_content>}</block></static>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>MagicFieldName</name></type> <name>get</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>field</name></decl></parameter>)</parameter_list> <block>{<block_content>
      <return>return <expr><call><name><name>lookup</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>field</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>
  }</block></enum>


  <comment type="line">// So the generated QueryParser(CharStream) won't error out</comment>
  <constructor><specifier>protected</specifier> <name>SolrQueryParserBase</name><parameter_list>()</parameter_list> <block>{<block_content>
  </block_content>}</block></constructor>
  <comment type="line">// the generated parser will create these in QueryParser</comment>
  <function_decl><type><specifier>public</specifier> <specifier>abstract</specifier> <name>void</name></type> <name>ReInit</name><parameter_list>(<parameter><decl><type><name>CharStream</name></type> <name>stream</name></decl></parameter>)</parameter_list>;</function_decl>
  <function_decl><type><specifier>public</specifier> <specifier>abstract</specifier> <name>Query</name></type> <name>TopLevelQuery</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>field</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>ParseException</name></expr></argument>, <argument><expr><name>SyntaxError</name></expr></argument></throws>;</function_decl>


  <function><type><specifier>public</specifier> <name>void</name></type> <name>init</name><parameter_list>(<parameter><decl><type><name>Version</name></type> <name>matchVersion</name></decl></parameter>, <parameter><decl><type><name>String</name></type> <name>defaultField</name></decl></parameter>, <parameter><decl><type><name>QParser</name></type> <name>parser</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><name><name>this</name><operator>.</operator><name>schema</name></name> <operator>=</operator> <call><name><name>parser</name><operator>.</operator><name>getReq</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSchema</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>this</name><operator>.</operator><name>parser</name></name> <operator>=</operator> <name>parser</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>this</name><operator>.</operator><name>defaultField</name></name> <operator>=</operator> <name>defaultField</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>this</name><operator>.</operator><name>analyzer</name></name> <operator>=</operator> <call><name><name>schema</name><operator>.</operator><name>getQueryAnalyzer</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></function>

    <comment type="block" format="javadoc">/** Parses a query string, returning a {@link org.apache.lucene.search.Query}.
    *  @param query  the query string to be parsed.
    */</comment>
  <function><type><specifier>public</specifier> <name>Query</name></type> <name>parse</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>query</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>SyntaxError</name></expr></argument></throws> <block>{<block_content>
    <expr_stmt><expr><call><name>ReInit</name><argument_list>(<argument><expr><operator>new</operator> <call><name>FastCharStream</name><argument_list>(<argument><expr><operator>new</operator> <call><name>StringReader</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <try>try <block>{<block_content>
      <comment type="line">// TopLevelQuery is a Query followed by the end-of-input (EOF)</comment>
      <decl_stmt><decl><type><name>Query</name></type> <name>res</name> <init>= <expr><call><name>TopLevelQuery</name><argument_list>(<argument><expr><literal type="null">null</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>  <comment type="line">// pass null so we can tell later if an explicit field was provided or not</comment>
      <return>return <expr><ternary><condition><expr><name>res</name><operator>!=</operator><literal type="null">null</literal></expr> ?</condition><then> <expr><name>res</name></expr> </then><else>: <expr><call><name>newBooleanQuery</name><argument_list>(<argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</return>
    </block_content>}</block>
    <catch>catch <parameter_list>(<parameter><decl><type><name>ParseException</name></type> <name>tme</name></decl></parameter>)</parameter_list> <block>{<block_content>
      <throw>throw <expr><operator>new</operator> <call><name>SyntaxError</name><argument_list>(<argument><expr><literal type="string">"Cannot parse '"</literal> <operator>+</operator><name>query</name><operator>+</operator> <literal type="string">"': "</literal> <operator>+</operator> <call><name><name>tme</name><operator>.</operator><name>getMessage</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>tme</name></expr></argument>)</argument_list></call></expr>;</throw>
    </block_content>}</block></catch>
    <catch>catch <parameter_list>(<parameter><decl><type><name>TokenMgrError</name></type> <name>tme</name></decl></parameter>)</parameter_list> <block>{<block_content>
      <throw>throw <expr><operator>new</operator> <call><name>SyntaxError</name><argument_list>(<argument><expr><literal type="string">"Cannot parse '"</literal> <operator>+</operator><name>query</name><operator>+</operator> <literal type="string">"': "</literal> <operator>+</operator> <call><name><name>tme</name><operator>.</operator><name>getMessage</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>tme</name></expr></argument>)</argument_list></call></expr>;</throw>
    </block_content>}</block></catch>
    <catch>catch <parameter_list>(<parameter><decl><type><name><name>BooleanQuery</name><operator>.</operator><name>TooManyClauses</name></name></type> <name>tmc</name></decl></parameter>)</parameter_list> <block>{<block_content>
      <throw>throw <expr><operator>new</operator> <call><name>SyntaxError</name><argument_list>(<argument><expr><literal type="string">"Cannot parse '"</literal> <operator>+</operator><name>query</name><operator>+</operator> <literal type="string">"': too many boolean clauses"</literal></expr></argument>, <argument><expr><name>tmc</name></expr></argument>)</argument_list></call></expr>;</throw>
    </block_content>}</block></catch></try>
  </block_content>}</block></function>


  <comment type="block" format="javadoc">/**
   * @return Returns the default field.
   */</comment>
  <function><type><specifier>public</specifier> <name>String</name></type> <name>getDefaultField</name><parameter_list>()</parameter_list> <block>{<block_content>
    <return>return <expr><name><name>this</name><operator>.</operator><name>defaultField</name></name></expr>;</return>
  </block_content>}</block></function>

  <comment type="block" format="javadoc">/** Handles the default field if null is passed */</comment>
  <function><type><specifier>public</specifier> <name>String</name></type> <name>getField</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>fieldName</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <return>return <expr><ternary><condition><expr><name>fieldName</name> <operator>!=</operator> <literal type="null">null</literal></expr> ?</condition><then> <expr><name>fieldName</name></expr> </then><else>: <expr><name><name>this</name><operator>.</operator><name>defaultField</name></name></expr></else></ternary></expr>;</return>
  </block_content>}</block></function>

  <comment type="block" format="javadoc">/**
   * @see #setAutoGeneratePhraseQueries(boolean)
   */</comment>
  <function><type><specifier>public</specifier> <specifier>final</specifier> <name>boolean</name></type> <name>getAutoGeneratePhraseQueries</name><parameter_list>()</parameter_list> <block>{<block_content>
    <return>return <expr><name>autoGeneratePhraseQueries</name></expr>;</return>
  </block_content>}</block></function>

  <comment type="block" format="javadoc">/**
   * Set to true if phrase queries will be automatically generated
   * when the analyzer returns more than one term from whitespace
   * delimited text.
   * NOTE: this behavior may not be suitable for all languages.
   * &lt;p&gt;
   * Set to false if phrase queries should only be generated when
   * surrounded by double quotes.
   */</comment>
  <function><type><specifier>public</specifier> <specifier>final</specifier> <name>void</name></type> <name>setAutoGeneratePhraseQueries</name><parameter_list>(<parameter><decl><type><name>boolean</name></type> <name>value</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><name><name>this</name><operator>.</operator><name>autoGeneratePhraseQueries</name></name> <operator>=</operator> <name>value</name></expr>;</expr_stmt>
  </block_content>}</block></function>

   <comment type="block" format="javadoc">/**
   * Get the minimal similarity for fuzzy queries.
   */</comment>
  <function><type><specifier>public</specifier> <name>float</name></type> <name>getFuzzyMinSim</name><parameter_list>()</parameter_list> <block>{<block_content>
      <return>return <expr><name>fuzzyMinSim</name></expr>;</return>
  </block_content>}</block></function>

  <comment type="block" format="javadoc">/**
   * Set the minimum similarity for fuzzy queries.
   * Default is 2f.
   */</comment>
  <function><type><specifier>public</specifier> <name>void</name></type> <name>setFuzzyMinSim</name><parameter_list>(<parameter><decl><type><name>float</name></type> <name>fuzzyMinSim</name></decl></parameter>)</parameter_list> <block>{<block_content>
      <expr_stmt><expr><name><name>this</name><operator>.</operator><name>fuzzyMinSim</name></name> <operator>=</operator> <name>fuzzyMinSim</name></expr>;</expr_stmt>
  </block_content>}</block></function>

   <comment type="block" format="javadoc">/**
   * Get the prefix length for fuzzy queries.
   * @return Returns the fuzzyPrefixLength.
   */</comment>
  <function><type><specifier>public</specifier> <name>int</name></type> <name>getFuzzyPrefixLength</name><parameter_list>()</parameter_list> <block>{<block_content>
    <return>return <expr><name>fuzzyPrefixLength</name></expr>;</return>
  </block_content>}</block></function>

  <comment type="block" format="javadoc">/**
   * Set the prefix length for fuzzy queries. Default is 0.
   * @param fuzzyPrefixLength The fuzzyPrefixLength to set.
   */</comment>
  <function><type><specifier>public</specifier> <name>void</name></type> <name>setFuzzyPrefixLength</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>fuzzyPrefixLength</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><name><name>this</name><operator>.</operator><name>fuzzyPrefixLength</name></name> <operator>=</operator> <name>fuzzyPrefixLength</name></expr>;</expr_stmt>
  </block_content>}</block></function>

  <comment type="block" format="javadoc">/**
   * Sets the default slop for phrases.  If zero, then exact phrase matches
   * are required.  Default value is zero.
   */</comment>
  <function><type><specifier>public</specifier> <name>void</name></type> <name>setPhraseSlop</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>phraseSlop</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><name><name>this</name><operator>.</operator><name>phraseSlop</name></name> <operator>=</operator> <name>phraseSlop</name></expr>;</expr_stmt>
  </block_content>}</block></function>

  <comment type="block" format="javadoc">/**
   * Gets the default slop for phrases.
   */</comment>
  <function><type><specifier>public</specifier> <name>int</name></type> <name>getPhraseSlop</name><parameter_list>()</parameter_list> <block>{<block_content>
    <return>return <expr><name>phraseSlop</name></expr>;</return>
  </block_content>}</block></function>


  <comment type="block" format="javadoc">/**
   * Set to &lt;code&gt;true&lt;/code&gt; to allow leading wildcard characters.
   * &lt;p&gt;
   * When set, &lt;code&gt;*&lt;/code&gt; or &lt;code&gt;?&lt;/code&gt; are allowed as
   * the first character of a PrefixQuery and WildcardQuery.
   * Note that this can produce very slow
   * queries on big indexes.
   * &lt;p&gt;
   * Default: false.
   */</comment>
  <function><type><specifier>public</specifier> <name>void</name></type> <name>setAllowLeadingWildcard</name><parameter_list>(<parameter><decl><type><name>boolean</name></type> <name>allowLeadingWildcard</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><name><name>this</name><operator>.</operator><name>allowLeadingWildcard</name></name> <operator>=</operator> <name>allowLeadingWildcard</name></expr>;</expr_stmt>
  </block_content>}</block></function>

  <comment type="block" format="javadoc">/**
   * @see #setAllowLeadingWildcard(boolean)
   */</comment>
  <function><type><specifier>public</specifier> <name>boolean</name></type> <name>getAllowLeadingWildcard</name><parameter_list>()</parameter_list> <block>{<block_content>
    <return>return <expr><name>allowLeadingWildcard</name></expr>;</return>
  </block_content>}</block></function>

  <comment type="block" format="javadoc">/**
   * Set to &lt;code&gt;true&lt;/code&gt; to enable position increments in result query.
   * &lt;p&gt;
   * When set, result phrase and multi-phrase queries will
   * be aware of position increments.
   * Useful when e.g. a StopFilter increases the position increment of
   * the token that follows an omitted token.
   * &lt;p&gt;
   * Default: true.
   */</comment>
  <function><type><specifier>public</specifier> <name>void</name></type> <name>setEnablePositionIncrements</name><parameter_list>(<parameter><decl><type><name>boolean</name></type> <name>enable</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><name><name>this</name><operator>.</operator><name>enablePositionIncrements</name></name> <operator>=</operator> <name>enable</name></expr>;</expr_stmt>
  </block_content>}</block></function>

  <comment type="block" format="javadoc">/**
   * @see #setEnablePositionIncrements(boolean)
   */</comment>
  <function><type><specifier>public</specifier> <name>boolean</name></type> <name>getEnablePositionIncrements</name><parameter_list>()</parameter_list> <block>{<block_content>
    <return>return <expr><name>enablePositionIncrements</name></expr>;</return>
  </block_content>}</block></function>

  <comment type="block" format="javadoc">/**
   * Sets the boolean operator of the QueryParser.
   * In default mode (&lt;code&gt;OR_OPERATOR&lt;/code&gt;) terms without any modifiers
   * are considered optional: for example &lt;code&gt;capital of Hungary&lt;/code&gt; is equal to
   * &lt;code&gt;capital OR of OR Hungary&lt;/code&gt;.&lt;br/&gt;
   * In &lt;code&gt;AND_OPERATOR&lt;/code&gt; mode terms are considered to be in conjunction: the
   * above mentioned query is parsed as &lt;code&gt;capital AND of AND Hungary&lt;/code&gt;
   */</comment>
  <function><type><specifier>public</specifier> <name>void</name></type> <name>setDefaultOperator</name><parameter_list>(<parameter><decl><type><name>Operator</name></type> <name>op</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><name><name>this</name><operator>.</operator><name>operator</name></name> <operator>=</operator> <name>op</name></expr>;</expr_stmt>
  </block_content>}</block></function>


  <comment type="block" format="javadoc">/**
   * Gets implicit operator setting, which will be either AND_OPERATOR
   * or OR_OPERATOR.
   */</comment>
  <function><type><specifier>public</specifier> <name>Operator</name></type> <name>getDefaultOperator</name><parameter_list>()</parameter_list> <block>{<block_content>
    <return>return <expr><name>operator</name></expr>;</return>
  </block_content>}</block></function>


  <comment type="block" format="javadoc">/**
   * By default QueryParser uses {@link org.apache.lucene.search.MultiTermQuery#CONSTANT_SCORE_AUTO_REWRITE_DEFAULT}
   * when creating a PrefixQuery, WildcardQuery or RangeQuery. This implementation is generally preferable because it
   * a) Runs faster b) Does not have the scarcity of terms unduly influence score
   * c) avoids any "TooManyBooleanClauses" exception.
   * However, if your application really needs to use the
   * old-fashioned BooleanQuery expansion rewriting and the above
   * points are not relevant then use this to change
   * the rewrite method.
   */</comment>
  <function><type><specifier>public</specifier> <name>void</name></type> <name>setMultiTermRewriteMethod</name><parameter_list>(<parameter><decl><type><name><name>MultiTermQuery</name><operator>.</operator><name>RewriteMethod</name></name></type> <name>method</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><name>multiTermRewriteMethod</name> <operator>=</operator> <name>method</name></expr>;</expr_stmt>
  </block_content>}</block></function>


  <comment type="block" format="javadoc">/**
   * @see #setMultiTermRewriteMethod
   */</comment>
  <function><type><specifier>public</specifier> <name><name>MultiTermQuery</name><operator>.</operator><name>RewriteMethod</name></name></type> <name>getMultiTermRewriteMethod</name><parameter_list>()</parameter_list> <block>{<block_content>
    <return>return <expr><name>multiTermRewriteMethod</name></expr>;</return>
  </block_content>}</block></function>


  <function><type><specifier>protected</specifier> <name>void</name></type> <name>addClause</name><parameter_list>(<parameter><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name>BooleanClause</name></argument>&gt;</argument_list></name></type> <name>clauses</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>conj</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>mods</name></decl></parameter>, <parameter><decl><type><name>Query</name></type> <name>q</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>boolean</name></type> <name>required</name></decl>, <decl><type ref="prev"/><name>prohibited</name></decl>;</decl_stmt>

    <comment type="line">// If this term is introduced by AND, make the preceding term required,</comment>
    <comment type="line">// unless it's already prohibited</comment>
    <if_stmt><if>if <condition>(<expr><call><name><name>clauses</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>conj</name> <operator>==</operator> <name>CONJ_AND</name></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>BooleanClause</name></type> <name>c</name> <init>= <expr><call><name><name>clauses</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><call><name><name>clauses</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>c</name><operator>.</operator><name>isProhibited</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name><name>c</name><operator>.</operator><name>setOccur</name></name><argument_list>(<argument><expr><name><name>BooleanClause</name><operator>.</operator><name>Occur</name><operator>.</operator><name>MUST</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name><name>clauses</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>operator</name> <operator>==</operator> <name>AND_OPERATOR</name> <operator>&amp;&amp;</operator> <name>conj</name> <operator>==</operator> <name>CONJ_OR</name></expr>)</condition> <block>{<block_content>
      <comment type="line">// If this term is introduced by OR, make the preceding term optional,</comment>
      <comment type="line">// unless it's prohibited (that means we leave -a OR b but +a OR b--&gt;a OR b)</comment>
      <comment type="line">// notice if the input is a OR b, first term is parsed as required; without</comment>
      <comment type="line">// this modification a OR b would parsed as +a OR b</comment>
      <decl_stmt><decl><type><name>BooleanClause</name></type> <name>c</name> <init>= <expr><call><name><name>clauses</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><call><name><name>clauses</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>c</name><operator>.</operator><name>isProhibited</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name><name>c</name><operator>.</operator><name>setOccur</name></name><argument_list>(<argument><expr><name><name>BooleanClause</name><operator>.</operator><name>Occur</name><operator>.</operator><name>SHOULD</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// We might have been passed a null query; the term might have been</comment>
    <comment type="line">// filtered away by the analyzer.</comment>
    <if_stmt><if>if <condition>(<expr><name>q</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><block type="pseudo"><block_content>
      <return>return;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>operator</name> <operator>==</operator> <name>OR_OPERATOR</name></expr>)</condition> <block>{<block_content>
      <comment type="line">// We set REQUIRED if we're introduced by AND or +; PROHIBITED if</comment>
      <comment type="line">// introduced by NOT or -; make sure not to set both.</comment>
      <expr_stmt><expr><name>prohibited</name> <operator>=</operator> <operator>(</operator><name>mods</name> <operator>==</operator> <name>MOD_NOT</name><operator>)</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>required</name> <operator>=</operator> <operator>(</operator><name>mods</name> <operator>==</operator> <name>MOD_REQ</name><operator>)</operator></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>conj</name> <operator>==</operator> <name>CONJ_AND</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>prohibited</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>required</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <comment type="line">// We set PROHIBITED if we're introduced by NOT or -; We set REQUIRED</comment>
      <comment type="line">// if not PROHIBITED and not introduced by OR</comment>
      <expr_stmt><expr><name>prohibited</name> <operator>=</operator> <operator>(</operator><name>mods</name> <operator>==</operator> <name>MOD_NOT</name><operator>)</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>required</name>   <operator>=</operator> <operator>(</operator><operator>!</operator><name>prohibited</name> <operator>&amp;&amp;</operator> <name>conj</name> <operator>!=</operator> <name>CONJ_OR</name><operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>required</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>prohibited</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name><name>clauses</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><call><name>newBooleanClause</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name><name>BooleanClause</name><operator>.</operator><name>Occur</name><operator>.</operator><name>MUST</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><operator>!</operator><name>required</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>prohibited</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name><name>clauses</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><call><name>newBooleanClause</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name><name>BooleanClause</name><operator>.</operator><name>Occur</name><operator>.</operator><name>SHOULD</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><operator>!</operator><name>required</name> <operator>&amp;&amp;</operator> <name>prohibited</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name><name>clauses</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><call><name>newBooleanClause</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name><name>BooleanClause</name><operator>.</operator><name>Occur</name><operator>.</operator><name>MUST_NOT</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
      <throw>throw <expr><operator>new</operator> <call><name>RuntimeException</name><argument_list>(<argument><expr><literal type="string">"Clause cannot be both required and prohibited"</literal></expr></argument>)</argument_list></call></expr>;</throw></block_content></block></else></if_stmt>
  </block_content>}</block></function>



  <function><type><specifier>protected</specifier> <name>Query</name></type> <name>newFieldQuery</name><parameter_list>(<parameter><decl><type><name>Analyzer</name></type> <name>analyzer</name></decl></parameter>, <parameter><decl><type><name>String</name></type> <name>field</name></decl></parameter>, <parameter><decl><type><name>String</name></type> <name>queryText</name></decl></parameter>, <parameter><decl><type><name>boolean</name></type> <name>quoted</name></decl></parameter>)</parameter_list>  <throws>throws <argument><expr><name>SyntaxError</name></expr></argument></throws> <block>{<block_content>
    <comment type="line">// Use the analyzer to get all the tokens, and then build a TermQuery,</comment>
    <comment type="line">// PhraseQuery, or nothing based on the term count</comment>

    <decl_stmt><decl><type><name>TokenStream</name></type> <name>source</name></decl>;</decl_stmt>
    <try>try <block>{<block_content>
      <expr_stmt><expr><name>source</name> <operator>=</operator> <call><name><name>analyzer</name><operator>.</operator><name>tokenStream</name></name><argument_list>(<argument><expr><name>field</name></expr></argument>, <argument><expr><operator>new</operator> <call><name>StringReader</name><argument_list>(<argument><expr><name>queryText</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>source</name><operator>.</operator><name>reset</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block> <catch>catch <parameter_list>(<parameter><decl><type><name>IOException</name></type> <name>e</name></decl></parameter>)</parameter_list> <block>{<block_content>
      <throw>throw <expr><operator>new</operator> <call><name>SyntaxError</name><argument_list>(<argument><expr><literal type="string">"Unable to initialize TokenStream to analyze query text"</literal></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</throw>
    </block_content>}</block></catch></try>
    <decl_stmt><decl><type><name>CachingTokenFilter</name></type> <name>buffer</name> <init>= <expr><operator>new</operator> <call><name>CachingTokenFilter</name><argument_list>(<argument><expr><name>source</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TermToBytesRefAttribute</name></type> <name>termAtt</name> <init>= <expr><literal type="null">null</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PositionIncrementAttribute</name></type> <name>posIncrAtt</name> <init>= <expr><literal type="null">null</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>numTokens</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name><name>buffer</name><operator>.</operator><name>reset</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><call><name><name>buffer</name><operator>.</operator><name>hasAttribute</name></name><argument_list>(<argument><expr><name><name>TermToBytesRefAttribute</name><operator>.</operator><name>class</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>termAtt</name> <operator>=</operator> <call><name><name>buffer</name><operator>.</operator><name>getAttribute</name></name><argument_list>(<argument><expr><name><name>TermToBytesRefAttribute</name><operator>.</operator><name>class</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name><name>buffer</name><operator>.</operator><name>hasAttribute</name></name><argument_list>(<argument><expr><name><name>PositionIncrementAttribute</name><operator>.</operator><name>class</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>posIncrAtt</name> <operator>=</operator> <call><name><name>buffer</name><operator>.</operator><name>getAttribute</name></name><argument_list>(<argument><expr><name><name>PositionIncrementAttribute</name><operator>.</operator><name>class</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <decl_stmt><decl><type><name>int</name></type> <name>positionCount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>boolean</name></type> <name>severalTokensAtSamePosition</name> <init>= <expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>boolean</name></type> <name>hasMoreTokens</name> <init>= <expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>termAtt</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
      <try>try <block>{<block_content>
        <expr_stmt><expr><name>hasMoreTokens</name> <operator>=</operator> <call><name><name>buffer</name><operator>.</operator><name>incrementToken</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <while>while <condition>(<expr><name>hasMoreTokens</name></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><name>numTokens</name><operator>++</operator></expr>;</expr_stmt>
          <decl_stmt><decl><type><name>int</name></type> <name>positionIncrement</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>posIncrAtt</name> <operator>!=</operator> <literal type="null">null</literal><operator>)</operator></expr> ?</condition><then> <expr><call><name><name>posIncrAtt</name><operator>.</operator><name>getPositionIncrement</name></name><argument_list>()</argument_list></call></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
          <if_stmt><if>if <condition>(<expr><name>positionIncrement</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>positionCount</name> <operator>+=</operator> <name>positionIncrement</name></expr>;</expr_stmt>
          </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><name>severalTokensAtSamePosition</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
          </block_content>}</block></else></if_stmt>
          <expr_stmt><expr><name>hasMoreTokens</name> <operator>=</operator> <call><name><name>buffer</name><operator>.</operator><name>incrementToken</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></while>
      </block_content>}</block> <catch>catch <parameter_list>(<parameter><decl><type><name>IOException</name></type> <name>e</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <comment type="line">// ignore</comment>
      </block_content>}</block></catch></try>
    </block_content>}</block></if></if_stmt>
    <try>try <block>{<block_content>
      <comment type="line">// rewind the buffer stream</comment>
      <expr_stmt><expr><call><name><name>buffer</name><operator>.</operator><name>reset</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

      <comment type="line">// close original stream - all tokens buffered</comment>
      <expr_stmt><expr><call><name><name>source</name><operator>.</operator><name>close</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    <catch>catch <parameter_list>(<parameter><decl><type><name>IOException</name></type> <name>e</name></decl></parameter>)</parameter_list> <block>{<block_content>
      <throw>throw <expr><operator>new</operator> <call><name>SyntaxError</name><argument_list>(<argument><expr><literal type="string">"Cannot close TokenStream analyzing query text"</literal></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</throw>
    </block_content>}</block></catch></try>

    <decl_stmt><decl><type><name>BytesRef</name></type> <name>bytes</name> <init>= <expr><ternary><condition><expr><name>termAtt</name> <operator>==</operator> <literal type="null">null</literal></expr> ?</condition><then> <expr><literal type="null">null</literal></expr> </then><else>: <expr><call><name><name>termAtt</name><operator>.</operator><name>getBytesRef</name></name><argument_list>()</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>numTokens</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
      <return>return <expr><literal type="null">null</literal></expr>;</return></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><name>numTokens</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
      <try>try <block>{<block_content>
        <decl_stmt><decl><type><name>boolean</name></type> <name>hasNext</name> <init>= <expr><call><name><name>buffer</name><operator>.</operator><name>incrementToken</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <assert>assert <expr><name>hasNext</name> <operator>==</operator> <literal type="boolean">true</literal></expr>;</assert>
        <expr_stmt><expr><call><name><name>termAtt</name><operator>.</operator><name>fillBytesRef</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block> <catch>catch <parameter_list>(<parameter><decl><type><name>IOException</name></type> <name>e</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <comment type="line">// safe to ignore, because we know the number of tokens</comment>
      </block_content>}</block></catch></try>
      <return>return <expr><call><name>newTermQuery</name><argument_list>(<argument><expr><operator>new</operator> <call><name>Term</name><argument_list>(<argument><expr><name>field</name></expr></argument>, <argument><expr><call><name><name>BytesRef</name><operator>.</operator><name>deepCopyOf</name></name><argument_list>(<argument><expr><name>bytes</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>severalTokensAtSamePosition</name> <operator>||</operator> <operator>(</operator><operator>!</operator><name>quoted</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>autoGeneratePhraseQueries</name><operator>)</operator></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>positionCount</name> <operator>==</operator> <literal type="number">1</literal> <operator>||</operator> <operator>(</operator><operator>!</operator><name>quoted</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>autoGeneratePhraseQueries</name><operator>)</operator></expr>)</condition> <block>{<block_content>
          <comment type="line">// no phrase query:</comment>
          <decl_stmt><decl><type><name>BooleanQuery</name></type> <name>q</name> <init>= <expr><call><name>newBooleanQuery</name><argument_list>(<argument><expr><name>positionCount</name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

          <decl_stmt><decl><type><name><name>BooleanClause</name><operator>.</operator><name>Occur</name></name></type> <name>occur</name> <init>= <expr><ternary><condition><expr><name>positionCount</name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>operator</name> <operator>==</operator> <name>AND_OPERATOR</name></expr> ?</condition><then>
            <expr><name><name>BooleanClause</name><operator>.</operator><name>Occur</name><operator>.</operator><name>MUST</name></name></expr> </then><else>: <expr><name><name>BooleanClause</name><operator>.</operator><name>Occur</name><operator>.</operator><name>SHOULD</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>

          <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numTokens</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <try>try <block>{<block_content>
              <decl_stmt><decl><type><name>boolean</name></type> <name>hasNext</name> <init>= <expr><call><name><name>buffer</name><operator>.</operator><name>incrementToken</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
              <assert>assert <expr><name>hasNext</name> <operator>==</operator> <literal type="boolean">true</literal></expr>;</assert>
              <expr_stmt><expr><call><name><name>termAtt</name><operator>.</operator><name>fillBytesRef</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block> <catch>catch <parameter_list>(<parameter><decl><type><name>IOException</name></type> <name>e</name></decl></parameter>)</parameter_list> <block>{<block_content>
              <comment type="line">// safe to ignore, because we know the number of tokens</comment>
            </block_content>}</block></catch></try>
            <decl_stmt><decl><type><name>Query</name></type> <name>currentQuery</name> <init>= <expr><call><name>newTermQuery</name><argument_list>(
                <argument><expr><operator>new</operator> <call><name>Term</name><argument_list>(<argument><expr><name>field</name></expr></argument>, <argument><expr><call><name><name>BytesRef</name><operator>.</operator><name>deepCopyOf</name></name><argument_list>(<argument><expr><name>bytes</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>q</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name>currentQuery</name></expr></argument>, <argument><expr><name>occur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></for>
          <return>return <expr><name>q</name></expr>;</return>
        </block_content>}</block></if>
        <else>else <block>{<block_content>
          <comment type="line">// phrase query:</comment>
          <decl_stmt><decl><type><name>MultiPhraseQuery</name></type> <name>mpq</name> <init>= <expr><call><name>newMultiPhraseQuery</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><call><name><name>mpq</name><operator>.</operator><name>setSlop</name></name><argument_list>(<argument><expr><name>phraseSlop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <decl_stmt><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name>Term</name></argument>&gt;</argument_list></name></type> <name>multiTerms</name> <init>= <expr><operator>new</operator> <call><name><name>ArrayList</name><argument_list type="generic">&lt;<argument><name>Term</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>int</name></type> <name>position</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
          <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numTokens</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>positionIncrement</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
            <try>try <block>{<block_content>
              <decl_stmt><decl><type><name>boolean</name></type> <name>hasNext</name> <init>= <expr><call><name><name>buffer</name><operator>.</operator><name>incrementToken</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
              <assert>assert <expr><name>hasNext</name> <operator>==</operator> <literal type="boolean">true</literal></expr>;</assert>
              <expr_stmt><expr><call><name><name>termAtt</name><operator>.</operator><name>fillBytesRef</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
              <if_stmt><if>if <condition>(<expr><name>posIncrAtt</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>positionIncrement</name> <operator>=</operator> <call><name><name>posIncrAtt</name><operator>.</operator><name>getPositionIncrement</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
              </block_content>}</block></if></if_stmt>
            </block_content>}</block> <catch>catch <parameter_list>(<parameter><decl><type><name>IOException</name></type> <name>e</name></decl></parameter>)</parameter_list> <block>{<block_content>
              <comment type="line">// safe to ignore, because we know the number of tokens</comment>
            </block_content>}</block></catch></try>

            <if_stmt><if>if <condition>(<expr><name>positionIncrement</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name><name>multiTerms</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
              <if_stmt><if>if <condition>(<expr><name>enablePositionIncrements</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name><name>mpq</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><call><name><name>multiTerms</name><operator>.</operator><name>toArray</name></name><argument_list>(<argument><expr><operator>new</operator> <name><name>Term</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name>position</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              </block_content>}</block></if> <else>else <block>{<block_content>
                <expr_stmt><expr><call><name><name>mpq</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><call><name><name>multiTerms</name><operator>.</operator><name>toArray</name></name><argument_list>(<argument><expr><operator>new</operator> <name><name>Term</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              </block_content>}</block></else></if_stmt>
              <expr_stmt><expr><call><name><name>multiTerms</name><operator>.</operator><name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>position</name> <operator>+=</operator> <name>positionIncrement</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>multiTerms</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><operator>new</operator> <call><name>Term</name><argument_list>(<argument><expr><name>field</name></expr></argument>, <argument><expr><call><name><name>BytesRef</name><operator>.</operator><name>deepCopyOf</name></name><argument_list>(<argument><expr><name>bytes</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></for>
          <if_stmt><if>if <condition>(<expr><name>enablePositionIncrements</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name><name>mpq</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><call><name><name>multiTerms</name><operator>.</operator><name>toArray</name></name><argument_list>(<argument><expr><operator>new</operator> <name><name>Term</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name>position</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><call><name><name>mpq</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><call><name><name>multiTerms</name><operator>.</operator><name>toArray</name></name><argument_list>(<argument><expr><operator>new</operator> <name><name>Term</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></else></if_stmt>
          <return>return <expr><name>mpq</name></expr>;</return>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if>
      <else>else <block>{<block_content>
        <decl_stmt><decl><type><name>PhraseQuery</name></type> <name>pq</name> <init>= <expr><call><name>newPhraseQuery</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>pq</name><operator>.</operator><name>setSlop</name></name><argument_list>(<argument><expr><name>phraseSlop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>position</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numTokens</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
          <decl_stmt><decl><type><name>int</name></type> <name>positionIncrement</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

          <try>try <block>{<block_content>
            <decl_stmt><decl><type><name>boolean</name></type> <name>hasNext</name> <init>= <expr><call><name><name>buffer</name><operator>.</operator><name>incrementToken</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <assert>assert <expr><name>hasNext</name> <operator>==</operator> <literal type="boolean">true</literal></expr>;</assert>
            <expr_stmt><expr><call><name><name>termAtt</name><operator>.</operator><name>fillBytesRef</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>posIncrAtt</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
              <expr_stmt><expr><name>positionIncrement</name> <operator>=</operator> <call><name><name>posIncrAtt</name><operator>.</operator><name>getPositionIncrement</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
          </block_content>}</block> <catch>catch <parameter_list>(<parameter><decl><type><name>IOException</name></type> <name>e</name></decl></parameter>)</parameter_list> <block>{<block_content>
            <comment type="line">// safe to ignore, because we know the number of tokens</comment>
          </block_content>}</block></catch></try>

          <if_stmt><if>if <condition>(<expr><name>enablePositionIncrements</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>position</name> <operator>+=</operator> <name>positionIncrement</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>pq</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><operator>new</operator> <call><name>Term</name><argument_list>(<argument><expr><name>field</name></expr></argument>, <argument><expr><call><name><name>BytesRef</name><operator>.</operator><name>deepCopyOf</name></name><argument_list>(<argument><expr><name>bytes</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name>position</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><call><name><name>pq</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><operator>new</operator> <call><name>Term</name><argument_list>(<argument><expr><name>field</name></expr></argument>, <argument><expr><call><name><name>BytesRef</name><operator>.</operator><name>deepCopyOf</name></name><argument_list>(<argument><expr><name>bytes</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></else></if_stmt>
        </block_content>}</block></for>
        <return>return <expr><name>pq</name></expr>;</return>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></function>



  <comment type="block" format="javadoc">/**
   * Base implementation delegates to {@link #getFieldQuery(String,String,boolean)}.
   * This method may be overridden, for example, to return
   * a SpanNearQuery instead of a PhraseQuery.
   *
   */</comment>
  <function><type><specifier>protected</specifier> <name>Query</name></type> <name>getFieldQuery</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>field</name></decl></parameter>, <parameter><decl><type><name>String</name></type> <name>queryText</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>slop</name></decl></parameter>)</parameter_list>
        <throws>throws <argument><expr><name>SyntaxError</name></expr></argument></throws> <block>{<block_content>
    <decl_stmt><decl><type><name>Query</name></type> <name>query</name> <init>= <expr><call><name>getFieldQuery</name><argument_list>(<argument><expr><name>field</name></expr></argument>, <argument><expr><name>queryText</name></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>query</name> <operator>instanceof</operator> <name>PhraseQuery</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><operator>(</operator><operator>(</operator><name>PhraseQuery</name><operator>)</operator> <name>query</name><operator>)</operator><operator>.</operator><call><name>setSlop</name><argument_list>(<argument><expr><name>slop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>query</name> <operator>instanceof</operator> <name>MultiPhraseQuery</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><operator>(</operator><operator>(</operator><name>MultiPhraseQuery</name><operator>)</operator> <name>query</name><operator>)</operator><operator>.</operator><call><name>setSlop</name><argument_list>(<argument><expr><name>slop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>query</name></expr>;</return>
  </block_content>}</block></function>


 <comment type="block" format="javadoc">/**
  * Builds a new BooleanQuery instance
  * @param disableCoord disable coord
  * @return new BooleanQuery instance
  */</comment>
  <function><type><specifier>protected</specifier> <name>BooleanQuery</name></type> <name>newBooleanQuery</name><parameter_list>(<parameter><decl><type><name>boolean</name></type> <name>disableCoord</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <return>return <expr><operator>new</operator> <call><name>BooleanQuery</name><argument_list>(<argument><expr><name>disableCoord</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></function>

 <comment type="block" format="javadoc">/**
  * Builds a new BooleanClause instance
  * @param q sub query
  * @param occur how this clause should occur when matching documents
  * @return new BooleanClause instance
  */</comment>
  <function><type><specifier>protected</specifier> <name>BooleanClause</name></type> <name>newBooleanClause</name><parameter_list>(<parameter><decl><type><name>Query</name></type> <name>q</name></decl></parameter>, <parameter><decl><type><name><name>BooleanClause</name><operator>.</operator><name>Occur</name></name></type> <name>occur</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <return>return <expr><operator>new</operator> <call><name>BooleanClause</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name>occur</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></function>

  <comment type="block" format="javadoc">/**
   * Builds a new TermQuery instance
   * @param term term
   * @return new TermQuery instance
   */</comment>
  <function><type><specifier>protected</specifier> <name>Query</name></type> <name>newTermQuery</name><parameter_list>(<parameter><decl><type><name>Term</name></type> <name>term</name></decl></parameter>)</parameter_list><block>{<block_content>
    <return>return <expr><operator>new</operator> <call><name>TermQuery</name><argument_list>(<argument><expr><name>term</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></function>

  <comment type="block" format="javadoc">/**
   * Builds a new PhraseQuery instance
   * @return new PhraseQuery instance
   */</comment>
  <function><type><specifier>protected</specifier> <name>PhraseQuery</name></type> <name>newPhraseQuery</name><parameter_list>()</parameter_list><block>{<block_content>
    <return>return <expr><operator>new</operator> <call><name>PhraseQuery</name><argument_list>()</argument_list></call></expr>;</return>
  </block_content>}</block></function>

  <comment type="block" format="javadoc">/**
   * Builds a new MultiPhraseQuery instance
   * @return new MultiPhraseQuery instance
   */</comment>
  <function><type><specifier>protected</specifier> <name>MultiPhraseQuery</name></type> <name>newMultiPhraseQuery</name><parameter_list>()</parameter_list><block>{<block_content>
    <return>return <expr><operator>new</operator> <call><name>MultiPhraseQuery</name><argument_list>()</argument_list></call></expr>;</return>
  </block_content>}</block></function>

  <comment type="block" format="javadoc">/**
   * Builds a new PrefixQuery instance
   * @param prefix Prefix term
   * @return new PrefixQuery instance
   */</comment>
  <function><type><specifier>protected</specifier> <name>Query</name></type> <name>newPrefixQuery</name><parameter_list>(<parameter><decl><type><name>Term</name></type> <name>prefix</name></decl></parameter>)</parameter_list><block>{<block_content>
    <decl_stmt><decl><type><name>PrefixQuery</name></type> <name>query</name> <init>= <expr><operator>new</operator> <call><name>PrefixQuery</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>query</name><operator>.</operator><name>setRewriteMethod</name></name><argument_list>(<argument><expr><name>multiTermRewriteMethod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>query</name></expr>;</return>
  </block_content>}</block></function>

  <comment type="block" format="javadoc">/**
   * Builds a new RegexpQuery instance
   * @param regexp Regexp term
   * @return new RegexpQuery instance
   */</comment>
  <function><type><specifier>protected</specifier> <name>Query</name></type> <name>newRegexpQuery</name><parameter_list>(<parameter><decl><type><name>Term</name></type> <name>regexp</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>RegexpQuery</name></type> <name>query</name> <init>= <expr><operator>new</operator> <call><name>RegexpQuery</name><argument_list>(<argument><expr><name>regexp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>query</name><operator>.</operator><name>setRewriteMethod</name></name><argument_list>(<argument><expr><name>multiTermRewriteMethod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>query</name></expr>;</return>
  </block_content>}</block></function>

  <comment type="block" format="javadoc">/**
   * Builds a new FuzzyQuery instance
   * @param term Term
   * @param minimumSimilarity minimum similarity
   * @param prefixLength prefix length
   * @return new FuzzyQuery Instance
   */</comment>
  <function><type><specifier>protected</specifier> <name>Query</name></type> <name>newFuzzyQuery</name><parameter_list>(<parameter><decl><type><name>Term</name></type> <name>term</name></decl></parameter>, <parameter><decl><type><name>float</name></type> <name>minimumSimilarity</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>prefixLength</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <comment type="line">// FuzzyQuery doesn't yet allow constant score rewrite</comment>
    <decl_stmt><decl><type><name>String</name></type> <name>text</name> <init>= <expr><call><name><name>term</name><operator>.</operator><name>text</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>numEdits</name> <init>= <expr><call><name><name>FuzzyQuery</name><operator>.</operator><name>floatToEdits</name></name><argument_list>(<argument><expr><name>minimumSimilarity</name></expr></argument>, 
        <argument><expr><call><name><name>text</name><operator>.</operator><name>codePointCount</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name><name>text</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <return>return <expr><operator>new</operator> <call><name>FuzzyQuery</name><argument_list>(<argument><expr><name>term</name></expr></argument>,<argument><expr><name>numEdits</name></expr></argument>,<argument><expr><name>prefixLength</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></function>

  <comment type="block" format="javadoc">/**
   * Builds a new MatchAllDocsQuery instance
   * @return new MatchAllDocsQuery instance
   */</comment>
  <function><type><specifier>protected</specifier> <name>Query</name></type> <name>newMatchAllDocsQuery</name><parameter_list>()</parameter_list> <block>{<block_content>
    <return>return <expr><operator>new</operator> <call><name>MatchAllDocsQuery</name><argument_list>()</argument_list></call></expr>;</return>
  </block_content>}</block></function>

  <comment type="block" format="javadoc">/**
   * Builds a new WildcardQuery instance
   * @param t wildcard term
   * @return new WildcardQuery instance
   */</comment>
  <function><type><specifier>protected</specifier> <name>Query</name></type> <name>newWildcardQuery</name><parameter_list>(<parameter><decl><type><name>Term</name></type> <name>t</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>WildcardQuery</name></type> <name>query</name> <init>= <expr><operator>new</operator> <call><name>WildcardQuery</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>query</name><operator>.</operator><name>setRewriteMethod</name></name><argument_list>(<argument><expr><name>multiTermRewriteMethod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>query</name></expr>;</return>
  </block_content>}</block></function>

  <comment type="block" format="javadoc">/**
   * Factory method for generating query, given a set of clauses.
   * By default creates a boolean query composed of clauses passed in.
   *
   * Can be overridden by extending classes, to modify query being
   * returned.
   *
   * @param clauses List that contains {@link org.apache.lucene.search.BooleanClause} instances
   *    to join.
   *
   * @return Resulting {@link org.apache.lucene.search.Query} object.
   */</comment>
  <function><type><specifier>protected</specifier> <name>Query</name></type> <name>getBooleanQuery</name><parameter_list>(<parameter><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name>BooleanClause</name></argument>&gt;</argument_list></name></type> <name>clauses</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>SyntaxError</name></expr></argument></throws> <block>{<block_content>
    <return>return <expr><call><name>getBooleanQuery</name><argument_list>(<argument><expr><name>clauses</name></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></function>

  <comment type="block" format="javadoc">/**
   * Factory method for generating query, given a set of clauses.
   * By default creates a boolean query composed of clauses passed in.
   *
   * Can be overridden by extending classes, to modify query being
   * returned.
   *
   * @param clauses List that contains {@link org.apache.lucene.search.BooleanClause} instances
   *    to join.
   * @param disableCoord true if coord scoring should be disabled.
   *
   * @return Resulting {@link org.apache.lucene.search.Query} object.
   */</comment>
  <function><type><specifier>protected</specifier> <name>Query</name></type> <name>getBooleanQuery</name><parameter_list>(<parameter><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name>BooleanClause</name></argument>&gt;</argument_list></name></type> <name>clauses</name></decl></parameter>, <parameter><decl><type><name>boolean</name></type> <name>disableCoord</name></decl></parameter>)</parameter_list>
    <throws>throws <argument><expr><name>SyntaxError</name></expr></argument></throws>
  <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name><name>clauses</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call><operator>==</operator><literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <return>return <expr><literal type="null">null</literal></expr>;</return> <comment type="line">// all clause words were filtered away by the analyzer.</comment>
    </block_content>}</block></if></if_stmt>
    <decl_stmt><decl><type><name>BooleanQuery</name></type> <name>query</name> <init>= <expr><call><name>newBooleanQuery</name><argument_list>(<argument><expr><name>disableCoord</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <for>for<control>(<init><decl><type><specifier>final</specifier> <name>BooleanClause</name></type> <name>clause</name><range>: <expr><name>clauses</name></expr></range></decl></init>)</control> <block>{<block_content>
      <expr_stmt><expr><call><name><name>query</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <return>return <expr><name>query</name></expr>;</return>
  </block_content>}</block></function>


   <comment type="line">// called from parser</comment>
  <function><type><name>Query</name></type> <name>handleBareTokenQuery</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>qfield</name></decl></parameter>, <parameter><decl><type><name>Token</name></type> <name>term</name></decl></parameter>, <parameter><decl><type><name>Token</name></type> <name>fuzzySlop</name></decl></parameter>, <parameter><decl><type><name>boolean</name></type> <name>prefix</name></decl></parameter>, <parameter><decl><type><name>boolean</name></type> <name>wildcard</name></decl></parameter>, <parameter><decl><type><name>boolean</name></type> <name>fuzzy</name></decl></parameter>, <parameter><decl><type><name>boolean</name></type> <name>regexp</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>SyntaxError</name></expr></argument></throws> <block>{<block_content>
    <decl_stmt><decl><type><name>Query</name></type> <name>q</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>String</name></type> <name>termImage</name><init>=<expr><call><name>discardEscapeChar</name><argument_list>(<argument><expr><name><name>term</name><operator>.</operator><name>image</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>wildcard</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>q</name> <operator>=</operator> <call><name>getWildcardQuery</name><argument_list>(<argument><expr><name>qfield</name></expr></argument>, <argument><expr><name><name>term</name><operator>.</operator><name>image</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>prefix</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>q</name> <operator>=</operator> <call><name>getPrefixQuery</name><argument_list>(<argument><expr><name>qfield</name></expr></argument>,
          <argument><expr><call><name>discardEscapeChar</name><argument_list>(<argument><expr><call><name><name>term</name><operator>.</operator><name>image</name><operator>.</operator><name>substring</name></name>
              <argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name><name>term</name><operator>.</operator><name>image</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>regexp</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>q</name> <operator>=</operator> <call><name>getRegexpQuery</name><argument_list>(<argument><expr><name>qfield</name></expr></argument>, <argument><expr><call><name><name>term</name><operator>.</operator><name>image</name><operator>.</operator><name>substring</name></name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name><name>term</name><operator>.</operator><name>image</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>fuzzy</name></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>float</name></type> <name>fms</name> <init>= <expr><name>fuzzyMinSim</name></expr></init></decl>;</decl_stmt>
      <try>try <block>{<block_content>
        <expr_stmt><expr><name>fms</name> <operator>=</operator> <call><name><name>Float</name><operator>.</operator><name>valueOf</name></name><argument_list>(<argument><expr><call><name><name>fuzzySlop</name><operator>.</operator><name>image</name><operator>.</operator><name>substring</name></name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>.</operator><call><name>floatValue</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block> <catch>catch <parameter_list>(<parameter><decl><type><name>Exception</name></type> <name>ignored</name></decl></parameter>)</parameter_list> <block>{<block_content> </block_content>}</block></catch></try>
      <if_stmt><if>if<condition>(<expr><name>fms</name> <operator>&lt;</operator> <literal type="number">0.0f</literal></expr>)</condition><block>{<block_content>
        <throw>throw <expr><operator>new</operator> <call><name>SyntaxError</name><argument_list>(<argument><expr><literal type="string">"Minimum similarity for a FuzzyQuery has to be between 0.0f and 1.0f !"</literal></expr></argument>)</argument_list></call></expr>;</throw>
      </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>fms</name> <operator>&gt;=</operator> <literal type="number">1.0f</literal> <operator>&amp;&amp;</operator> <name>fms</name> <operator>!=</operator> <operator>(</operator><name>int</name><operator>)</operator> <name>fms</name></expr>)</condition> <block>{<block_content>
        <throw>throw <expr><operator>new</operator> <call><name>SyntaxError</name><argument_list>(<argument><expr><literal type="string">"Fractional edit distances are not allowed!"</literal></expr></argument>)</argument_list></call></expr>;</throw>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>q</name> <operator>=</operator> <call><name>getFuzzyQuery</name><argument_list>(<argument><expr><name>qfield</name></expr></argument>, <argument><expr><name>termImage</name></expr></argument>, <argument><expr><name>fms</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><name>q</name> <operator>=</operator> <call><name>getFieldQuery</name><argument_list>(<argument><expr><name>qfield</name></expr></argument>, <argument><expr><name>termImage</name></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <return>return <expr><name>q</name></expr>;</return>
  </block_content>}</block></function>

  <comment type="line">// called from parser</comment>
  <function><type><name>Query</name></type> <name>handleQuotedTerm</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>qfield</name></decl></parameter>, <parameter><decl><type><name>Token</name></type> <name>term</name></decl></parameter>, <parameter><decl><type><name>Token</name></type> <name>fuzzySlop</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>SyntaxError</name></expr></argument></throws> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>s</name> <init>= <expr><name>phraseSlop</name></expr></init></decl>;</decl_stmt>  <comment type="line">// default</comment>
    <if_stmt><if>if <condition>(<expr><name>fuzzySlop</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
      <try>try <block>{<block_content>
        <expr_stmt><expr><name>s</name> <operator>=</operator> <call><name><name>Float</name><operator>.</operator><name>valueOf</name></name><argument_list>(<argument><expr><call><name><name>fuzzySlop</name><operator>.</operator><name>image</name><operator>.</operator><name>substring</name></name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>.</operator><call><name>intValue</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block>
      <catch>catch <parameter_list>(<parameter><decl><type><name>Exception</name></type> <name>ignored</name></decl></parameter>)</parameter_list> <block>{<block_content> </block_content>}</block></catch></try>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><call><name>getFieldQuery</name><argument_list>(<argument><expr><name>qfield</name></expr></argument>, <argument><expr><call><name>discardEscapeChar</name><argument_list>(<argument><expr><call><name><name>term</name><operator>.</operator><name>image</name><operator>.</operator><name>substring</name></name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name><name>term</name><operator>.</operator><name>image</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></function>

  <comment type="line">// called from parser</comment>
  <function><type><name>Query</name></type> <name>handleBoost</name><parameter_list>(<parameter><decl><type><name>Query</name></type> <name>q</name></decl></parameter>, <parameter><decl><type><name>Token</name></type> <name>boost</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>boost</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>float</name></type> <name>boostVal</name> <init>= <expr><call><name><name>Float</name><operator>.</operator><name>parseFloat</name></name><argument_list>(<argument><expr><name><name>boost</name><operator>.</operator><name>image</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <comment type="line">// avoid boosting null queries, such as those caused by stop words</comment>
      <if_stmt><if>if <condition>(<expr><name>q</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name><name>q</name><operator>.</operator><name>setBoost</name></name><argument_list>(<argument><expr><name>boostVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>q</name></expr>;</return>
  </block_content>}</block></function>



  <comment type="block" format="javadoc">/**
   * Returns a String where the escape char has been
   * removed, or kept only once if there was a double escape.
   *
   * Supports escaped unicode characters, e. g. translates
   * &lt;code&gt;\\u0041&lt;/code&gt; to &lt;code&gt;A&lt;/code&gt;.
   *
   */</comment>
  <function><type><name>String</name></type> <name>discardEscapeChar</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>input</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>SyntaxError</name></expr></argument></throws> <block>{<block_content>
    <comment type="line">// Create char array to hold unescaped char sequence</comment>
    <decl_stmt><decl><type><name><name>char</name><index>[]</index></name></type> <name>output</name> <init>= <expr><operator>new</operator> <name><name>char</name><index>[<expr><call><name><name>input</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr>]</index></name></expr></init></decl>;</decl_stmt>

    <comment type="line">// The length of the output can be less than the input</comment>
    <comment type="line">// due to discarded escape chars. This variable holds</comment>
    <comment type="line">// the actual length of the output</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>length</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <comment type="line">// We remember whether the last processed character was</comment>
    <comment type="line">// an escape character</comment>
    <decl_stmt><decl><type><name>boolean</name></type> <name>lastCharWasEscapeChar</name> <init>= <expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt>

    <comment type="line">// The multiplier the current unicode digit must be multiplied with.</comment>
    <comment type="line">// E. g. the first digit must be multiplied with 16^3, the second with 16^2...</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>codePointMultiplier</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <comment type="line">// Used to calculate the codepoint of the escaped unicode character</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>codePoint</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name><name>input</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
      <decl_stmt><decl><type><name>char</name></type> <name>curChar</name> <init>= <expr><call><name><name>input</name><operator>.</operator><name>charAt</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><name>codePointMultiplier</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>codePoint</name> <operator>+=</operator> <call><name>hexToInt</name><argument_list>(<argument><expr><name>curChar</name></expr></argument>)</argument_list></call> <operator>*</operator> <name>codePointMultiplier</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>codePointMultiplier</name> <operator>&gt;&gt;&gt;=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>codePointMultiplier</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><name><name>output</name><index>[<expr><name>length</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator><name>codePoint</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>codePoint</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>lastCharWasEscapeChar</name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>curChar</name> <operator>==</operator> <literal type="char">'u'</literal></expr>)</condition> <block>{<block_content>
          <comment type="line">// found an escaped unicode character</comment>
          <expr_stmt><expr><name>codePointMultiplier</name> <operator>=</operator> <literal type="number">16</literal> <operator>*</operator> <literal type="number">16</literal> <operator>*</operator> <literal type="number">16</literal></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
          <comment type="line">// this character was escaped</comment>
          <expr_stmt><expr><name><name>output</name><index>[<expr><name>length</name></expr>]</index></name> <operator>=</operator> <name>curChar</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>length</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><name>lastCharWasEscapeChar</name> <operator>=</operator> <literal type="boolean">false</literal></expr>;</expr_stmt>
      </block_content>}</block></if> <else>else <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>curChar</name> <operator>==</operator> <literal type="char">'\\'</literal></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><name>lastCharWasEscapeChar</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
          <expr_stmt><expr><name><name>output</name><index>[<expr><name>length</name></expr>]</index></name> <operator>=</operator> <name>curChar</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>length</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>

    <if_stmt><if>if <condition>(<expr><name>codePointMultiplier</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <throw>throw <expr><operator>new</operator> <call><name>SyntaxError</name><argument_list>(<argument><expr><literal type="string">"Truncated unicode escape sequence."</literal></expr></argument>)</argument_list></call></expr>;</throw>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>lastCharWasEscapeChar</name></expr>)</condition> <block>{<block_content>
      <throw>throw <expr><operator>new</operator> <call><name>SyntaxError</name><argument_list>(<argument><expr><literal type="string">"Term can not end with escape character."</literal></expr></argument>)</argument_list></call></expr>;</throw>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><operator>new</operator> <call><name>String</name><argument_list>(<argument><expr><name>output</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></function>

  <comment type="block" format="javadoc">/** Returns the numeric value of the hexadecimal character */</comment>
  <function><type><specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>hexToInt</name><parameter_list>(<parameter><decl><type><name>char</name></type> <name>c</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>SyntaxError</name></expr></argument></throws> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><literal type="char">'0'</literal> <operator>&lt;=</operator> <name>c</name> <operator>&amp;&amp;</operator> <name>c</name> <operator>&lt;=</operator> <literal type="char">'9'</literal></expr>)</condition> <block>{<block_content>
      <return>return <expr><name>c</name> <operator>-</operator> <literal type="char">'0'</literal></expr>;</return>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><literal type="char">'a'</literal> <operator>&lt;=</operator> <name>c</name> <operator>&amp;&amp;</operator> <name>c</name> <operator>&lt;=</operator> <literal type="char">'f'</literal></expr>)</condition><block>{<block_content>
      <return>return <expr><name>c</name> <operator>-</operator> <literal type="char">'a'</literal> <operator>+</operator> <literal type="number">10</literal></expr>;</return>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><literal type="char">'A'</literal> <operator>&lt;=</operator> <name>c</name> <operator>&amp;&amp;</operator> <name>c</name> <operator>&lt;=</operator> <literal type="char">'F'</literal></expr>)</condition> <block>{<block_content>
      <return>return <expr><name>c</name> <operator>-</operator> <literal type="char">'A'</literal> <operator>+</operator> <literal type="number">10</literal></expr>;</return>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <throw>throw <expr><operator>new</operator> <call><name>SyntaxError</name><argument_list>(<argument><expr><literal type="string">"Non-hex character in Unicode escape sequence: "</literal> <operator>+</operator> <name>c</name></expr></argument>)</argument_list></call></expr>;</throw>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></function>

  <comment type="block" format="javadoc">/**
   * Returns a String where those characters that QueryParser
   * expects to be escaped are escaped by a preceding &lt;code&gt;\&lt;/code&gt;.
   */</comment>
  <function><type><specifier>public</specifier> <specifier>static</specifier> <name>String</name></type> <name>escape</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>s</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>StringBuilder</name></type> <name>sb</name> <init>= <expr><operator>new</operator> <call><name>StringBuilder</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name><name>s</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
      <decl_stmt><decl><type><name>char</name></type> <name>c</name> <init>= <expr><call><name><name>s</name><operator>.</operator><name>charAt</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <comment type="line">// These characters are part of the query syntax and must be escaped</comment>
      <if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'\\'</literal> <operator>||</operator> <name>c</name> <operator>==</operator> <literal type="char">'+'</literal> <operator>||</operator> <name>c</name> <operator>==</operator> <literal type="char">'-'</literal> <operator>||</operator> <name>c</name> <operator>==</operator> <literal type="char">'!'</literal> <operator>||</operator> <name>c</name> <operator>==</operator> <literal type="char">'('</literal> <operator>||</operator> <name>c</name> <operator>==</operator> <literal type="char">')'</literal> <operator>||</operator> <name>c</name> <operator>==</operator> <literal type="char">':'</literal>
        <operator>||</operator> <name>c</name> <operator>==</operator> <literal type="char">'^'</literal> <operator>||</operator> <name>c</name> <operator>==</operator> <literal type="char">'['</literal> <operator>||</operator> <name>c</name> <operator>==</operator> <literal type="char">']'</literal> <operator>||</operator> <name>c</name> <operator>==</operator> <literal type="char">'\"'</literal> <operator>||</operator> <name>c</name> <operator>==</operator> <literal type="char">'{'</literal> <operator>||</operator> <name>c</name> <operator>==</operator> <literal type="char">'}'</literal> <operator>||</operator> <name>c</name> <operator>==</operator> <literal type="char">'~'</literal>
        <operator>||</operator> <name>c</name> <operator>==</operator> <literal type="char">'*'</literal> <operator>||</operator> <name>c</name> <operator>==</operator> <literal type="char">'?'</literal> <operator>||</operator> <name>c</name> <operator>==</operator> <literal type="char">'|'</literal> <operator>||</operator> <name>c</name> <operator>==</operator> <literal type="char">'&amp;'</literal> <operator>||</operator> <name>c</name> <operator>==</operator> <literal type="char">'/'</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name><name>sb</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><literal type="char">'\\'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name><name>sb</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <return>return <expr><call><name><name>sb</name><operator>.</operator><name>toString</name></name><argument_list>()</argument_list></call></expr>;</return>
  </block_content>}</block></function>


  <function><type><specifier>protected</specifier> <name>ReversedWildcardFilterFactory</name></type> <name>getReversedWildcardFilterFactory</name><parameter_list>(<parameter><decl><type><name>FieldType</name></type> <name>fieldType</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>leadingWildcards</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>leadingWildcards</name> <operator>=</operator> <operator>new</operator> <call><name><name>HashMap</name><argument_list type="generic">&lt;<argument><name>FieldType</name></argument>, <argument><name>ReversedWildcardFilterFactory</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <decl_stmt><decl><type><name>ReversedWildcardFilterFactory</name></type> <name>fac</name> <init>= <expr><call><name><name>leadingWildcards</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>fieldType</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>fac</name> <operator>!=</operator> <literal type="null">null</literal> <operator>||</operator> <call><name><name>leadingWildcards</name><operator>.</operator><name>containsKey</name></name><argument_list>(<argument><expr><name>fac</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <return>return <expr><name>fac</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <decl_stmt><decl><type><name>Analyzer</name></type> <name>a</name> <init>= <expr><call><name><name>fieldType</name><operator>.</operator><name>getAnalyzer</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>a</name> <operator>instanceof</operator> <name>TokenizerChain</name></expr>)</condition> <block>{<block_content>
      <comment type="line">// examine the indexing analysis chain if it supports leading wildcards</comment>
      <decl_stmt><decl><type><name>TokenizerChain</name></type> <name>tc</name> <init>= <expr><operator>(</operator><name>TokenizerChain</name><operator>)</operator><name>a</name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name><name>TokenFilterFactory</name><index>[]</index></name></type> <name>factories</name> <init>= <expr><call><name><name>tc</name><operator>.</operator><name>getTokenFilterFactories</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
      <for>for <control>(<init><decl><type><name>TokenFilterFactory</name></type> <name>factory</name> <range>: <expr><name>factories</name></expr></range></decl></init>)</control> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>factory</name> <operator>instanceof</operator> <name>ReversedWildcardFilterFactory</name></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><name>fac</name> <operator>=</operator> <operator>(</operator><name>ReversedWildcardFilterFactory</name><operator>)</operator><name>factory</name></expr>;</expr_stmt>
          <break>break;</break>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name><name>leadingWildcards</name><operator>.</operator><name>put</name></name><argument_list>(<argument><expr><name>fieldType</name></expr></argument>, <argument><expr><name>fac</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>fac</name></expr>;</return>
  </block_content>}</block></function>


  <function><type><specifier>private</specifier> <name>void</name></type> <name>checkNullField</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>field</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>SolrException</name></expr></argument></throws> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>field</name> <operator>==</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <name>defaultField</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
      <throw>throw <expr><operator>new</operator> <call><name>SolrException</name>
          <argument_list>(<argument><expr><name><name>SolrException</name><operator>.</operator><name>ErrorCode</name><operator>.</operator><name>BAD_REQUEST</name></name></expr></argument>,
              <argument><expr><literal type="string">"no field name specified in query and no default specified via 'df' param"</literal></expr></argument>)</argument_list></call></expr>;</throw>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></function>

  <function><type><specifier>protected</specifier> <name>String</name></type> <name>analyzeIfMultitermTermText</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>field</name></decl></parameter>, <parameter><decl><type><name>String</name></type> <name>part</name></decl></parameter>, <parameter><decl><type><name>FieldType</name></type> <name>fieldType</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>part</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>part</name></expr>;</return></block_content></block></if></if_stmt>

    <decl_stmt><decl><type><name>SchemaField</name></type> <name>sf</name> <init>= <expr><call><name><name>schema</name><operator>.</operator><name>getFieldOrNull</name></name><argument_list>(<argument><expr><operator>(</operator><name>field</name><operator>)</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>sf</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <operator>!</operator> <operator>(</operator><name>fieldType</name> <operator>instanceof</operator> <name>TextField</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>part</name></expr>;</return></block_content></block></if></if_stmt>
    <decl_stmt><decl><type><name>String</name></type> <name>out</name> <init>= <expr><call><name><name>TextField</name><operator>.</operator><name>analyzeMultiTerm</name></name><argument_list>(<argument><expr><name>field</name></expr></argument>, <argument><expr><name>part</name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>TextField</name><operator>)</operator><name>fieldType</name><operator>)</operator><operator>.</operator><call><name>getMultiTermAnalyzer</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>.</operator><call><name>utf8ToString</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <return>return <expr><name>out</name></expr>;</return>
  </block_content>}</block></function>


  <comment type="line">// called from parser</comment>
  <function><type><specifier>protected</specifier> <name>Query</name></type> <name>getFieldQuery</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>field</name></decl></parameter>, <parameter><decl><type><name>String</name></type> <name>queryText</name></decl></parameter>, <parameter><decl><type><name>boolean</name></type> <name>quoted</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>SyntaxError</name></expr></argument></throws> <block>{<block_content>
    <expr_stmt><expr><call><name>checkNullField</name><argument_list>(<argument><expr><name>field</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="line">// intercept magic field name of "_" to use as a hook for our</comment>
    <comment type="line">// own functions.</comment>
    <if_stmt><if>if <condition>(<expr><call><name><name>field</name><operator>.</operator><name>charAt</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="char">'_'</literal> <operator>&amp;&amp;</operator> <name>parser</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>MagicFieldName</name></type> <name>magic</name> <init>= <expr><call><name><name>MagicFieldName</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>field</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><literal type="null">null</literal> <operator>!=</operator> <name>magic</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>QParser</name></type> <name>nested</name> <init>= <expr><call><name><name>parser</name><operator>.</operator><name>subQuery</name></name><argument_list>(<argument><expr><name>queryText</name></expr></argument>, <argument><expr><name><name>magic</name><operator>.</operator><name>subParser</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <return>return <expr><call><name><name>nested</name><operator>.</operator><name>getQuery</name></name><argument_list>()</argument_list></call></expr>;</return>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <decl_stmt><decl><type><name>SchemaField</name></type> <name>sf</name> <init>= <expr><call><name><name>schema</name><operator>.</operator><name>getFieldOrNull</name></name><argument_list>(<argument><expr><name>field</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>sf</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>FieldType</name></type> <name>ft</name> <init>= <expr><call><name><name>sf</name><operator>.</operator><name>getType</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
      <comment type="line">// delegate to type for everything except tokenized fields</comment>
      <if_stmt><if>if <condition>(<expr><call><name><name>ft</name><operator>.</operator><name>isTokenized</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
        <return>return <expr><call><name>newFieldQuery</name><argument_list>(<argument><expr><name>analyzer</name></expr></argument>, <argument><expr><name>field</name></expr></argument>, <argument><expr><name>queryText</name></expr></argument>, <argument><expr><name>quoted</name> <operator>||</operator> <operator>(</operator><name>ft</name> <operator>instanceof</operator> <name>TextField</name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name>TextField</name><operator>)</operator><name>ft</name><operator>)</operator><operator>.</operator><call><name>getAutoGeneratePhraseQueries</name><argument_list>()</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</return>
      </block_content>}</block></if> <else>else <block>{<block_content>
        <return>return <expr><call><name><name>sf</name><operator>.</operator><name>getType</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getFieldQuery</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>sf</name></expr></argument>, <argument><expr><name>queryText</name></expr></argument>)</argument_list></call></expr>;</return>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// default to a normal field query</comment>
    <return>return <expr><call><name>newFieldQuery</name><argument_list>(<argument><expr><name>analyzer</name></expr></argument>, <argument><expr><name>field</name></expr></argument>, <argument><expr><name>queryText</name></expr></argument>, <argument><expr><name>quoted</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></function>


  <comment type="line">// called from parser</comment>
  <function><type><specifier>protected</specifier> <name>Query</name></type> <name>getRangeQuery</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>field</name></decl></parameter>, <parameter><decl><type><name>String</name></type> <name>part1</name></decl></parameter>, <parameter><decl><type><name>String</name></type> <name>part2</name></decl></parameter>, <parameter><decl><type><name>boolean</name></type> <name>startInclusive</name></decl></parameter>, <parameter><decl><type><name>boolean</name></type> <name>endInclusive</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>SyntaxError</name></expr></argument></throws> <block>{<block_content>
    <expr_stmt><expr><call><name>checkNullField</name><argument_list>(<argument><expr><name>field</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>SchemaField</name></type> <name>sf</name> <init>= <expr><call><name><name>schema</name><operator>.</operator><name>getField</name></name><argument_list>(<argument><expr><name>field</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <return>return <expr><call><name><name>sf</name><operator>.</operator><name>getType</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getRangeQuery</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>sf</name></expr></argument>, <argument><expr><name>part1</name></expr></argument>, <argument><expr><name>part2</name></expr></argument>, <argument><expr><name>startInclusive</name></expr></argument>, <argument><expr><name>endInclusive</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></function>

  <comment type="line">// called from parser</comment>
  <function><type><specifier>protected</specifier> <name>Query</name></type> <name>getPrefixQuery</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>field</name></decl></parameter>, <parameter><decl><type><name>String</name></type> <name>termStr</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>SyntaxError</name></expr></argument></throws> <block>{<block_content>
    <expr_stmt><expr><call><name>checkNullField</name><argument_list>(<argument><expr><name>field</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>termStr</name> <operator>=</operator> <call><name>analyzeIfMultitermTermText</name><argument_list>(<argument><expr><name>field</name></expr></argument>, <argument><expr><name>termStr</name></expr></argument>, <argument><expr><call><name><name>schema</name><operator>.</operator><name>getFieldType</name></name><argument_list>(<argument><expr><name>field</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Solr has always used constant scoring for prefix queries.  This should return constant scoring by default.</comment>
    <return>return <expr><call><name>newPrefixQuery</name><argument_list>(<argument><expr><operator>new</operator> <call><name>Term</name><argument_list>(<argument><expr><name>field</name></expr></argument>, <argument><expr><name>termStr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></function>

  <comment type="line">// called from parser</comment>
  <function><type><specifier>protected</specifier> <name>Query</name></type> <name>getWildcardQuery</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>field</name></decl></parameter>, <parameter><decl><type><name>String</name></type> <name>termStr</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>SyntaxError</name></expr></argument></throws> <block>{<block_content>
    <expr_stmt><expr><call><name>checkNullField</name><argument_list>(<argument><expr><name>field</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="line">// *:* -&gt; MatchAllDocsQuery</comment>
    <if_stmt><if>if <condition>(<expr><literal type="string">"*"</literal><operator>.</operator><call><name>equals</name><argument_list>(<argument><expr><name>field</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"*"</literal><operator>.</operator><call><name>equals</name><argument_list>(<argument><expr><name>termStr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <return>return <expr><call><name>newMatchAllDocsQuery</name><argument_list>()</argument_list></call></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <decl_stmt><decl><type><name>FieldType</name></type> <name>fieldType</name> <init>= <expr><call><name><name>schema</name><operator>.</operator><name>getFieldType</name></name><argument_list>(<argument><expr><name>field</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>termStr</name> <operator>=</operator> <call><name>analyzeIfMultitermTermText</name><argument_list>(<argument><expr><name>field</name></expr></argument>, <argument><expr><name>termStr</name></expr></argument>, <argument><expr><name>fieldType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="line">// can we use reversed wildcards in this field?</comment>
    <decl_stmt><decl><type><name>ReversedWildcardFilterFactory</name></type> <name>factory</name> <init>= <expr><call><name>getReversedWildcardFilterFactory</name><argument_list>(<argument><expr><name>fieldType</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>factory</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>Term</name></type> <name>term</name> <init>= <expr><operator>new</operator> <call><name>Term</name><argument_list>(<argument><expr><name>field</name></expr></argument>, <argument><expr><name>termStr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <comment type="line">// fsa representing the query</comment>
      <decl_stmt><decl><type><name>Automaton</name></type> <name>automaton</name> <init>= <expr><call><name><name>WildcardQuery</name><operator>.</operator><name>toAutomaton</name></name><argument_list>(<argument><expr><name>term</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <comment type="line">// TODO: we should likely use the automaton to calculate shouldReverse, too.</comment>
      <if_stmt><if>if <condition>(<expr><call><name><name>factory</name><operator>.</operator><name>shouldReverse</name></name><argument_list>(<argument><expr><name>termStr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>automaton</name> <operator>=</operator> <call><name><name>BasicOperations</name><operator>.</operator><name>concatenate</name></name><argument_list>(<argument><expr><name>automaton</name></expr></argument>, <argument><expr><call><name><name>BasicAutomata</name><operator>.</operator><name>makeChar</name></name><argument_list>(<argument><expr><call><name><name>factory</name><operator>.</operator><name>getMarkerChar</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>SpecialOperations</name><operator>.</operator><name>reverse</name></name><argument_list>(<argument><expr><name>automaton</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if> <else>else <block>{<block_content>
        <comment type="line">// reverse wildcardfilter is active: remove false positives</comment>
        <comment type="line">// fsa representing false positives (markerChar*)</comment>
        <decl_stmt><decl><type><name>Automaton</name></type> <name>falsePositives</name> <init>= <expr><call><name><name>BasicOperations</name><operator>.</operator><name>concatenate</name></name><argument_list>(
            <argument><expr><call><name><name>BasicAutomata</name><operator>.</operator><name>makeChar</name></name><argument_list>(<argument><expr><call><name><name>factory</name><operator>.</operator><name>getMarkerChar</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
            <argument><expr><call><name><name>BasicAutomata</name><operator>.</operator><name>makeAnyString</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <comment type="line">// subtract these away</comment>
        <expr_stmt><expr><name>automaton</name> <operator>=</operator> <call><name><name>BasicOperations</name><operator>.</operator><name>minus</name></name><argument_list>(<argument><expr><name>automaton</name></expr></argument>, <argument><expr><name>falsePositives</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <return>return <expr><operator>new</operator> <class><super><name>AutomatonQuery</name></super><argument_list>(<argument><expr><name>term</name></expr></argument>, <argument><expr><name>automaton</name></expr></argument>)</argument_list> <block>{
        <comment type="line">// override toString so its completely transparent</comment>
        <function><annotation>@<name>Override</name></annotation>
        <type><specifier>public</specifier> <name>String</name></type> <name>toString</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>field</name></decl></parameter>)</parameter_list> <block>{<block_content>
          <decl_stmt><decl><type><name>StringBuilder</name></type> <name>buffer</name> <init>= <expr><operator>new</operator> <call><name>StringBuilder</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
          <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>getField</name><argument_list>()</argument_list></call><operator>.</operator><call><name>equals</name><argument_list>(<argument><expr><name>field</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name><name>buffer</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><call><name>getField</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>buffer</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><literal type="string">":"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><call><name><name>buffer</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><call><name><name>term</name><operator>.</operator><name>text</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name><name>buffer</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><call><name><name>ToStringUtils</name><operator>.</operator><name>boost</name></name><argument_list>(<argument><expr><call><name>getBoost</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <return>return <expr><call><name><name>buffer</name><operator>.</operator><name>toString</name></name><argument_list>()</argument_list></call></expr>;</return>
        </block_content>}</block></function>
      }</block></class></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// Solr has always used constant scoring for wildcard queries.  This should return constant scoring by default.</comment>
    <return>return <expr><call><name>newWildcardQuery</name><argument_list>(<argument><expr><operator>new</operator> <call><name>Term</name><argument_list>(<argument><expr><name>field</name></expr></argument>, <argument><expr><name>termStr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></function>

  <comment type="line">// called from parser</comment>
  <function><type><specifier>protected</specifier> <name>Query</name></type> <name>getRegexpQuery</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>field</name></decl></parameter>, <parameter><decl><type><name>String</name></type> <name>termStr</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>SyntaxError</name></expr></argument></throws>
  <block>{<block_content>
    <expr_stmt><expr><name>termStr</name> <operator>=</operator> <call><name>analyzeIfMultitermTermText</name><argument_list>(<argument><expr><name>field</name></expr></argument>, <argument><expr><name>termStr</name></expr></argument>, <argument><expr><call><name><name>schema</name><operator>.</operator><name>getFieldType</name></name><argument_list>(<argument><expr><name>field</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>newRegexpQuery</name><argument_list>(<argument><expr><operator>new</operator> <call><name>Term</name><argument_list>(<argument><expr><name>field</name></expr></argument>, <argument><expr><name>termStr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></function>

  <comment type="line">// called from parser</comment>
  <function><type><specifier>protected</specifier> <name>Query</name></type> <name>getFuzzyQuery</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>field</name></decl></parameter>, <parameter><decl><type><name>String</name></type> <name>termStr</name></decl></parameter>, <parameter><decl><type><name>float</name></type> <name>minSimilarity</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>SyntaxError</name></expr></argument></throws> <block>{<block_content>
    <expr_stmt><expr><name>termStr</name> <operator>=</operator> <call><name>analyzeIfMultitermTermText</name><argument_list>(<argument><expr><name>field</name></expr></argument>, <argument><expr><name>termStr</name></expr></argument>, <argument><expr><call><name><name>schema</name><operator>.</operator><name>getFieldType</name></name><argument_list>(<argument><expr><name>field</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>Term</name></type> <name>t</name> <init>= <expr><operator>new</operator> <call><name>Term</name><argument_list>(<argument><expr><name>field</name></expr></argument>, <argument><expr><name>termStr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <return>return <expr><call><name>newFuzzyQuery</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>minSimilarity</name></expr></argument>, <argument><expr><call><name>getFuzzyPrefixLength</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></function>

  <comment type="line">// called from parser</comment>
  <function><type><specifier>protected</specifier> <name>Query</name></type> <name>getLocalParams</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>qfield</name></decl></parameter>, <parameter><decl><type><name>String</name></type> <name>lparams</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>SyntaxError</name></expr></argument></throws> <block>{<block_content>
    <decl_stmt><decl><type><name>QParser</name></type> <name>nested</name> <init>= <expr><call><name><name>parser</name><operator>.</operator><name>subQuery</name></name><argument_list>(<argument><expr><name>lparams</name></expr></argument>, <argument><expr><literal type="null">null</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <return>return <expr><call><name><name>nested</name><operator>.</operator><name>getQuery</name></name><argument_list>()</argument_list></call></expr>;</return>
  </block_content>}</block></function>

}</block></class>
<expr_stmt><expr><name>diff</name> <operator>--</operator><name>git</name> <name>a</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>parser</name><operator>/</operator><name><name>Token</name><operator>.</operator><name>java</name></name> <name>b</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>parser</name><operator>/</operator><name><name>Token</name><operator>.</operator><name>java</name></name>
<operator>new</operator> <name>file</name> <name>mode</name> <literal type="number">100644</literal>
<name>index</name> <literal type="number">00000000000..0d596035928</literal>
<operator>--</operator> <operator>/</operator><name>dev</name><operator>/</operator><literal type="null">null</literal>
<operator>++</operator> <name>b</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>parser</name><operator>/</operator><name><name>Token</name><operator>.</operator><name>java</name></name>
@@ <operator>-</operator><literal type="number">0</literal></expr><operator>,</operator><expr><literal type="number">0</literal> <operator>+</operator><literal type="number">1</literal></expr><operator>,</operator><expr><literal type="number">131</literal> @@</expr></expr_stmt>
<comment type="block">/* Generated By:JavaCC: Do not edit this line. Token.java Version 5.0 */</comment>
<comment type="block">/* JavaCCOptions:TOKEN_EXTENDS=,KEEP_LINE_COL=null,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */</comment>
<package>package <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>parser</name></name>;</package>

<comment type="block" format="javadoc">/**
 * Describes the input token stream.
 */</comment>

<class><specifier>public</specifier> class <name>Token</name> <super_list><implements>implements <super><name><name>java</name><operator>.</operator><name>io</name><operator>.</operator><name>Serializable</name></name></super></implements></super_list> <block>{

  <comment type="block" format="javadoc">/**
   * The version identifier for this Serializable class.
   * Increment only if the &lt;i&gt;serialized&lt;/i&gt; form of the
   * class changes.
   */</comment>
  <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>long</name></type> <name>serialVersionUID</name> <init>= <expr><literal type="number">1L</literal></expr></init></decl>;</decl_stmt>

  <comment type="block" format="javadoc">/**
   * An integer that describes the kind of this token.  This numbering
   * system is determined by JavaCCParser, and a table of these numbers is
   * stored in the file ...Constants.java.
   */</comment>
  <decl_stmt><decl><type><specifier>public</specifier> <name>int</name></type> <name>kind</name></decl>;</decl_stmt>

  <comment type="block" format="javadoc">/** The line number of the first character of this Token. */</comment>
  <decl_stmt><decl><type><specifier>public</specifier> <name>int</name></type> <name>beginLine</name></decl>;</decl_stmt>
  <comment type="block" format="javadoc">/** The column number of the first character of this Token. */</comment>
  <decl_stmt><decl><type><specifier>public</specifier> <name>int</name></type> <name>beginColumn</name></decl>;</decl_stmt>
  <comment type="block" format="javadoc">/** The line number of the last character of this Token. */</comment>
  <decl_stmt><decl><type><specifier>public</specifier> <name>int</name></type> <name>endLine</name></decl>;</decl_stmt>
  <comment type="block" format="javadoc">/** The column number of the last character of this Token. */</comment>
  <decl_stmt><decl><type><specifier>public</specifier> <name>int</name></type> <name>endColumn</name></decl>;</decl_stmt>

  <comment type="block" format="javadoc">/**
   * The string image of the token.
   */</comment>
  <decl_stmt><decl><type><specifier>public</specifier> <name>String</name></type> <name>image</name></decl>;</decl_stmt>

  <comment type="block" format="javadoc">/**
   * A reference to the next regular (non-special) token from the input
   * stream.  If this is the last token from the input stream, or if the
   * token manager has not read tokens beyond this one, this field is
   * set to null.  This is true only if this token is also a regular
   * token.  Otherwise, see below for a description of the contents of
   * this field.
   */</comment>
  <decl_stmt><decl><type><specifier>public</specifier> <name>Token</name></type> <name>next</name></decl>;</decl_stmt>

  <comment type="block" format="javadoc">/**
   * This field is used to access special tokens that occur prior to this
   * token, but after the immediately preceding regular (non-special) token.
   * If there are no such special tokens, this field is set to null.
   * When there are more than one such special token, this field refers
   * to the last of these special tokens, which in turn refers to the next
   * previous special token through its specialToken field, and so on
   * until the first special token (whose specialToken field is null).
   * The next fields of special tokens refer to other special tokens that
   * immediately follow it (without an intervening regular token).  If there
   * is no such token, this field is null.
   */</comment>
  <decl_stmt><decl><type><specifier>public</specifier> <name>Token</name></type> <name>specialToken</name></decl>;</decl_stmt>

  <comment type="block" format="javadoc">/**
   * An optional attribute value of the Token.
   * Tokens which are not used as syntactic sugar will often contain
   * meaningful values that will be used later on by the compiler or
   * interpreter. This attribute value is often different from the image.
   * Any subclass of Token that actually wants to return a non-null value can
   * override this method as appropriate.
   */</comment>
  <function><type><specifier>public</specifier> <name>Object</name></type> <name>getValue</name><parameter_list>()</parameter_list> <block>{<block_content>
    <return>return <expr><literal type="null">null</literal></expr>;</return>
  </block_content>}</block></function>

  <comment type="block" format="javadoc">/**
   * No-argument constructor
   */</comment>
  <constructor><specifier>public</specifier> <name>Token</name><parameter_list>()</parameter_list> <block>{<block_content/>}</block></constructor>

  <comment type="block" format="javadoc">/**
   * Constructs a new token for the specified Image.
   */</comment>
  <constructor><specifier>public</specifier> <name>Token</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>kind</name></decl></parameter>)</parameter_list>
  <block>{<block_content>
    <expr_stmt><expr><call><name>this</name><argument_list>(<argument><expr><name>kind</name></expr></argument>, <argument><expr><literal type="null">null</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></constructor>

  <comment type="block" format="javadoc">/**
   * Constructs a new token for the specified Image and Kind.
   */</comment>
  <constructor><specifier>public</specifier> <name>Token</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>kind</name></decl></parameter>, <parameter><decl><type><name>String</name></type> <name>image</name></decl></parameter>)</parameter_list>
  <block>{<block_content>
    <expr_stmt><expr><name><name>this</name><operator>.</operator><name>kind</name></name> <operator>=</operator> <name>kind</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>this</name><operator>.</operator><name>image</name></name> <operator>=</operator> <name>image</name></expr>;</expr_stmt>
  </block_content>}</block></constructor>

  <comment type="block" format="javadoc">/**
   * Returns the image.
   */</comment>
  <function><type><specifier>public</specifier> <name>String</name></type> <name>toString</name><parameter_list>()</parameter_list>
  <block>{<block_content>
    <return>return <expr><name>image</name></expr>;</return>
  </block_content>}</block></function>

  <comment type="block" format="javadoc">/**
   * Returns a new Token object, by default. However, if you want, you
   * can create and return subclass objects based on the value of ofKind.
   * Simply add the cases to the switch for all those special cases.
   * For example, if you have a subclass of Token called IDToken that
   * you want to create if ofKind is ID, simply add something like :
   *
   *    case MyParserConstants.ID : return new IDToken(ofKind, image);
   *
   * to the following switch statement. Then you can cast matchedToken
   * variable to the appropriate type and use sit in your lexical actions.
   */</comment>
  <function><type><specifier>public</specifier> <specifier>static</specifier> <name>Token</name></type> <name>newToken</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>ofKind</name></decl></parameter>, <parameter><decl><type><name>String</name></type> <name>image</name></decl></parameter>)</parameter_list>
  <block>{<block_content>
    <switch>switch<condition>(<expr><name>ofKind</name></expr>)</condition>
    <block>{<block_content>
      <default>default :</default> <return>return <expr><operator>new</operator> <call><name>Token</name><argument_list>(<argument><expr><name>ofKind</name></expr></argument>, <argument><expr><name>image</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></switch>
  </block_content>}</block></function>

  <function><type><specifier>public</specifier> <specifier>static</specifier> <name>Token</name></type> <name>newToken</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>ofKind</name></decl></parameter>)</parameter_list>
  <block>{<block_content>
    <return>return <expr><call><name>newToken</name><argument_list>(<argument><expr><name>ofKind</name></expr></argument>, <argument><expr><literal type="null">null</literal></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></function>

}</block></class>
<comment type="block">/* JavaCC - OriginalChecksum=f463ad6fd3205ca07166de02ee86b907 (do not edit this line) */</comment>
<expr_stmt><expr><name>diff</name> <operator>--</operator><name>git</name> <name>a</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>parser</name><operator>/</operator><name><name>TokenMgrError</name><operator>.</operator><name>java</name></name> <name>b</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>parser</name><operator>/</operator><name><name>TokenMgrError</name><operator>.</operator><name>java</name></name>
<operator>new</operator> <name>file</name> <name>mode</name> <literal type="number">100644</literal>
<name>index</name> <literal type="number">00000000000..9dbfd06a38b</literal>
<operator>--</operator> <operator>/</operator><name>dev</name><operator>/</operator><literal type="null">null</literal>
<operator>++</operator> <name>b</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>parser</name><operator>/</operator><name><name>TokenMgrError</name><operator>.</operator><name>java</name></name>
@@ <operator>-</operator><literal type="number">0</literal></expr><operator>,</operator><expr><literal type="number">0</literal> <operator>+</operator><literal type="number">1</literal></expr><operator>,</operator><expr><literal type="number">147</literal> @@</expr></expr_stmt>
<comment type="block">/* Generated By:JavaCC: Do not edit this line. TokenMgrError.java Version 5.0 */</comment>
<comment type="block">/* JavaCCOptions: */</comment>
<package>package <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>parser</name></name>;</package>

<comment type="block" format="javadoc">/** Token Manager Error. */</comment>
<class><specifier>public</specifier> class <name>TokenMgrError</name> <super_list><extends>extends <super><name>Error</name></super></extends></super_list>
<block>{

  <comment type="block" format="javadoc">/**
   * The version identifier for this Serializable class.
   * Increment only if the &lt;i&gt;serialized&lt;/i&gt; form of the
   * class changes.
   */</comment>
  <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>long</name></type> <name>serialVersionUID</name> <init>= <expr><literal type="number">1L</literal></expr></init></decl>;</decl_stmt>

  <comment type="block">/*
   * Ordinals for various reasons why an Error of this type can be thrown.
   */</comment>

  <comment type="block" format="javadoc">/**
   * Lexical error occurred.
   */</comment>
  <decl_stmt><decl><type><specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>LEXICAL_ERROR</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <comment type="block" format="javadoc">/**
   * An attempt was made to create a second instance of a static token manager.
   */</comment>
  <decl_stmt><decl><type><specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>STATIC_LEXER_ERROR</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

  <comment type="block" format="javadoc">/**
   * Tried to change to an invalid lexical state.
   */</comment>
  <decl_stmt><decl><type><specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>INVALID_LEXICAL_STATE</name> <init>= <expr><literal type="number">2</literal></expr></init></decl>;</decl_stmt>

  <comment type="block" format="javadoc">/**
   * Detected (and bailed out of) an infinite loop in the token manager.
   */</comment>
  <decl_stmt><decl><type><specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>LOOP_DETECTED</name> <init>= <expr><literal type="number">3</literal></expr></init></decl>;</decl_stmt>

  <comment type="block" format="javadoc">/**
   * Indicates the reason why the exception is thrown. It will have
   * one of the above 4 values.
   */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>errorCode</name></decl>;</decl_stmt>

  <comment type="block" format="javadoc">/**
   * Replaces unprintable characters by their escaped (or unicode escaped)
   * equivalents in the given string
   */</comment>
  <function><type><specifier>protected</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>String</name></type> <name>addEscapes</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>str</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>StringBuffer</name></type> <name>retval</name> <init>= <expr><operator>new</operator> <call><name>StringBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name>ch</name></decl>;</decl_stmt>
    <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name><name>str</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
      <switch>switch <condition>(<expr><call><name><name>str</name><operator>.</operator><name>charAt</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition>
      <block>{<block_content>
        <case>case <expr><literal type="number">0</literal></expr> :</case>
          <continue>continue;</continue>
        <case>case <expr><literal type="char">'\b'</literal></expr>:</case>
          <expr_stmt><expr><call><name><name>retval</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><literal type="string">"\\b"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <continue>continue;</continue>
        <case>case <expr><literal type="char">'\t'</literal></expr>:</case>
          <expr_stmt><expr><call><name><name>retval</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><literal type="string">"\\t"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <continue>continue;</continue>
        <case>case <expr><literal type="char">'\n'</literal></expr>:</case>
          <expr_stmt><expr><call><name><name>retval</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><literal type="string">"\\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <continue>continue;</continue>
        <case>case <expr><literal type="char">'\f'</literal></expr>:</case>
          <expr_stmt><expr><call><name><name>retval</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><literal type="string">"\\f"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <continue>continue;</continue>
        <case>case <expr><literal type="char">'\r'</literal></expr>:</case>
          <expr_stmt><expr><call><name><name>retval</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><literal type="string">"\\r"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <continue>continue;</continue>
        <case>case <expr><literal type="char">'\"'</literal></expr>:</case>
          <expr_stmt><expr><call><name><name>retval</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><literal type="string">"\\\""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <continue>continue;</continue>
        <case>case <expr><literal type="char">'\''</literal></expr>:</case>
          <expr_stmt><expr><call><name><name>retval</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><literal type="string">"\\\'"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <continue>continue;</continue>
        <case>case <expr><literal type="char">'\\'</literal></expr>:</case>
          <expr_stmt><expr><call><name><name>retval</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><literal type="string">"\\\\"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <continue>continue;</continue>
        <default>default:</default>
          <if_stmt><if>if <condition>(<expr><operator>(</operator><name>ch</name> <operator>=</operator> <call><name><name>str</name><operator>.</operator><name>charAt</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0x20</literal> <operator>||</operator> <name>ch</name> <operator>&gt;</operator> <literal type="number">0x7e</literal></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>String</name></type> <name>s</name> <init>= <expr><literal type="string">"0000"</literal> <operator>+</operator> <call><name><name>Integer</name><operator>.</operator><name>toString</name></name><argument_list>(<argument><expr><name>ch</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>retval</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><literal type="string">"\\u"</literal> <operator>+</operator> <call><name><name>s</name><operator>.</operator><name>substring</name></name><argument_list>(<argument><expr><call><name><name>s</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call> <operator>-</operator> <literal type="number">4</literal></expr></argument>, <argument><expr><call><name><name>s</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><call><name><name>retval</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></else></if_stmt>
          <continue>continue;</continue>
      </block_content>}</block></switch>
    </block_content>}</block></for>
    <return>return <expr><call><name><name>retval</name><operator>.</operator><name>toString</name></name><argument_list>()</argument_list></call></expr>;</return>
  </block_content>}</block></function>

  <comment type="block" format="javadoc">/**
   * Returns a detailed message for the Error when it is thrown by the
   * token manager to indicate a lexical error.
   * Parameters :
   *    EOFSeen     : indicates if EOF caused the lexical error
   *    curLexState : lexical state in which this error occurred
   *    errorLine   : line number when the error occurred
   *    errorColumn : column number when the error occurred
   *    errorAfter  : prefix that was seen before this error occurred
   *    curchar     : the offending character
   * Note: You can customize the lexical error message by modifying this method.
   */</comment>
  <function><type><specifier>protected</specifier> <specifier>static</specifier> <name>String</name></type> <name>LexicalError</name><parameter_list>(<parameter><decl><type><name>boolean</name></type> <name>EOFSeen</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>lexState</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>errorLine</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>errorColumn</name></decl></parameter>, <parameter><decl><type><name>String</name></type> <name>errorAfter</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>curChar</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <return>return<expr><operator>(</operator><literal type="string">"Lexical error at line "</literal> <operator>+</operator>
          <name>errorLine</name> <operator>+</operator> <literal type="string">", column "</literal> <operator>+</operator>
          <name>errorColumn</name> <operator>+</operator> <literal type="string">".  Encountered: "</literal> <operator>+</operator>
          <operator>(</operator><ternary><condition><expr><name>EOFSeen</name></expr> ?</condition><then> <expr><literal type="string">"&lt;EOF&gt; "</literal></expr> </then><else>: <expr><operator>(</operator><literal type="string">"\""</literal> <operator>+</operator> <call><name>addEscapes</name><argument_list>(<argument><expr><call><name><name>String</name><operator>.</operator><name>valueOf</name></name><argument_list>(<argument><expr><name>curChar</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="string">"\""</literal><operator>)</operator> <operator>+</operator> <literal type="string">" ("</literal> <operator>+</operator> <operator>(</operator><name>int</name><operator>)</operator><name>curChar</name> <operator>+</operator> <literal type="string">"), "</literal></expr></else></ternary><operator>)</operator> <operator>+</operator>
          <literal type="string">"after : \""</literal> <operator>+</operator> <call><name>addEscapes</name><argument_list>(<argument><expr><name>errorAfter</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="string">"\""</literal><operator>)</operator></expr>;</return>
  </block_content>}</block></function>

  <comment type="block" format="javadoc">/**
   * You can also modify the body of this method to customize your error messages.
   * For example, cases like LOOP_DETECTED and INVALID_LEXICAL_STATE are not
   * of end-users concern, so you can return something like :
   *
   *     "Internal Error : Please file a bug report .... "
   *
   * from this method for such cases in the release version of your parser.
   */</comment>
  <function><type><specifier>public</specifier> <name>String</name></type> <name>getMessage</name><parameter_list>()</parameter_list> <block>{<block_content>
    <return>return <expr><call><name><name>super</name><operator>.</operator><name>getMessage</name></name><argument_list>()</argument_list></call></expr>;</return>
  </block_content>}</block></function>

  <comment type="block">/*
   * Constructors of various flavors follow.
   */</comment>

  <comment type="block" format="javadoc">/** No arg constructor. */</comment>
  <constructor><specifier>public</specifier> <name>TokenMgrError</name><parameter_list>()</parameter_list> <block>{<block_content>
  </block_content>}</block></constructor>

  <comment type="block" format="javadoc">/** Constructor with message and reason. */</comment>
  <constructor><specifier>public</specifier> <name>TokenMgrError</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>message</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>reason</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>super</name><argument_list>(<argument><expr><name>message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>errorCode</name> <operator>=</operator> <name>reason</name></expr>;</expr_stmt>
  </block_content>}</block></constructor>

  <comment type="block" format="javadoc">/** Full Constructor. */</comment>
  <constructor><specifier>public</specifier> <name>TokenMgrError</name><parameter_list>(<parameter><decl><type><name>boolean</name></type> <name>EOFSeen</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>lexState</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>errorLine</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>errorColumn</name></decl></parameter>, <parameter><decl><type><name>String</name></type> <name>errorAfter</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>curChar</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>reason</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>this</name><argument_list>(<argument><expr><call><name>LexicalError</name><argument_list>(<argument><expr><name>EOFSeen</name></expr></argument>, <argument><expr><name>lexState</name></expr></argument>, <argument><expr><name>errorLine</name></expr></argument>, <argument><expr><name>errorColumn</name></expr></argument>, <argument><expr><name>errorAfter</name></expr></argument>, <argument><expr><name>curChar</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>reason</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></constructor>
}</block></class>
<comment type="block">/* JavaCC - OriginalChecksum=200a46f65c1a0f71a7f037b35f4e934e (do not edit this line) */</comment>
<expr_stmt><expr><name>diff</name> <operator>--</operator><name>git</name> <name>a</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>request</name><operator>/</operator><name><name>SimpleFacets</name><operator>.</operator><name>java</name></name> <name>b</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>request</name><operator>/</operator><name><name>SimpleFacets</name><operator>.</operator><name>java</name></name>
<name>index</name> <name>e1a583b50f7</name><operator>..</operator><name>f5148a028e1</name> <literal type="number">100644</literal>
<operator>--</operator> <name>a</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>request</name><operator>/</operator><name><name>SimpleFacets</name><operator>.</operator><name>java</name></name>
<operator>++</operator> <name>b</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>request</name><operator>/</operator><name><name>SimpleFacets</name><operator>.</operator><name>java</name></name>
@@ <operator>-</operator><literal type="number">18</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">18</literal></expr><operator>,</operator><expr><literal type="number">6</literal> @@</expr></expr_stmt>
 <package>package <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>request</name></name>;</package>
 
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>index</name><operator>.</operator><name>*</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>queryparser</name><operator>.</operator><name>classic</name><operator>.</operator><name>ParseException</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>search</name><operator>.</operator><name>*</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>search</name><operator>.</operator><name>grouping</name><operator>.</operator><name>AbstractAllGroupHeadsCollector</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>search</name><operator>.</operator><name>grouping</name><operator>.</operator><name>term</name><operator>.</operator><name>TermGroupFacetCollector</name></name>;</import>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">95</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">94</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@ <specifier>public</specifier> <name>class</name> <name>SimpleFacets</name> <block>{
   }</block>
 
 
  <specifier>protected</specifier> <name>void</name> <call><name>parseParams</name><argument_list>(<argument><expr><name>String</name> <name>type</name></expr></argument>, <argument><expr><name>String</name> <name>param</name></expr></argument>)</argument_list></call> <throws>throws <argument><expr><name>ParseException</name></expr></argument>, <argument><expr><name>IOException</name> <block>{
  <expr><specifier>protected</specifier> <name>void</name> <call><name>parseParams</name><argument_list>(<argument><expr><name>String</name> <name>type</name></expr></argument>, <argument><expr><name>String</name> <name>param</name></expr></argument>)</argument_list></call></expr></block></expr></argument></throws> <throws>throws <argument><expr><name>SyntaxError</name></expr></argument>, <argument><expr><name>IOException</name> <block>{
     <expr><name>localParams</name> <operator>=</operator> <call><name><name>QueryParsing</name><operator>.</operator><name>getLocalParams</name></name><argument_list>(<argument><expr><name>param</name></expr></argument>, <argument><expr><call><name><name>req</name><operator>.</operator><name>getParams</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></block></expr></argument></throws></expr>;</expr_stmt>
     <expr_stmt><expr><name>docs</name> <operator>=</operator> <name>docsOrig</name></expr>;</expr_stmt>
     <expr_stmt><expr><name>facetValue</name> <operator>=</operator> <name>param</name></expr>;</expr_stmt>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">209</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">208</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@ <specifier>public</specifier> <name>class</name> <name>SimpleFacets</name> <block>{
 
     }</block></expr></expr_stmt> <catch>catch <parameter_list>(<parameter><decl><type><name>IOException</name></type> <name>e</name></decl></parameter>)</parameter_list> <block>{<block_content>
       <throw>throw <expr><operator>new</operator> <call><name>SolrException</name><argument_list>(<argument><expr><name><name>ErrorCode</name><operator>.</operator><name>SERVER_ERROR</name></name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</throw>
    </block_content>}</block></catch> <catch>catch <parameter_list>(<parameter><decl><type><name>ParseException</name></type> <name>e</name></decl></parameter>)</parameter_list> <block>{<block_content>
    </block_content>}</block></catch> <catch>catch <parameter_list>(<parameter><decl><type><name>SyntaxError</name></type> <name>e</name></decl></parameter>)</parameter_list> <block>{<block_content>
       <throw>throw <expr><operator>new</operator> <call><name>SolrException</name><argument_list>(<argument><expr><name><name>ErrorCode</name><operator>.</operator><name>BAD_REQUEST</name></name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</throw>
     </block_content>}</block></catch>
     <return>return <expr><name>facetResponse</name></expr>;</return>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">221</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">220</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@ <specifier>public</specifier> <name>class</name> <name>SimpleFacets</name> <block>{
    <expr><operator>*</operator>
    <operator>*</operator> @<name>see</name> <name>FacetParams</name><operator>#</operator><name>FACET_QUERY</name>
    <operator>*</operator><operator>/</operator>
  <specifier>public</specifier> <name><name>NamedList</name><argument_list type="generic">&lt;<argument><name>Integer</name></argument>&gt;</argument_list></name> <call><name>getFacetQueryCounts</name><argument_list>()</argument_list></call> <throws>throws <argument><expr><name>IOException</name></expr></argument>,<argument><expr><name>ParseException</name> <block>{
  <expr><specifier>public</specifier> <name><name>NamedList</name><argument_list type="generic">&lt;<argument><name>Integer</name></argument>&gt;</argument_list></name> <call><name>getFacetQueryCounts</name><argument_list>()</argument_list></call></expr></block></expr></argument></throws> <throws>throws <argument><expr><name>IOException</name></expr></argument>,<argument><expr><name>SyntaxError</name> <block>{
 
     <expr><name><name>NamedList</name><argument_list type="generic">&lt;<argument><name>Integer</name></argument>&gt;</argument_list></name> <name>res</name> <operator>=</operator> <operator>new</operator> <call><name><name>SimpleOrderedMap</name><argument_list type="generic">&lt;<argument><name>Integer</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></block></expr></argument></throws></expr>;
 
@@ <expr><operator>-</operator><literal type="number">409</literal></expr>,<expr><literal type="number">7</literal> <operator>+</operator><literal type="number">408</literal></expr>,<expr><literal type="number">7</literal> @@ <specifier>public</specifier> <name>class</name> <name>SimpleFacets</name> <block>{
    <expr><operator>*</operator> @<name>see</name> <operator>#</operator><name>getFacetTermEnumCounts</name>
    <operator>*</operator><operator>/</operator>
   <specifier>public</specifier> <name><name>NamedList</name><argument_list type="generic">&lt;<argument><name>Object</name></argument>&gt;</argument_list></name> <call><name>getFacetFieldCounts</name><argument_list>()</argument_list></call>
          <throws>throws <argument><expr><name>IOException</name></expr></argument>, <argument><expr><name>ParseException</name> <block>{</block></expr></argument></throws>
          <throws>throws <argument><expr><name>IOException</name></expr></argument>, <argument><expr><name>SyntaxError</name> <block>{
 
     <expr><name><name>NamedList</name><argument_list type="generic">&lt;<argument><name>Object</name></argument>&gt;</argument_list></name> <name>res</name> <operator>=</operator> <operator>new</operator> <call><name><name>SimpleOrderedMap</name><argument_list type="generic">&lt;<argument><name>Object</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></block></expr></argument></throws></expr>;
     <expr><name><name>String</name><index>[]</index></name> <name>facetFs</name> <operator>=</operator> <call><name><name>params</name><operator>.</operator><name>getParams</name></name><argument_list>(<argument><expr><name><name>FacetParams</name><operator>.</operator><name>FACET_FIELD</name></name></expr></argument>)</argument_list></call></expr>;
@@ <expr><operator>-</operator><literal type="number">826</literal></expr>,<expr><literal type="number">7</literal> <operator>+</operator><literal type="number">825</literal></expr>,<expr><literal type="number">7</literal> @@ <specifier>public</specifier> <name>class</name> <name>SimpleFacets</name> <block>{
    <expr><operator>*</operator><operator>/</operator>
   @<name>Deprecated</name>
   <specifier>public</specifier> <name><name>NamedList</name><argument_list type="generic">&lt;<argument><name>Object</name></argument>&gt;</argument_list></name> <call><name>getFacetDateCounts</name><argument_list>()</argument_list></call>
    <throws>throws <argument><expr><name>IOException</name></expr></argument>, <argument><expr><name>ParseException</name> <block>{</block></expr></argument></throws>
    <throws>throws <argument><expr><name>IOException</name></expr></argument>, <argument><expr><name>SyntaxError</name> <block>{
 
     <expr><name>final</name> <name><name>NamedList</name><argument_list type="generic">&lt;<argument><name>Object</name></argument>&gt;</argument_list></name> <name>resOuter</name> <operator>=</operator> <operator>new</operator> <call><name><name>SimpleOrderedMap</name><argument_list type="generic">&lt;<argument><name>Object</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></block></expr></argument></throws></expr>;
     <expr><name>final</name> <name><name>String</name><index>[]</index></name> <name>fields</name> <operator>=</operator> <call><name><name>params</name><operator>.</operator><name>getParams</name></name><argument_list>(<argument><expr><name><name>FacetParams</name><operator>.</operator><name>FACET_DATE</name></name></expr></argument>)</argument_list></call></expr>;
@@ <expr><operator>-</operator><literal type="number">845</literal></expr>,<expr><literal type="number">7</literal> <operator>+</operator><literal type="number">844</literal></expr>,<expr><literal type="number">7</literal> @@ <specifier>public</specifier> <name>class</name> <name>SimpleFacets</name> <block>{
    <expr><operator>*</operator><operator>/</operator>
   @<name>Deprecated</name>
   <specifier>public</specifier> <name>void</name> <call><name>getFacetDateCounts</name><argument_list>(<argument><expr><name>String</name> <name>dateFacet</name></expr></argument>, <argument><expr><name><name>NamedList</name><argument_list type="generic">&lt;<argument><name>Object</name></argument>&gt;</argument_list></name> <name>resOuter</name></expr></argument>)</argument_list></call>
      <throws>throws <argument><expr><name>IOException</name></expr></argument>, <argument><expr><name>ParseException</name> <block>{</block></expr></argument></throws>
      <throws>throws <argument><expr><name>IOException</name></expr></argument>, <argument><expr><name>SyntaxError</name> <block>{
 
     <expr><name>final</name> <name>IndexSchema</name> <name>schema</name> <operator>=</operator> <call><name><name>searcher</name><operator>.</operator><name>getSchema</name></name><argument_list>()</argument_list></call></expr></block></expr></argument></throws></expr>;
 
@@ <expr><operator>-</operator><literal type="number">1008</literal></expr>,<expr><literal type="number">7</literal> <operator>+</operator><literal type="number">1007</literal></expr>,<expr><literal type="number">7</literal> @@ <specifier>public</specifier> <name>class</name> <name>SimpleFacets</name> <block>{
    <expr><operator>*</operator> @<name>see</name> <name>FacetParams</name><operator>#</operator><name>FACET_RANGE</name>
    <operator>*</operator><operator>/</operator>
 
  <specifier>public</specifier> <name><name>NamedList</name><argument_list type="generic">&lt;<argument><name>Object</name></argument>&gt;</argument_list></name> <call><name>getFacetRangeCounts</name><argument_list>()</argument_list></call> <throws>throws <argument><expr><name>IOException</name></expr></argument>, <argument><expr><name>ParseException</name> <block>{
  <expr><specifier>public</specifier> <name><name>NamedList</name><argument_list type="generic">&lt;<argument><name>Object</name></argument>&gt;</argument_list></name> <call><name>getFacetRangeCounts</name><argument_list>()</argument_list></call></expr></block></expr></argument></throws> <throws>throws <argument><expr><name>IOException</name></expr></argument>, <argument><expr><name>SyntaxError</name> <block>{
     <expr><name>final</name> <name><name>NamedList</name><argument_list type="generic">&lt;<argument><name>Object</name></argument>&gt;</argument_list></name> <name>resOuter</name> <operator>=</operator> <operator>new</operator> <call><name><name>SimpleOrderedMap</name><argument_list type="generic">&lt;<argument><name>Object</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></block></expr></argument></throws></expr>;
     <expr><name>final</name> <name><name>String</name><index>[]</index></name> <name>fields</name> <operator>=</operator> <call><name><name>params</name><operator>.</operator><name>getParams</name></name><argument_list>(<argument><expr><name><name>FacetParams</name><operator>.</operator><name>FACET_RANGE</name></name></expr></argument>)</argument_list></call></expr>;
 
@@ <expr><operator>-</operator><literal type="number">1022</literal></expr>,<expr><literal type="number">7</literal> <operator>+</operator><literal type="number">1021</literal></expr>,<expr><literal type="number">7</literal> @@ <specifier>public</specifier> <name>class</name> <name>SimpleFacets</name> <block>{
   }</block>
 
   <name>void</name> <call><name>getFacetRangeCounts</name><argument_list>(<argument><expr><name>String</name> <name>facetRange</name></expr></argument>, <argument><expr><name><name>NamedList</name><argument_list type="generic">&lt;<argument><name>Object</name></argument>&gt;</argument_list></name> <name>resOuter</name></expr></argument>)</argument_list></call>
      <throws>throws <argument><expr><name>IOException</name></expr></argument>, <argument><expr><name>ParseException</name> <block>{</block></expr></argument></throws>
      <throws>throws <argument><expr><name>IOException</name></expr></argument>, <argument><expr><name>SyntaxError</name> <block>{
 
     <expr><name>final</name> <name>IndexSchema</name> <name>schema</name> <operator>=</operator> <call><name><name>searcher</name><operator>.</operator><name>getSchema</name></name><argument_list>()</argument_list></call></expr></block></expr></argument></throws></expr>;
 
<expr><name>diff</name> <operator>--</operator><name>git</name> <name>a</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>search</name><operator>/</operator><name><name>BoostQParserPlugin</name><operator>.</operator><name>java</name></name> <name>b</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>search</name><operator>/</operator><name><name>BoostQParserPlugin</name><operator>.</operator><name>java</name></name>
<name>index</name> <literal type="number">1abb0c93632</literal><operator>..</operator><name>bf8e7ae97b4</name> <literal type="number">100755</literal>
<operator>--</operator> <name>a</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>search</name><operator>/</operator><name><name>BoostQParserPlugin</name><operator>.</operator><name>java</name></name>
<operator>++</operator> <name>b</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>search</name><operator>/</operator><name><name>BoostQParserPlugin</name><operator>.</operator><name>java</name></name>
@@ <operator>-</operator><literal type="number">20</literal></expr>,<expr><literal type="number">7</literal> <operator>+</operator><literal type="number">20</literal></expr>,<expr><literal type="number">6</literal> @@</expr> <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>queries</name><operator>.</operator><name>function</name><operator>.</operator><name>BoostedQuery</name></name>;</import></block></expr>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>queries</name><operator>.</operator><name>function</name><operator>.</operator><name>FunctionQuery</name></name>;</import></block></expr>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>queries</name><operator>.</operator><name>function</name><operator>.</operator><name>ValueSource</name></name>;</import></block></expr>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>queries</name><operator>.</operator><name>function</name><operator>.</operator><name>valuesource</name><operator>.</operator><name>QueryValueSource</name></name>;</import></block></expr>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>queryparser</name><operator>.</operator><name>classic</name><operator>.</operator><name>ParseException</name></name>;</import></block></expr></expr_stmt>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>search</name><operator>.</operator><name>Query</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>common</name><operator>.</operator><name>params</name><operator>.</operator><name>SolrParams</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>common</name><operator>.</operator><name>util</name><operator>.</operator><name>NamedList</name></name>;</import>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">52</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">51</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@ <specifier>public</specifier> <name>class</name> <name>BoostQParserPlugin</name> extends <name>QParserPlugin</name> <block>{
       <expr><name>String</name> <name>b</name></expr>;
 
       @<expr><name>Override</name>
      <specifier>public</specifier> <name>Query</name> <call><name>parse</name><argument_list>()</argument_list></call> <throws>throws <argument><expr><name>ParseException</name> <block>{
      <expr><specifier>public</specifier> <name>Query</name> <call><name>parse</name><argument_list>()</argument_list></call></expr></block></expr></argument></throws> <throws>throws <argument><expr><name>SyntaxError</name> <block>{
         <expr><name>b</name> <operator>=</operator> <call><name><name>localParams</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>BOOSTFUNC</name></expr></argument>)</argument_list></call></expr></block></expr></argument></throws></expr>;
         <expr><name>baseParser</name> <operator>=</operator> <call><name>subQuery</name><argument_list>(<argument><expr><call><name><name>localParams</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name><name>QueryParsing</name><operator>.</operator><name>V</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="null">null</literal></expr></argument>)</argument_list></call></expr>;
         <expr><name>Query</name> <name>q</name> <operator>=</operator> <call><name><name>baseParser</name><operator>.</operator><name>getQuery</name></name><argument_list>()</argument_list></call></expr>;
@@ <expr><operator>-</operator><literal type="number">74</literal></expr>,<expr><literal type="number">7</literal> <operator>+</operator><literal type="number">73</literal></expr>,<expr><literal type="number">7</literal> @@ <specifier>public</specifier> <name>class</name> <name>BoostQParserPlugin</name> extends <name>QParserPlugin</name> <block>{
       }</block>
                                            
       @<name>Override</name>
      <specifier>public</specifier> <name>Query</name> <call><name>getHighlightQuery</name><argument_list>()</argument_list></call> <throws>throws <argument><expr><name>ParseException</name> <block>{
      <expr><specifier>public</specifier> <name>Query</name> <call><name>getHighlightQuery</name><argument_list>()</argument_list></call></expr></block></expr></argument></throws> <throws>throws <argument><expr><name>SyntaxError</name> <block>{</block></expr></argument></throws></expr>
         <return>return <expr><call><name><name>baseParser</name><operator>.</operator><name>getHighlightQuery</name></name><argument_list>()</argument_list></call></expr>;</return>
       }</block></expr></expr_stmt>
 
<expr_stmt><expr><name>diff</name> <operator>--</operator><name>git</name> <name>a</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>search</name><operator>/</operator><name><name>DisMaxQParser</name><operator>.</operator><name>java</name></name> <name>b</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>search</name><operator>/</operator><name><name>DisMaxQParser</name><operator>.</operator><name>java</name></name>
<name>index</name> <name>f02a061d0ba</name><operator>..</operator><literal type="number">844484930b5</literal> <literal type="number">100644</literal>
<operator>--</operator> <name>a</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>search</name><operator>/</operator><name><name>DisMaxQParser</name><operator>.</operator><name>java</name></name>
<operator>++</operator> <name>b</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>search</name><operator>/</operator><name><name>DisMaxQParser</name><operator>.</operator><name>java</name></name>
@@ <operator>-</operator><literal type="number">16</literal></expr><operator>,</operator><expr><literal type="number">12</literal> <operator>+</operator><literal type="number">16</literal></expr><operator>,</operator><expr><literal type="number">11</literal> @@
  <operator>*</operator><operator>/</operator></expr></expr_stmt>
 <package>package <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>search</name></name>;</package>
 
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>queryparser</name><operator>.</operator><name>classic</name><operator>.</operator><name>ParseException</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>queryparser</name><operator>.</operator><name>classic</name><operator>.</operator><name>QueryParser</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>search</name><operator>.</operator><name>BooleanClause</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>search</name><operator>.</operator><name>BooleanQuery</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>search</name><operator>.</operator><name>Query</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>common</name><operator>.</operator><name>params</name><operator>.</operator><name>CommonParams</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>parser</name><operator>.</operator><name>QueryParser</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>schema</name><operator>.</operator><name>IndexSchema</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>common</name><operator>.</operator><name>params</name><operator>.</operator><name>DisMaxParams</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>common</name><operator>.</operator><name>params</name><operator>.</operator><name>SolrParams</name></name>;</import>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">58</literal></expr><operator>,</operator><expr><literal type="number">8</literal> <operator>+</operator><literal type="number">57</literal></expr><operator>,</operator><expr><literal type="number">8</literal> @@ <specifier>public</specifier> <name>class</name> <name>DisMaxQParser</name> extends <name>QParser</name> <block>{
    <expr><operator>*</operator><operator>/</operator>
   <specifier>public</specifier> <specifier>static</specifier> <name>String</name> <call><name>parseMinShouldMatch</name><argument_list>(<argument><expr><name>final</name> <name>IndexSchema</name> <name>schema</name></expr></argument>, 
                                            <argument><expr><name>final</name> <name>SolrParams</name> <name>params</name></expr></argument>)</argument_list></call> <block>{
    <expr><name><name>QueryParser</name><operator>.</operator><name>Operator</name></name> <name>op</name> <operator>=</operator> <call><name><name>QueryParsing</name><operator>.</operator><name>getQueryParserDefaultOperator</name></name>
      <argument_list>(<argument><expr><name>schema</name></expr></argument>, <argument><expr><call><name><name>params</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name><name>QueryParsing</name><operator>.</operator><name>OP</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
    <expr><name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>parser</name><operator>.</operator><name>QueryParser</name><operator>.</operator><name>Operator</name></name> <name>op</name> <operator>=</operator> <call><name><name>QueryParsing</name><operator>.</operator><name>getQueryParserDefaultOperator</name></name>
        <argument_list>(<argument><expr><name>schema</name></expr></argument>, <argument><expr><call><name><name>params</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name><name>QueryParsing</name><operator>.</operator><name>OP</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
     <return>return <expr><call><name><name>params</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name><name>DisMaxParams</name><operator>.</operator><name>MM</name></name></expr></argument>, 
                       <argument><expr><ternary><condition><expr><call><name><name>op</name><operator>.</operator><name>equals</name></name><argument_list>(<argument><expr><name><name>QueryParser</name><operator>.</operator><name>Operator</name><operator>.</operator><name>AND</name></name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="string">"100%"</literal></expr> </then><else>: <expr><literal type="string">"0%"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</return></block></expr>
   }</block>
@@ <operator>-</operator><literal type="number">69</literal></expr><operator>,</operator><expr><literal type="number">12</literal> <operator>+</operator><literal type="number">68</literal></expr><operator>,</operator><expr><literal type="number">12</literal> @@ <specifier>public</specifier> <name>class</name> <name>DisMaxQParser</name> extends <name>QParser</name> <block>{
    <expr><operator>*</operator> <name>or</name> <block>{@<expr><name>link</name> <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>schema</name><operator>.</operator><name>IndexSchema</name></name><operator>#</operator><call><name>getDefaultSearchFieldName</name><argument_list>()</argument_list></call></expr>}</block><operator>.</operator>
    <operator>*</operator><operator>/</operator>
   <specifier>public</specifier> <specifier>static</specifier> <name><name>Map</name><argument_list type="generic">&lt;<argument><name>String</name></argument>, <argument><name>Float</name></argument>&gt;</argument_list></name> <call><name>parseQueryFields</name><argument_list>(<argument><expr><name>final</name> <name>IndexSchema</name> <name>indexSchema</name></expr></argument>, <argument><expr><name>final</name> <name>SolrParams</name> <name>solrParams</name></expr></argument>)</argument_list></call>
      <throws>throws <argument><expr><name>ParseException</name> <block>{</block></expr></argument></throws>
      <throws>throws <argument><expr><name>SyntaxError</name> <block>{
     <expr><name><name>Map</name><argument_list type="generic">&lt;<argument><name>String</name></argument>, <argument><name>Float</name></argument>&gt;</argument_list></name> <name>queryFields</name> <operator>=</operator> <call><name><name>SolrPluginUtils</name><operator>.</operator><name>parseFieldBoosts</name></name><argument_list>(<argument><expr><call><name><name>solrParams</name><operator>.</operator><name>getParams</name></name><argument_list>(<argument><expr><name><name>DisMaxParams</name><operator>.</operator><name>QF</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></block></expr></argument></throws></expr>;
     <if_stmt><if>if <condition>(<expr><call><name><name>queryFields</name><operator>.</operator><name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
       <decl_stmt><decl><type><name>String</name></type> <name>df</name> <init>= <expr><call><name><name>QueryParsing</name><operator>.</operator><name>getDefaultField</name></name><argument_list>(<argument><expr><name>indexSchema</name></expr></argument>, <argument><expr><call><name><name>solrParams</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name><name>CommonParams</name><operator>.</operator><name>DF</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
       <if_stmt><if>if <condition>(<expr><name>df</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
        <throw>throw <expr><operator>new</operator> <call><name>ParseException</name><argument_list>(<argument><expr><literal type="string">"Neither "</literal><operator>+</operator><name><name>DisMaxParams</name><operator>.</operator><name>QF</name></name><operator>+</operator><literal type="string">", "</literal><operator>+</operator><name><name>CommonParams</name><operator>.</operator><name>DF</name></name> <operator>+</operator><literal type="string">", nor the default search field are present."</literal></expr></argument>)</argument_list></call></expr>;</throw>
        <throw>throw <expr><operator>new</operator> <call><name>SyntaxError</name><argument_list>(<argument><expr><literal type="string">"Neither "</literal><operator>+</operator><name><name>DisMaxParams</name><operator>.</operator><name>QF</name></name><operator>+</operator><literal type="string">", "</literal><operator>+</operator><name><name>CommonParams</name><operator>.</operator><name>DF</name></name> <operator>+</operator><literal type="string">", nor the default search field are present."</literal></expr></argument>)</argument_list></call></expr>;</throw>
       <expr_stmt/></block_content></block></if></if_stmt></block_content></block></if></if_stmt>}</block>
       <call><name><name>queryFields</name><operator>.</operator><name>put</name></name><argument_list>(<argument><expr><name>df</name></expr></argument>, <argument><expr><literal type="number">1.0f</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
     }
@<annotation>@</annotation> -<expr_stmt><expr><literal type="number">96</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">95</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@ <specifier>public</specifier> <name>class</name> <name>DisMaxQParser</name> extends <name>QParser</name> <block>{
 
 
   @<expr><name>Override</name>
  <specifier>public</specifier> <name>Query</name> <call><name>parse</name><argument_list>()</argument_list></call> <throws>throws <argument><expr><name>ParseException</name> <block>{
  <expr><specifier>public</specifier> <name>Query</name> <call><name>parse</name><argument_list>()</argument_list></call></expr></block></expr></argument></throws> <throws>throws <argument><expr><name>SyntaxError</name> <block>{
     <expr><name>SolrParams</name> <name>solrParams</name> <operator>=</operator> <call><name><name>SolrParams</name><operator>.</operator><name>wrapDefaults</name></name><argument_list>(<argument><expr><name>localParams</name></expr></argument>, <argument><expr><name>params</name></expr></argument>)</argument_list></call></expr></block></expr></argument></throws></expr>;
 
     <expr><name>queryFields</name> <operator>=</operator> <call><name>parseQueryFields</name><argument_list>(<argument><expr><call><name><name>req</name><operator>.</operator><name>getSchema</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>solrParams</name></expr></argument>)</argument_list></call></expr>;
@@ <expr><operator>-</operator><literal type="number">115</literal></expr>,<expr><literal type="number">7</literal> <operator>+</operator><literal type="number">114</literal></expr>,<expr><literal type="number">7</literal> @@ <specifier>public</specifier> <name>class</name> <name>DisMaxQParser</name> extends <name>QParser</name> <block>{
     <return>return <expr><name>query</name></expr>;</return></block></expr>
   }</block>
 
  <specifier>protected</specifier> <name>void</name> <call><name>addBoostFunctions</name><argument_list>(<argument><expr><name>BooleanQuery</name> <name>query</name></expr></argument>, <argument><expr><name>SolrParams</name> <name>solrParams</name></expr></argument>)</argument_list></call> <throws>throws <argument><expr><name>ParseException</name> <block>{
  <expr><specifier>protected</specifier> <name>void</name> <call><name>addBoostFunctions</name><argument_list>(<argument><expr><name>BooleanQuery</name> <name>query</name></expr></argument>, <argument><expr><name>SolrParams</name> <name>solrParams</name></expr></argument>)</argument_list></call></expr></block></expr></argument></throws> <throws>throws <argument><expr><name>SyntaxError</name> <block>{
     <expr><name><name>String</name><index>[]</index></name> <name>boostFuncs</name> <operator>=</operator> <call><name><name>solrParams</name><operator>.</operator><name>getParams</name></name><argument_list>(<argument><expr><name><name>DisMaxParams</name><operator>.</operator><name>BF</name></name></expr></argument>)</argument_list></call></expr></block></expr></argument></throws></expr>;</expr_stmt>
     <if_stmt><if>if <condition>(<expr><literal type="null">null</literal> <operator>!=</operator> <name>boostFuncs</name> <operator>&amp;&amp;</operator> <literal type="number">0</literal> <operator>!=</operator> <name><name>boostFuncs</name><operator>.</operator><name>length</name></name></expr>)</condition> <block>{<block_content>
       <for>for <control>(<init><decl><type><name>String</name></type> <name>boostFunc</name> <range>: <expr><name>boostFuncs</name></expr></range></decl></init>)</control> <block>{<block_content>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">133</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">132</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@ <specifier>public</specifier> <name>class</name> <name>DisMaxQParser</name> extends <name>QParser</name> <block>{
     }</block></expr></expr_stmt>
   </block_content>}</block></for>
 
  <function><type><specifier>protected</specifier> <name>void</name></type> <name>addBoostQuery</name><parameter_list>(<parameter><decl><type><name>BooleanQuery</name></type> <name>query</name></decl></parameter>, <parameter><decl><type><name>SolrParams</name></type> <name>solrParams</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>ParseException</name></expr></argument></throws> <block>{<block_content>
  <function><type><specifier>protected</specifier> <name>void</name></type> <name>addBoostQuery</name><parameter_list>(<parameter><decl><type><name>BooleanQuery</name></type> <name>query</name></decl></parameter>, <parameter><decl><type><name>SolrParams</name></type> <name>solrParams</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>SyntaxError</name></expr></argument></throws> <block>{<block_content>
     <expr_stmt><expr><name>boostParams</name> <operator>=</operator> <call><name><name>solrParams</name><operator>.</operator><name>getParams</name></name><argument_list>(<argument><expr><name><name>DisMaxParams</name><operator>.</operator><name>BQ</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
     <comment type="line">//List&lt;Query&gt; boostQueries = SolrPluginUtils.parseQueryStrings(req, boostParams);</comment>
     <expr_stmt><expr><name>boostQueries</name> <operator>=</operator> <literal type="null">null</literal></expr>;</expr_stmt>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">168</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">167</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@ <specifier>public</specifier> <name>class</name> <name>DisMaxQParser</name> extends <name>QParser</name> <block>{
   }</block>
 
   <comment type="block" format="javadoc">/** Adds the main query to the query argument. If its blank then false is returned. */</comment>
  <specifier>protected</specifier> <name>boolean</name> <call><name>addMainQuery</name><argument_list>(<argument><expr><name>BooleanQuery</name> <name>query</name></expr></argument>, <argument><expr><name>SolrParams</name> <name>solrParams</name></expr></argument>)</argument_list></call> <throws>throws <argument><expr><name>ParseException</name> <block>{
  <expr><specifier>protected</specifier> <name>boolean</name> <call><name>addMainQuery</name><argument_list>(<argument><expr><name>BooleanQuery</name> <name>query</name></expr></argument>, <argument><expr><name>SolrParams</name> <name>solrParams</name></expr></argument>)</argument_list></call></expr></block></expr></argument></throws> <throws>throws <argument><expr><name>SyntaxError</name> <block>{
     <expr><name><name>Map</name><argument_list type="generic">&lt;<argument><name>String</name></argument>, <argument><name>Float</name></argument>&gt;</argument_list></name> <name>phraseFields</name> <operator>=</operator> <call><name><name>SolrPluginUtils</name><operator>.</operator><name>parseFieldBoosts</name></name><argument_list>(<argument><expr><call><name><name>solrParams</name><operator>.</operator><name>getParams</name></name><argument_list>(<argument><expr><name><name>DisMaxParams</name><operator>.</operator><name>PF</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></block></expr></argument></throws></expr>;</expr_stmt>
     <decl_stmt><decl><type><name>float</name></type> <name>tiebreaker</name> <init>= <expr><call><name><name>solrParams</name><operator>.</operator><name>getFloat</name></name><argument_list>(<argument><expr><name><name>DisMaxParams</name><operator>.</operator><name>TIE</name></name></expr></argument>, <argument><expr><literal type="number">0.0f</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
 
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">206</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">205</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@ <specifier>public</specifier> <name>class</name> <name>DisMaxQParser</name> extends <name>QParser</name> <block>{
     <return>return <expr><literal type="boolean">true</literal></expr>;</return>
   }</block></expr></expr_stmt>
 
  <function><type><specifier>protected</specifier> <name>Query</name></type> <name>getAlternateUserQuery</name><parameter_list>(<parameter><decl><type><name>SolrParams</name></type> <name>solrParams</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>ParseException</name></expr></argument></throws> <block>{<block_content>
  <function><type><specifier>protected</specifier> <name>Query</name></type> <name>getAlternateUserQuery</name><parameter_list>(<parameter><decl><type><name>SolrParams</name></type> <name>solrParams</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>SyntaxError</name></expr></argument></throws> <block>{<block_content>
     <decl_stmt><decl><type><name>String</name></type> <name>altQ</name> <init>= <expr><call><name><name>solrParams</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name><name>DisMaxParams</name><operator>.</operator><name>ALTQ</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
     <if_stmt><if>if <condition>(<expr><name>altQ</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
       <decl_stmt><decl><type><name>QParser</name></type> <name>altQParser</name> <init>= <expr><call><name>subQuery</name><argument_list>(<argument><expr><name>altQ</name></expr></argument>, <argument><expr><literal type="null">null</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">216</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">215</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@ <specifier>public</specifier> <name>class</name> <name>DisMaxQParser</name> extends <name>QParser</name> <block>{
     }</block></expr></expr_stmt>
   </block_content>}</block></if></if_stmt>
 
  <function><type><specifier>protected</specifier> <name>Query</name></type> <name>getPhraseQuery</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>userQuery</name></decl></parameter>, <parameter><decl><type><name><name>SolrPluginUtils</name><operator>.</operator><name>DisjunctionMaxQueryParser</name></name></type> <name>pp</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>ParseException</name></expr></argument></throws> <block>{<block_content>
  <function><type><specifier>protected</specifier> <name>Query</name></type> <name>getPhraseQuery</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>userQuery</name></decl></parameter>, <parameter><decl><type><name><name>SolrPluginUtils</name><operator>.</operator><name>DisjunctionMaxQueryParser</name></name></type> <name>pp</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>SyntaxError</name></expr></argument></throws> <block>{<block_content>
     <comment type="block">/* * * Add on Phrases for the Query * * */</comment>
 
     <comment type="block">/* build up phrase boosting queries */</comment>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">231</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">230</literal></expr><operator>,</operator><expr><literal type="number">9</literal> @@ <specifier>public</specifier> <name>class</name> <name>DisMaxQParser</name> extends <name>QParser</name> <block>{
   }</block>
 
   <specifier>protected</specifier> <name>Query</name> <call><name>getUserQuery</name><argument_list>(<argument><expr><name>String</name> <name>userQuery</name></expr></argument>, <argument><expr><name><name>SolrPluginUtils</name><operator>.</operator><name>DisjunctionMaxQueryParser</name></name> <name>up</name></expr></argument>, <argument><expr><name>SolrParams</name> <name>solrParams</name></expr></argument>)</argument_list></call>
          <throws>throws <argument><expr><name>ParseException</name> <block>{</block></expr></argument></throws>
          <throws>throws <argument><expr><name>SyntaxError</name> <block>{


     <expr><name>String</name> <name>minShouldMatch</name> <operator>=</operator> <call><name>parseMinShouldMatch</name><argument_list>(<argument><expr><call><name><name>req</name><operator>.</operator><name>getSchema</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>solrParams</name></expr></argument>)</argument_list></call></expr></block></expr></argument></throws></expr>;</expr_stmt>
     <decl_stmt><decl><type><name>Query</name></type> <name>dis</name> <init>= <expr><call><name><name>up</name><operator>.</operator><name>parse</name></name><argument_list>(<argument><expr><name>userQuery</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
     <decl_stmt><decl><type><name>Query</name></type> <name>query</name> <init>= <expr><name>dis</name></expr></init></decl>;</decl_stmt>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">261</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">262</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@ <specifier>public</specifier> <name>class</name> <name>DisMaxQParser</name> extends <name>QParser</name> <block>{
   }</block>
 
   @<name>Override</name>
  <specifier>public</specifier> <name>Query</name> <call><name>getHighlightQuery</name><argument_list>()</argument_list></call> <throws>throws <argument><expr><name>ParseException</name> <block>{
  <expr><specifier>public</specifier> <name>Query</name> <call><name>getHighlightQuery</name><argument_list>()</argument_list></call></expr></block></expr></argument></throws> <throws>throws <argument><expr><name>SyntaxError</name> <block>{</block></expr></argument></throws></expr></expr_stmt>
     <return>return <expr><name>parsedUserQuery</name> <operator>==</operator> <literal type="null">null</literal> <operator>?</operator> <name>altUserQuery</name> <operator>:</operator> <name>parsedUserQuery</name></expr>;</return>
   </block_content>}</block></function>
 
<expr_stmt><expr><name>diff</name> <operator>--</operator><name>git</name> <name>a</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>search</name><operator>/</operator><name><name>ExtendedDismaxQParserPlugin</name><operator>.</operator><name>java</name></name> <name>b</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>search</name><operator>/</operator><name><name>ExtendedDismaxQParserPlugin</name><operator>.</operator><name>java</name></name>
<name>index</name> <name>e1724d9602c</name><operator>..</operator><literal type="number">55049bae2de</literal> <literal type="number">100755</literal>
<operator>--</operator> <name>a</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>search</name><operator>/</operator><name><name>ExtendedDismaxQParserPlugin</name><operator>.</operator><name>java</name></name>
<operator>++</operator> <name>b</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>search</name><operator>/</operator><name><name>ExtendedDismaxQParserPlugin</name><operator>.</operator><name>java</name></name>
@@ <operator>-</operator><literal type="number">34</literal></expr><operator>,</operator><expr><literal type="number">11</literal> <operator>+</operator><literal type="number">34</literal></expr><operator>,</operator><expr><literal type="number">11</literal> @@</expr></expr_stmt> <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>queries</name><operator>.</operator><name>function</name><operator>.</operator><name>FunctionQuery</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>queries</name><operator>.</operator><name>function</name><operator>.</operator><name>ValueSource</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>queries</name><operator>.</operator><name>function</name><operator>.</operator><name>valuesource</name><operator>.</operator><name>ProductFloatFunction</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>queries</name><operator>.</operator><name>function</name><operator>.</operator><name>valuesource</name><operator>.</operator><name>QueryValueSource</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>queryparser</name><operator>.</operator><name>classic</name><operator>.</operator><name>ParseException</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>queryparser</name><operator>.</operator><name>classic</name><operator>.</operator><name>QueryParser</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>search</name><operator>.</operator><name>*</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>analysis</name><operator>.</operator><name>TokenizerChain</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>search</name><operator>.</operator><name>SolrQueryParser</name><operator>.</operator><name>MagicFieldName</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>parser</name><operator>.</operator><name>ParseException</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>parser</name><operator>.</operator><name>QueryParser</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>parser</name><operator>.</operator><name>SolrQueryParserBase</name><operator>.</operator><name>MagicFieldName</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>common</name><operator>.</operator><name>params</name><operator>.</operator><name>DisMaxParams</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>common</name><operator>.</operator><name>params</name><operator>.</operator><name>SolrParams</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>common</name><operator>.</operator><name>util</name><operator>.</operator><name>NamedList</name></name>;</import>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">118</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">118</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@ <name>class</name> <name>ExtendedDismaxQParser</name> extends <name>QParser</name> <block>{
 
 
   @<expr><name>Override</name>
  <specifier>public</specifier> <name>Query</name> <call><name>parse</name><argument_list>()</argument_list></call> <throws>throws <argument><expr><name>ParseException</name> <block>{
  <expr><specifier>public</specifier> <name>Query</name> <call><name>parse</name><argument_list>()</argument_list></call></expr></block></expr></argument></throws> <throws>throws <argument><expr><name>SyntaxError</name> <block>{
     <expr><name>SolrParams</name> <name>localParams</name> <operator>=</operator> <call><name>getLocalParams</name><argument_list>()</argument_list></call></expr></block></expr></argument></throws></expr>;
     <name>SolrParams</name> <name>params</name> <operator>=</operator> <call><name>getParams</name><argument_list>()</argument_list></call></block></expr>;</expr_stmt>
     
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">173</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">173</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@ <name>class</name> <name>ExtendedDismaxQParser</name> extends <name>QParser</name> <block>{
         <expr><call><name><name>query</name><operator>.</operator><name>add</name></name><argument_list>( <argument><expr><name>altUserQuery</name></expr></argument> , <argument><expr><name><name>BooleanClause</name><operator>.</operator><name>Occur</name><operator>.</operator><name>MUST</name></name></expr></argument> )</argument_list></call></expr>;
       }</block></expr></expr_stmt> <if_stmt><else>else <block>{<block_content>
         <return>return <expr><literal type="null">null</literal></expr>;</return>
        <comment type="line">// throw new ParseException("missing query string" );</comment>
        <comment type="line">// throw new SyntaxError("missing query string" );</comment>
       </block_content>}</block></else></if_stmt>
     </block_content>}</block></function>
     <if_stmt><else>else <block>{<block_content>     
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">451</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">451</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@ <name>class</name> <name>ExtendedDismaxQParser</name> extends <name>QParser</name> <block>{
                                         <expr><name>int</name> <name>shingleSize</name></expr>,
                                         <expr><name>final</name> <name>float</name> <name>tiebreaker</name></expr>,
                                         <expr><name>final</name> <name>int</name> <name>slop</name></expr>) 
    <throws>throws <argument><expr><name>ParseException</name> <block>{</block></expr></argument></throws>
    <throws>throws <argument><expr><name>SyntaxError</name> <block>{</block></expr></argument></throws></block></expr></expr_stmt>
     
     <if_stmt><if>if <condition>(<expr><literal type="null">null</literal> <operator>==</operator> <name>fields</name> <operator>||</operator> <call><name><name>fields</name><operator>.</operator><name>isEmpty</name></name><argument_list>()</argument_list></call> <operator>||</operator> 
         <literal type="null">null</literal> <operator>==</operator> <name>clauses</name> <operator>||</operator> <call><name><name>clauses</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&lt;</operator> <name>shingleSize</name></expr> )</condition><block type="pseudo"><block_content> 
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">519</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">519</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@ <name>class</name> <name>ExtendedDismaxQParser</name> extends <name>QParser</name> <block>{
   }</block>
 
   @<name>Override</name>
  <specifier>public</specifier> <name>Query</name> <call><name>getHighlightQuery</name><argument_list>()</argument_list></call> <throws>throws <argument><expr><name>ParseException</name> <block>{
  <expr><specifier>public</specifier> <name>Query</name> <call><name>getHighlightQuery</name><argument_list>()</argument_list></call></expr></block></expr></argument></throws> <throws>throws <argument><expr><name>SyntaxError</name> <block>{</block></expr></argument></throws></expr></expr_stmt></block_content></block></if></if_stmt>
     <return>return <expr><name>parsedUserQuery</name> <operator>==</operator> <literal type="null">null</literal> <operator>?</operator> <name>altUserQuery</name> <operator>:</operator> <name>parsedUserQuery</name></expr>;</return>
   </block_content>}</block></else></if_stmt>
 
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">900</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">900</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@ <name>class</name> <name>ExtendedDismaxQParser</name> extends <name>QParser</name> <block>{
     <expr><specifier>protected</specifier> <name><name>Map</name><argument_list type="generic">&lt;<argument><name>String</name></argument>,<argument><name>Alias</name></argument>&gt;</argument_list></name> <name>aliases</name> <operator>=</operator> <operator>new</operator> <call><name><name>HashMap</name><argument_list type="generic">&lt;<argument><name>String</name></argument>,<argument><name>Alias</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;
 
     <specifier>public</specifier> <call><name>ExtendedSolrQueryParser</name><argument_list>(<argument><expr><name>QParser</name> <name>parser</name></expr></argument>, <argument><expr><name>String</name> <name>defaultField</name></expr></argument>)</argument_list></call> <block>{
      <expr><call><name>super</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>defaultField</name></expr></argument>, <argument><expr><literal type="null">null</literal></expr></argument>)</argument_list></call></expr>;
      <call><name>super</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>defaultField</name></expr></argument>)</argument_list></call></block></block></expr>;</expr_stmt>
       <comment type="line">// don't trust that our parent class won't ever change it's default</comment>
       <expr_stmt><expr><call><name>setDefaultOperator</name><argument_list>(<argument><expr><name><name>QueryParser</name><operator>.</operator><name>Operator</name><operator>.</operator><name>OR</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
     </block_content>}</block></function>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">911</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">911</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@ <name>class</name> <name>ExtendedDismaxQParser</name> extends <name>QParser</name> <block>{
     }</block>
 
     @<name>Override</name>
    <specifier>protected</specifier> <name>Query</name> <call><name>getBooleanQuery</name><argument_list>(<argument><expr><name>List</name> <name>clauses</name></expr></argument>, <argument><expr><name>boolean</name> <name>disableCoord</name></expr></argument>)</argument_list></call> <throws>throws <argument><expr><name>ParseException</name> <block>{
    <expr><specifier>protected</specifier> <name>Query</name> <call><name>getBooleanQuery</name><argument_list>(<argument><expr><name>List</name> <name>clauses</name></expr></argument>, <argument><expr><name>boolean</name> <name>disableCoord</name></expr></argument>)</argument_list></call></expr></block></expr></argument></throws> <throws>throws <argument><expr><name>SyntaxError</name> <block>{
       <expr><name>Query</name> <name>q</name> <operator>=</operator> <call><name><name>super</name><operator>.</operator><name>getBooleanQuery</name></name><argument_list>(<argument><expr><name>clauses</name></expr></argument>, <argument><expr><name>disableCoord</name></expr></argument>)</argument_list></call></expr></block></expr></argument></throws></expr>;</expr_stmt>
       <if_stmt><if>if <condition>(<expr><name>q</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
         <expr_stmt><expr><name>q</name> <operator>=</operator> <call><name><name>QueryUtils</name><operator>.</operator><name>makeQueryable</name></name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">971</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">971</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@ <name>class</name> <name>ExtendedDismaxQParser</name> extends <name>QParser</name> <block>{
     <expr><name>int</name> <name>slop</name></expr>;
 
     @<name>Override</name>
    <specifier>protected</specifier> <name>Query</name> <call><name>getFieldQuery</name><argument_list>(<argument><expr><name>String</name> <name>field</name></expr></argument>, <argument><expr><name>String</name> <name>val</name></expr></argument>, <argument><expr><name>boolean</name> <name>quoted</name></expr></argument>)</argument_list></call> <throws>throws <argument><expr><name>ParseException</name> <block>{
    <expr><specifier>protected</specifier> <name>Query</name> <call><name>getFieldQuery</name><argument_list>(<argument><expr><name>String</name> <name>field</name></expr></argument>, <argument><expr><name>String</name> <name>val</name></expr></argument>, <argument><expr><name>boolean</name> <name>quoted</name></expr></argument>)</argument_list></call></expr></block></expr></argument></throws> <throws>throws <argument><expr><name>SyntaxError</name> <block>{
 <comment type="line">//System.out.println("getFieldQuery: val="+val);</comment>
 
       <expr><name><name>this</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name><name>QType</name><operator>.</operator><name>FIELD</name></name></expr></block></expr></argument></throws></block></expr>;</expr_stmt>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">982</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">982</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@ <name>class</name> <name>ExtendedDismaxQParser</name> extends <name>QParser</name> <block>{
     }</block>
 
     @<name>Override</name>
    <specifier>protected</specifier> <name>Query</name> <call><name>getFieldQuery</name><argument_list>(<argument><expr><name>String</name> <name>field</name></expr></argument>, <argument><expr><name>String</name> <name>val</name></expr></argument>, <argument><expr><name>int</name> <name>slop</name></expr></argument>)</argument_list></call> <throws>throws <argument><expr><name>ParseException</name> <block>{
    <expr><specifier>protected</specifier> <name>Query</name> <call><name>getFieldQuery</name><argument_list>(<argument><expr><name>String</name> <name>field</name></expr></argument>, <argument><expr><name>String</name> <name>val</name></expr></argument>, <argument><expr><name>int</name> <name>slop</name></expr></argument>)</argument_list></call></expr></block></expr></argument></throws> <throws>throws <argument><expr><name>SyntaxError</name> <block>{
 <comment type="line">//System.out.println("getFieldQuery: val="+val+" slop="+slop);</comment>
 
       <expr><name><name>this</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name><name>QType</name><operator>.</operator><name>PHRASE</name></name></expr></block></expr></argument></throws></expr>;</expr_stmt>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">993</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">993</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@ <name>class</name> <name>ExtendedDismaxQParser</name> extends <name>QParser</name> <block>{
     }</block>
 
     @<name>Override</name>
    <specifier>protected</specifier> <name>Query</name> <call><name>getPrefixQuery</name><argument_list>(<argument><expr><name>String</name> <name>field</name></expr></argument>, <argument><expr><name>String</name> <name>val</name></expr></argument>)</argument_list></call> <throws>throws <argument><expr><name>ParseException</name> <block>{
    <expr><specifier>protected</specifier> <name>Query</name> <call><name>getPrefixQuery</name><argument_list>(<argument><expr><name>String</name> <name>field</name></expr></argument>, <argument><expr><name>String</name> <name>val</name></expr></argument>)</argument_list></call></expr></block></expr></argument></throws> <throws>throws <argument><expr><name>SyntaxError</name> <block>{</block></expr></argument></throws></expr></expr_stmt>
 <comment type="line">//System.out.println("getPrefixQuery: val="+val);</comment>
       <if_stmt><if>if <condition>(<expr><call><name><name>val</name><operator>.</operator><name>equals</name></name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>field</name><operator>.</operator><name>equals</name></name><argument_list>(<argument><expr><literal type="string">"*"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
         <return>return <expr><operator>new</operator> <call><name>MatchAllDocsQuery</name><argument_list>()</argument_list></call></expr>;</return>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">1005</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">1005</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@ <name>class</name> <name>ExtendedDismaxQParser</name> extends <name>QParser</name> <block>{
     }</block>
 
     @<name>Override</name>
    <specifier>protected</specifier> <name>Query</name> <call><name>newFieldQuery</name><argument_list>(<argument><expr><name>Analyzer</name> <name>analyzer</name></expr></argument>, <argument><expr><name>String</name> <name>field</name></expr></argument>, <argument><expr><name>String</name> <name>queryText</name></expr></argument>, <argument><expr><name>boolean</name> <name>quoted</name></expr></argument>)</argument_list></call> <throws>throws <argument><expr><name>ParseException</name> <block>{
    <expr><specifier>protected</specifier> <name>Query</name> <call><name>newFieldQuery</name><argument_list>(<argument><expr><name>Analyzer</name> <name>analyzer</name></expr></argument>, <argument><expr><name>String</name> <name>field</name></expr></argument>, <argument><expr><name>String</name> <name>queryText</name></expr></argument>, <argument><expr><name>boolean</name> <name>quoted</name></expr></argument>)</argument_list></call></expr></block></expr></argument></throws> <throws>throws <argument><expr><name>SyntaxError</name> <block>{
       <expr><name>Analyzer</name> <name>actualAnalyzer</name></expr></block></expr></argument></throws></expr>;</expr_stmt>
       <if_stmt><if>if <condition>(<expr><name>removeStopFilter</name></expr>)</condition> <block>{<block_content>
         <if_stmt><if>if <condition>(<expr><name>nonStopFilterAnalyzerPerField</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">1022</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">1022</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@ <name>class</name> <name>ExtendedDismaxQParser</name> extends <name>QParser</name> <block>{
     }</block>
 
     @<name>Override</name>
     <specifier>protected</specifier> <name>Query</name> <call><name>getRangeQuery</name><argument_list>(<argument><expr><name>String</name> <name>field</name></expr></argument>, <argument><expr><name>String</name> <name>a</name></expr></argument>, <argument><expr><name>String</name> <name>b</name></expr></argument>, <argument><expr><name>boolean</name> <name>startInclusive</name></expr></argument>, <argument><expr><name>boolean</name> <name>endInclusive</name></expr></argument>)</argument_list></call> <throws>throws <argument><expr><name>ParseException</name> <block>{
     <expr><specifier>protected</specifier> <name>Query</name> <call><name>getRangeQuery</name><argument_list>(<argument><expr><name>String</name> <name>field</name></expr></argument>, <argument><expr><name>String</name> <name>a</name></expr></argument>, <argument><expr><name>String</name> <name>b</name></expr></argument>, <argument><expr><name>boolean</name> <name>startInclusive</name></expr></argument>, <argument><expr><name>boolean</name> <name>endInclusive</name></expr></argument>)</argument_list></call></expr></block></expr></argument></throws> <throws>throws <argument><expr><name>SyntaxError</name> <block>{
 <comment type="line">//System.out.println("getRangeQuery:");</comment>
 
       <expr><name><name>this</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name><name>QType</name><operator>.</operator><name>RANGE</name></name></expr></block></expr></argument></throws></expr>;</expr_stmt>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">1035</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">1035</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@ <name>class</name> <name>ExtendedDismaxQParser</name> extends <name>QParser</name> <block>{
     }</block>
 
     @<name>Override</name>
    <specifier>protected</specifier> <name>Query</name> <call><name>getWildcardQuery</name><argument_list>(<argument><expr><name>String</name> <name>field</name></expr></argument>, <argument><expr><name>String</name> <name>val</name></expr></argument>)</argument_list></call> <throws>throws <argument><expr><name>ParseException</name> <block>{
    <expr><specifier>protected</specifier> <name>Query</name> <call><name>getWildcardQuery</name><argument_list>(<argument><expr><name>String</name> <name>field</name></expr></argument>, <argument><expr><name>String</name> <name>val</name></expr></argument>)</argument_list></call></expr></block></expr></argument></throws> <throws>throws <argument><expr><name>SyntaxError</name> <block>{</block></expr></argument></throws></expr></expr_stmt>
 <comment type="line">//System.out.println("getWildcardQuery: val="+val);</comment>
 
       <if_stmt><if>if <condition>(<expr><call><name><name>val</name><operator>.</operator><name>equals</name></name><argument_list>(<argument><expr><literal type="string">"*"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">1052</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">1052</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@ <name>class</name> <name>ExtendedDismaxQParser</name> extends <name>QParser</name> <block>{
     }</block>
 
     @<name>Override</name>
    <specifier>protected</specifier> <name>Query</name> <call><name>getFuzzyQuery</name><argument_list>(<argument><expr><name>String</name> <name>field</name></expr></argument>, <argument><expr><name>String</name> <name>val</name></expr></argument>, <argument><expr><name>float</name> <name>minSimilarity</name></expr></argument>)</argument_list></call> <throws>throws <argument><expr><name>ParseException</name> <block>{
    <expr><specifier>protected</specifier> <name>Query</name> <call><name>getFuzzyQuery</name><argument_list>(<argument><expr><name>String</name> <name>field</name></expr></argument>, <argument><expr><name>String</name> <name>val</name></expr></argument>, <argument><expr><name>float</name> <name>minSimilarity</name></expr></argument>)</argument_list></call></expr></block></expr></argument></throws> <throws>throws <argument><expr><name>SyntaxError</name> <block>{
 <comment type="line">//System.out.println("getFuzzyQuery: val="+val);</comment>
 
       <expr><name><name>this</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name><name>QType</name><operator>.</operator><name>FUZZY</name></name></expr></block></expr></argument></throws></expr>;</expr_stmt>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">1069</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">1069</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@ <name>class</name> <name>ExtendedDismaxQParser</name> extends <name>QParser</name> <block>{
      <expr><operator>*</operator> <name><name>DisjunctionMaxQuery</name><operator>.</operator></name>  (<name>so</name> <name>yes</name><operator>:</operator> <name>aliases</name> <name>which</name> <name>point</name> <name>at</name> <name>other</name>
      <operator>*</operator> <name>aliases</name> <name>should</name> <name>work</name></expr>)
      <operator>*</operator><operator>/</operator>
    <specifier>protected</specifier> <name>Query</name> <call><name>getAliasedQuery</name><argument_list>()</argument_list></call> <throws>throws <argument><expr><name>ParseException</name> <block>{
    <expr><specifier>protected</specifier> <name>Query</name> <call><name>getAliasedQuery</name><argument_list>()</argument_list></call></expr></block></expr></argument></throws> <throws>throws <argument><expr><name>SyntaxError</name> <block>{
       <expr><name>Alias</name> <name>a</name> <operator>=</operator> <call><name><name>aliases</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>field</name></expr></argument>)</argument_list></call></expr></block></expr></argument></throws></block></expr>;</expr_stmt>
       <expr_stmt><expr><call><name><name>this</name><operator>.</operator><name>validateCyclicAliasing</name></name><argument_list>(<argument><expr><name>field</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
       <if_stmt><if>if <condition>(<expr><name>a</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">1112</literal></expr><operator>,</operator><expr><literal type="number">11</literal> <operator>+</operator><literal type="number">1112</literal></expr><operator>,</operator><expr><literal type="number">11</literal> @@ <name>class</name> <name>ExtendedDismaxQParser</name> extends <name>QParser</name> <block>{
     <comment type="block" format="javadoc">/**
      * Validate there is no cyclic referencing in the aliasing
      */</comment>
    <expr><specifier>private</specifier> <name>void</name> <call><name>validateCyclicAliasing</name><argument_list>(<argument><expr><name>String</name> <name>field</name></expr></argument>)</argument_list></call> <throws>throws <argument><expr><name>ParseException</name> <block>{
    <expr><specifier>private</specifier> <name>void</name> <call><name>validateCyclicAliasing</name><argument_list>(<argument><expr><name>String</name> <name>field</name></expr></argument>)</argument_list></call></expr></block></expr></argument></throws> <throws>throws <argument><expr><name>SyntaxError</name> <block>{
        <expr><name><name>Set</name><argument_list type="generic">&lt;<argument><name>String</name></argument>&gt;</argument_list></name> <name>set</name> <operator>=</operator> <operator>new</operator> <call><name><name>HashSet</name><argument_list type="generic">&lt;<argument><name>String</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></block></expr></argument></throws></expr>;
        <call><name><name>set</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name>field</name></expr></argument>)</argument_list></call></block></expr>;</expr_stmt>
        <if_stmt><if>if<condition>(<expr><call><name>validateField</name><argument_list>(<argument><expr><name>field</name></expr></argument>, <argument><expr><name>set</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
         <throw>throw <expr><operator>new</operator> <call><name>ParseException</name><argument_list>(<argument><expr><literal type="string">"Field aliases lead to a cycle"</literal></expr></argument>)</argument_list></call></expr>;</throw>
         <throw>throw <expr><operator>new</operator> <call><name>SyntaxError</name><argument_list>(<argument><expr><literal type="string">"Field aliases lead to a cycle"</literal></expr></argument>)</argument_list></call></expr>;</throw>
        </block_content>}</block></if></if_stmt>
     </block_content>}</block></if></if_stmt>
     
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">1138</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">1138</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@ <name>class</name> <name>ExtendedDismaxQParser</name> extends <name>QParser</name> <block>{
       <return>return <expr><name>hascycle</name></expr>;</return>
     }</block></expr></expr_stmt>
 
    <function><type><specifier>protected</specifier> <name><name>List</name><argument_list type="generic">&lt;<argument><name>Query</name></argument>&gt;</argument_list></name></type> <name>getQueries</name><parameter_list>(<parameter><decl><type><name>Alias</name></type> <name>a</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>ParseException</name></expr></argument></throws> <block>{<block_content>
    <function><type><specifier>protected</specifier> <name><name>List</name><argument_list type="generic">&lt;<argument><name>Query</name></argument>&gt;</argument_list></name></type> <name>getQueries</name><parameter_list>(<parameter><decl><type><name>Alias</name></type> <name>a</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>SyntaxError</name></expr></argument></throws> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>a</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="null">null</literal></expr>;</return></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><call><name><name>a</name><operator>.</operator><name>fields</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call><operator>==</operator><literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="null">null</literal></expr>;</return></block_content></block></if></if_stmt>
        <decl_stmt><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name>Query</name></argument>&gt;</argument_list></name></type> <name>lst</name><init>= <expr><operator>new</operator> <call><name><name>ArrayList</name><argument_list type="generic">&lt;<argument><name>Query</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>diff</name> <operator>--</operator><name>git</name> <name>a</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>search</name><operator>/</operator><name><name>FunctionQParser</name><operator>.</operator><name>java</name></name> <name>b</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>search</name><operator>/</operator><name><name>FunctionQParser</name><operator>.</operator><name>java</name></name>
<name>index</name> <literal type="number">0f0adc03559</literal><operator>..</operator><literal type="number">53744eaa27d</literal> <literal type="number">100755</literal>
<operator>--</operator> <name>a</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>search</name><operator>/</operator><name><name>FunctionQParser</name><operator>.</operator><name>java</name></name>
<operator>++</operator> <name>b</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>search</name><operator>/</operator><name><name>FunctionQParser</name><operator>.</operator><name>java</name></name>
@@ <operator>-</operator><literal type="number">19</literal></expr><operator>,</operator><expr><literal type="number">12</literal> <operator>+</operator><literal type="number">19</literal></expr><operator>,</operator><expr><literal type="number">10</literal> @@</expr></expr_stmt> <package>package <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>search</name></name>;</package>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>queries</name><operator>.</operator><name>function</name><operator>.</operator><name>FunctionQuery</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>queries</name><operator>.</operator><name>function</name><operator>.</operator><name>ValueSource</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>queries</name><operator>.</operator><name>function</name><operator>.</operator><name>valuesource</name><operator>.</operator><name>*</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>queryparser</name><operator>.</operator><name>classic</name><operator>.</operator><name>ParseException</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>search</name><operator>.</operator><name>Query</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>common</name><operator>.</operator><name>params</name><operator>.</operator><name>SolrParams</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>request</name><operator>.</operator><name>SolrQueryRequest</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>schema</name><operator>.</operator><name>SchemaField</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>search</name><operator>.</operator><name>function</name><operator>.</operator><name>*</name></name>;</import>
 
 <import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>ArrayList</name></name>;</import>
 <import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>HashMap</name></name>;</import>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">60</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">58</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@ <specifier>public</specifier> <name>class</name> <name>FunctionQParser</name> extends <name>QParser</name> <block>{
   }</block>
 
   @<name>Override</name>
  <specifier>public</specifier> <name>Query</name> <call><name>parse</name><argument_list>()</argument_list></call> <throws>throws <argument><expr><name>ParseException</name> <block>{
  <expr><specifier>public</specifier> <name>Query</name> <call><name>parse</name><argument_list>()</argument_list></call></expr></block></expr></argument></throws> <throws>throws <argument><expr><name>SyntaxError</name> <block>{
     <expr><name>sp</name> <operator>=</operator> <operator>new</operator> <call><name><name>QueryParsing</name><operator>.</operator><name>StrParser</name></name><argument_list>(<argument><expr><call><name>getString</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></block></expr></argument></throws></expr>;</expr_stmt>
 
     <decl_stmt><decl><type><name>ValueSource</name></type> <name>vs</name> <init>= <expr><literal type="null">null</literal></expr></init></decl>;</decl_stmt>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">92</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">90</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@ <specifier>public</specifier> <name>class</name> <name>FunctionQParser</name> extends <name>QParser</name> <block>{
     }</block></expr></expr_stmt>
 
     <if_stmt><if>if <condition>(<expr><name>parseToEnd</name> <operator>&amp;&amp;</operator> <name><name>sp</name><operator>.</operator><name>pos</name></name> <operator>&lt;</operator> <name><name>sp</name><operator>.</operator><name>end</name></name></expr>)</condition> <block>{<block_content>
      <throw>throw <expr><operator>new</operator> <call><name>ParseException</name><argument_list>(<argument><expr><literal type="string">"Unexpected text after function: "</literal> <operator>+</operator> <call><name><name>sp</name><operator>.</operator><name>val</name><operator>.</operator><name>substring</name></name><argument_list>(<argument><expr><name><name>sp</name><operator>.</operator><name>pos</name></name></expr></argument>, <argument><expr><name><name>sp</name><operator>.</operator><name>end</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw>
      <throw>throw <expr><operator>new</operator> <call><name>SyntaxError</name><argument_list>(<argument><expr><literal type="string">"Unexpected text after function: "</literal> <operator>+</operator> <call><name><name>sp</name><operator>.</operator><name>val</name><operator>.</operator><name>substring</name></name><argument_list>(<argument><expr><name><name>sp</name><operator>.</operator><name>pos</name></name></expr></argument>, <argument><expr><name><name>sp</name><operator>.</operator><name>end</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw>
     </block_content>}</block></if></if_stmt>
 
     <if_stmt><if>if <condition>(<expr><name>lst</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">107</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">105</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@ <specifier>public</specifier> <name>class</name> <name>FunctionQParser</name> extends <name>QParser</name> <block>{
    <expr><operator>*</operator> 
    <operator>*</operator> @</expr><return>return <expr><name>whether</name> <name>more</name> <name>args</name> <name>exist</name>
    <operator>*</operator><operator>/</operator>
  <specifier>public</specifier> <name>boolean</name> <call><name>hasMoreArguments</name><argument_list>()</argument_list></call> <throws>throws <argument><expr><name>ParseException</name> <block>{
  <expr><specifier>public</specifier> <name>boolean</name> <call><name>hasMoreArguments</name><argument_list>()</argument_list></call></expr></block></expr></argument></throws> <throws>throws <argument><expr><name>SyntaxError</name> <block>{
     <expr><name>int</name> <name>ch</name> <operator>=</operator> <call><name><name>sp</name><operator>.</operator><name>peek</name></name><argument_list>()</argument_list></call></expr></block></expr></argument></throws></expr>;</return></block></expr></expr_stmt>
     <comment type="block">/* determine whether the function is ending with a paren or end of str */</comment>
     <return>return <expr><operator>(</operator><operator>!</operator> <operator>(</operator><name>ch</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>ch</name> <operator>==</operator> <literal type="char">')'</literal><operator>)</operator> <operator>)</operator></expr>;</return>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">116</literal></expr><operator>,</operator><expr><literal type="number">9</literal> <operator>+</operator><literal type="number">114</literal></expr><operator>,</operator><expr><literal type="number">9</literal> @@ <specifier>public</specifier> <name>class</name> <name>FunctionQParser</name> extends <name>QParser</name> <block>{
   <comment type="block">/*
    * TODO: Doc
    */</comment>
  <expr><specifier>public</specifier> <name>String</name> <call><name>parseId</name><argument_list>()</argument_list></call> <throws>throws <argument><expr><name>ParseException</name> <block>{
  <expr><specifier>public</specifier> <name>String</name> <call><name>parseId</name><argument_list>()</argument_list></call></expr></block></expr></argument></throws> <throws>throws <argument><expr><name>SyntaxError</name> <block>{
     <expr><name>String</name> <name>value</name> <operator>=</operator> <call><name>parseArg</name><argument_list>()</argument_list></call></expr></block></expr></argument></throws></expr>;</block></expr></expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>argWasQuoted</name></expr>)</condition><block type="pseudo"><block_content> <throw>throw <expr><operator>new</operator> <call><name>ParseException</name><argument_list>(<argument><expr><literal type="string">"Expected identifier instead of quoted string:"</literal> <operator>+</operator> <name>value</name></expr></argument>)</argument_list></call></expr>;</throw></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>argWasQuoted</name></expr>)</condition><block type="pseudo"><block_content> <throw>throw <expr><operator>new</operator> <call><name>SyntaxError</name><argument_list>(<argument><expr><literal type="string">"Expected identifier instead of quoted string:"</literal> <operator>+</operator> <name>value</name></expr></argument>)</argument_list></call></expr>;</throw></block_content></block></if></if_stmt>
     <return>return <expr><name>value</name></expr>;</return>
   </block_content>}</block></if></if_stmt>
   
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">127</literal></expr><operator>,</operator><expr><literal type="number">9</literal> <operator>+</operator><literal type="number">125</literal></expr><operator>,</operator><expr><literal type="number">9</literal> @@ <specifier>public</specifier> <name>class</name> <name>FunctionQParser</name> extends <name>QParser</name> <block>{
    <expr><operator>*</operator> 
    <operator>*</operator> @</expr><return>return <expr><name>Float</name>
    <operator>*</operator><operator>/</operator>
  <specifier>public</specifier> <name>Float</name> <call><name>parseFloat</name><argument_list>()</argument_list></call> <throws>throws <argument><expr><name>ParseException</name> <block>{
  <expr><specifier>public</specifier> <name>Float</name> <call><name>parseFloat</name><argument_list>()</argument_list></call></expr></block></expr></argument></throws> <throws>throws <argument><expr><name>SyntaxError</name> <block>{
     <expr><name>String</name> <name>str</name> <operator>=</operator> <call><name>parseArg</name><argument_list>()</argument_list></call></expr></block></expr></argument></throws></expr>;</return></block></expr></expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>argWasQuoted</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <throw>throw <expr><operator>new</operator> <call><name>ParseException</name><argument_list>(<argument><expr><literal type="string">"Expected float instead of quoted string:"</literal> <operator>+</operator> <name>str</name></expr></argument>)</argument_list></call></expr>;</throw></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>argWasQuoted</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <throw>throw <expr><operator>new</operator> <call><name>SyntaxError</name><argument_list>(<argument><expr><literal type="string">"Expected float instead of quoted string:"</literal> <operator>+</operator> <name>str</name></expr></argument>)</argument_list></call></expr>;</throw></block_content></block></if></if_stmt>
     <decl_stmt><decl><type><name>float</name></type> <name>value</name> <init>= <expr><call><name><name>Float</name><operator>.</operator><name>parseFloat</name></name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
     <return>return <expr><name>value</name></expr>;</return>
   </block_content>}</block></function>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">138</literal></expr><operator>,</operator><expr><literal type="number">9</literal> <operator>+</operator><literal type="number">136</literal></expr><operator>,</operator><expr><literal type="number">9</literal> @@ <specifier>public</specifier> <name>class</name> <name>FunctionQParser</name> extends <name>QParser</name> <block>{
    <expr><operator>*</operator> <name>Parse</name> <name>a</name> <name>Double</name>
    <operator>*</operator> @</expr><return>return <expr><name>double</name>
    <operator>*</operator><operator>/</operator>
  <specifier>public</specifier> <name>double</name> <call><name>parseDouble</name><argument_list>()</argument_list></call> <throws>throws <argument><expr><name>ParseException</name> <block>{
  <expr><specifier>public</specifier> <name>double</name> <call><name>parseDouble</name><argument_list>()</argument_list></call></expr></block></expr></argument></throws> <throws>throws <argument><expr><name>SyntaxError</name> <block>{
     <expr><name>String</name> <name>str</name> <operator>=</operator> <call><name>parseArg</name><argument_list>()</argument_list></call></expr></block></expr></argument></throws></expr>;</return></block></expr></expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>argWasQuoted</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <throw>throw <expr><operator>new</operator> <call><name>ParseException</name><argument_list>(<argument><expr><literal type="string">"Expected double instead of quoted string:"</literal> <operator>+</operator> <name>str</name></expr></argument>)</argument_list></call></expr>;</throw></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>argWasQuoted</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <throw>throw <expr><operator>new</operator> <call><name>SyntaxError</name><argument_list>(<argument><expr><literal type="string">"Expected double instead of quoted string:"</literal> <operator>+</operator> <name>str</name></expr></argument>)</argument_list></call></expr>;</throw></block_content></block></if></if_stmt>
     <decl_stmt><decl><type><name>double</name></type> <name>value</name> <init>= <expr><call><name><name>Double</name><operator>.</operator><name>parseDouble</name></name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
     <return>return <expr><name>value</name></expr>;</return>
   </block_content>}</block></function>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">149</literal></expr><operator>,</operator><expr><literal type="number">9</literal> <operator>+</operator><literal type="number">147</literal></expr><operator>,</operator><expr><literal type="number">9</literal> @@ <specifier>public</specifier> <name>class</name> <name>FunctionQParser</name> extends <name>QParser</name> <block>{
    <expr><operator>*</operator> <name>Parse</name> <name>an</name> <name>integer</name>
    <operator>*</operator> @</expr><return>return <expr><name>An</name> <name>int</name>
    <operator>*</operator><operator>/</operator>
  <specifier>public</specifier> <name>int</name> <call><name>parseInt</name><argument_list>()</argument_list></call> <throws>throws <argument><expr><name>ParseException</name> <block>{
  <expr><specifier>public</specifier> <name>int</name> <call><name>parseInt</name><argument_list>()</argument_list></call></expr></block></expr></argument></throws> <throws>throws <argument><expr><name>SyntaxError</name> <block>{
     <expr><name>String</name> <name>str</name> <operator>=</operator> <call><name>parseArg</name><argument_list>()</argument_list></call></expr></block></expr></argument></throws></expr>;</return></block></expr></expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>argWasQuoted</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <throw>throw <expr><operator>new</operator> <call><name>ParseException</name><argument_list>(<argument><expr><literal type="string">"Expected double instead of quoted string:"</literal> <operator>+</operator> <name>str</name></expr></argument>)</argument_list></call></expr>;</throw></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>argWasQuoted</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <throw>throw <expr><operator>new</operator> <call><name>SyntaxError</name><argument_list>(<argument><expr><literal type="string">"Expected double instead of quoted string:"</literal> <operator>+</operator> <name>str</name></expr></argument>)</argument_list></call></expr>;</throw></block_content></block></if></if_stmt>
     <decl_stmt><decl><type><name>int</name></type> <name>value</name> <init>= <expr><call><name><name>Integer</name><operator>.</operator><name>parseInt</name></name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
     <return>return <expr><name>value</name></expr>;</return>
   </block_content>}</block></if></if_stmt>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">162</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">160</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@ <specifier>public</specifier> <name>class</name> <name>FunctionQParser</name> extends <name>QParser</name> <block>{
     <return>return <expr><name>argWasQuoted</name></expr>;</return>
   }</block></expr></expr_stmt>
 
  <function><type><specifier>public</specifier> <name>String</name></type> <name>parseArg</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>ParseException</name></expr></argument></throws> <block>{<block_content>
  <function><type><specifier>public</specifier> <name>String</name></type> <name>parseArg</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>SyntaxError</name></expr></argument></throws> <block>{<block_content>
     <expr_stmt><expr><name>argWasQuoted</name> <operator>=</operator> <literal type="boolean">false</literal></expr>;</expr_stmt>
 
     <expr_stmt><expr><call><name><name>sp</name><operator>.</operator><name>eatws</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">186</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">184</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@ <specifier>public</specifier> <name>class</name> <name>FunctionQParser</name> extends <name>QParser</name> <block>{
         <expr><name>int</name> <name>valStart</name> <operator>=</operator> <name><name>sp</name><operator>.</operator><name>pos</name></name></expr>;</block></expr></expr_stmt>
         <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
           <if_stmt><if>if <condition>(<expr><name><name>sp</name><operator>.</operator><name>pos</name></name> <operator>&gt;=</operator> <name><name>sp</name><operator>.</operator><name>end</name></name></expr>)</condition> <block>{<block_content>
            <throw>throw <expr><operator>new</operator> <call><name>ParseException</name><argument_list>(<argument><expr><literal type="string">"Missing end to unquoted value starting at "</literal> <operator>+</operator> <name>valStart</name> <operator>+</operator> <literal type="string">" str='"</literal> <operator>+</operator> <name><name>sp</name><operator>.</operator><name>val</name></name> <operator>+</operator><literal type="string">"'"</literal></expr></argument>)</argument_list></call></expr>;</throw>
            <throw>throw <expr><operator>new</operator> <call><name>SyntaxError</name><argument_list>(<argument><expr><literal type="string">"Missing end to unquoted value starting at "</literal> <operator>+</operator> <name>valStart</name> <operator>+</operator> <literal type="string">" str='"</literal> <operator>+</operator> <name><name>sp</name><operator>.</operator><name>val</name></name> <operator>+</operator><literal type="string">"'"</literal></expr></argument>)</argument_list></call></expr>;</throw>
           </block_content>}</block></if></if_stmt>
           <decl_stmt><decl><type><name>char</name></type> <name>c</name> <init>= <expr><call><name><name>sp</name><operator>.</operator><name>val</name><operator>.</operator><name>charAt</name></name><argument_list>(<argument><expr><name><name>sp</name><operator>.</operator><name>pos</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
           <if_stmt><if>if <condition>(<expr><name>c</name><operator>==</operator><literal type="char">')'</literal> <operator>||</operator> <name>c</name><operator>==</operator><literal type="char">','</literal> <operator>||</operator> <call><name><name>Character</name><operator>.</operator><name>isWhitespace</name></name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">209</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">207</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@ <specifier>public</specifier> <name>class</name> <name>FunctionQParser</name> extends <name>QParser</name> <block>{
    <expr><operator>*</operator> 
    <operator>*</operator> @</expr><return>return <expr><name>List</name><operator>&amp;</operator><name>lt</name></expr>;</return><name>ValueSource</name><operator>&amp;</operator><name>gt</name></block></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><operator>/</operator>
  <specifier>public</specifier> <name><name>List</name><argument_list type="generic">&lt;<argument><name>ValueSource</name></argument>&gt;</argument_list></name> <call><name>parseValueSourceList</name><argument_list>()</argument_list></call> <throws>throws <argument><expr><name>ParseException</name> <block>{
  <expr><specifier>public</specifier> <name><name>List</name><argument_list type="generic">&lt;<argument><name>ValueSource</name></argument>&gt;</argument_list></name> <call><name>parseValueSourceList</name><argument_list>()</argument_list></call></expr></block></expr></argument></throws> <throws>throws <argument><expr><name>SyntaxError</name> <block>{
     <expr><name><name>List</name><argument_list type="generic">&lt;<argument><name>ValueSource</name></argument>&gt;</argument_list></name> <name>sources</name> <operator>=</operator> <operator>new</operator> <call><name><name>ArrayList</name><argument_list type="generic">&lt;<argument><name>ValueSource</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></block></expr></argument></throws></expr>;</expr_stmt>
     <while>while <condition>(<expr><call><name>hasMoreArguments</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
       <expr_stmt><expr><call><name><name>sources</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><call><name>parseValueSource</name><argument_list>(<argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">220</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">218</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@ <specifier>public</specifier> <name>class</name> <name>FunctionQParser</name> extends <name>QParser</name> <block>{
   <comment type="block" format="javadoc">/**
    * Parse an individual ValueSource.
    */</comment>
  <expr><specifier>public</specifier> <name>ValueSource</name> <call><name>parseValueSource</name><argument_list>()</argument_list></call> <throws>throws <argument><expr><name>ParseException</name> <block>{
  <expr><specifier>public</specifier> <name>ValueSource</name> <call><name>parseValueSource</name><argument_list>()</argument_list></call></expr></block></expr></argument></throws> <throws>throws <argument><expr><name>SyntaxError</name> <block>{</block></expr></argument></throws></expr>
     <comment type="block">/* consume the delimiter afterward for an external call to parseValueSource */</comment>
     <return>return <expr><call><name>parseValueSource</name><argument_list>(<argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr>;</return>
   }</block></expr></expr_stmt>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">228</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">226</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@ <specifier>public</specifier> <name>class</name> <name>FunctionQParser</name> extends <name>QParser</name> <block>{
   <comment type="block">/*
    * TODO: Doc
    */</comment>
  <expr><specifier>public</specifier> <name>Query</name> <call><name>parseNestedQuery</name><argument_list>()</argument_list></call> <throws>throws <argument><expr><name>ParseException</name> <block>{
  <expr><specifier>public</specifier> <name>Query</name> <call><name>parseNestedQuery</name><argument_list>()</argument_list></call></expr></block></expr></argument></throws> <throws>throws <argument><expr><name>SyntaxError</name> <block>{
     <expr><name>Query</name> <name>nestedQuery</name></expr></block></expr></argument></throws></expr>;</block></expr></expr_stmt>
     
     <if_stmt><if>if <condition>(<expr><call><name><name>sp</name><operator>.</operator><name>opt</name></name><argument_list>(<argument><expr><literal type="string">"$"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">257</literal></expr><operator>,</operator><expr><literal type="number">10</literal> <operator>+</operator><literal type="number">255</literal></expr><operator>,</operator><expr><literal type="number">10</literal> @@ <specifier>public</specifier> <name>class</name> <name>FunctionQParser</name> extends <name>QParser</name> <block>{
           <expr><name>sub</name> <operator>=</operator> <call><name>subQuery</name><argument_list>(<argument><expr><name>qs</name></expr></argument>, <argument><expr><literal type="null">null</literal></expr></argument>)</argument_list></call></expr>;
           <comment type="line">// int subEnd = sub.findEnd(')');</comment>
           <comment type="line">// TODO.. implement functions to find the end of a nested query</comment>
          <throw>throw <argument_list>new <argument><expr><call><name>ParseException</name><argument_list>(<argument><expr><literal type="string">"Nested local params must have value in v parameter.  got '"</literal> <operator>+</operator> <name>qs</name> <operator>+</operator> <literal type="string">"'"</literal></expr></argument>)</argument_list></call></expr></argument></argument_list></throw></block></expr>;</expr_stmt>
          <throw>throw <expr><operator>new</operator> <call><name>SyntaxError</name><argument_list>(<argument><expr><literal type="string">"Nested local params must have value in v parameter.  got '"</literal> <operator>+</operator> <name>qs</name> <operator>+</operator> <literal type="string">"'"</literal></expr></argument>)</argument_list></call></expr>;</throw>
         </block_content>}</block></if></if_stmt>
       </block_content>}</block></while> <if_stmt><else>else <block>{<block_content>
        <throw>throw <expr><operator>new</operator> <call><name>ParseException</name><argument_list>(<argument><expr><literal type="string">"Nested function query must use $param or {!v=value} forms. got '"</literal> <operator>+</operator> <name>qs</name> <operator>+</operator> <literal type="string">"'"</literal></expr></argument>)</argument_list></call></expr>;</throw>
        <throw>throw <expr><operator>new</operator> <call><name>SyntaxError</name><argument_list>(<argument><expr><literal type="string">"Nested function query must use $param or {!v=value} forms. got '"</literal> <operator>+</operator> <name>qs</name> <operator>+</operator> <literal type="string">"'"</literal></expr></argument>)</argument_list></call></expr>;</throw>
       </block_content>}</block></else></if_stmt>
   
       <expr_stmt><expr><name><name>sp</name><operator>.</operator><name>pos</name></name> <operator>+=</operator> <name>end</name><operator>-</operator><name>start</name></expr>;</expr_stmt>  <comment type="line">// advance past nested query</comment>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">276</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">274</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@ <specifier>public</specifier> <name>class</name> <name>FunctionQParser</name> extends <name>QParser</name> <block>{
    <expr><operator>*</operator> 
    <operator>*</operator> @<name>param</name> <name>doConsumeDelimiter</name> <name>whether</name> <name>to</name> <name>consume</name> <name>a</name> <name>delimiter</name> <name>following</name> <name>the</name> <name>ValueSource</name>  
    <operator>*</operator><operator>/</operator>
  <specifier>protected</specifier> <name>ValueSource</name> <call><name>parseValueSource</name><argument_list>(<argument><expr><name>boolean</name> <name>doConsumeDelimiter</name></expr></argument>)</argument_list></call> <throws>throws <argument><expr><name>ParseException</name> <block>{
  <expr><specifier>protected</specifier> <name>ValueSource</name> <call><name>parseValueSource</name><argument_list>(<argument><expr><name>boolean</name> <name>doConsumeDelimiter</name></expr></argument>)</argument_list></call></expr></block></expr></argument></throws> <throws>throws <argument><expr><name>SyntaxError</name> <block>{
     <expr><name>ValueSource</name> <name>valueSource</name></expr></block></expr></argument></throws></expr>;
     
     <name>int</name> <name>ch</name> <operator>=</operator> <call><name><name>sp</name><operator>.</operator><name>peek</name></name><argument_list>()</argument_list></call></block></expr>;</expr_stmt>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">297</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">295</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@ <specifier>public</specifier> <name>class</name> <name>FunctionQParser</name> extends <name>QParser</name> <block>{
       <expr><name>String</name> <name>param</name> <operator>=</operator> <call><name><name>sp</name><operator>.</operator><name>getId</name></name><argument_list>()</argument_list></call></expr>;
       <name>String</name> <name>val</name> <operator>=</operator> <call><name>getParam</name><argument_list>(<argument><expr><name>param</name></expr></argument>)</argument_list></call></block></expr>;</expr_stmt>
       <if_stmt><if>if <condition>(<expr><name>val</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
        <throw>throw <expr><operator>new</operator> <call><name>ParseException</name><argument_list>(<argument><expr><literal type="string">"Missing param "</literal> <operator>+</operator> <name>param</name> <operator>+</operator> <literal type="string">" while parsing function '"</literal> <operator>+</operator> <name><name>sp</name><operator>.</operator><name>val</name></name> <operator>+</operator> <literal type="string">"'"</literal></expr></argument>)</argument_list></call></expr>;</throw>
        <throw>throw <expr><operator>new</operator> <call><name>SyntaxError</name><argument_list>(<argument><expr><literal type="string">"Missing param "</literal> <operator>+</operator> <name>param</name> <operator>+</operator> <literal type="string">" while parsing function '"</literal> <operator>+</operator> <name><name>sp</name><operator>.</operator><name>val</name></name> <operator>+</operator> <literal type="string">"'"</literal></expr></argument>)</argument_list></call></expr>;</throw>
       </block_content>}</block></if></if_stmt>
 
       <decl_stmt><decl><type><name>QParser</name></type> <name>subParser</name> <init>= <expr><call><name>subQuery</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><literal type="string">"func"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">349</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">347</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@ <specifier>public</specifier> <name>class</name> <name>FunctionQParser</name> extends <name>QParser</name> <block>{
         <comment type="line">// a function... look it up.</comment>
         <expr><name>ValueSourceParser</name> <name>argParser</name> <operator>=</operator> <call><name><name>req</name><operator>.</operator><name>getCore</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getValueSourceParser</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</block></expr></expr_stmt>
         <if_stmt><if>if <condition>(<expr><name>argParser</name><operator>==</operator><literal type="null">null</literal></expr>)</condition> <block>{<block_content>
          <throw>throw <expr><operator>new</operator> <call><name>ParseException</name><argument_list>(<argument><expr><literal type="string">"Unknown function "</literal> <operator>+</operator> <name>id</name> <operator>+</operator> <literal type="string">" in FunctionQuery("</literal> <operator>+</operator> <name>sp</name> <operator>+</operator> <literal type="string">")"</literal></expr></argument>)</argument_list></call></expr>;</throw>
          <throw>throw <expr><operator>new</operator> <call><name>SyntaxError</name><argument_list>(<argument><expr><literal type="string">"Unknown function "</literal> <operator>+</operator> <name>id</name> <operator>+</operator> <literal type="string">" in FunctionQuery("</literal> <operator>+</operator> <name>sp</name> <operator>+</operator> <literal type="string">")"</literal></expr></argument>)</argument_list></call></expr>;</throw>
         </block_content>}</block></if></if_stmt>
         <expr_stmt><expr><name>valueSource</name> <operator>=</operator> <call><name><name>argParser</name><operator>.</operator><name>parse</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
         <expr_stmt><expr><call><name><name>sp</name><operator>.</operator><name>expect</name></name><argument_list>(<argument><expr><literal type="string">")"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">379</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">377</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@ <specifier>public</specifier> <name>class</name> <name>FunctionQParser</name> extends <name>QParser</name> <block>{
    <expr><operator>*</operator> 
    <operator>*</operator> @</expr><return>return <expr><name>whether</name> <name>a</name> <name>delimiter</name> <name>was</name> <name>consumed</name>
    <operator>*</operator><operator>/</operator>
  <specifier>protected</specifier> <name>boolean</name> <call><name>consumeArgumentDelimiter</name><argument_list>()</argument_list></call> <throws>throws <argument><expr><name>ParseException</name> <block>{
  <expr><specifier>protected</specifier> <name>boolean</name> <call><name>consumeArgumentDelimiter</name><argument_list>()</argument_list></call></expr></block></expr></argument></throws> <throws>throws <argument><expr><name>SyntaxError</name> <block>{</block></expr></argument></throws></expr></return>
     <comment type="block">/* if a list of args is ending, don't expect the comma */</comment>
     <if_stmt><if>if <condition>(<expr><call><name>hasMoreArguments</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
       <expr_stmt><expr><call><name><name>sp</name><operator>.</operator><name>expect</name></name><argument_list>(<argument><expr><literal type="string">","</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>diff</name> <operator>--</operator><name>git</name> <name>a</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>search</name><operator>/</operator><name><name>FunctionRangeQParserPlugin</name><operator>.</operator><name>java</name></name> <name>b</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>search</name><operator>/</operator><name><name>FunctionRangeQParserPlugin</name><operator>.</operator><name>java</name></name>
<name>index</name> <literal type="number">0e89772dfe2</literal><operator>..</operator><literal type="number">095c90d937f</literal> <literal type="number">100755</literal>
<operator>--</operator> <name>a</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>search</name><operator>/</operator><name><name>FunctionRangeQParserPlugin</name><operator>.</operator><name>java</name></name>
<operator>++</operator> <name>b</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>search</name><operator>/</operator><name><name>FunctionRangeQParserPlugin</name><operator>.</operator><name>java</name></name>
@@ <operator>-</operator><literal type="number">16</literal></expr><operator>,</operator><expr><literal type="number">23</literal> <operator>+</operator><literal type="number">16</literal></expr><operator>,</operator><expr><literal type="number">15</literal> @@
  <operator>*</operator><operator>/</operator></expr></expr_stmt>
 <package>package <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>search</name></name>;</package>
 
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>index</name><operator>.</operator><name>IndexReader</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>queries</name><operator>.</operator><name>function</name><operator>.</operator><name>FunctionValues</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>queries</name><operator>.</operator><name>function</name><operator>.</operator><name>FunctionQuery</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>queries</name><operator>.</operator><name>function</name><operator>.</operator><name>ValueSource</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>queries</name><operator>.</operator><name>function</name><operator>.</operator><name>ValueSourceScorer</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>queries</name><operator>.</operator><name>function</name><operator>.</operator><name>valuesource</name><operator>.</operator><name>QueryValueSource</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>queryparser</name><operator>.</operator><name>classic</name><operator>.</operator><name>ParseException</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>search</name><operator>.</operator><name>*</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>common</name><operator>.</operator><name>params</name><operator>.</operator><name>SolrParams</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>common</name><operator>.</operator><name>util</name><operator>.</operator><name>NamedList</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>core</name><operator>.</operator><name>SolrConfig</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>request</name><operator>.</operator><name>SolrQueryRequest</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>search</name><operator>.</operator><name>function</name><operator>.</operator><name>*</name></name>;</import>
 
<import>import <name><name>java</name><operator>.</operator><name>io</name><operator>.</operator><name>IOException</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>Map</name></name>;</import>

 <comment type="block" format="javadoc">/**
  * Create a range query over a function.
  * &lt;br&gt;Other parameters:
@@ -56,7 +48,7 @@ public class FunctionRangeQParserPlugin extends QParserPlugin {
       String funcStr;
 
       @Override
      public Query parse() throws ParseException {
      public Query parse() throws SyntaxError {
         funcStr = localParams.get(QueryParsing.V, null);
         Query funcQ = subQuery(funcStr, FunctionQParserPlugin.NAME).getQuery();
         if (funcQ instanceof FunctionQuery) {
diff --git a/solr/core/src/java/org/apache/solr/search/Grouping.java b/solr/core/src/java/org/apache/solr/search/Grouping.java
index 23599e3b6d7..1ae2561cab2 100755
-- a/solr/core/src/java/org/apache/solr/search/Grouping.java
++ b/solr/core/src/java/org/apache/solr/search/Grouping.java
@@ -18,12 +18,10 @@
 package org.apache.solr.search;
 
 import org.apache.commons.lang.ArrayUtils;
import org.apache.lucene.index.IndexableField;
 import org.apache.lucene.index.StorableField;
 import org.apache.lucene.queries.function.FunctionQuery;
 import org.apache.lucene.queries.function.ValueSource;
 import org.apache.lucene.queries.function.valuesource.QueryValueSource;
import org.apache.lucene.queryparser.classic.ParseException;
 import org.apache.lucene.search.*;
 import org.apache.lucene.search.grouping.*;
 import org.apache.lucene.search.grouping.function.FunctionAllGroupHeadsCollector;
@@ -128,7 +126,7 @@ public class Grouping {
    *
    * @param field The fieldname to group by.
    */</comment>
  <function><type><specifier>public</specifier> <name>void</name></type> <name>addFieldCommand</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>field</name></decl></parameter>, <parameter><decl><type><name>SolrQueryRequest</name></type> <name>request</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>ParseException</name></expr></argument></throws> <block>{<block_content>
  <function><type><specifier>public</specifier> <name>void</name></type> <name>addFieldCommand</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>field</name></decl></parameter>, <parameter><decl><type><name>SolrQueryRequest</name></type> <name>request</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>SyntaxError</name></expr></argument></throws> <block>{<block_content>
     <decl_stmt><decl><type><name>SchemaField</name></type> <name>schemaField</name> <init>= <expr><call><name><name>searcher</name><operator>.</operator><name>getSchema</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getField</name><argument_list>(<argument><expr><name>field</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt> <comment type="line">// Throws an exception when field doesn't exist. Bad request.</comment>
     <decl_stmt><decl><type><name>FieldType</name></type> <name>fieldType</name> <init>= <expr><call><name><name>schemaField</name><operator>.</operator><name>getType</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
     <decl_stmt><decl><type><name>ValueSource</name></type> <name>valueSource</name> <init>= <expr><call><name><name>fieldType</name><operator>.</operator><name>getValueSource</name></name><argument_list>(<argument><expr><name>schemaField</name></expr></argument>, <argument><expr><literal type="null">null</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">160</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">158</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@ <specifier>public</specifier> <name>class</name> <name>Grouping</name> <block>{
     <expr><call><name><name>commands</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name>gc</name></expr></argument>)</argument_list></call></expr>;
   }</block></expr></expr_stmt>
 
  <function><type><specifier>public</specifier> <name>void</name></type> <name>addFunctionCommand</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>groupByStr</name></decl></parameter>, <parameter><decl><type><name>SolrQueryRequest</name></type> <name>request</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>ParseException</name></expr></argument></throws> <block>{<block_content>
  <function><type><specifier>public</specifier> <name>void</name></type> <name>addFunctionCommand</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>groupByStr</name></decl></parameter>, <parameter><decl><type><name>SolrQueryRequest</name></type> <name>request</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>SyntaxError</name></expr></argument></throws> <block>{<block_content>
     <decl_stmt><decl><type><name>QParser</name></type> <name>parser</name> <init>= <expr><call><name><name>QParser</name><operator>.</operator><name>getParser</name></name><argument_list>(<argument><expr><name>groupByStr</name></expr></argument>, <argument><expr><literal type="string">"func"</literal></expr></argument>, <argument><expr><name>request</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
     <decl_stmt><decl><type><name>Query</name></type> <name>q</name> <init>= <expr><call><name><name>parser</name><operator>.</operator><name>getQuery</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
     <decl_stmt><decl><type><specifier>final</specifier> <name><name>Grouping</name><operator>.</operator><name>Command</name></name></type> <name>gc</name></decl>;</decl_stmt>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">203</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">201</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@ <specifier>public</specifier> <name>class</name> <name>Grouping</name> <block>{
     <expr><call><name><name>commands</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name>gc</name></expr></argument>)</argument_list></call></expr>;
   }</block></expr></expr_stmt>
 
  <function><type><specifier>public</specifier> <name>void</name></type> <name>addQueryCommand</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>groupByStr</name></decl></parameter>, <parameter><decl><type><name>SolrQueryRequest</name></type> <name>request</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>ParseException</name></expr></argument></throws> <block>{<block_content>
  <function><type><specifier>public</specifier> <name>void</name></type> <name>addQueryCommand</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>groupByStr</name></decl></parameter>, <parameter><decl><type><name>SolrQueryRequest</name></type> <name>request</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>SyntaxError</name></expr></argument></throws> <block>{<block_content>
     <decl_stmt><decl><type><name>QParser</name></type> <name>parser</name> <init>= <expr><call><name><name>QParser</name><operator>.</operator><name>getParser</name></name><argument_list>(<argument><expr><name>groupByStr</name></expr></argument>, <argument><expr><literal type="null">null</literal></expr></argument>, <argument><expr><name>request</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
     <decl_stmt><decl><type><name>Query</name></type> <name>gq</name> <init>= <expr><call><name><name>parser</name><operator>.</operator><name>getQuery</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
     <decl_stmt><decl><type><name><name>Grouping</name><operator>.</operator><name>CommandQuery</name></name></type> <name>gc</name> <init>= <expr><operator>new</operator> <call><name>CommandQuery</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>diff</name> <operator>--</operator><name>git</name> <name>a</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>search</name><operator>/</operator><name><name>JoinQParserPlugin</name><operator>.</operator><name>java</name></name> <name>b</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>search</name><operator>/</operator><name><name>JoinQParserPlugin</name><operator>.</operator><name>java</name></name>
<name>index</name> <literal type="number">7d444af1910</literal><operator>..</operator><literal type="number">682268ac47a</literal> <literal type="number">100644</literal>
<operator>--</operator> <name>a</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>search</name><operator>/</operator><name><name>JoinQParserPlugin</name><operator>.</operator><name>java</name></name>
<operator>++</operator> <name>b</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>search</name><operator>/</operator><name><name>JoinQParserPlugin</name><operator>.</operator><name>java</name></name>
@@ <operator>-</operator><literal type="number">17</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">17</literal></expr><operator>,</operator><expr><literal type="number">6</literal> @@</expr></expr_stmt>
 <package>package <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>search</name></name>;</package>
 
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>index</name><operator>.</operator><name>*</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>queryparser</name><operator>.</operator><name>classic</name><operator>.</operator><name>ParseException</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>search</name><operator>.</operator><name>*</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>search</name><operator>.</operator><name>similarities</name><operator>.</operator><name>Similarity</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>util</name><operator>.</operator><name>Bits</name></name>;</import>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">53</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">52</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@ <specifier>public</specifier> <name>class</name> <name>JoinQParserPlugin</name> extends <name>QParserPlugin</name> <block>{
 
   <expr><specifier>public</specifier> <name>QParser</name> <call><name>createParser</name><argument_list>(<argument><expr><name>String</name> <name>qstr</name></expr></argument>, <argument><expr><name>SolrParams</name> <name>localParams</name></expr></argument>, <argument><expr><name>SolrParams</name> <name>params</name></expr></argument>, <argument><expr><name>SolrQueryRequest</name> <name>req</name></expr></argument>)</argument_list></call> <block>{
     <return>return <expr><operator>new</operator> <class><super><name>QParser</name></super><argument_list>(<argument><expr><name>qstr</name></expr></argument>, <argument><expr><name>localParams</name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>req</name></expr></argument>)</argument_list> <block>{
      <function><type><specifier>public</specifier> <name>Query</name></type> <name>parse</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>ParseException</name></expr></argument></throws> <block>{<block_content>
      <function><type><specifier>public</specifier> <name>Query</name></type> <name>parse</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>SyntaxError</name></expr></argument></throws> <block>{<block_content>
         <decl_stmt><decl><type><name>String</name></type> <name>fromField</name> <init>= <expr><call><name>getParam</name><argument_list>(<argument><expr><literal type="string">"from"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
         <decl_stmt><decl><type><name>String</name></type> <name>fromIndex</name> <init>= <expr><call><name>getParam</name><argument_list>(<argument><expr><literal type="string">"fromIndex"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
         <decl_stmt><decl><type><name>String</name></type> <name>toField</name> <init>= <expr><call><name>getParam</name><argument_list>(<argument><expr><literal type="string">"to"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>diff</name> <operator>--</operator><name>git</name> <name>a</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>search</name><operator>/</operator><name><name>LuceneQParserPlugin</name><operator>.</operator><name>java</name></name> <name>b</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>search</name><operator>/</operator><name><name>LuceneQParserPlugin</name><operator>.</operator><name>java</name></name>
<name>index</name> <literal type="number">6912c4d868a</literal><operator>..</operator><literal type="number">326d5aeb700</literal> <literal type="number">100755</literal>
<operator>--</operator> <name>a</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>search</name><operator>/</operator><name><name>LuceneQParserPlugin</name><operator>.</operator><name>java</name></name>
<operator>++</operator> <name>b</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>search</name><operator>/</operator><name><name>LuceneQParserPlugin</name><operator>.</operator><name>java</name></name>
@@ <operator>-</operator><literal type="number">16</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">16</literal></expr><operator>,</operator><expr><literal type="number">6</literal> @@
  <operator>*</operator><operator>/</operator></expr></expr_stmt>
 <package>package <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>search</name></name>;</package>
 
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>queryparser</name><operator>.</operator><name>classic</name><operator>.</operator><name>ParseException</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>search</name><operator>.</operator><name>Query</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>search</name><operator>.</operator><name>Sort</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>common</name><operator>.</operator><name>params</name><operator>.</operator><name>CommonParams</name></name>;</import>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">55</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">54</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@ <name>class</name> <name>LuceneQParser</name> extends <name>QParser</name> <block>{
 
 
   @<expr><name>Override</name>
  <specifier>public</specifier> <name>Query</name> <call><name>parse</name><argument_list>()</argument_list></call> <throws>throws <argument><expr><name>ParseException</name> <block>{
  <expr><specifier>public</specifier> <name>Query</name> <call><name>parse</name><argument_list>()</argument_list></call></expr></block></expr></argument></throws> <throws>throws <argument><expr><name>SyntaxError</name> <block>{
     <expr><name>String</name> <name>qstr</name> <operator>=</operator> <call><name>getString</name><argument_list>()</argument_list></call></expr></block></expr></argument></throws></expr>;</block></expr></expr_stmt>
     <if_stmt><if>if <condition>(<expr><name>qstr</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <call><name><name>qstr</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call><operator>==</operator><literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="null">null</literal></expr>;</return></block_content></block></if></if_stmt>
 
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">75</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">74</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@ <name>class</name> <name>LuceneQParser</name> extends <name>QParser</name> <block>{
 
   @<expr><name>Override</name>
   <specifier>public</specifier> <name><name>String</name><index>[]</index></name> <call><name>getDefaultHighlightFields</name><argument_list>()</argument_list></call> <block>{
    <return>return <expr><name>lparser</name> <operator>==</operator> <literal type="null">null</literal> <operator>?</operator> <operator>new</operator> <name><name>String</name><index>[]</index></name><block>{}</block> <operator>:</operator> <operator>new</operator> <name><name>String</name><index>[]</index></name><block>{<expr><call><name><name>lparser</name><operator>.</operator><name>getField</name></name><argument_list>()</argument_list></call></expr>}</block></expr>;</return></block></expr>
    <return>return <expr><ternary><condition><expr><name>lparser</name> <operator>==</operator> <literal type="null">null</literal></expr> ?</condition><then> <expr><operator>new</operator> <name><name>String</name><index>[]</index></name><block>{}</block></expr> </then><else>: <expr><operator>new</operator> <name><name>String</name><index>[]</index></name><block>{<expr><call><name><name>lparser</name><operator>.</operator><name>getDefaultField</name></name><argument_list>()</argument_list></call></expr>}</block></expr></else></ternary></expr>;</return></block></expr></expr_stmt></block_content></block></function></block_content></block></function></block></class></expr></return></block></expr>
   }</block></expr></expr_stmt>
   
 </block_content>}</block></function>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">89</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">88</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@ <name>class</name> <name>OldLuceneQParser</name> extends <name>LuceneQParser</name> <block>{
   }</block>
 
   @<name>Override</name>
  <specifier>public</specifier> <name>Query</name> <call><name>parse</name><argument_list>()</argument_list></call> <throws>throws <argument><expr><name>ParseException</name> <block>{
  <expr><specifier>public</specifier> <name>Query</name> <call><name>parse</name><argument_list>()</argument_list></call></expr></block></expr></argument></throws> <throws>throws <argument><expr><name>SyntaxError</name> <block>{</block></expr></argument></throws></expr></expr_stmt>
     <comment type="line">// handle legacy "query;sort" syntax</comment>
     <if_stmt><if>if <condition>(<expr><call><name>getLocalParams</name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
       <decl_stmt><decl><type><name>String</name></type> <name>qstr</name> <init>= <expr><call><name>getString</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">107</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">106</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@ <name>class</name> <name>OldLuceneQParser</name> extends <name>LuceneQParser</name> <block>{
           <expr><name>qstr</name> <operator>=</operator> <call><name><name>commands</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;
         }</block></expr></expr_stmt>
         <if_stmt><if type="elseif">else if <condition>(<expr><call><name><name>commands</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&gt;</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
          <throw>throw <expr><operator>new</operator> <call><name>ParseException</name><argument_list>(<argument><expr><literal type="string">"If you want to use multiple ';' in the query, use the 'sort' param."</literal></expr></argument>)</argument_list></call></expr>;</throw>
          <throw>throw <expr><operator>new</operator> <call><name>SyntaxError</name><argument_list>(<argument><expr><literal type="string">"If you want to use multiple ';' in the query, use the 'sort' param."</literal></expr></argument>)</argument_list></call></expr>;</throw>
         </block_content>}</block></if></if_stmt>
       </block_content>}</block></if></if_stmt>
       <expr_stmt><expr><call><name>setString</name><argument_list>(<argument><expr><name>qstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">117</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">116</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@ <name>class</name> <name>OldLuceneQParser</name> extends <name>LuceneQParser</name> <block>{
   }</block>
 
   @<name>Override</name>
  <specifier>public</specifier> <name>SortSpec</name> <call><name>getSort</name><argument_list>(<argument><expr><name>boolean</name> <name>useGlobal</name></expr></argument>)</argument_list></call> <throws>throws <argument><expr><name>ParseException</name> <block>{
  <expr><specifier>public</specifier> <name>SortSpec</name> <call><name>getSort</name><argument_list>(<argument><expr><name>boolean</name> <name>useGlobal</name></expr></argument>)</argument_list></call></expr></block></expr></argument></throws> <throws>throws <argument><expr><name>SyntaxError</name> <block>{
     <expr><name>SortSpec</name> <name>sort</name> <operator>=</operator> <call><name><name>super</name><operator>.</operator><name>getSort</name></name><argument_list>(<argument><expr><name>useGlobal</name></expr></argument>)</argument_list></call></expr></block></expr></argument></throws></expr>;</expr_stmt>
     <if_stmt><if>if <condition>(<expr><name>sortStr</name> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <call><name><name>sortStr</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name><name>sort</name><operator>.</operator><name>getSort</name></name><argument_list>()</argument_list></call><operator>==</operator><literal type="null">null</literal></expr>)</condition> <block>{<block_content>
       <decl_stmt><decl><type><name>Sort</name></type> <name>oldSort</name> <init>= <expr><call><name><name>QueryParsing</name><operator>.</operator><name>parseSort</name></name><argument_list>(<argument><expr><name>sortStr</name></expr></argument>, <argument><expr><call><name>getReq</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>diff</name> <operator>--</operator><name>git</name> <name>a</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>search</name><operator>/</operator><name><name>NestedQParserPlugin</name><operator>.</operator><name>java</name></name> <name>b</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>search</name><operator>/</operator><name><name>NestedQParserPlugin</name><operator>.</operator><name>java</name></name>
<name>index</name> <name>d7fdff81c6d</name><operator>..</operator><name>c53dfadc935</name> <literal type="number">100755</literal>
<operator>--</operator> <name>a</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>search</name><operator>/</operator><name><name>NestedQParserPlugin</name><operator>.</operator><name>java</name></name>
<operator>++</operator> <name>b</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>search</name><operator>/</operator><name><name>NestedQParserPlugin</name><operator>.</operator><name>java</name></name>
@@ <operator>-</operator><literal type="number">17</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">17</literal></expr><operator>,</operator><expr><literal type="number">6</literal> @@</expr></expr_stmt>
 <package>package <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>search</name></name>;</package>
 
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>queries</name><operator>.</operator><name>function</name><operator>.</operator><name>ValueSource</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>queryparser</name><operator>.</operator><name>classic</name><operator>.</operator><name>ParseException</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>search</name><operator>.</operator><name>Query</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>common</name><operator>.</operator><name>params</name><operator>.</operator><name>SolrParams</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>common</name><operator>.</operator><name>util</name><operator>.</operator><name>NamedList</name></name>;</import>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">46</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">45</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@ <specifier>public</specifier> <name>class</name> <name>NestedQParserPlugin</name> extends <name>QParserPlugin</name> <block>{
       <expr><name>String</name> <name>b</name></expr>;
 
       @<name>Override</name>
      <specifier>public</specifier> <name>Query</name> <call><name>parse</name><argument_list>()</argument_list></call> <throws>throws <argument><expr><name>ParseException</name> <block>{
      <expr><specifier>public</specifier> <name>Query</name> <call><name>parse</name><argument_list>()</argument_list></call></expr></block></expr></argument></throws> <throws>throws <argument><expr><name>SyntaxError</name> <block>{
         <expr><name>baseParser</name> <operator>=</operator> <call><name>subQuery</name><argument_list>(<argument><expr><call><name><name>localParams</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name><name>QueryParsing</name><operator>.</operator><name>V</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="null">null</literal></expr></argument>)</argument_list></call></expr></block></expr></argument></throws></block></expr>;</expr_stmt>
         <return>return <expr><call><name><name>baseParser</name><operator>.</operator><name>getQuery</name></name><argument_list>()</argument_list></call></expr>;</return>
       </block_content>}</block></if></if_stmt>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">57</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">56</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@ <specifier>public</specifier> <name>class</name> <name>NestedQParserPlugin</name> extends <name>QParserPlugin</name> <block>{
       }</block>
 
       @<name>Override</name>
      <specifier>public</specifier> <name>Query</name> <call><name>getHighlightQuery</name><argument_list>()</argument_list></call> <throws>throws <argument><expr><name>ParseException</name> <block>{
      <expr><specifier>public</specifier> <name>Query</name> <call><name>getHighlightQuery</name><argument_list>()</argument_list></call></expr></block></expr></argument></throws> <throws>throws <argument><expr><name>SyntaxError</name> <block>{</block></expr></argument></throws></expr></expr_stmt>
         <return>return <expr><call><name><name>baseParser</name><operator>.</operator><name>getHighlightQuery</name></name><argument_list>()</argument_list></call></expr>;</return>
       </block_content>}</block></function>
 
<expr_stmt><expr><name>diff</name> <operator>--</operator><name>git</name> <name>a</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>search</name><operator>/</operator><name><name>QParser</name><operator>.</operator><name>java</name></name> <name>b</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>search</name><operator>/</operator><name><name>QParser</name><operator>.</operator><name>java</name></name>
<name>index</name> <literal type="number">71f375a0f4e</literal><operator>..</operator><literal type="number">16db2d36b5f</literal> <literal type="number">100755</literal>
<operator>--</operator> <name>a</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>search</name><operator>/</operator><name><name>QParser</name><operator>.</operator><name>java</name></name>
<operator>++</operator> <name>b</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>search</name><operator>/</operator><name><name>QParser</name><operator>.</operator><name>java</name></name>
@@ <operator>-</operator><literal type="number">16</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">16</literal></expr><operator>,</operator><expr><literal type="number">6</literal> @@
  <operator>*</operator><operator>/</operator></expr></expr_stmt>
 <package>package <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>search</name></name>;</package>
 
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>queryparser</name><operator>.</operator><name>classic</name><operator>.</operator><name>ParseException</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>search</name><operator>.</operator><name>Query</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>search</name><operator>.</operator><name>ScoreDoc</name></name>;</import> <comment type="line">//Issue 1726</comment>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>search</name><operator>.</operator><name>Sort</name></name>;</import>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">100</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">99</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@ <specifier>public</specifier> <specifier>abstract</specifier> <name>class</name> <name>QParser</name> <block>{
    <expr><operator>*</operator> <name>there</name> <name>was</name> <name>no</name> <call><name>input</name> <argument_list>(<argument><expr><name><name>e</name><operator>.</operator><name>g</name><operator>.</operator> <name>no</name></name> <name>query</name> <name>string</name></expr></argument>)</argument_list></call> <name>to</name> <name><name>parse</name><operator>.</operator></name>
    * @<name>see</name> <operator>#</operator><call><name>getQuery</name><argument_list>()</argument_list></call>
    <operator>*</operator><operator>*</operator><operator>/</operator>
  <specifier>public</specifier> <specifier>abstract</specifier> <name>Query</name> <call><name>parse</name><argument_list>()</argument_list></call> <throws>throws <argument><expr><name>ParseException</name></expr></argument></throws></expr>;
  <specifier>public</specifier> <specifier>abstract</specifier> <name>Query</name> <call><name>parse</name><argument_list>()</argument_list></call> <throws>throws <argument><expr><name>SyntaxError</name></expr></argument></throws></block></expr>;</expr_stmt>
 
   <function><type><specifier>public</specifier> <name>SolrParams</name></type> <name>getLocalParams</name><parameter_list>()</parameter_list> <block>{<block_content>
     <return>return <expr><name>localParams</name></expr>;</return>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">138</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">137</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@ <specifier>public</specifier> <specifier>abstract</specifier> <name>class</name> <name>QParser</name> <block>{
    <expr><operator>*</operator> <name>Returns</name> <name>the</name> <name>resulting</name> <name>query</name> <name>from</name> <name>this</name> <name>QParser</name></expr>, <expr><name>calling</name> <call><name>parse</name><argument_list>()</argument_list></call> <name>only</name> <name>the</name>
    <operator>*</operator> <name>first</name> <name>time</name> <name>and</name> <name>caching</name> <name>the</name> <name>Query</name> <name><name>result</name><operator>.</operator></name>
    *<operator>/</operator>
  <specifier>public</specifier> <name>Query</name> <call><name>getQuery</name><argument_list>()</argument_list></call> <throws>throws <argument><expr><name>ParseException</name> <block>{
  <expr><specifier>public</specifier> <name>Query</name> <call><name>getQuery</name><argument_list>()</argument_list></call></expr></block></expr></argument></throws> <throws>throws <argument><expr><name>SyntaxError</name> <block>{</block></expr></argument></throws></expr>
     <if_stmt><if>if <condition>(<expr><name>query</name><operator>==</operator><literal type="null">null</literal></expr>)</condition> <block>{<block_content>
       <expr_stmt><expr><name>query</name><operator>=</operator><call><name>parse</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
 
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">174</literal></expr><operator>,</operator><expr><literal type="number">9</literal> <operator>+</operator><literal type="number">173</literal></expr><operator>,</operator><expr><literal type="number">9</literal> @@ <specifier>public</specifier> <specifier>abstract</specifier> <name>class</name> <name>QParser</name> <block>{
     }</block></expr></expr_stmt>
   </block_content>}</block></if></if_stmt>
 
  <specifier>private</specifier> <name>void</name> <call><name>checkRecurse</name><argument_list>()</argument_list></call> <throws>throws <argument><expr><name>ParseException</name> <block>{
  <expr><specifier>private</specifier> <name>void</name> <call><name>checkRecurse</name><argument_list>()</argument_list></call></expr></block></expr></argument></throws> <throws>throws <argument><expr><name>SyntaxError</name> <block>{</block></expr></argument></throws></block></expr></expr_stmt>
     <if_stmt><if>if <condition>(<expr><name>recurseCount</name><operator>++</operator> <operator>&gt;=</operator> <literal type="number">100</literal></expr>)</condition> <block>{<block_content>
      <throw>throw <expr><operator>new</operator> <call><name>ParseException</name><argument_list>(<argument><expr><literal type="string">"Infinite Recursion detected parsing query '"</literal> <operator>+</operator> <name>qstr</name> <operator>+</operator> <literal type="string">"'"</literal></expr></argument>)</argument_list></call></expr>;</throw>
      <throw>throw <expr><operator>new</operator> <call><name>SyntaxError</name><argument_list>(<argument><expr><literal type="string">"Infinite Recursion detected parsing query '"</literal> <operator>+</operator> <name>qstr</name> <operator>+</operator> <literal type="string">"'"</literal></expr></argument>)</argument_list></call></expr>;</throw>
     </block_content>}</block></if></if_stmt>
   </block_content>}</block></function>
 
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">197</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">196</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@ <specifier>public</specifier> <specifier>abstract</specifier> <name>class</name> <name>QParser</name> <block>{
   }</block>
 
   <comment type="block" format="javadoc">/** Create a new QParser for parsing an embedded sub-query */</comment>
  <specifier>public</specifier> <name>QParser</name> <call><name>subQuery</name><argument_list>(<argument><expr><name>String</name> <name>q</name></expr></argument>, <argument><expr><name>String</name> <name>defaultType</name></expr></argument>)</argument_list></call> <throws>throws <argument><expr><name>ParseException</name> <block>{
  <expr><specifier>public</specifier> <name>QParser</name> <call><name>subQuery</name><argument_list>(<argument><expr><name>String</name> <name>q</name></expr></argument>, <argument><expr><name>String</name> <name>defaultType</name></expr></argument>)</argument_list></call></expr></block></expr></argument></throws> <throws>throws <argument><expr><name>SyntaxError</name> <block>{
     <expr><call><name>checkRecurse</name><argument_list>()</argument_list></call></expr></block></expr></argument></throws></expr>;</expr_stmt>
     <if_stmt><if>if <condition>(<expr><name>defaultType</name> <operator>==</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <name>localParams</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
       <comment type="line">// if not passed, try and get the defaultType from local params</comment>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">213</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">212</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@ <specifier>public</specifier> <specifier>abstract</specifier> <name>class</name> <name>QParser</name> <block>{
    <expr><operator>*</operator> <name>use</name> <name>common</name> <name>params</name> <name>to</name> <name>look</name> <name>up</name> <name>pageScore</name> <name>and</name> <name>pageDoc</name> <name>in</name> <name>global</name> <name>params</name>
    <operator>*</operator> @</expr><return>return <expr><name>the</name> <name>ScoreDoc</name>
    <operator>*</operator><operator>/</operator>
  <specifier>public</specifier> <name>ScoreDoc</name> <call><name>getPaging</name><argument_list>()</argument_list></call> <throws>throws <argument><expr><name>ParseException</name>
  <specifier>public</specifier> <name>ScoreDoc</name> <call><name>getPaging</name><argument_list>()</argument_list></call></expr></argument></throws> <throws>throws <argument><expr><name>SyntaxError</name>
   <block>{</block></expr></argument></throws></expr></return>
     <return>return <expr><literal type="null">null</literal></expr>;</return>
 
@@ <operator>-</operator><literal type="number">244</literal><operator>,</operator><literal type="number">7</literal> <operator>+</operator><literal type="number">243</literal><operator>,</operator><literal type="number">7</literal> @@ <specifier>public</specifier> <specifier>abstract</specifier> <name>class</name> <name>QParser</name> <block>{
    <expr><operator>*</operator> @<name>param</name> <name>useGlobalParams</name> <name>look</name> <name>up</name> <name>sort</name></expr>, <expr><name>start</name></expr>, <expr><name>rows</name> <name>in</name> <name>global</name> <name>params</name></expr> <if_stmt><if>if not in local params
    * @return the sort specification
    */
  public SortSpec getSort<condition>(<expr><name>boolean</name> <name>useGlobalParams</name></expr>)</condition><block type="pseudo"><block_content> <throws>throws <argument><expr><name>ParseException</name> <block>{
  <expr><specifier>public</specifier> <name>SortSpec</name> <call><name>getSort</name><argument_list>(<argument><expr><name>boolean</name> <name>useGlobalParams</name></expr></argument>)</argument_list></call></expr></block></expr></argument></throws> <throws>throws <argument><expr><name>SyntaxError</name> <block>{
     <expr><call><name>getQuery</name><argument_list>()</argument_list></call></expr></block></expr></argument></throws><empty_stmt>;</empty_stmt></block_content></block></if></if_stmt> <comment type="line">// ensure query is parsed first</comment>
 
     <name>String</name> <name>sortStr</name> <operator>=</operator> <literal type="null">null</literal></block></block></expr>;</expr_stmt>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">288</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">287</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@ <specifier>public</specifier> <specifier>abstract</specifier> <name>class</name> <name>QParser</name> <block>{
     <return>return <expr><operator>new</operator> <name><name>String</name><index>[]</index></name><block>{}</block></expr>;</return>
   }</block></expr></expr_stmt>
 
  <function><type><specifier>public</specifier> <name>Query</name></type> <name>getHighlightQuery</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>ParseException</name></expr></argument></throws> <block>{<block_content>
  <function><type><specifier>public</specifier> <name>Query</name></type> <name>getHighlightQuery</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>SyntaxError</name></expr></argument></throws> <block>{<block_content>
     <decl_stmt><decl><type><name>Query</name></type> <name>query</name> <init>= <expr><call><name>getQuery</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
     <return>return <expr><ternary><condition><expr><name>query</name> <operator>instanceof</operator> <name>WrappedQuery</name></expr> ?</condition><then> <expr><operator>(</operator><operator>(</operator><name>WrappedQuery</name><operator>)</operator><name>query</name><operator>)</operator><operator>.</operator><call><name>getWrappedQuery</name><argument_list>()</argument_list></call></expr> </then><else>: <expr><name>query</name></expr></else></ternary></expr>;</return>
   </block_content>}</block></function>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">306</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">305</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@ <specifier>public</specifier> <specifier>abstract</specifier> <name>class</name> <name>QParser</name> <block>{
    <expr><operator>*</operator></expr> <if_stmt><if>if qstr=&lt;code&gt;<block>{<block_content><expr><operator>!</operator><name>prefix</name> <name>f</name><operator>=</operator><name>myfield</name></expr></block_content>}</block></if></if_stmt><name><name>foo</name><argument_list type="generic">&lt;<argument><operator>/</operator><name>code</name></argument>&gt;</argument_list></name>
    <operator>*</operator> <name>then</name> <name>the</name> <name>prefix</name> <name>query</name> <name>parser</name> <name>will</name> <name>be</name> <name><name>used</name><operator>.</operator></name>
    *<operator>/</operator>
  <specifier>public</specifier> <specifier>static</specifier> <name>QParser</name> <call><name>getParser</name><argument_list>(<argument><expr><name>String</name> <name>qstr</name></expr></argument>, <argument><expr><name>String</name> <name>defaultParser</name></expr></argument>, <argument><expr><name>SolrQueryRequest</name> <name>req</name></expr></argument>)</argument_list></call> <throws>throws <argument><expr><name>ParseException</name> <block>{
  <expr><specifier>public</specifier> <specifier>static</specifier> <name>QParser</name> <call><name>getParser</name><argument_list>(<argument><expr><name>String</name> <name>qstr</name></expr></argument>, <argument><expr><name>String</name> <name>defaultParser</name></expr></argument>, <argument><expr><name>SolrQueryRequest</name> <name>req</name></expr></argument>)</argument_list></call></expr></block></expr></argument></throws> <throws>throws <argument><expr><name>SyntaxError</name> <block>{
     <comment type="line">// SolrParams localParams = QueryParsing.getLocalParams(qstr, req.getParams());</comment>
 
     <expr><name>String</name> <name>stringIncludingLocalParams</name> <operator>=</operator> <name>qstr</name></expr></block></expr></argument></throws></block></expr>;</expr_stmt>
<expr_stmt><expr><name>diff</name> <operator>--</operator><name>git</name> <name>a</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>search</name><operator>/</operator><name><name>QueryParsing</name><operator>.</operator><name>java</name></name> <name>b</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>search</name><operator>/</operator><name><name>QueryParsing</name><operator>.</operator><name>java</name></name>
<name>index</name> <name>a465b3aaabb</name><operator>..</operator><name>cb6c930e5fb</name> <literal type="number">100644</literal>
<operator>--</operator> <name>a</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>search</name><operator>/</operator><name><name>QueryParsing</name><operator>.</operator><name>java</name></name>
<operator>++</operator> <name>b</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>search</name><operator>/</operator><name><name>QueryParsing</name><operator>.</operator><name>java</name></name>
@@ <operator>-</operator><literal type="number">20</literal></expr><operator>,</operator><expr><literal type="number">8</literal> <operator>+</operator><literal type="number">20</literal></expr><operator>,</operator><expr><literal type="number">6</literal> @@</expr></expr_stmt> <package>package <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>search</name></name>;</package>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>index</name><operator>.</operator><name>Term</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>queries</name><operator>.</operator><name>function</name><operator>.</operator><name>FunctionQuery</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>queries</name><operator>.</operator><name>function</name><operator>.</operator><name>valuesource</name><operator>.</operator><name>QueryValueSource</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>queryparser</name><operator>.</operator><name>classic</name><operator>.</operator><name>ParseException</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>queryparser</name><operator>.</operator><name>classic</name><operator>.</operator><name>QueryParser</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>search</name><operator>.</operator><name>BooleanClause</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>search</name><operator>.</operator><name>BooleanQuery</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>search</name><operator>.</operator><name>ConstantScoreQuery</name></name>;</import>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">39</literal></expr><operator>,</operator><expr><literal type="number">6</literal> <operator>+</operator><literal type="number">37</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@</expr></expr_stmt> <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>util</name><operator>.</operator><name>CharsRef</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>common</name><operator>.</operator><name>SolrException</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>common</name><operator>.</operator><name>params</name><operator>.</operator><name>MapSolrParams</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>common</name><operator>.</operator><name>params</name><operator>.</operator><name>SolrParams</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>parser</name><operator>.</operator><name>QueryParser</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>request</name><operator>.</operator><name>SolrQueryRequest</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>schema</name><operator>.</operator><name>FieldType</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>schema</name><operator>.</operator><name>IndexSchema</name></name>;</import>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">95</literal></expr><operator>,</operator><expr><literal type="number">12</literal> <operator>+</operator><literal type="number">94</literal></expr><operator>,</operator><expr><literal type="number">12</literal> @@ <specifier>public</specifier> <name>class</name> <name>QueryParsing</name> <block>{
   }</block>
 
   <comment type="line">// note to self: something needs to detect infinite recursion when parsing queries</comment>
  <specifier>public</specifier> <specifier>static</specifier> <name>int</name> <call><name>parseLocalParams</name><argument_list>(<argument><expr><name>String</name> <name>txt</name></expr></argument>, <argument><expr><name>int</name> <name>start</name></expr></argument>, <argument><expr><name><name>Map</name><argument_list type="generic">&lt;<argument><name>String</name></argument>, <argument><name>String</name></argument>&gt;</argument_list></name> <name>target</name></expr></argument>, <argument><expr><name>SolrParams</name> <name>params</name></expr></argument>)</argument_list></call> <throws>throws <argument><expr><name>ParseException</name> <block>{
  <expr><specifier>public</specifier> <specifier>static</specifier> <name>int</name> <call><name>parseLocalParams</name><argument_list>(<argument><expr><name>String</name> <name>txt</name></expr></argument>, <argument><expr><name>int</name> <name>start</name></expr></argument>, <argument><expr><name><name>Map</name><argument_list type="generic">&lt;<argument><name>String</name></argument>, <argument><name>String</name></argument>&gt;</argument_list></name> <name>target</name></expr></argument>, <argument><expr><name>SolrParams</name> <name>params</name></expr></argument>)</argument_list></call></expr></block></expr></argument></throws> <throws>throws <argument><expr><name>SyntaxError</name> <block>{</block></expr></argument></throws></expr></expr_stmt>
     <return>return <expr><call><name>parseLocalParams</name><argument_list>(<argument><expr><name>txt</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>target</name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>LOCALPARAM_START</name></expr></argument>, <argument><expr><name>LOCALPARAM_END</name></expr></argument>)</argument_list></call></expr>;</return>
   </block_content>}</block></function>
 
 
  <function><type><specifier>public</specifier> <specifier>static</specifier> <name>int</name></type> <name>parseLocalParams</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>txt</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>start</name></decl></parameter>, <parameter><decl><type><name><name>Map</name><argument_list type="generic">&lt;<argument><name>String</name></argument>, <argument><name>String</name></argument>&gt;</argument_list></name></type> <name>target</name></decl></parameter>, <parameter><decl><type><name>SolrParams</name></type> <name>params</name></decl></parameter>, <parameter><decl><type><name>String</name></type> <name>startString</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>endChar</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>ParseException</name></expr></argument></throws> <block>{<block_content>
  <function><type><specifier>public</specifier> <specifier>static</specifier> <name>int</name></type> <name>parseLocalParams</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>txt</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>start</name></decl></parameter>, <parameter><decl><type><name><name>Map</name><argument_list type="generic">&lt;<argument><name>String</name></argument>, <argument><name>String</name></argument>&gt;</argument_list></name></type> <name>target</name></decl></parameter>, <parameter><decl><type><name>SolrParams</name></type> <name>params</name></decl></parameter>, <parameter><decl><type><name>String</name></type> <name>startString</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>endChar</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>SyntaxError</name></expr></argument></throws> <block>{<block_content>
     <decl_stmt><decl><type><name>int</name></type> <name>off</name> <init>= <expr><name>start</name></expr></init></decl>;</decl_stmt>
     <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>txt</name><operator>.</operator><name>startsWith</name></name><argument_list>(<argument><expr><name>startString</name></expr></argument>, <argument><expr><name>off</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>start</name></expr>;</return></block_content></block></if></if_stmt>
     <decl_stmt><decl><type><name>StrParser</name></type> <name>p</name> <init>= <expr><operator>new</operator> <call><name>StrParser</name><argument_list>(<argument><expr><name>txt</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><call><name><name>txt</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">109</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">108</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@ <specifier>public</specifier> <name>class</name> <name>QueryParsing</name> <block>{
     <for>for <control>(<init>;</init> <condition>;</condition><incr/>)</control> <block>{<block_content>
       <comment type="block">/*
       if (p.pos&gt;=txt.length()) {
        throw new ParseException("Missing '}' parsing local params '" + txt + '"');
        throw new SyntaxError("Missing '}' parsing local params '" + txt + '"');
       }
       */</comment>
       <decl_stmt><decl><type><name>char</name></type> <name>ch</name> <init>= <expr><call><name><name>p</name><operator>.</operator><name>peek</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">119</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">118</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@ <specifier>public</specifier> <name>class</name> <name>QueryParsing</name> <block>{
 
       <expr><name>String</name> <name>id</name> <operator>=</operator> <call><name><name>p</name><operator>.</operator><name>getId</name></name><argument_list>()</argument_list></call></expr>;</block></expr></expr_stmt>
       <if_stmt><if>if <condition>(<expr><call><name><name>id</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <throw>throw <expr><operator>new</operator> <call><name>ParseException</name><argument_list>(<argument><expr><literal type="string">"Expected ending character '"</literal> <operator>+</operator> <name>endChar</name> <operator>+</operator> <literal type="string">"' parsing local params '"</literal> <operator>+</operator> <name>txt</name> <operator>+</operator> <literal type="char">'"'</literal></expr></argument>)</argument_list></call></expr>;</throw>
        <throw>throw <expr><operator>new</operator> <call><name>SyntaxError</name><argument_list>(<argument><expr><literal type="string">"Expected ending character '"</literal> <operator>+</operator> <name>endChar</name> <operator>+</operator> <literal type="string">"' parsing local params '"</literal> <operator>+</operator> <name>txt</name> <operator>+</operator> <literal type="char">'"'</literal></expr></argument>)</argument_list></call></expr>;</throw>
 
       </block_content>}</block></if></if_stmt>
       <decl_stmt><decl><type><name>String</name></type> <name>val</name> <init>= <expr><literal type="null">null</literal></expr></init></decl>;</decl_stmt>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">148</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">147</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@ <specifier>public</specifier> <name>class</name> <name>QueryParsing</name> <block>{
           <expr><name>int</name> <name>valStart</name> <operator>=</operator> <name><name>p</name><operator>.</operator><name>pos</name></name></expr>;</block></expr></expr_stmt>
           <for>for <control>(<init>;</init> <condition>;</condition><incr/>)</control> <block>{<block_content>
             <if_stmt><if>if <condition>(<expr><name><name>p</name><operator>.</operator><name>pos</name></name> <operator>&gt;=</operator> <name><name>p</name><operator>.</operator><name>end</name></name></expr>)</condition> <block>{<block_content>
              <throw>throw <expr><operator>new</operator> <call><name>ParseException</name><argument_list>(<argument><expr><literal type="string">"Missing end to unquoted value starting at "</literal> <operator>+</operator> <name>valStart</name> <operator>+</operator> <literal type="string">" str='"</literal> <operator>+</operator> <name>txt</name> <operator>+</operator> <literal type="string">"'"</literal></expr></argument>)</argument_list></call></expr>;</throw>
              <throw>throw <expr><operator>new</operator> <call><name>SyntaxError</name><argument_list>(<argument><expr><literal type="string">"Missing end to unquoted value starting at "</literal> <operator>+</operator> <name>valStart</name> <operator>+</operator> <literal type="string">" str='"</literal> <operator>+</operator> <name>txt</name> <operator>+</operator> <literal type="string">"'"</literal></expr></argument>)</argument_list></call></expr>;</throw>
             </block_content>}</block></if></if_stmt>
             <decl_stmt><decl><type><name>char</name></type> <name>c</name> <init>= <expr><call><name><name>p</name><operator>.</operator><name>val</name><operator>.</operator><name>charAt</name></name><argument_list>(<argument><expr><name><name>p</name><operator>.</operator><name>pos</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
             <if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>endChar</name> <operator>||</operator> <call><name><name>Character</name><operator>.</operator><name>isWhitespace</name></name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">202</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">201</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@ <specifier>public</specifier> <name>class</name> <name>QueryParsing</name> <block>{
    <expr><operator>*</operator> <literal type="string">"{!prefix f=myfield}yes"</literal> <name>returns</name> <name>type</name><operator>=</operator><literal type="string">"prefix"</literal></expr>,<expr><name>f</name><operator>=</operator><literal type="string">"myfield"</literal></expr>,<expr><name>v</name><operator>=</operator><literal type="string">"yes"</literal>
    <operator>*</operator> <literal type="string">"{!prefix f=myfield v=$p}"</literal> <name>returns</name> <name>type</name><operator>=</operator><literal type="string">"prefix"</literal></expr>,<expr><name>f</name><operator>=</operator><literal type="string">"myfield"</literal></expr>,<expr><name>v</name><operator>=</operator><call><name><name>params</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="string">"p"</literal></expr></argument>)</argument_list></call>
    <operator>*</operator><operator>/</operator>
  <specifier>public</specifier> <specifier>static</specifier> <name>SolrParams</name> <call><name>getLocalParams</name><argument_list>(<argument><expr><name>String</name> <name>txt</name></expr></argument>, <argument><expr><name>SolrParams</name> <name>params</name></expr></argument>)</argument_list></call> <throws>throws <argument><expr><name>ParseException</name> <block>{
  <expr><specifier>public</specifier> <specifier>static</specifier> <name>SolrParams</name> <call><name>getLocalParams</name><argument_list>(<argument><expr><name>String</name> <name>txt</name></expr></argument>, <argument><expr><name>SolrParams</name> <name>params</name></expr></argument>)</argument_list></call></expr></block></expr></argument></throws> <throws>throws <argument><expr><name>SyntaxError</name> <block>{</block></expr></argument></throws></expr>
     <if_stmt><if>if <condition>(<expr><name>txt</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <operator>!</operator><call><name><name>txt</name><operator>.</operator><name>startsWith</name></name><argument_list>(<argument><expr><name>LOCALPARAM_START</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
       <return>return <expr><literal type="null">null</literal></expr>;</return>
     </block_content>}</block></if></if_stmt>
@@ <operator>-</operator><literal type="number">352</literal><operator>,</operator><literal type="number">7</literal> <operator>+</operator><literal type="number">351</literal><operator>,</operator><literal type="number">7</literal> @@ <specifier>public</specifier> <name>class</name> <name>QueryParsing</name> <block>{
         }</block></block></expr></expr_stmt>
       </block_content>}</block></if></if_stmt>
 
    </block_content>}</block></for> <catch>catch <parameter_list>(<parameter><decl><type><name>ParseException</name></type> <name>e</name></decl></parameter>)</parameter_list> <block>{<block_content>
    </block_content>}</block></catch> <catch>catch <parameter_list>(<parameter><decl><type><name>SyntaxError</name></type> <name>e</name></decl></parameter>)</parameter_list> <block>{<block_content>
       <throw>throw <expr><operator>new</operator> <call><name>SolrException</name><argument_list>(<argument><expr><name><name>SolrException</name><operator>.</operator><name>ErrorCode</name><operator>.</operator><name>BAD_REQUEST</name></name></expr></argument>, <argument><expr><literal type="string">"error in sort: "</literal> <operator>+</operator> <name>sortSpec</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</throw>
     </block_content>}</block></catch>
 
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">628</literal></expr><operator>,</operator><expr><literal type="number">13</literal> <operator>+</operator><literal type="number">627</literal></expr><operator>,</operator><expr><literal type="number">13</literal> @@ <specifier>public</specifier> <name>class</name> <name>QueryParsing</name> <block>{
     }</block>
 
 
    <name>void</name> <call><name>expect</name><argument_list>(<argument><expr><name>String</name> <name>s</name></expr></argument>)</argument_list></call> <throws>throws <argument><expr><name>ParseException</name> <block>{
    <expr><name>void</name> <call><name>expect</name><argument_list>(<argument><expr><name>String</name> <name>s</name></expr></argument>)</argument_list></call></expr></block></expr></argument></throws> <throws>throws <argument><expr><name>SyntaxError</name> <block>{
       <expr><call><name>eatws</name><argument_list>()</argument_list></call></expr></block></expr></argument></throws></expr>;</expr_stmt>
       <decl_stmt><decl><type><name>int</name></type> <name>slen</name> <init>= <expr><call><name><name>s</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
       <if_stmt><if>if <condition>(<expr><call><name><name>val</name><operator>.</operator><name>regionMatches</name></name><argument_list>(<argument><expr><name>pos</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>slen</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
         <expr_stmt><expr><name>pos</name> <operator>+=</operator> <name>slen</name></expr>;</expr_stmt>
       </block_content>}</block></if> <else>else <block>{<block_content>
        <throw>throw <expr><operator>new</operator> <call><name>ParseException</name><argument_list>(<argument><expr><literal type="string">"Expected '"</literal> <operator>+</operator> <name>s</name> <operator>+</operator> <literal type="string">"' at position "</literal> <operator>+</operator> <name>pos</name> <operator>+</operator> <literal type="string">" in '"</literal> <operator>+</operator> <name>val</name> <operator>+</operator> <literal type="string">"'"</literal></expr></argument>)</argument_list></call></expr>;</throw>
        <throw>throw <expr><operator>new</operator> <call><name>SyntaxError</name><argument_list>(<argument><expr><literal type="string">"Expected '"</literal> <operator>+</operator> <name>s</name> <operator>+</operator> <literal type="string">"' at position "</literal> <operator>+</operator> <name>pos</name> <operator>+</operator> <literal type="string">" in '"</literal> <operator>+</operator> <name>val</name> <operator>+</operator> <literal type="string">"'"</literal></expr></argument>)</argument_list></call></expr>;</throw>
       </block_content>}</block></else></if_stmt>
     </block_content>}</block></for>
 
@@ <operator>-</operator><literal type="number">723</literal><operator>,</operator><literal type="number">11</literal> <operator>+</operator><literal type="number">722</literal><operator>,</operator><literal type="number">11</literal> @@ <specifier>public</specifier> <name>class</name> <name>QueryParsing</name> <block>{
     }</block></block>
 
 
    <name>String</name> <call><name>getId</name><argument_list>()</argument_list></call> <throws>throws <argument><expr><name>ParseException</name> <block>{
    <expr><name>String</name> <call><name>getId</name><argument_list>()</argument_list></call></expr></block></expr></argument></throws> <throws>throws <argument><expr><name>SyntaxError</name> <block>{</block></expr></argument></throws></expr></expr_stmt>
       <return>return <expr><call><name>getId</name><argument_list>(<argument><expr><literal type="string">"Expected identifier"</literal></expr></argument>)</argument_list></call></expr>;</return>
     </block_content>}</block></function>
 
    <function><type><name>String</name></type> <name>getId</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>errMessage</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>ParseException</name></expr></argument></throws> <block>{<block_content>
    <function><type><name>String</name></type> <name>getId</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>errMessage</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>SyntaxError</name></expr></argument></throws> <block>{<block_content>
       <expr_stmt><expr><call><name>eatws</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
       <decl_stmt><decl><type><name>int</name></type> <name>id_start</name> <init>= <expr><name>pos</name></expr></init></decl>;</decl_stmt>
       <decl_stmt><decl><type><name>char</name></type> <name>ch</name></decl>;</decl_stmt>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">745</literal></expr><operator>,</operator><expr><literal type="number">12</literal> <operator>+</operator><literal type="number">744</literal></expr><operator>,</operator><expr><literal type="number">12</literal> @@ <specifier>public</specifier> <name>class</name> <name>QueryParsing</name> <block>{
       }</block></expr></expr_stmt>
 
       <if_stmt><if>if <condition>(<expr><name>errMessage</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
        <throw>throw <expr><operator>new</operator> <call><name>ParseException</name><argument_list>(<argument><expr><name>errMessage</name> <operator>+</operator> <literal type="string">" at pos "</literal> <operator>+</operator> <name>pos</name> <operator>+</operator> <literal type="string">" str='"</literal> <operator>+</operator> <name>val</name> <operator>+</operator> <literal type="string">"'"</literal></expr></argument>)</argument_list></call></expr>;</throw>
        <throw>throw <expr><operator>new</operator> <call><name>SyntaxError</name><argument_list>(<argument><expr><name>errMessage</name> <operator>+</operator> <literal type="string">" at pos "</literal> <operator>+</operator> <name>pos</name> <operator>+</operator> <literal type="string">" str='"</literal> <operator>+</operator> <name>val</name> <operator>+</operator> <literal type="string">"'"</literal></expr></argument>)</argument_list></call></expr>;</throw>
       </block_content>}</block></if></if_stmt>
       <return>return <expr><literal type="null">null</literal></expr>;</return>
     </block_content>}</block></function>
 
    <function><type><specifier>public</specifier> <name>String</name></type> <name>getGlobbedId</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>errMessage</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>ParseException</name></expr></argument></throws> <block>{<block_content>
    <function><type><specifier>public</specifier> <name>String</name></type> <name>getGlobbedId</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>errMessage</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>SyntaxError</name></expr></argument></throws> <block>{<block_content>
       <expr_stmt><expr><call><name>eatws</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
       <decl_stmt><decl><type><name>int</name></type> <name>id_start</name> <init>= <expr><name>pos</name></expr></init></decl>;</decl_stmt>
       <decl_stmt><decl><type><name>char</name></type> <name>ch</name></decl>;</decl_stmt>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">767</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">766</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@ <specifier>public</specifier> <name>class</name> <name>QueryParsing</name> <block>{
       }</block></expr></expr_stmt>
 
       <if_stmt><if>if <condition>(<expr><name>errMessage</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
        <throw>throw <expr><operator>new</operator> <call><name>ParseException</name><argument_list>(<argument><expr><name>errMessage</name> <operator>+</operator> <literal type="string">" at pos "</literal> <operator>+</operator> <name>pos</name> <operator>+</operator> <literal type="string">" str='"</literal> <operator>+</operator> <name>val</name> <operator>+</operator> <literal type="string">"'"</literal></expr></argument>)</argument_list></call></expr>;</throw>
        <throw>throw <expr><operator>new</operator> <call><name>SyntaxError</name><argument_list>(<argument><expr><name>errMessage</name> <operator>+</operator> <literal type="string">" at pos "</literal> <operator>+</operator> <name>pos</name> <operator>+</operator> <literal type="string">" str='"</literal> <operator>+</operator> <name>val</name> <operator>+</operator> <literal type="string">"'"</literal></expr></argument>)</argument_list></call></expr>;</throw>
       </block_content>}</block></if></if_stmt>
       <return>return <expr><literal type="null">null</literal></expr>;</return>
     </block_content>}</block></function>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">793</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">792</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@ <specifier>public</specifier> <name>class</name> <name>QueryParsing</name> <block>{
      <expr><operator>*</operator> <name>sort</name> <name><name>direction</name><operator>.</operator></name> (<name>True</name> <name>is</name> <name>desc</name></expr>, <expr><name>False</name> <name>is</name> <name>asc</name></expr>)<operator>.</operator>  
      <operator>*</operator> <name>Position</name> <name>is</name> <name>advanced</name> <name>to</name> <name>after</name> <name>the</name> <call><name>comma</name> <argument_list>(<argument><expr><name>or</name> <name>end</name></expr></argument>)</argument_list></call> <name>when</name> <name>result</name> <name>is</name> <name>non</name> <literal type="null">null</literal> 
      <operator>*</operator><operator>/</operator>
    <name>Boolean</name> <call><name>getSortDirection</name><argument_list>()</argument_list></call> <throws>throws <argument><expr><name>ParseException</name> <block>{
    <expr><name>Boolean</name> <call><name>getSortDirection</name><argument_list>()</argument_list></call></expr></block></expr></argument></throws> <throws>throws <argument><expr><name>SyntaxError</name> <block>{
       <expr><name>final</name> <name>int</name> <name>startPos</name> <operator>=</operator> <name>pos</name></expr></block></expr></argument></throws></block></expr>;</expr_stmt>
       <decl_stmt><decl><type><specifier>final</specifier> <name>String</name></type> <name>order</name> <init>= <expr><call><name>getId</name><argument_list>(<argument><expr><literal type="null">null</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
 
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">823</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">822</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@ <specifier>public</specifier> <name>class</name> <name>QueryParsing</name> <block>{
     }</block>
 
     <comment type="line">// return null if not a string</comment>
    <name>String</name> <call><name>getQuotedString</name><argument_list>()</argument_list></call> <throws>throws <argument><expr><name>ParseException</name> <block>{
    <expr><name>String</name> <call><name>getQuotedString</name><argument_list>()</argument_list></call></expr></block></expr></argument></throws> <throws>throws <argument><expr><name>SyntaxError</name> <block>{
       <expr><call><name>eatws</name><argument_list>()</argument_list></call></expr></block></expr></argument></throws></expr>;</expr_stmt>
       <decl_stmt><decl><type><name>char</name></type> <name>delim</name> <init>= <expr><call><name>peekChar</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
       <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>delim</name> <operator>==</operator> <literal type="char">'\"'</literal> <operator>||</operator> <name>delim</name> <operator>==</operator> <literal type="char">'\''</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">833</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">832</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@ <specifier>public</specifier> <name>class</name> <name>QueryParsing</name> <block>{
       <expr><name>StringBuilder</name> <name>sb</name> <operator>=</operator> <operator>new</operator> <call><name>StringBuilder</name><argument_list>()</argument_list></call></expr>;</block></expr></expr_stmt> <comment type="line">// needed for escaping</comment>
       <for>for <control>(<init>;</init> <condition>;</condition><incr/>)</control> <block>{<block_content>
         <if_stmt><if>if <condition>(<expr><name>pos</name> <operator>&gt;=</operator> <name>end</name></expr>)</condition> <block>{<block_content>
          <throw>throw <expr><operator>new</operator> <call><name>ParseException</name><argument_list>(<argument><expr><literal type="string">"Missing end quote for string at pos "</literal> <operator>+</operator> <operator>(</operator><name>val_start</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>+</operator> <literal type="string">" str='"</literal> <operator>+</operator> <name>val</name> <operator>+</operator> <literal type="string">"'"</literal></expr></argument>)</argument_list></call></expr>;</throw>
          <throw>throw <expr><operator>new</operator> <call><name>SyntaxError</name><argument_list>(<argument><expr><literal type="string">"Missing end quote for string at pos "</literal> <operator>+</operator> <operator>(</operator><name>val_start</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>+</operator> <literal type="string">" str='"</literal> <operator>+</operator> <name>val</name> <operator>+</operator> <literal type="string">"'"</literal></expr></argument>)</argument_list></call></expr>;</throw>
         </block_content>}</block></if></if_stmt>
         <decl_stmt><decl><type><name>char</name></type> <name>ch</name> <init>= <expr><call><name><name>val</name><operator>.</operator><name>charAt</name></name><argument_list>(<argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
         <if_stmt><if>if <condition>(<expr><name>ch</name> <operator>==</operator> <literal type="char">'\\'</literal></expr>)</condition> <block>{<block_content>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">858</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">857</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@ <specifier>public</specifier> <name>class</name> <name>QueryParsing</name> <block>{
               <break>break;</break></block></expr></expr_stmt>
             <case>case <expr><literal type="char">'u'</literal></expr>:</case>
               <if_stmt><if>if <condition>(<expr><name>pos</name> <operator>+</operator> <literal type="number">4</literal> <operator>&gt;=</operator> <name>end</name></expr>)</condition> <block>{<block_content>
                <throw>throw <expr><operator>new</operator> <call><name>ParseException</name><argument_list>(<argument><expr><literal type="string">"bad unicode escape \\uxxxx at pos"</literal> <operator>+</operator> <operator>(</operator><name>val_start</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>+</operator> <literal type="string">" str='"</literal> <operator>+</operator> <name>val</name> <operator>+</operator> <literal type="string">"'"</literal></expr></argument>)</argument_list></call></expr>;</throw>
                <throw>throw <expr><operator>new</operator> <call><name>SyntaxError</name><argument_list>(<argument><expr><literal type="string">"bad unicode escape \\uxxxx at pos"</literal> <operator>+</operator> <operator>(</operator><name>val_start</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>+</operator> <literal type="string">" str='"</literal> <operator>+</operator> <name>val</name> <operator>+</operator> <literal type="string">"'"</literal></expr></argument>)</argument_list></call></expr>;</throw>
               </block_content>}</block></if></if_stmt>
               <expr_stmt><expr><name>ch</name> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator> <call><name><name>Integer</name><operator>.</operator><name>parseInt</name></name><argument_list>(<argument><expr><call><name><name>val</name><operator>.</operator><name>substring</name></name><argument_list>(<argument><expr><name>pos</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>pos</name> <operator>+</operator> <literal type="number">5</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
               <expr_stmt><expr><name>pos</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>diff</name> <operator>--</operator><name>git</name> <name>a</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>search</name><operator>/</operator><name><name>ReturnFields</name><operator>.</operator><name>java</name></name> <name>b</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>search</name><operator>/</operator><name><name>ReturnFields</name><operator>.</operator><name>java</name></name>
<name>index</name> <name>a6820aa41cf</name><operator>..</operator><literal type="number">3b33faf08f3</literal> <literal type="number">100644</literal>
<operator>--</operator> <name>a</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>search</name><operator>/</operator><name><name>ReturnFields</name><operator>.</operator><name>java</name></name>
<operator>++</operator> <name>b</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>search</name><operator>/</operator><name><name>ReturnFields</name><operator>.</operator><name>java</name></name>
@@ <operator>-</operator><literal type="number">22</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">22</literal></expr><operator>,</operator><expr><literal type="number">6</literal> @@</expr></expr_stmt> <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>commons</name><operator>.</operator><name>io</name><operator>.</operator><name>FilenameUtils</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>queries</name><operator>.</operator><name>function</name><operator>.</operator><name>FunctionQuery</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>queries</name><operator>.</operator><name>function</name><operator>.</operator><name>ValueSource</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>queries</name><operator>.</operator><name>function</name><operator>.</operator><name>valuesource</name><operator>.</operator><name>QueryValueSource</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>queryparser</name><operator>.</operator><name>classic</name><operator>.</operator><name>ParseException</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>search</name><operator>.</operator><name>Query</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>common</name><operator>.</operator><name>SolrException</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>common</name><operator>.</operator><name>params</name><operator>.</operator><name>CommonParams</name></name>;</import>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">338</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">337</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@ <specifier>public</specifier> <name>class</name> <name>ReturnFields</name>
           <call><name><name>okFieldNames</name><operator>.</operator><name>add</name></name><argument_list>( <argument><expr><name>funcStr</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
           <expr_stmt><expr><call><name><name>augmenters</name><operator>.</operator><name>addTransformer</name></name><argument_list>( <argument><expr><operator>new</operator> <call><name>ValueSourceAugmenter</name><argument_list>( <argument><expr><name>key</name></expr></argument>, <argument><expr><name>parser</name></expr></argument>, <argument><expr><name>vs</name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
         </block_content>}</block></if></if_stmt>
        <catch>catch <parameter_list>(<parameter><decl><type><name>ParseException</name></type> <name>e</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <catch>catch <parameter_list>(<parameter><decl><type><name>SyntaxError</name></type> <name>e</name></decl></parameter>)</parameter_list> <block>{<block_content>
           <comment type="line">// try again, simple rules for a field name with no whitespace</comment>
           <expr_stmt><expr><name><name>sp</name><operator>.</operator><name>pos</name></name> <operator>=</operator> <name>start</name></expr>;</expr_stmt>
           <expr_stmt><expr><name>field</name> <operator>=</operator> <call><name><name>sp</name><operator>.</operator><name>getSimpleString</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">357</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">356</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@ <specifier>public</specifier> <name>class</name> <name>ReturnFields</name></expr></expr_stmt>
        <comment type="line">// end try as function</comment>
 
       </block_content>}</block></catch> <comment type="line">// end for(;;)</comment>
    </block_content>}</block></catch> <catch>catch <parameter_list>(<parameter><decl><type><name>ParseException</name></type> <name>e</name></decl></parameter>)</parameter_list> <block>{<block_content>
    </block_content>}</block></catch> <catch>catch <parameter_list>(<parameter><decl><type><name>SyntaxError</name></type> <name>e</name></decl></parameter>)</parameter_list> <block>{<block_content>
       <throw>throw <expr><operator>new</operator> <call><name>SolrException</name><argument_list>(<argument><expr><name><name>SolrException</name><operator>.</operator><name>ErrorCode</name><operator>.</operator><name>BAD_REQUEST</name></name></expr></argument>, <argument><expr><literal type="string">"Error parsing fieldname"</literal></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</throw>
     </block_content>}</block></catch>
   </block_content>}</block></for>
<expr_stmt><expr><name>diff</name> <operator>--</operator><name>git</name> <name>a</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>search</name><operator>/</operator><name><name>SolrQueryParser</name><operator>.</operator><name>java</name></name> <name>b</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>search</name><operator>/</operator><name><name>SolrQueryParser</name><operator>.</operator><name>java</name></name>
<name>index</name> <name>d8de2f694ea</name><operator>..</operator><name>f28262f5fff</name> <literal type="number">100644</literal>
<operator>--</operator> <name>a</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>search</name><operator>/</operator><name><name>SolrQueryParser</name><operator>.</operator><name>java</name></name>
<operator>++</operator> <name>b</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>search</name><operator>/</operator><name><name>SolrQueryParser</name><operator>.</operator><name>java</name></name>
@@ <operator>-</operator><literal type="number">20</literal></expr><operator>,</operator><expr><literal type="number">12</literal> <operator>+</operator><literal type="number">20</literal></expr><operator>,</operator><expr><literal type="number">9</literal> @@</expr></expr_stmt> <package>package <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>search</name></name>;</package>
 <import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>EnumSet</name></name>;</import>
 <import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>HashMap</name></name>;</import>
 <import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>Map</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>Map</name><operator>.</operator><name>Entry</name></name>;</import>
 
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>analysis</name><operator>.</operator><name>util</name><operator>.</operator><name>TokenFilterFactory</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>index</name><operator>.</operator><name>Term</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>queryparser</name><operator>.</operator><name>classic</name><operator>.</operator><name>ParseException</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>queryparser</name><operator>.</operator><name>classic</name><operator>.</operator><name>QueryParser</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>search</name><operator>.</operator><name>*</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>util</name><operator>.</operator><name>ToStringUtils</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>util</name><operator>.</operator><name>automaton</name><operator>.</operator><name>Automaton</name></name>;</import>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">36</literal></expr><operator>,</operator><expr><literal type="number">6</literal> <operator>+</operator><literal type="number">33</literal></expr><operator>,</operator><expr><literal type="number">8</literal> @@</expr></expr_stmt> <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>analysis</name><operator>.</operator><name>Analyzer</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>analysis</name><operator>.</operator><name>ReversedWildcardFilterFactory</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>analysis</name><operator>.</operator><name>TokenizerChain</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>common</name><operator>.</operator><name>SolrException</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>parser</name><operator>.</operator><name>ParseException</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>parser</name><operator>.</operator><name>QueryParser</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>schema</name><operator>.</operator><name>FieldType</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>schema</name><operator>.</operator><name>IndexSchema</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>schema</name><operator>.</operator><name>SchemaField</name></name>;</import>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">43</literal></expr><operator>,</operator><expr><literal type="number">215</literal> <operator>+</operator><literal type="number">42</literal></expr><operator>,</operator><expr><literal type="number">12</literal> @@</expr></expr_stmt> <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>schema</name><operator>.</operator><name>TextField</name></name>;</import>
 
 
 <comment type="block" format="javadoc">/**
 * A variation on the Lucene QueryParser which knows about the field 
 * types and query time analyzers configured in Solr's schema.xml.
 *
 * &lt;p&gt;
 * This class also deviates from the Lucene QueryParser by using 
 * ConstantScore versions of RangeQuery and PrefixQuery to prevent 
 * TooManyClauses exceptions.
 * &lt;/p&gt; 
 *
 * &lt;p&gt;
 * If the magic field name "&lt;code&gt;_val_&lt;/code&gt;" is used in a term or 
 * phrase query, the value is parsed as a function.
 * &lt;/p&gt;
 * Solr's default query parser, a schema-driven superset of the classic lucene query parser.
  */</comment>
 <class><specifier>public</specifier> class <name>SolrQueryParser</name> <super_list><extends>extends <super><name>QueryParser</name></super></extends></super_list> <block>{
  <decl_stmt><decl><type><specifier>protected</specifier> <specifier>final</specifier> <name>IndexSchema</name></type> <name>schema</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>protected</specifier> <specifier>final</specifier> <name>QParser</name></type> <name>parser</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>protected</specifier> <specifier>final</specifier> <name>String</name></type> <name>defaultField</name></decl>;</decl_stmt>

  <comment type="block" format="javadoc">/** 
   * Identifies the list of all known "magic fields" that trigger 
   * special parsing behavior
   */</comment>
  <enum><specifier>public</specifier> <specifier>static</specifier> enum <name>MagicFieldName</name> <block>{
    <decl><name>VAL</name><argument_list>(<argument><expr><literal type="string">"_val_"</literal></expr></argument>, <argument><expr><literal type="string">"func"</literal></expr></argument>)</argument_list></decl>, <decl><name>QUERY</name><argument_list>(<argument><expr><literal type="string">"_query_"</literal></expr></argument>, <argument><expr><literal type="null">null</literal></expr></argument>)</argument_list></decl>;
    
    <decl_stmt><decl><type><specifier>public</specifier> <specifier>final</specifier> <name>String</name></type> <name>field</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>public</specifier> <specifier>final</specifier> <name>String</name></type> <name>subParser</name></decl>;</decl_stmt>
    <constructor><name>MagicFieldName</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>field</name></decl></parameter>, <parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>subParser</name></decl></parameter>)</parameter_list> <block>{<block_content>
      <expr_stmt><expr><name><name>this</name><operator>.</operator><name>field</name></name> <operator>=</operator> <name>field</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>this</name><operator>.</operator><name>subParser</name></name> <operator>=</operator> <name>subParser</name></expr>;</expr_stmt>
    </block_content>}</block></constructor>
    <function><type><specifier>public</specifier> <name>String</name></type> <name>toString</name><parameter_list>()</parameter_list> <block>{<block_content>
      <return>return <expr><name>field</name></expr>;</return>
    </block_content>}</block></function>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <specifier>static</specifier> <name><name>Map</name><argument_list type="generic">&lt;<argument><name>String</name></argument>,<argument><name>MagicFieldName</name></argument>&gt;</argument_list></name></type> <name>lookup</name> 
      <init>= <expr><operator>new</operator> <call><name><name>HashMap</name><argument_list type="generic">&lt;<argument><name>String</name></argument>,<argument><name>MagicFieldName</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <static>static <block>{<block_content>
      <for>for<control>(<init><decl><type><name>MagicFieldName</name></type> <name>s</name> <range>: <expr><call><name><name>EnumSet</name><operator>.</operator><name>allOf</name></name><argument_list>(<argument><expr><name><name>MagicFieldName</name><operator>.</operator><name>class</name></name></expr></argument>)</argument_list></call></expr></range></decl></init>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name><name>lookup</name><operator>.</operator><name>put</name></name><argument_list>(<argument><expr><call><name><name>s</name><operator>.</operator><name>toString</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
    </block_content>}</block></static>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>MagicFieldName</name></type> <name>get</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <name>String</name></type> <name>field</name></decl></parameter>)</parameter_list> <block>{<block_content>
      <return>return <expr><call><name><name>lookup</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>field</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>
  }</block></enum>

  <comment type="line">// implementation detail - caching ReversedWildcardFilterFactory based on type</comment>
  <decl_stmt><decl><type><specifier>private</specifier> <name><name>Map</name><argument_list type="generic">&lt;<argument><name>FieldType</name></argument>, <argument><name>ReversedWildcardFilterFactory</name></argument>&gt;</argument_list></name></type> <name>leadingWildcards</name></decl>;</decl_stmt>
 
   <constructor><specifier>public</specifier> <name>SolrQueryParser</name><parameter_list>(<parameter><decl><type><name>QParser</name></type> <name>parser</name></decl></parameter>, <parameter><decl><type><name>String</name></type> <name>defaultField</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>this</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>defaultField</name></expr></argument>, <argument><expr><call><name><name>parser</name><operator>.</operator><name>getReq</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSchema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getQueryAnalyzer</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></constructor>

  <constructor><specifier>public</specifier> <name>SolrQueryParser</name><parameter_list>(<parameter><decl><type><name>QParser</name></type> <name>parser</name></decl></parameter>, <parameter><decl><type><name>String</name></type> <name>defaultField</name></decl></parameter>, <parameter><decl><type><name>Analyzer</name></type> <name>analyzer</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>super</name><argument_list>(<argument><expr><call><name><name>parser</name><operator>.</operator><name>getReq</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getCore</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSolrConfig</name><argument_list>()</argument_list></call><operator>.</operator><name>luceneMatchVersion</name></expr></argument>, <argument><expr><name>defaultField</name></expr></argument>, <argument><expr><name>analyzer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>this</name><operator>.</operator><name>schema</name></name> <operator>=</operator> <call><name><name>parser</name><operator>.</operator><name>getReq</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSchema</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>this</name><operator>.</operator><name>parser</name></name> <operator>=</operator> <name>parser</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>this</name><operator>.</operator><name>defaultField</name></name> <operator>=</operator> <name>defaultField</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>setEnablePositionIncrements</name><argument_list>(<argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>setLowercaseExpandedTerms</name><argument_list>(<argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>setAllowLeadingWildcard</name><argument_list>(<argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></constructor>

  <function><type><specifier>protected</specifier> <name>ReversedWildcardFilterFactory</name></type> <name>getReversedWildcardFilterFactory</name><parameter_list>(<parameter><decl><type><name>FieldType</name></type> <name>fieldType</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>leadingWildcards</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>leadingWildcards</name> <operator>=</operator> <operator>new</operator> <call><name><name>HashMap</name><argument_list type="generic">&lt;<argument><name>FieldType</name></argument>, <argument><name>ReversedWildcardFilterFactory</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <decl_stmt><decl><type><name>ReversedWildcardFilterFactory</name></type> <name>fac</name> <init>= <expr><call><name><name>leadingWildcards</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>fieldType</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>fac</name> <operator>==</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <call><name><name>leadingWildcards</name><operator>.</operator><name>containsKey</name></name><argument_list>(<argument><expr><name>fac</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <return>return <expr><name>fac</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <decl_stmt><decl><type><name>Analyzer</name></type> <name>a</name> <init>= <expr><call><name><name>fieldType</name><operator>.</operator><name>getAnalyzer</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>a</name> <operator>instanceof</operator> <name>TokenizerChain</name></expr>)</condition> <block>{<block_content>
      <comment type="line">// examine the indexing analysis chain if it supports leading wildcards</comment>
      <decl_stmt><decl><type><name>TokenizerChain</name></type> <name>tc</name> <init>= <expr><operator>(</operator><name>TokenizerChain</name><operator>)</operator><name>a</name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name><name>TokenFilterFactory</name><index>[]</index></name></type> <name>factories</name> <init>= <expr><call><name><name>tc</name><operator>.</operator><name>getTokenFilterFactories</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
      <for>for <control>(<init><decl><type><name>TokenFilterFactory</name></type> <name>factory</name> <range>: <expr><name>factories</name></expr></range></decl></init>)</control> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>factory</name> <operator>instanceof</operator> <name>ReversedWildcardFilterFactory</name></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><name>fac</name> <operator>=</operator> <operator>(</operator><name>ReversedWildcardFilterFactory</name><operator>)</operator><name>factory</name></expr>;</expr_stmt>
          <break>break;</break>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name><name>leadingWildcards</name><operator>.</operator><name>put</name></name><argument_list>(<argument><expr><name>fieldType</name></expr></argument>, <argument><expr><name>fac</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>fac</name></expr>;</return>
  </block_content>}</block></function>

  
  <function><type><specifier>private</specifier> <name>void</name></type> <name>checkNullField</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>field</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>SolrException</name></expr></argument></throws> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>field</name> <operator>==</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <name>defaultField</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
      <throw>throw <expr><operator>new</operator> <call><name>SolrException</name>
        <argument_list>(<argument><expr><name><name>SolrException</name><operator>.</operator><name>ErrorCode</name><operator>.</operator><name>BAD_REQUEST</name></name></expr></argument>,
         <argument><expr><literal type="string">"no field name specified in query and no default specified via 'df' param"</literal></expr></argument>)</argument_list></call></expr>;</throw>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></function>

  <function><type><specifier>protected</specifier> <name>String</name></type> <name>analyzeIfMultitermTermText</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>field</name></decl></parameter>, <parameter><decl><type><name>String</name></type> <name>part</name></decl></parameter>, <parameter><decl><type><name>FieldType</name></type> <name>fieldType</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>part</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>part</name></expr>;</return></block_content></block></if></if_stmt>

    <decl_stmt><decl><type><name>SchemaField</name></type> <name>sf</name> <init>= <expr><call><name><name>schema</name><operator>.</operator><name>getFieldOrNull</name></name><argument_list>(<argument><expr><operator>(</operator><name>field</name><operator>)</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>sf</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <operator>!</operator> <operator>(</operator><name>fieldType</name> <operator>instanceof</operator> <name>TextField</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>part</name></expr>;</return></block_content></block></if></if_stmt>
    <decl_stmt><decl><type><name>String</name></type> <name>out</name> <init>= <expr><call><name><name>TextField</name><operator>.</operator><name>analyzeMultiTerm</name></name><argument_list>(<argument><expr><name>field</name></expr></argument>, <argument><expr><name>part</name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>TextField</name><operator>)</operator><name>fieldType</name><operator>)</operator><operator>.</operator><call><name>getMultiTermAnalyzer</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>.</operator><call><name>utf8ToString</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <comment type="line">// System.out.println("INPUT="+part + " OUTPUT="+out);</comment>
    <return>return <expr><name>out</name></expr>;</return>
  </block_content>}</block></function>

  <function><annotation>@<name>Override</name></annotation>
  <type><specifier>protected</specifier> <name>Query</name></type> <name>getFieldQuery</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>field</name></decl></parameter>, <parameter><decl><type><name>String</name></type> <name>queryText</name></decl></parameter>, <parameter><decl><type><name>boolean</name></type> <name>quoted</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>ParseException</name></expr></argument></throws> <block>{<block_content>
    <expr_stmt><expr><call><name>checkNullField</name><argument_list>(<argument><expr><name>field</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="line">// intercept magic field name of "_" to use as a hook for our</comment>
    <comment type="line">// own functions.</comment>
    <if_stmt><if>if <condition>(<expr><call><name><name>field</name><operator>.</operator><name>charAt</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="char">'_'</literal> <operator>&amp;&amp;</operator> <name>parser</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>MagicFieldName</name></type> <name>magic</name> <init>= <expr><call><name><name>MagicFieldName</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>field</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><literal type="null">null</literal> <operator>!=</operator> <name>magic</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>QParser</name></type> <name>nested</name> <init>= <expr><call><name><name>parser</name><operator>.</operator><name>subQuery</name></name><argument_list>(<argument><expr><name>queryText</name></expr></argument>, <argument><expr><name><name>magic</name><operator>.</operator><name>subParser</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <return>return <expr><call><name><name>nested</name><operator>.</operator><name>getQuery</name></name><argument_list>()</argument_list></call></expr>;</return>
      </block_content>}</block></if></if_stmt> 
    </block_content>}</block></if></if_stmt>
    <decl_stmt><decl><type><name>SchemaField</name></type> <name>sf</name> <init>= <expr><call><name><name>schema</name><operator>.</operator><name>getFieldOrNull</name></name><argument_list>(<argument><expr><name>field</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>sf</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>FieldType</name></type> <name>ft</name> <init>= <expr><call><name><name>sf</name><operator>.</operator><name>getType</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
      <comment type="line">// delegate to type for everything except tokenized fields</comment>
      <if_stmt><if>if <condition>(<expr><call><name><name>ft</name><operator>.</operator><name>isTokenized</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
        <return>return <expr><call><name><name>super</name><operator>.</operator><name>getFieldQuery</name></name><argument_list>(<argument><expr><name>field</name></expr></argument>, <argument><expr><name>queryText</name></expr></argument>, <argument><expr><name>quoted</name> <operator>||</operator> <operator>(</operator><name>ft</name> <operator>instanceof</operator> <name>TextField</name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name>TextField</name><operator>)</operator><name>ft</name><operator>)</operator><operator>.</operator><call><name>getAutoGeneratePhraseQueries</name><argument_list>()</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</return>
      </block_content>}</block></if> <else>else <block>{<block_content>
        <return>return <expr><call><name><name>sf</name><operator>.</operator><name>getType</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getFieldQuery</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>sf</name></expr></argument>, <argument><expr><name>queryText</name></expr></argument>)</argument_list></call></expr>;</return>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// default to a normal field query</comment>
    <return>return <expr><call><name><name>super</name><operator>.</operator><name>getFieldQuery</name></name><argument_list>(<argument><expr><name>field</name></expr></argument>, <argument><expr><name>queryText</name></expr></argument>, <argument><expr><name>quoted</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></function>

  <function><annotation>@<name>Override</name></annotation>
  <type><specifier>protected</specifier> <name>Query</name></type> <name>getRangeQuery</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>field</name></decl></parameter>, <parameter><decl><type><name>String</name></type> <name>part1</name></decl></parameter>, <parameter><decl><type><name>String</name></type> <name>part2</name></decl></parameter>, <parameter><decl><type><name>boolean</name></type> <name>startInclusive</name></decl></parameter>, <parameter><decl><type><name>boolean</name></type> <name>endInclusive</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>ParseException</name></expr></argument></throws> <block>{<block_content>
    <expr_stmt><expr><call><name>checkNullField</name><argument_list>(<argument><expr><name>field</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>SchemaField</name></type> <name>sf</name> <init>= <expr><call><name><name>schema</name><operator>.</operator><name>getField</name></name><argument_list>(<argument><expr><name>field</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <return>return <expr><call><name><name>sf</name><operator>.</operator><name>getType</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getRangeQuery</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>sf</name></expr></argument>, <argument><expr><name>part1</name></expr></argument>, <argument><expr><name>part2</name></expr></argument>, <argument><expr><name>startInclusive</name></expr></argument>, <argument><expr><name>endInclusive</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></function>

  <function><annotation>@<name>Override</name></annotation>
  <type><specifier>protected</specifier> <name>Query</name></type> <name>getPrefixQuery</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>field</name></decl></parameter>, <parameter><decl><type><name>String</name></type> <name>termStr</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>ParseException</name></expr></argument></throws> <block>{<block_content>
    <expr_stmt><expr><call><name>checkNullField</name><argument_list>(<argument><expr><name>field</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>termStr</name> <operator>=</operator> <call><name>analyzeIfMultitermTermText</name><argument_list>(<argument><expr><name>field</name></expr></argument>, <argument><expr><name>termStr</name></expr></argument>, <argument><expr><call><name><name>schema</name><operator>.</operator><name>getFieldType</name></name><argument_list>(<argument><expr><name>field</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Solr has always used constant scoring for prefix queries.  This should return constant scoring by default.</comment>
    <return>return <expr><call><name>newPrefixQuery</name><argument_list>(<argument><expr><operator>new</operator> <call><name>Term</name><argument_list>(<argument><expr><name>field</name></expr></argument>, <argument><expr><name>termStr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></function>
  <function><annotation>@<name>Override</name></annotation>
  <type><specifier>protected</specifier> <name>Query</name></type> <name>getWildcardQuery</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>field</name></decl></parameter>, <parameter><decl><type><name>String</name></type> <name>termStr</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>ParseException</name></expr></argument></throws> <block>{<block_content>
    <expr_stmt><expr><call><name>checkNullField</name><argument_list>(<argument><expr><name>field</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="line">// *:* -&gt; MatchAllDocsQuery</comment>
    <if_stmt><if>if <condition>(<expr><literal type="string">"*"</literal><operator>.</operator><call><name>equals</name><argument_list>(<argument><expr><name>field</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"*"</literal><operator>.</operator><call><name>equals</name><argument_list>(<argument><expr><name>termStr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <return>return <expr><call><name>newMatchAllDocsQuery</name><argument_list>()</argument_list></call></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <decl_stmt><decl><type><name>FieldType</name></type> <name>fieldType</name> <init>= <expr><call><name><name>schema</name><operator>.</operator><name>getFieldType</name></name><argument_list>(<argument><expr><name>field</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>termStr</name> <operator>=</operator> <call><name>analyzeIfMultitermTermText</name><argument_list>(<argument><expr><name>field</name></expr></argument>, <argument><expr><name>termStr</name></expr></argument>, <argument><expr><name>fieldType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="line">// can we use reversed wildcards in this field?</comment>
    <decl_stmt><decl><type><name>ReversedWildcardFilterFactory</name></type> <name>factory</name> <init>= <expr><call><name>getReversedWildcardFilterFactory</name><argument_list>(<argument><expr><name>fieldType</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>factory</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>Term</name></type> <name>term</name> <init>= <expr><operator>new</operator> <call><name>Term</name><argument_list>(<argument><expr><name>field</name></expr></argument>, <argument><expr><name>termStr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <comment type="line">// fsa representing the query</comment>
      <decl_stmt><decl><type><name>Automaton</name></type> <name>automaton</name> <init>= <expr><call><name><name>WildcardQuery</name><operator>.</operator><name>toAutomaton</name></name><argument_list>(<argument><expr><name>term</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <comment type="line">// TODO: we should likely use the automaton to calculate shouldReverse, too.</comment>
      <if_stmt><if>if <condition>(<expr><call><name><name>factory</name><operator>.</operator><name>shouldReverse</name></name><argument_list>(<argument><expr><name>termStr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>automaton</name> <operator>=</operator> <call><name><name>BasicOperations</name><operator>.</operator><name>concatenate</name></name><argument_list>(<argument><expr><name>automaton</name></expr></argument>, <argument><expr><call><name><name>BasicAutomata</name><operator>.</operator><name>makeChar</name></name><argument_list>(<argument><expr><call><name><name>factory</name><operator>.</operator><name>getMarkerChar</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>SpecialOperations</name><operator>.</operator><name>reverse</name></name><argument_list>(<argument><expr><name>automaton</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if> <else>else <block>{<block_content> 
        <comment type="line">// reverse wildcardfilter is active: remove false positives</comment>
        <comment type="line">// fsa representing false positives (markerChar*)</comment>
        <decl_stmt><decl><type><name>Automaton</name></type> <name>falsePositives</name> <init>= <expr><call><name><name>BasicOperations</name><operator>.</operator><name>concatenate</name></name><argument_list>(
            <argument><expr><call><name><name>BasicAutomata</name><operator>.</operator><name>makeChar</name></name><argument_list>(<argument><expr><call><name><name>factory</name><operator>.</operator><name>getMarkerChar</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, 
            <argument><expr><call><name><name>BasicAutomata</name><operator>.</operator><name>makeAnyString</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <comment type="line">// subtract these away</comment>
        <expr_stmt><expr><name>automaton</name> <operator>=</operator> <call><name><name>BasicOperations</name><operator>.</operator><name>minus</name></name><argument_list>(<argument><expr><name>automaton</name></expr></argument>, <argument><expr><name>falsePositives</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <return>return <expr><operator>new</operator> <class><super><name>AutomatonQuery</name></super><argument_list>(<argument><expr><name>term</name></expr></argument>, <argument><expr><name>automaton</name></expr></argument>)</argument_list> <block>{
        <comment type="line">// override toString so its completely transparent</comment>
        <function><annotation>@<name>Override</name></annotation>
        <type><specifier>public</specifier> <name>String</name></type> <name>toString</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>field</name></decl></parameter>)</parameter_list> <block>{<block_content>
          <decl_stmt><decl><type><name>StringBuilder</name></type> <name>buffer</name> <init>= <expr><operator>new</operator> <call><name>StringBuilder</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
          <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>getField</name><argument_list>()</argument_list></call><operator>.</operator><call><name>equals</name><argument_list>(<argument><expr><name>field</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name><name>buffer</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><call><name>getField</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>buffer</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><literal type="string">":"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><call><name><name>buffer</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><call><name><name>term</name><operator>.</operator><name>text</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name><name>buffer</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><call><name><name>ToStringUtils</name><operator>.</operator><name>boost</name></name><argument_list>(<argument><expr><call><name>getBoost</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <return>return <expr><call><name><name>buffer</name><operator>.</operator><name>toString</name></name><argument_list>()</argument_list></call></expr>;</return>
        </block_content>}</block></function>
      }</block></class></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// Solr has always used constant scoring for wildcard queries.  This should return constant scoring by default.</comment>
    <return>return <expr><call><name>newWildcardQuery</name><argument_list>(<argument><expr><operator>new</operator> <call><name>Term</name><argument_list>(<argument><expr><name>field</name></expr></argument>, <argument><expr><name>termStr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></function>

  <function><annotation>@<name>Override</name></annotation>
  <type><specifier>protected</specifier> <name>Query</name></type> <name>getRegexpQuery</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>field</name></decl></parameter>, <parameter><decl><type><name>String</name></type> <name>termStr</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>ParseException</name></expr></argument></throws>
  <block>{<block_content>
    <expr_stmt><expr><name>termStr</name> <operator>=</operator> <call><name>analyzeIfMultitermTermText</name><argument_list>(<argument><expr><name>field</name></expr></argument>, <argument><expr><name>termStr</name></expr></argument>, <argument><expr><call><name><name>schema</name><operator>.</operator><name>getFieldType</name></name><argument_list>(<argument><expr><name>field</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>newRegexpQuery</name><argument_list>(<argument><expr><operator>new</operator> <call><name>Term</name><argument_list>(<argument><expr><name>field</name></expr></argument>, <argument><expr><name>termStr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></function>

  <function><annotation>@<name>Override</name></annotation>
  <type><specifier>protected</specifier> <name>Query</name></type> <name>getFuzzyQuery</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>field</name></decl></parameter>, <parameter><decl><type><name>String</name></type> <name>termStr</name></decl></parameter>, <parameter><decl><type><name>float</name></type> <name>minSimilarity</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>ParseException</name></expr></argument></throws> <block>{<block_content>
    <expr_stmt><expr><name>termStr</name> <operator>=</operator> <call><name>analyzeIfMultitermTermText</name><argument_list>(<argument><expr><name>field</name></expr></argument>, <argument><expr><name>termStr</name></expr></argument>, <argument><expr><call><name><name>schema</name><operator>.</operator><name>getFieldType</name></name><argument_list>(<argument><expr><name>field</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>Term</name></type> <name>t</name> <init>= <expr><operator>new</operator> <call><name>Term</name><argument_list>(<argument><expr><name>field</name></expr></argument>, <argument><expr><name>termStr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <return>return <expr><call><name>newFuzzyQuery</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>minSimilarity</name></expr></argument>, <argument><expr><call><name>getFuzzyPrefixLength</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    <expr_stmt><expr><call><name>super</name><argument_list>(<argument><expr><call><name><name>parser</name><operator>.</operator><name>getReq</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getCore</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSolrConfig</name><argument_list>()</argument_list></call><operator>.</operator><name>luceneMatchVersion</name></expr></argument>, <argument><expr><name>defaultField</name></expr></argument>, <argument><expr><name>parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
   </block_content>}</block></function>
 
 }</block></class>
<expr_stmt><expr><name>diff</name> <operator>--</operator><name>git</name> <name>a</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>search</name><operator>/</operator><name><name>SpatialFilterQParser</name><operator>.</operator><name>java</name></name> <name>b</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>search</name><operator>/</operator><name><name>SpatialFilterQParser</name><operator>.</operator><name>java</name></name>
<name>index</name> <literal type="number">7c91cf8b1c2</literal><operator>..</operator><name>b29db72ab6d</name> <literal type="number">100644</literal>
<operator>--</operator> <name>a</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>search</name><operator>/</operator><name><name>SpatialFilterQParser</name><operator>.</operator><name>java</name></name>
<operator>++</operator> <name>b</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>search</name><operator>/</operator><name><name>SpatialFilterQParser</name><operator>.</operator><name>java</name></name>
@@ <operator>-</operator><literal type="number">17</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">17</literal></expr><operator>,</operator><expr><literal type="number">6</literal> @@</expr></expr_stmt> <package>package <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>search</name></name>;</package>
  <expr_stmt><expr><operator>*</operator><operator>/</operator></expr></expr_stmt>
 
 
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>queryparser</name><operator>.</operator><name>classic</name><operator>.</operator><name>ParseException</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>search</name><operator>.</operator><name>Query</name></name>;</import>
 <import>import <name><name>com</name><operator>.</operator><name>spatial4j</name><operator>.</operator><name>core</name><operator>.</operator><name>distance</name><operator>.</operator><name>DistanceUtils</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>common</name><operator>.</operator><name>SolrException</name></name>;</import>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">44</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">43</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@ <specifier>public</specifier> <name>class</name> <name>SpatialFilterQParser</name> extends <name>QParser</name> <block>{
   
 
   @<expr><name>Override</name>
  <specifier>public</specifier> <name>Query</name> <call><name>parse</name><argument_list>()</argument_list></call> <throws>throws <argument><expr><name>ParseException</name> <block>{
  <expr><specifier>public</specifier> <name>Query</name> <call><name>parse</name><argument_list>()</argument_list></call></expr></block></expr></argument></throws> <throws>throws <argument><expr><name>SyntaxError</name> <block>{
     <comment type="line">//if more than one, we need to treat them as a point...</comment>
     <comment type="line">//TODO: Should we accept multiple fields</comment>
     <expr><name><name>String</name><index>[]</index></name> <name>fields</name> <operator>=</operator> <call><name><name>localParams</name><operator>.</operator><name>getParams</name></name><argument_list>(<argument><expr><literal type="string">"f"</literal></expr></argument>)</argument_list></call></expr></block></expr></argument></throws></expr>;
<name>diff</name> <operator>--</operator><name>git</name> <name>a</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>search</name><operator>/</operator><name><name>SurroundQParserPlugin</name><operator>.</operator><name>java</name></name> <name>b</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>search</name><operator>/</operator><name><name>SurroundQParserPlugin</name><operator>.</operator><name>java</name></name>
<name>index</name> <name>f5dad7cb6a2</name><operator>..</operator><literal type="number">44f0fd4daca</literal> <literal type="number">100644</literal>
<operator>--</operator> <name>a</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>search</name><operator>/</operator><name><name>SurroundQParserPlugin</name><operator>.</operator><name>java</name></name>
<operator>++</operator> <name>b</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>search</name><operator>/</operator><name><name>SurroundQParserPlugin</name><operator>.</operator><name>java</name></name>
@@ <operator>-</operator><literal type="number">18</literal><operator>,</operator><literal type="number">12</literal> <operator>+</operator><literal type="number">18</literal><operator>,</operator><literal type="number">10</literal> @@</block></expr></expr_stmt> <package>package <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>search</name></name>;</package>
  <expr_stmt><expr><operator>*</operator><operator>/</operator></expr></expr_stmt>
 
 
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>queryparser</name><operator>.</operator><name>classic</name><operator>.</operator><name>ParseException</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>search</name><operator>.</operator><name>Query</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>common</name><operator>.</operator><name>params</name><operator>.</operator><name>CommonParams</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>common</name><operator>.</operator><name>params</name><operator>.</operator><name>SolrParams</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>common</name><operator>.</operator><name>util</name><operator>.</operator><name>NamedList</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>handler</name><operator>.</operator><name>SnapPuller</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>request</name><operator>.</operator><name>SolrQueryRequest</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>queryparser</name><operator>.</operator><name>surround</name><operator>.</operator><name>parser</name><operator>.</operator><name>*</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>queryparser</name><operator>.</operator><name>surround</name><operator>.</operator><name>query</name><operator>.</operator><name>*</name></name>;</import>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">74</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">72</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@ <name>class</name> <name>SurroundQParser</name> extends <name>QParser</name> <block>{
 
   @<expr><name>Override</name>
   <specifier>public</specifier> <name>Query</name> <call><name>parse</name><argument_list>()</argument_list></call>
      <throws>throws <argument><expr><name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>queryparser</name><operator>.</operator><name>classic</name><operator>.</operator><name>ParseException</name></name> <block>{</block></expr></argument></throws>
      <throws>throws <argument><expr><name>SyntaxError</name> <block>{
     <expr><name>SrndQuery</name> <name>sq</name></expr></block></expr></argument></throws></expr>;
     <name>String</name> <name>qstr</name> <operator>=</operator> <call><name>getString</name><argument_list>()</argument_list></call></block></expr>;</expr_stmt>
     <if_stmt><if>if <condition>(<expr><name>qstr</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><block type="pseudo"><block_content>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">95</literal></expr><operator>,</operator><expr><literal type="number">8</literal> <operator>+</operator><literal type="number">93</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@ <name>class</name> <name>SurroundQParser</name> extends <name>QParser</name> <block>{
       <expr><name>sq</name> <operator>=</operator> <call><name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>queryparser</name><operator>.</operator><name>surround</name><operator>.</operator><name>parser</name><operator>.</operator><name>QueryParser</name>
           <operator>.</operator><name>parse</name></name><argument_list>(<argument><expr><name>qstr</name></expr></argument>)</argument_list></call></expr>;
     }</block></expr></expr_stmt></block_content></block></if></if_stmt> <catch>catch <parameter_list>(<parameter><decl><type><name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>queryparser</name><operator>.</operator><name>surround</name><operator>.</operator><name>parser</name><operator>.</operator><name>ParseException</name></name></type> <name>pe</name></decl></parameter>)</parameter_list> <block>{<block_content>
      <throw>throw <expr><operator>new</operator> <call><name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>queryparser</name><operator>.</operator><name>classic</name><operator>.</operator><name>ParseException</name></name><argument_list>(
          <argument><expr><call><name><name>pe</name><operator>.</operator><name>getMessage</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw>
      <throw>throw <expr><operator>new</operator> <call><name>SyntaxError</name><argument_list>(<argument><expr><name>pe</name></expr></argument>)</argument_list></call></expr>;</throw>
     </block_content>}</block></catch>
     
     <comment type="line">// so what do we do with the SrndQuery ??</comment>
<expr_stmt><expr><name>diff</name> <operator>--</operator><name>git</name> <name>a</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>search</name><operator>/</operator><name><name>SyntaxError</name><operator>.</operator><name>java</name></name> <name>b</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>search</name><operator>/</operator><name><name>SyntaxError</name><operator>.</operator><name>java</name></name>
<operator>new</operator> <name>file</name> <name>mode</name> <literal type="number">100644</literal>
<name>index</name> <literal type="number">00000000000..b26ca43f5d8</literal>
<operator>--</operator> <operator>/</operator><name>dev</name><operator>/</operator><literal type="null">null</literal>
<operator>++</operator> <name>b</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>search</name><operator>/</operator><name><name>SyntaxError</name><operator>.</operator><name>java</name></name>
@@ <operator>-</operator><literal type="number">0</literal></expr><operator>,</operator><expr><literal type="number">0</literal> <operator>+</operator><literal type="number">1</literal></expr><operator>,</operator><expr><literal type="number">31</literal> @@</expr></expr_stmt>
<comment type="block">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</comment>

<package>package <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>search</name></name>;</package>

<comment type="block" format="javadoc">/** Simple checked exception for parsing errors */</comment>
<class><specifier>public</specifier> class <name>SyntaxError</name> <super_list><extends>extends <super><name>Exception</name></super></extends></super_list> <block>{
  <constructor><specifier>public</specifier> <name>SyntaxError</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>msg</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>super</name><argument_list>(<argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></constructor>
  <constructor><specifier>public</specifier> <name>SyntaxError</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>msg</name></decl></parameter>, <parameter><decl><type><name>Throwable</name></type> <name>cause</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>super</name><argument_list>(<argument><expr><name>msg</name></expr></argument>, <argument><expr><name>cause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></constructor>
  <constructor><specifier>public</specifier> <name>SyntaxError</name><parameter_list>(<parameter><decl><type><name>Throwable</name></type> <name>cause</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>super</name><argument_list>(<argument><expr><name>cause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></constructor>
}</block></class>
<expr_stmt><expr><name>diff</name> <operator>--</operator><name>git</name> <name>a</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>search</name><operator>/</operator><name><name>ValueSourceParser</name><operator>.</operator><name>java</name></name> <name>b</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>search</name><operator>/</operator><name><name>ValueSourceParser</name><operator>.</operator><name>java</name></name>
<name>index</name> <literal type="number">897dde8ee81</literal><operator>..</operator><literal type="number">3a935f7166c</literal> <literal type="number">100755</literal>
<operator>--</operator> <name>a</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>search</name><operator>/</operator><name><name>ValueSourceParser</name><operator>.</operator><name>java</name></name>
<operator>++</operator> <name>b</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>search</name><operator>/</operator><name><name>ValueSourceParser</name><operator>.</operator><name>java</name></name>
@@ <operator>-</operator><literal type="number">26</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">26</literal></expr><operator>,</operator><expr><literal type="number">6</literal> @@</expr></expr_stmt> <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>queries</name><operator>.</operator><name>function</name><operator>.</operator><name>docvalues</name><operator>.</operator><name>BoolDocValues</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>queries</name><operator>.</operator><name>function</name><operator>.</operator><name>docvalues</name><operator>.</operator><name>DoubleDocValues</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>queries</name><operator>.</operator><name>function</name><operator>.</operator><name>docvalues</name><operator>.</operator><name>LongDocValues</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>queries</name><operator>.</operator><name>function</name><operator>.</operator><name>valuesource</name><operator>.</operator><name>*</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>queryparser</name><operator>.</operator><name>classic</name><operator>.</operator><name>ParseException</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>search</name><operator>.</operator><name>Query</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>search</name><operator>.</operator><name>IndexSearcher</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>search</name><operator>.</operator><name>SortField</name></name>;</import>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">61</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">60</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@ <specifier>public</specifier> <specifier>abstract</specifier> <name>class</name> <name>ValueSourceParser</name> implements <name>NamedListInitializedPlugin</name> <block>{
   <comment type="block" format="javadoc">/**
    * Parse the user input into a ValueSource.
    */</comment>
  <expr><specifier>public</specifier> <specifier>abstract</specifier> <name>ValueSource</name> <call><name>parse</name><argument_list>(<argument><expr><name>FunctionQParser</name> <name>fp</name></expr></argument>)</argument_list></call> <throws>throws <argument><expr><name>ParseException</name></expr></argument></throws></expr>;
  <specifier>public</specifier> <specifier>abstract</specifier> <name>ValueSource</name> <call><name>parse</name><argument_list>(<argument><expr><name>FunctionQParser</name> <name>fp</name></expr></argument>)</argument_list></call> <throws>throws <argument><expr><name>SyntaxError</name></expr></argument></throws></block></expr>;</expr_stmt>
 
   <comment type="block">/* standard functions */</comment>
   <decl_stmt><decl><type><specifier>public</specifier> <specifier>static</specifier> <name><name>Map</name><argument_list type="generic">&lt;<argument><name>String</name></argument>, <argument><name>ValueSourceParser</name></argument>&gt;</argument_list></name></type> <name>standardValueSourceParsers</name> <init>= <expr><operator>new</operator> <call><name><name>HashMap</name><argument_list type="generic">&lt;<argument><name>String</name></argument>, <argument><name>ValueSourceParser</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">87</literal></expr><operator>,</operator><expr><literal type="number">33</literal> <operator>+</operator><literal type="number">86</literal></expr><operator>,</operator><expr><literal type="number">33</literal> @@ <specifier>public</specifier> <specifier>abstract</specifier> <name>class</name> <name>ValueSourceParser</name> implements <name>NamedListInitializedPlugin</name> <block>{
   <expr><specifier>static</specifier> <block>{
     <expr><call><name>addParser</name><argument_list>(<argument><expr><literal type="string">"testfunc"</literal></expr></argument>, <argument><expr><operator>new</operator> <class><super><name>ValueSourceParser</name></super><argument_list>()</argument_list> <block>{
       <function><annotation>@<name>Override</name></annotation>
      <type><specifier>public</specifier> <name>ValueSource</name></type> <name>parse</name><parameter_list>(<parameter><decl><type><name>FunctionQParser</name></type> <name>fp</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>ParseException</name></expr></argument></throws> <block>{<block_content>
      <function><type><specifier>public</specifier> <name>ValueSource</name></type> <name>parse</name><parameter_list>(<parameter><decl><type><name>FunctionQParser</name></type> <name>fp</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>SyntaxError</name></expr></argument></throws> <block>{<block_content>
         <decl_stmt><decl><type><specifier>final</specifier> <name>ValueSource</name></type> <name>source</name> <init>= <expr><call><name><name>fp</name><operator>.</operator><name>parseValueSource</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
         <return>return <expr><operator>new</operator> <call><name>TestValueSource</name><argument_list>(<argument><expr><name>source</name></expr></argument>)</argument_list></call></expr>;</return>
       <expr_stmt/>}</block_content>
     }</block></function>)</block_content></block>;</function>
     <expr_stmt><expr><call><name>addParser</name><argument_list>(<argument><expr><literal type="string">"ord"</literal></expr></argument>, <argument><expr><operator>new</operator> <class><super><name>ValueSourceParser</name></super><argument_list>()</argument_list> <block>{
       <function><annotation>@<name>Override</name></annotation>
      <type><specifier>public</specifier> <name>ValueSource</name></type> <name>parse</name><parameter_list>(<parameter><decl><type><name>FunctionQParser</name></type> <name>fp</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>ParseException</name></expr></argument></throws> <block>{<block_content>
      <function><type><specifier>public</specifier> <name>ValueSource</name></type> <name>parse</name><parameter_list>(<parameter><decl><type><name>FunctionQParser</name></type> <name>fp</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>SyntaxError</name></expr></argument></throws> <block>{<block_content>
         <decl_stmt><decl><type><name>String</name></type> <name>field</name> <init>= <expr><call><name><name>fp</name><operator>.</operator><name>parseId</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
         <return>return <expr><operator>new</operator> <call><name>OrdFieldSource</name><argument_list>(<argument><expr><name>field</name></expr></argument>)</argument_list></call></expr>;</return>
       <expr_stmt/>}</block_content>
     }</block></function>)</block_content></block>;</function>
     <expr_stmt><expr><call><name>addParser</name><argument_list>(<argument><expr><literal type="string">"literal"</literal></expr></argument>, <argument><expr><operator>new</operator> <class><super><name>ValueSourceParser</name></super><argument_list>()</argument_list> <block>{
       <function><annotation>@<name>Override</name></annotation>
      <type><specifier>public</specifier> <name>ValueSource</name></type> <name>parse</name><parameter_list>(<parameter><decl><type><name>FunctionQParser</name></type> <name>fp</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>ParseException</name></expr></argument></throws> <block>{<block_content>
      <function><type><specifier>public</specifier> <name>ValueSource</name></type> <name>parse</name><parameter_list>(<parameter><decl><type><name>FunctionQParser</name></type> <name>fp</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>SyntaxError</name></expr></argument></throws> <block>{<block_content>
         <return>return <expr><operator>new</operator> <call><name>LiteralValueSource</name><argument_list>(<argument><expr><call><name><name>fp</name><operator>.</operator><name>parseArg</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
       <expr_stmt/>}</block_content>
     }</block></function>)</block_content></block>;</function>
     <expr_stmt><expr><call><name>addParser</name><argument_list>(<argument><expr><literal type="string">"threadid"</literal></expr></argument>, <argument><expr><operator>new</operator> <class><super><name>ValueSourceParser</name></super><argument_list>()</argument_list> <block>{
       <function><annotation>@<name>Override</name></annotation>
      <type><specifier>public</specifier> <name>ValueSource</name></type> <name>parse</name><parameter_list>(<parameter><decl><type><name>FunctionQParser</name></type> <name>fp</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>ParseException</name></expr></argument></throws> <block>{<block_content>
      <function><type><specifier>public</specifier> <name>ValueSource</name></type> <name>parse</name><parameter_list>(<parameter><decl><type><name>FunctionQParser</name></type> <name>fp</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>SyntaxError</name></expr></argument></throws> <block>{<block_content>
         <return>return <expr><operator>new</operator> <call><name>LongConstValueSource</name><argument_list>(<argument><expr><call><name><name>Thread</name><operator>.</operator><name>currentThread</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
       <expr_stmt/>}</block_content>
     }</block></function>)</block_content></block>;</function>
     <expr_stmt><expr><call><name>addParser</name><argument_list>(<argument><expr><literal type="string">"sleep"</literal></expr></argument>, <argument><expr><operator>new</operator> <class><super><name>ValueSourceParser</name></super><argument_list>()</argument_list> <block>{
       <function><annotation>@<name>Override</name></annotation>
      <type><specifier>public</specifier> <name>ValueSource</name></type> <name>parse</name><parameter_list>(<parameter><decl><type><name>FunctionQParser</name></type> <name>fp</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>ParseException</name></expr></argument></throws> <block>{<block_content>
      <function><type><specifier>public</specifier> <name>ValueSource</name></type> <name>parse</name><parameter_list>(<parameter><decl><type><name>FunctionQParser</name></type> <name>fp</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>SyntaxError</name></expr></argument></throws> <block>{<block_content>
         <decl_stmt><decl><type><name>int</name></type> <name>ms</name> <init>= <expr><call><name><name>fp</name><operator>.</operator><name>parseInt</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
         <decl_stmt><decl><type><name>ValueSource</name></type> <name>source</name> <init>= <expr><call><name><name>fp</name><operator>.</operator><name>parseValueSource</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
         <try>try <block>{<block_content>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">126</literal></expr><operator>,</operator><expr><literal type="number">14</literal> <operator>+</operator><literal type="number">125</literal></expr><operator>,</operator><expr><literal type="number">14</literal> @@ <specifier>public</specifier> <specifier>abstract</specifier> class <name>ValueSourceParser</name> implements <name>NamedListInitializedPlugin</name> <block>{
     }</block></expr></expr_stmt></block_content></block></try></block_content></block></function></block_content></block></function></block></class></expr></argument>)</argument_list></call></expr>;</expr_stmt>
     <expr_stmt><expr><call><name>addParser</name><argument_list>(<argument><expr><literal type="string">"rord"</literal></expr></argument>, <argument><expr><operator>new</operator> <class><super><name>ValueSourceParser</name></super><argument_list>()</argument_list> <block>{
       <function><annotation>@<name>Override</name></annotation>
      <type><specifier>public</specifier> <name>ValueSource</name></type> <name>parse</name><parameter_list>(<parameter><decl><type><name>FunctionQParser</name></type> <name>fp</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>ParseException</name></expr></argument></throws> <block>{<block_content>
      <function><type><specifier>public</specifier> <name>ValueSource</name></type> <name>parse</name><parameter_list>(<parameter><decl><type><name>FunctionQParser</name></type> <name>fp</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>SyntaxError</name></expr></argument></throws> <block>{<block_content>
         <decl_stmt><decl><type><name>String</name></type> <name>field</name> <init>= <expr><call><name><name>fp</name><operator>.</operator><name>parseId</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
         <return>return <expr><operator>new</operator> <call><name>ReverseOrdFieldSource</name><argument_list>(<argument><expr><name>field</name></expr></argument>)</argument_list></call></expr>;</return>
       <expr_stmt/>}</block_content>
     }</block></function>)</block_content></block>;</function>
     <expr_stmt><expr><call><name>addParser</name><argument_list>(<argument><expr><literal type="string">"top"</literal></expr></argument>, <argument><expr><operator>new</operator> <class><super><name>ValueSourceParser</name></super><argument_list>()</argument_list> <block>{
       <function><annotation>@<name>Override</name></annotation>
      <type><specifier>public</specifier> <name>ValueSource</name></type> <name>parse</name><parameter_list>(<parameter><decl><type><name>FunctionQParser</name></type> <name>fp</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>ParseException</name></expr></argument></throws> <block>{<block_content>
      <function><type><specifier>public</specifier> <name>ValueSource</name></type> <name>parse</name><parameter_list>(<parameter><decl><type><name>FunctionQParser</name></type> <name>fp</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>SyntaxError</name></expr></argument></throws> <block>{<block_content>
         <comment type="line">// top(vs) is now a no-op</comment>
         <decl_stmt><decl><type><name>ValueSource</name></type> <name>source</name> <init>= <expr><call><name><name>fp</name><operator>.</operator><name>parseValueSource</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
         <return>return <expr><name>source</name></expr>;</return>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">141</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">140</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@ <specifier>public</specifier> <specifier>abstract</specifier> class <name>ValueSourceParser</name> implements <name>NamedListInitializedPlugin</name> <block>{
     }</block></expr></expr_stmt></block_content></block></function></block_content></block></function></block></class></expr></argument>)</argument_list></call></expr>;</expr_stmt>
     <expr_stmt><expr><call><name>addParser</name><argument_list>(<argument><expr><literal type="string">"linear"</literal></expr></argument>, <argument><expr><operator>new</operator> <class><super><name>ValueSourceParser</name></super><argument_list>()</argument_list> <block>{
       <function><annotation>@<name>Override</name></annotation>
      <type><specifier>public</specifier> <name>ValueSource</name></type> <name>parse</name><parameter_list>(<parameter><decl><type><name>FunctionQParser</name></type> <name>fp</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>ParseException</name></expr></argument></throws> <block>{<block_content>
      <function><type><specifier>public</specifier> <name>ValueSource</name></type> <name>parse</name><parameter_list>(<parameter><decl><type><name>FunctionQParser</name></type> <name>fp</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>SyntaxError</name></expr></argument></throws> <block>{<block_content>
         <decl_stmt><decl><type><name>ValueSource</name></type> <name>source</name> <init>= <expr><call><name><name>fp</name><operator>.</operator><name>parseValueSource</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
         <decl_stmt><decl><type><name>float</name></type> <name>slope</name> <init>= <expr><call><name><name>fp</name><operator>.</operator><name>parseFloat</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
         <decl_stmt><decl><type><name>float</name></type> <name>intercept</name> <init>= <expr><call><name><name>fp</name><operator>.</operator><name>parseFloat</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">150</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">149</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@ <specifier>public</specifier> <specifier>abstract</specifier> class <name>ValueSourceParser</name> implements <name>NamedListInitializedPlugin</name> <block>{
     }</block></expr></expr_stmt></block_content></block></function></block_content></block></function></block></class></expr></argument>)</argument_list></call></expr>;</expr_stmt>
     <expr_stmt><expr><call><name>addParser</name><argument_list>(<argument><expr><literal type="string">"recip"</literal></expr></argument>, <argument><expr><operator>new</operator> <class><super><name>ValueSourceParser</name></super><argument_list>()</argument_list> <block>{
       <function><annotation>@<name>Override</name></annotation>
      <type><specifier>public</specifier> <name>ValueSource</name></type> <name>parse</name><parameter_list>(<parameter><decl><type><name>FunctionQParser</name></type> <name>fp</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>ParseException</name></expr></argument></throws> <block>{<block_content>
      <function><type><specifier>public</specifier> <name>ValueSource</name></type> <name>parse</name><parameter_list>(<parameter><decl><type><name>FunctionQParser</name></type> <name>fp</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>SyntaxError</name></expr></argument></throws> <block>{<block_content>
         <decl_stmt><decl><type><name>ValueSource</name></type> <name>source</name> <init>= <expr><call><name><name>fp</name><operator>.</operator><name>parseValueSource</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
         <decl_stmt><decl><type><name>float</name></type> <name>m</name> <init>= <expr><call><name><name>fp</name><operator>.</operator><name>parseFloat</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
         <decl_stmt><decl><type><name>float</name></type> <name>a</name> <init>= <expr><call><name><name>fp</name><operator>.</operator><name>parseFloat</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">160</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">159</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@ <specifier>public</specifier> <specifier>abstract</specifier> class <name>ValueSourceParser</name> implements <name>NamedListInitializedPlugin</name> <block>{
     }</block></expr></expr_stmt></block_content></block></function></block_content></block></function></block></class></expr></argument>)</argument_list></call></expr>;</expr_stmt>
     <expr_stmt><expr><call><name>addParser</name><argument_list>(<argument><expr><literal type="string">"scale"</literal></expr></argument>, <argument><expr><operator>new</operator> <class><super><name>ValueSourceParser</name></super><argument_list>()</argument_list> <block>{
       <function><annotation>@<name>Override</name></annotation>
      <type><specifier>public</specifier> <name>ValueSource</name></type> <name>parse</name><parameter_list>(<parameter><decl><type><name>FunctionQParser</name></type> <name>fp</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>ParseException</name></expr></argument></throws> <block>{<block_content>
      <function><type><specifier>public</specifier> <name>ValueSource</name></type> <name>parse</name><parameter_list>(<parameter><decl><type><name>FunctionQParser</name></type> <name>fp</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>SyntaxError</name></expr></argument></throws> <block>{<block_content>
         <decl_stmt><decl><type><name>ValueSource</name></type> <name>source</name> <init>= <expr><call><name><name>fp</name><operator>.</operator><name>parseValueSource</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
         <decl_stmt><decl><type><name>float</name></type> <name>min</name> <init>= <expr><call><name><name>fp</name><operator>.</operator><name>parseFloat</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
         <decl_stmt><decl><type><name>float</name></type> <name>max</name> <init>= <expr><call><name><name>fp</name><operator>.</operator><name>parseFloat</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">169</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">168</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@ <specifier>public</specifier> <specifier>abstract</specifier> class <name>ValueSourceParser</name> implements <name>NamedListInitializedPlugin</name> <block>{
     }</block></expr></expr_stmt></block_content></block></function></block_content></block></function></block></class></expr></argument>)</argument_list></call></expr>;</expr_stmt>
     <expr_stmt><expr><call><name>addParser</name><argument_list>(<argument><expr><literal type="string">"div"</literal></expr></argument>, <argument><expr><operator>new</operator> <class><super><name>ValueSourceParser</name></super><argument_list>()</argument_list> <block>{
       <function><annotation>@<name>Override</name></annotation>
      <type><specifier>public</specifier> <name>ValueSource</name></type> <name>parse</name><parameter_list>(<parameter><decl><type><name>FunctionQParser</name></type> <name>fp</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>ParseException</name></expr></argument></throws> <block>{<block_content>
      <function><type><specifier>public</specifier> <name>ValueSource</name></type> <name>parse</name><parameter_list>(<parameter><decl><type><name>FunctionQParser</name></type> <name>fp</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>SyntaxError</name></expr></argument></throws> <block>{<block_content>
         <decl_stmt><decl><type><name>ValueSource</name></type> <name>a</name> <init>= <expr><call><name><name>fp</name><operator>.</operator><name>parseValueSource</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
         <decl_stmt><decl><type><name>ValueSource</name></type> <name>b</name> <init>= <expr><call><name><name>fp</name><operator>.</operator><name>parseValueSource</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
         <return>return <expr><operator>new</operator> <call><name>DivFloatFunction</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</return>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">177</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">176</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@ <specifier>public</specifier> <specifier>abstract</specifier> class <name>ValueSourceParser</name> implements <name>NamedListInitializedPlugin</name> <block>{
     }</block></expr></expr_stmt></block_content></block></function></block_content></block></function></block></class></expr></argument>)</argument_list></call></expr>;</expr_stmt>
     <expr_stmt><expr><call><name>addParser</name><argument_list>(<argument><expr><literal type="string">"mod"</literal></expr></argument>, <argument><expr><operator>new</operator> <class><super><name>ValueSourceParser</name></super><argument_list>()</argument_list> <block>{
       <function><annotation>@<name>Override</name></annotation>
      <type><specifier>public</specifier> <name>ValueSource</name></type> <name>parse</name><parameter_list>(<parameter><decl><type><name>FunctionQParser</name></type> <name>fp</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>ParseException</name></expr></argument></throws> <block>{<block_content>
      <function><type><specifier>public</specifier> <name>ValueSource</name></type> <name>parse</name><parameter_list>(<parameter><decl><type><name>FunctionQParser</name></type> <name>fp</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>SyntaxError</name></expr></argument></throws> <block>{<block_content>
         <decl_stmt><decl><type><name>ValueSource</name></type> <name>a</name> <init>= <expr><call><name><name>fp</name><operator>.</operator><name>parseValueSource</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
         <decl_stmt><decl><type><name>ValueSource</name></type> <name>b</name> <init>= <expr><call><name><name>fp</name><operator>.</operator><name>parseValueSource</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
         <return>return <expr><operator>new</operator> <class><super><name>DualFloatFunction</name></super><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list> <block>{
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">194</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">193</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@ <specifier>public</specifier> <specifier>abstract</specifier> class <name>ValueSourceParser</name> implements <name>NamedListInitializedPlugin</name> <block>{
     }</block></expr></expr_stmt></block></class></expr></return></block_content></block></function></block_content></block></function></block></class></expr></argument>)</argument_list></call></expr>;</expr_stmt>
     <expr_stmt><expr><call><name>addParser</name><argument_list>(<argument><expr><literal type="string">"map"</literal></expr></argument>, <argument><expr><operator>new</operator> <class><super><name>ValueSourceParser</name></super><argument_list>()</argument_list> <block>{
       <function><annotation>@<name>Override</name></annotation>
      <type><specifier>public</specifier> <name>ValueSource</name></type> <name>parse</name><parameter_list>(<parameter><decl><type><name>FunctionQParser</name></type> <name>fp</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>ParseException</name></expr></argument></throws> <block>{<block_content>
      <function><type><specifier>public</specifier> <name>ValueSource</name></type> <name>parse</name><parameter_list>(<parameter><decl><type><name>FunctionQParser</name></type> <name>fp</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>SyntaxError</name></expr></argument></throws> <block>{<block_content>
         <decl_stmt><decl><type><name>ValueSource</name></type> <name>source</name> <init>= <expr><call><name><name>fp</name><operator>.</operator><name>parseValueSource</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
         <decl_stmt><decl><type><name>float</name></type> <name>min</name> <init>= <expr><call><name><name>fp</name><operator>.</operator><name>parseFloat</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
         <decl_stmt><decl><type><name>float</name></type> <name>max</name> <init>= <expr><call><name><name>fp</name><operator>.</operator><name>parseFloat</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">206</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">205</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@ <specifier>public</specifier> <specifier>abstract</specifier> class <name>ValueSourceParser</name> implements <name>NamedListInitializedPlugin</name> <block>{
 
     <expr><call><name>addParser</name><argument_list>(<argument><expr><literal type="string">"abs"</literal></expr></argument>, <argument><expr><operator>new</operator> <class><super><name>ValueSourceParser</name></super><argument_list>()</argument_list> <block>{
       <function><annotation>@<name>Override</name></annotation>
      <type><specifier>public</specifier> <name>ValueSource</name></type> <name>parse</name><parameter_list>(<parameter><decl><type><name>FunctionQParser</name></type> <name>fp</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>ParseException</name></expr></argument></throws> <block>{<block_content>
      <function><type><specifier>public</specifier> <name>ValueSource</name></type> <name>parse</name><parameter_list>(<parameter><decl><type><name>FunctionQParser</name></type> <name>fp</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>SyntaxError</name></expr></argument></throws> <block>{<block_content>
         <decl_stmt><decl><type><name>ValueSource</name></type> <name>source</name> <init>= <expr><call><name><name>fp</name><operator>.</operator><name>parseValueSource</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
         <return>return <expr><operator>new</operator> <class><super><name>SimpleFloatFunction</name></super><argument_list>(<argument><expr><name>source</name></expr></argument>)</argument_list> <block>{
           <annotation>@<name>Override</name></annotation>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">223</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">222</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@ <specifier>public</specifier> <specifier>abstract</specifier> class <name>ValueSourceParser</name> implements <name>NamedListInitializedPlugin</name> <block>{
     }</block></expr></expr_stmt></block></class></expr></return></block_content></block></function></block_content></block></function></block></class></expr></argument>)</argument_list></call></expr>;
     <call><name>addParser</name><argument_list>(<argument><expr><literal type="string">"sum"</literal></expr></argument>, <argument><expr><operator>new</operator> <class><super><name>ValueSourceParser</name></super><argument_list>()</argument_list> <block>{
       <function><annotation>@<name>Override</name></annotation>
      <type><specifier>public</specifier> <name>ValueSource</name></type> <name>parse</name><parameter_list>(<parameter><decl><type><name>FunctionQParser</name></type> <name>fp</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>ParseException</name></expr></argument></throws> <block>{<block_content>
      <function><type><specifier>public</specifier> <name>ValueSource</name></type> <name>parse</name><parameter_list>(<parameter><decl><type><name>FunctionQParser</name></type> <name>fp</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>SyntaxError</name></expr></argument></throws> <block>{<block_content>
         <decl_stmt><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name>ValueSource</name></argument>&gt;</argument_list></name></type> <name>sources</name> <init>= <expr><call><name><name>fp</name><operator>.</operator><name>parseValueSourceList</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
         <return>return <expr><operator>new</operator> <call><name>SumFloatFunction</name><argument_list>(<argument><expr><call><name><name>sources</name><operator>.</operator><name>toArray</name></name><argument_list>(<argument><expr><operator>new</operator> <name><name>ValueSource</name><index>[<expr><call><name><name>sources</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
       <expr_stmt/>}</block_content>
@@ -232</block><operator>,</operator>7 +231<operator>,</operator>7 @@ public abstract class ValueSourceParser implements NamedListInitializedPlugin <block>{<block_content>
 
     <expr_stmt><expr><call><name>addParser</name><argument_list>(<argument><expr><literal type="string">"product"</literal></expr></argument>, <argument><expr><operator>new</operator> <class><super><name>ValueSourceParser</name></super><argument_list>()</argument_list> <block>{
       <function><annotation>@<name>Override</name></annotation>
      <type><specifier>public</specifier> <name>ValueSource</name></type> <name>parse</name><parameter_list>(<parameter><decl><type><name>FunctionQParser</name></type> <name>fp</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>ParseException</name></expr></argument></throws> <block>{<block_content>
      <function><type><specifier>public</specifier> <name>ValueSource</name></type> <name>parse</name><parameter_list>(<parameter><decl><type><name>FunctionQParser</name></type> <name>fp</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>SyntaxError</name></expr></argument></throws> <block>{<block_content>
         <decl_stmt><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name>ValueSource</name></argument>&gt;</argument_list></name></type> <name>sources</name> <init>= <expr><call><name><name>fp</name><operator>.</operator><name>parseValueSourceList</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
         <return>return <expr><operator>new</operator> <call><name>ProductFloatFunction</name><argument_list>(<argument><expr><call><name><name>sources</name><operator>.</operator><name>toArray</name></name><argument_list>(<argument><expr><operator>new</operator> <name><name>ValueSource</name><index>[<expr><call><name><name>sources</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
       <expr_stmt/>}</block_content>
@@ -241</block><operator>,</operator>7 +240<operator>,</operator>7 @@ public abstract class ValueSourceParser implements NamedListInitializedPlugin <block>{<block_content>
 
     <expr_stmt><expr><call><name>addParser</name><argument_list>(<argument><expr><literal type="string">"sub"</literal></expr></argument>, <argument><expr><operator>new</operator> <class><super><name>ValueSourceParser</name></super><argument_list>()</argument_list> <block>{
       <function><annotation>@<name>Override</name></annotation>
      <type><specifier>public</specifier> <name>ValueSource</name></type> <name>parse</name><parameter_list>(<parameter><decl><type><name>FunctionQParser</name></type> <name>fp</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>ParseException</name></expr></argument></throws> <block>{<block_content>
      <function><type><specifier>public</specifier> <name>ValueSource</name></type> <name>parse</name><parameter_list>(<parameter><decl><type><name>FunctionQParser</name></type> <name>fp</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>SyntaxError</name></expr></argument></throws> <block>{<block_content>
         <decl_stmt><decl><type><name>ValueSource</name></type> <name>a</name> <init>= <expr><call><name><name>fp</name><operator>.</operator><name>parseValueSource</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
         <decl_stmt><decl><type><name>ValueSource</name></type> <name>b</name> <init>= <expr><call><name><name>fp</name><operator>.</operator><name>parseValueSource</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
         <return>return <expr><operator>new</operator> <class><super><name>DualFloatFunction</name></super><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list> <block>{
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">259</literal></expr><operator>,</operator><expr><literal type="number">14</literal> <operator>+</operator><literal type="number">258</literal></expr><operator>,</operator><expr><literal type="number">14</literal> @@ <specifier>public</specifier> <specifier>abstract</specifier> class <name>ValueSourceParser</name> implements <name>NamedListInitializedPlugin</name> <block>{
     }</block></expr></expr_stmt></block></class></expr></return></block_content></block></function></block_content></block></function></block></class></expr></argument>)</argument_list></call></expr>;</expr_stmt>
     <expr_stmt><expr><call><name>addParser</name><argument_list>(<argument><expr><literal type="string">"vector"</literal></expr></argument>, <argument><expr><operator>new</operator> <class><super><name>ValueSourceParser</name></super><argument_list>()</argument_list><block>{
       <function><annotation>@<name>Override</name></annotation>
      <type><specifier>public</specifier> <name>ValueSource</name></type> <name>parse</name><parameter_list>(<parameter><decl><type><name>FunctionQParser</name></type> <name>fp</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>ParseException</name></expr></argument></throws><block>{<block_content>
      <function><type><specifier>public</specifier> <name>ValueSource</name></type> <name>parse</name><parameter_list>(<parameter><decl><type><name>FunctionQParser</name></type> <name>fp</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>SyntaxError</name></expr></argument></throws> <block>{<block_content>
         <return>return <expr><operator>new</operator> <call><name>VectorValueSource</name><argument_list>(<argument><expr><call><name><name>fp</name><operator>.</operator><name>parseValueSourceList</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
       <expr_stmt/>}</block_content>
     }</block></function>)</block_content></block>;</function>
     <expr_stmt><expr><call><name>addParser</name><argument_list>(<argument><expr><literal type="string">"query"</literal></expr></argument>, <argument><expr><operator>new</operator> <class><super><name>ValueSourceParser</name></super><argument_list>()</argument_list> <block>{
       <comment type="line">// boost(query($q),rating)</comment>
       <function><annotation>@<name>Override</name></annotation>
      <type><specifier>public</specifier> <name>ValueSource</name></type> <name>parse</name><parameter_list>(<parameter><decl><type><name>FunctionQParser</name></type> <name>fp</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>ParseException</name></expr></argument></throws> <block>{<block_content>
      <function><type><specifier>public</specifier> <name>ValueSource</name></type> <name>parse</name><parameter_list>(<parameter><decl><type><name>FunctionQParser</name></type> <name>fp</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>SyntaxError</name></expr></argument></throws> <block>{<block_content>
         <decl_stmt><decl><type><name>Query</name></type> <name>q</name> <init>= <expr><call><name><name>fp</name><operator>.</operator><name>parseNestedQuery</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
         <decl_stmt><decl><type><name>float</name></type> <name>defVal</name> <init>= <expr><literal type="number">0.0f</literal></expr></init></decl>;</decl_stmt>
         <if_stmt><if>if <condition>(<expr><call><name><name>fp</name><operator>.</operator><name>hasMoreArguments</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">277</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">276</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@ <specifier>public</specifier> <specifier>abstract</specifier> class <name>ValueSourceParser</name> implements <name>NamedListInitializedPlugin</name> <block>{
     }</block></expr></expr_stmt></block_content></block></if></if_stmt></block_content></block></function></block_content></block></function></block></class></expr></argument>)</argument_list></call></expr>;</expr_stmt>
     <expr_stmt><expr><call><name>addParser</name><argument_list>(<argument><expr><literal type="string">"boost"</literal></expr></argument>, <argument><expr><operator>new</operator> <class><super><name>ValueSourceParser</name></super><argument_list>()</argument_list> <block>{
       <function><annotation>@<name>Override</name></annotation>
      <type><specifier>public</specifier> <name>ValueSource</name></type> <name>parse</name><parameter_list>(<parameter><decl><type><name>FunctionQParser</name></type> <name>fp</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>ParseException</name></expr></argument></throws> <block>{<block_content>
      <function><type><specifier>public</specifier> <name>ValueSource</name></type> <name>parse</name><parameter_list>(<parameter><decl><type><name>FunctionQParser</name></type> <name>fp</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>SyntaxError</name></expr></argument></throws> <block>{<block_content>
         <decl_stmt><decl><type><name>Query</name></type> <name>q</name> <init>= <expr><call><name><name>fp</name><operator>.</operator><name>parseNestedQuery</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
         <decl_stmt><decl><type><name>ValueSource</name></type> <name>vs</name> <init>= <expr><call><name><name>fp</name><operator>.</operator><name>parseValueSource</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
         <decl_stmt><decl><type><name>BoostedQuery</name></type> <name>bq</name> <init>= <expr><operator>new</operator> <call><name>BoostedQuery</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name>vs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">286</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">285</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@ <specifier>public</specifier> <specifier>abstract</specifier> class <name>ValueSourceParser</name> implements <name>NamedListInitializedPlugin</name> <block>{
     }</block></expr></expr_stmt></block_content></block></function></block_content></block></function></block></class></expr></argument>)</argument_list></call></expr>;</expr_stmt>
     <expr_stmt><expr><call><name>addParser</name><argument_list>(<argument><expr><literal type="string">"joindf"</literal></expr></argument>, <argument><expr><operator>new</operator> <class><super><name>ValueSourceParser</name></super><argument_list>()</argument_list> <block>{
       <function><annotation>@<name>Override</name></annotation>
      <type><specifier>public</specifier> <name>ValueSource</name></type> <name>parse</name><parameter_list>(<parameter><decl><type><name>FunctionQParser</name></type> <name>fp</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>ParseException</name></expr></argument></throws> <block>{<block_content>
      <function><type><specifier>public</specifier> <name>ValueSource</name></type> <name>parse</name><parameter_list>(<parameter><decl><type><name>FunctionQParser</name></type> <name>fp</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>SyntaxError</name></expr></argument></throws> <block>{<block_content>
         <decl_stmt><decl><type><name>String</name></type> <name>f0</name> <init>= <expr><call><name><name>fp</name><operator>.</operator><name>parseArg</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
         <decl_stmt><decl><type><name>String</name></type> <name>qf</name> <init>= <expr><call><name><name>fp</name><operator>.</operator><name>parseArg</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
         <return>return <expr><operator>new</operator> <call><name>JoinDocFreqValueSource</name><argument_list>( <argument><expr><name>f0</name></expr></argument>, <argument><expr><name>qf</name></expr></argument> )</argument_list></call></expr>;</return>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">297</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">296</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@ <specifier>public</specifier> <specifier>abstract</specifier> class <name>ValueSourceParser</name> implements <name>NamedListInitializedPlugin</name> <block>{
 
     <expr><call><name>addParser</name><argument_list>(<argument><expr><literal type="string">"hsin"</literal></expr></argument>, <argument><expr><operator>new</operator> <class><super><name>ValueSourceParser</name></super><argument_list>()</argument_list> <block>{
       <function><annotation>@<name>Override</name></annotation>
      <type><specifier>public</specifier> <name>ValueSource</name></type> <name>parse</name><parameter_list>(<parameter><decl><type><name>FunctionQParser</name></type> <name>fp</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>ParseException</name></expr></argument></throws> <block>{<block_content>
      <function><type><specifier>public</specifier> <name>ValueSource</name></type> <name>parse</name><parameter_list>(<parameter><decl><type><name>FunctionQParser</name></type> <name>fp</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>SyntaxError</name></expr></argument></throws> <block>{<block_content>
 
         <decl_stmt><decl><type><name>double</name></type> <name>radius</name> <init>= <expr><call><name><name>fp</name><operator>.</operator><name>parseDouble</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
         <comment type="line">//SOLR-2114, make the convert flag required, since the parser doesn't support much in the way of lookahead or the ability to convert a String into a ValueSource</comment>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">338</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">337</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@ <specifier>public</specifier> <specifier>abstract</specifier> class <name>ValueSourceParser</name> implements <name>NamedListInitializedPlugin</name> <block>{
 
     <expr><call><name>addParser</name><argument_list>(<argument><expr><literal type="string">"ghhsin"</literal></expr></argument>, <argument><expr><operator>new</operator> <class><super><name>ValueSourceParser</name></super><argument_list>()</argument_list> <block>{
       <function><annotation>@<name>Override</name></annotation>
      <type><specifier>public</specifier> <name>ValueSource</name></type> <name>parse</name><parameter_list>(<parameter><decl><type><name>FunctionQParser</name></type> <name>fp</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>ParseException</name></expr></argument></throws> <block>{<block_content>
      <function><type><specifier>public</specifier> <name>ValueSource</name></type> <name>parse</name><parameter_list>(<parameter><decl><type><name>FunctionQParser</name></type> <name>fp</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>SyntaxError</name></expr></argument></throws> <block>{<block_content>
         <decl_stmt><decl><type><name>double</name></type> <name>radius</name> <init>= <expr><call><name><name>fp</name><operator>.</operator><name>parseDouble</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
 
         <decl_stmt><decl><type><name>ValueSource</name></type> <name>gh1</name> <init>= <expr><call><name><name>fp</name><operator>.</operator><name>parseValueSource</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">350</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">349</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@ <specifier>public</specifier> <specifier>abstract</specifier> class <name>ValueSourceParser</name> implements <name>NamedListInitializedPlugin</name> <block>{
 
     <expr><call><name>addParser</name><argument_list>(<argument><expr><literal type="string">"geohash"</literal></expr></argument>, <argument><expr><operator>new</operator> <class><super><name>ValueSourceParser</name></super><argument_list>()</argument_list> <block>{
       <function><annotation>@<name>Override</name></annotation>
      <type><specifier>public</specifier> <name>ValueSource</name></type> <name>parse</name><parameter_list>(<parameter><decl><type><name>FunctionQParser</name></type> <name>fp</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>ParseException</name></expr></argument></throws> <block>{<block_content>
      <function><type><specifier>public</specifier> <name>ValueSource</name></type> <name>parse</name><parameter_list>(<parameter><decl><type><name>FunctionQParser</name></type> <name>fp</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>SyntaxError</name></expr></argument></throws> <block>{<block_content>
 
         <decl_stmt><decl><type><name>ValueSource</name></type> <name>lat</name> <init>= <expr><call><name><name>fp</name><operator>.</operator><name>parseValueSource</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
         <decl_stmt><decl><type><name>ValueSource</name></type> <name>lon</name> <init>= <expr><call><name><name>fp</name><operator>.</operator><name>parseValueSource</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">360</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">359</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@ <specifier>public</specifier> <specifier>abstract</specifier> class <name>ValueSourceParser</name> implements <name>NamedListInitializedPlugin</name> <block>{
     }</block></expr></expr_stmt></block_content></block></function></block_content></block></function></block></class></expr></argument>)</argument_list></call></expr>;
     <call><name>addParser</name><argument_list>(<argument><expr><literal type="string">"strdist"</literal></expr></argument>, <argument><expr><operator>new</operator> <class><super><name>ValueSourceParser</name></super><argument_list>()</argument_list> <block>{
       <function><annotation>@<name>Override</name></annotation>
      <type><specifier>public</specifier> <name>ValueSource</name></type> <name>parse</name><parameter_list>(<parameter><decl><type><name>FunctionQParser</name></type> <name>fp</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>ParseException</name></expr></argument></throws> <block>{<block_content>
      <function><type><specifier>public</specifier> <name>ValueSource</name></type> <name>parse</name><parameter_list>(<parameter><decl><type><name>FunctionQParser</name></type> <name>fp</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>SyntaxError</name></expr></argument></throws> <block>{<block_content>
 
         <decl_stmt><decl><type><name>ValueSource</name></type> <name>str1</name> <init>= <expr><call><name><name>fp</name><operator>.</operator><name>parseValueSource</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
         <decl_stmt><decl><type><name>ValueSource</name></type> <name>str2</name> <init>= <expr><call><name><name>fp</name><operator>.</operator><name>parseValueSource</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">385</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">384</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@ <specifier>public</specifier> <specifier>abstract</specifier> class <name>ValueSourceParser</name> implements <name>NamedListInitializedPlugin</name> <block>{
     }</block></expr></expr_stmt></block_content></block></function></block_content></block></function></block></class></expr></argument>)</argument_list></call></block></expr>;</expr_stmt>
     <expr_stmt><expr><call><name>addParser</name><argument_list>(<argument><expr><literal type="string">"field"</literal></expr></argument>, <argument><expr><operator>new</operator> <class><super><name>ValueSourceParser</name></super><argument_list>()</argument_list> <block>{
       <function><annotation>@<name>Override</name></annotation>
      <type><specifier>public</specifier> <name>ValueSource</name></type> <name>parse</name><parameter_list>(<parameter><decl><type><name>FunctionQParser</name></type> <name>fp</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>ParseException</name></expr></argument></throws> <block>{<block_content>
      <function><type><specifier>public</specifier> <name>ValueSource</name></type> <name>parse</name><parameter_list>(<parameter><decl><type><name>FunctionQParser</name></type> <name>fp</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>SyntaxError</name></expr></argument></throws> <block>{<block_content>
 
         <decl_stmt><decl><type><name>String</name></type> <name>fieldName</name> <init>= <expr><call><name><name>fp</name><operator>.</operator><name>parseArg</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
         <decl_stmt><decl><type><name>SchemaField</name></type> <name>f</name> <init>= <expr><call><name><name>fp</name><operator>.</operator><name>getReq</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSchema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getField</name><argument_list>(<argument><expr><name>fieldName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">527</literal></expr><operator>,</operator><expr><literal type="number">21</literal> <operator>+</operator><literal type="number">526</literal></expr><operator>,</operator><expr><literal type="number">21</literal> @@ <specifier>public</specifier> <specifier>abstract</specifier> class <name>ValueSourceParser</name> implements <name>NamedListInitializedPlugin</name> <block>{
     }</block></expr></expr_stmt></block_content></block></function></block_content></block></function></block></class></expr></argument>)</argument_list></call></expr>;</expr_stmt>
     <expr_stmt><expr><call><name>addParser</name><argument_list>(<argument><expr><literal type="string">"max"</literal></expr></argument>, <argument><expr><operator>new</operator> <class><super><name>ValueSourceParser</name></super><argument_list>()</argument_list> <block>{
       <function><annotation>@<name>Override</name></annotation>
      <type><specifier>public</specifier> <name>ValueSource</name></type> <name>parse</name><parameter_list>(<parameter><decl><type><name>FunctionQParser</name></type> <name>fp</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>ParseException</name></expr></argument></throws> <block>{<block_content>
      <function><type><specifier>public</specifier> <name>ValueSource</name></type> <name>parse</name><parameter_list>(<parameter><decl><type><name>FunctionQParser</name></type> <name>fp</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>SyntaxError</name></expr></argument></throws> <block>{<block_content>
         <decl_stmt><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name>ValueSource</name></argument>&gt;</argument_list></name></type> <name>sources</name> <init>= <expr><call><name><name>fp</name><operator>.</operator><name>parseValueSourceList</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
         <return>return <expr><operator>new</operator> <call><name>MaxFloatFunction</name><argument_list>(<argument><expr><call><name><name>sources</name><operator>.</operator><name>toArray</name></name><argument_list>(<argument><expr><operator>new</operator> <name><name>ValueSource</name><index>[<expr><call><name><name>sources</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
       <expr_stmt/>}</block_content>
     }</block></function>)</block_content></block>;</function>
     <expr_stmt><expr><call><name>addParser</name><argument_list>(<argument><expr><literal type="string">"min"</literal></expr></argument>, <argument><expr><operator>new</operator> <class><super><name>ValueSourceParser</name></super><argument_list>()</argument_list> <block>{
       <function><annotation>@<name>Override</name></annotation>
      <type><specifier>public</specifier> <name>ValueSource</name></type> <name>parse</name><parameter_list>(<parameter><decl><type><name>FunctionQParser</name></type> <name>fp</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>ParseException</name></expr></argument></throws> <block>{<block_content>
      <function><type><specifier>public</specifier> <name>ValueSource</name></type> <name>parse</name><parameter_list>(<parameter><decl><type><name>FunctionQParser</name></type> <name>fp</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>SyntaxError</name></expr></argument></throws> <block>{<block_content>
         <decl_stmt><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name>ValueSource</name></argument>&gt;</argument_list></name></type> <name>sources</name> <init>= <expr><call><name><name>fp</name><operator>.</operator><name>parseValueSourceList</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
         <return>return <expr><operator>new</operator> <call><name>MinFloatFunction</name><argument_list>(<argument><expr><call><name><name>sources</name><operator>.</operator><name>toArray</name></name><argument_list>(<argument><expr><operator>new</operator> <name><name>ValueSource</name><index>[<expr><call><name><name>sources</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
       <expr_stmt/>}</block_content>
     }</block></function>)</block_content></block>;</function>
     <expr_stmt><expr><call><name>addParser</name><argument_list>(<argument><expr><literal type="string">"sqedist"</literal></expr></argument>, <argument><expr><operator>new</operator> <class><super><name>ValueSourceParser</name></super><argument_list>()</argument_list> <block>{
       <function><annotation>@<name>Override</name></annotation>
      <type><specifier>public</specifier> <name>ValueSource</name></type> <name>parse</name><parameter_list>(<parameter><decl><type><name>FunctionQParser</name></type> <name>fp</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>ParseException</name></expr></argument></throws> <block>{<block_content>
      <function><type><specifier>public</specifier> <name>ValueSource</name></type> <name>parse</name><parameter_list>(<parameter><decl><type><name>FunctionQParser</name></type> <name>fp</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>SyntaxError</name></expr></argument></throws> <block>{<block_content>
         <decl_stmt><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name>ValueSource</name></argument>&gt;</argument_list></name></type> <name>sources</name> <init>= <expr><call><name><name>fp</name><operator>.</operator><name>parseValueSourceList</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
         <decl_stmt><decl><type><name>MVResult</name></type> <name>mvr</name> <init>= <expr><call><name>getMultiValueSources</name><argument_list>(<argument><expr><name>sources</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
 
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">551</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">550</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@ <specifier>public</specifier> <specifier>abstract</specifier> class <name>ValueSourceParser</name> implements <name>NamedListInitializedPlugin</name> <block>{
 
     <expr><call><name>addParser</name><argument_list>(<argument><expr><literal type="string">"dist"</literal></expr></argument>, <argument><expr><operator>new</operator> <class><super><name>ValueSourceParser</name></super><argument_list>()</argument_list> <block>{
       <function><annotation>@<name>Override</name></annotation>
      <type><specifier>public</specifier> <name>ValueSource</name></type> <name>parse</name><parameter_list>(<parameter><decl><type><name>FunctionQParser</name></type> <name>fp</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>ParseException</name></expr></argument></throws> <block>{<block_content>
      <function><type><specifier>public</specifier> <name>ValueSource</name></type> <name>parse</name><parameter_list>(<parameter><decl><type><name>FunctionQParser</name></type> <name>fp</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>SyntaxError</name></expr></argument></throws> <block>{<block_content>
         <decl_stmt><decl><type><name>float</name></type> <name>power</name> <init>= <expr><call><name><name>fp</name><operator>.</operator><name>parseFloat</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
         <decl_stmt><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name>ValueSource</name></argument>&gt;</argument_list></name></type> <name>sources</name> <init>= <expr><call><name><name>fp</name><operator>.</operator><name>parseValueSourceList</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
         <decl_stmt><decl><type><name>MVResult</name></type> <name>mvr</name> <init>= <expr><call><name>getMultiValueSources</name><argument_list>(<argument><expr><name>sources</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">577</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">576</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@ <specifier>public</specifier> <specifier>abstract</specifier> class <name>ValueSourceParser</name> implements <name>NamedListInitializedPlugin</name> <block>{
 
     <expr><call><name>addParser</name><argument_list>(<argument><expr><literal type="string">"docfreq"</literal></expr></argument>, <argument><expr><operator>new</operator> <class><super><name>ValueSourceParser</name></super><argument_list>()</argument_list> <block>{
       <function><annotation>@<name>Override</name></annotation>
      <type><specifier>public</specifier> <name>ValueSource</name></type> <name>parse</name><parameter_list>(<parameter><decl><type><name>FunctionQParser</name></type> <name>fp</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>ParseException</name></expr></argument></throws> <block>{<block_content>
      <function><type><specifier>public</specifier> <name>ValueSource</name></type> <name>parse</name><parameter_list>(<parameter><decl><type><name>FunctionQParser</name></type> <name>fp</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>SyntaxError</name></expr></argument></throws> <block>{<block_content>
         <decl_stmt><decl><type><name>TInfo</name></type> <name>tinfo</name> <init>= <expr><call><name>parseTerm</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
         <return>return <expr><operator>new</operator> <call><name>DocFreqValueSource</name><argument_list>(<argument><expr><name><name>tinfo</name><operator>.</operator><name>field</name></name></expr></argument>, <argument><expr><name><name>tinfo</name><operator>.</operator><name>val</name></name></expr></argument>, <argument><expr><name><name>tinfo</name><operator>.</operator><name>indexedField</name></name></expr></argument>, <argument><expr><name><name>tinfo</name><operator>.</operator><name>indexedBytes</name></name></expr></argument>)</argument_list></call></expr>;</return>
       <expr_stmt/>}</block_content>
@@ -585</block><operator>,</operator>7 +584<operator>,</operator>7 @@ public abstract class ValueSourceParser implements NamedListInitializedPlugin <block>{<block_content>
 
     <expr_stmt><expr><call><name>addParser</name><argument_list>(<argument><expr><literal type="string">"totaltermfreq"</literal></expr></argument>, <argument><expr><operator>new</operator> <class><super><name>ValueSourceParser</name></super><argument_list>()</argument_list> <block>{
       <function><annotation>@<name>Override</name></annotation>
      <type><specifier>public</specifier> <name>ValueSource</name></type> <name>parse</name><parameter_list>(<parameter><decl><type><name>FunctionQParser</name></type> <name>fp</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>ParseException</name></expr></argument></throws> <block>{<block_content>
      <function><type><specifier>public</specifier> <name>ValueSource</name></type> <name>parse</name><parameter_list>(<parameter><decl><type><name>FunctionQParser</name></type> <name>fp</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>SyntaxError</name></expr></argument></throws> <block>{<block_content>
         <decl_stmt><decl><type><name>TInfo</name></type> <name>tinfo</name> <init>= <expr><call><name>parseTerm</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
         <return>return <expr><operator>new</operator> <call><name>TotalTermFreqValueSource</name><argument_list>(<argument><expr><name><name>tinfo</name><operator>.</operator><name>field</name></name></expr></argument>, <argument><expr><name><name>tinfo</name><operator>.</operator><name>val</name></name></expr></argument>, <argument><expr><name><name>tinfo</name><operator>.</operator><name>indexedField</name></name></expr></argument>, <argument><expr><name><name>tinfo</name><operator>.</operator><name>indexedBytes</name></name></expr></argument>)</argument_list></call></expr>;</return>
       <expr_stmt/>}</block_content>
@@ -594</block><operator>,</operator>7 +593<operator>,</operator>7 @@ public abstract class ValueSourceParser implements NamedListInitializedPlugin <block>{<block_content>
 
     <expr_stmt><expr><call><name>addParser</name><argument_list>(<argument><expr><literal type="string">"sumtotaltermfreq"</literal></expr></argument>, <argument><expr><operator>new</operator> <class><super><name>ValueSourceParser</name></super><argument_list>()</argument_list> <block>{
       <function><annotation>@<name>Override</name></annotation>
      <type><specifier>public</specifier> <name>ValueSource</name></type> <name>parse</name><parameter_list>(<parameter><decl><type><name>FunctionQParser</name></type> <name>fp</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>ParseException</name></expr></argument></throws> <block>{<block_content>
      <function><type><specifier>public</specifier> <name>ValueSource</name></type> <name>parse</name><parameter_list>(<parameter><decl><type><name>FunctionQParser</name></type> <name>fp</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>SyntaxError</name></expr></argument></throws> <block>{<block_content>
         <decl_stmt><decl><type><name>String</name></type> <name>field</name> <init>= <expr><call><name><name>fp</name><operator>.</operator><name>parseArg</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
         <return>return <expr><operator>new</operator> <call><name>SumTotalTermFreqValueSource</name><argument_list>(<argument><expr><name>field</name></expr></argument>)</argument_list></call></expr>;</return>
       <expr_stmt/>}</block_content>
@@ -603</block><operator>,</operator>7 +602<operator>,</operator>7 @@ public abstract class ValueSourceParser implements NamedListInitializedPlugin <block>{<block_content>
 
     <expr_stmt><expr><call><name>addParser</name><argument_list>(<argument><expr><literal type="string">"idf"</literal></expr></argument>, <argument><expr><operator>new</operator> <class><super><name>ValueSourceParser</name></super><argument_list>()</argument_list> <block>{
       <function><annotation>@<name>Override</name></annotation>
      <type><specifier>public</specifier> <name>ValueSource</name></type> <name>parse</name><parameter_list>(<parameter><decl><type><name>FunctionQParser</name></type> <name>fp</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>ParseException</name></expr></argument></throws> <block>{<block_content>
      <function><type><specifier>public</specifier> <name>ValueSource</name></type> <name>parse</name><parameter_list>(<parameter><decl><type><name>FunctionQParser</name></type> <name>fp</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>SyntaxError</name></expr></argument></throws> <block>{<block_content>
         <decl_stmt><decl><type><name>TInfo</name></type> <name>tinfo</name> <init>= <expr><call><name>parseTerm</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
         <return>return <expr><operator>new</operator> <call><name>IDFValueSource</name><argument_list>(<argument><expr><name><name>tinfo</name><operator>.</operator><name>field</name></name></expr></argument>, <argument><expr><name><name>tinfo</name><operator>.</operator><name>val</name></name></expr></argument>, <argument><expr><name><name>tinfo</name><operator>.</operator><name>indexedField</name></name></expr></argument>, <argument><expr><name><name>tinfo</name><operator>.</operator><name>indexedBytes</name></name></expr></argument>)</argument_list></call></expr>;</return>
       <expr_stmt/>}</block_content>
@@ -611</block><operator>,</operator>7 +610<operator>,</operator>7 @@ public abstract class ValueSourceParser implements NamedListInitializedPlugin <block>{<block_content>
 
     <expr_stmt><expr><call><name>addParser</name><argument_list>(<argument><expr><literal type="string">"termfreq"</literal></expr></argument>, <argument><expr><operator>new</operator> <class><super><name>ValueSourceParser</name></super><argument_list>()</argument_list> <block>{
       <function><annotation>@<name>Override</name></annotation>
      <type><specifier>public</specifier> <name>ValueSource</name></type> <name>parse</name><parameter_list>(<parameter><decl><type><name>FunctionQParser</name></type> <name>fp</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>ParseException</name></expr></argument></throws> <block>{<block_content>
      <function><type><specifier>public</specifier> <name>ValueSource</name></type> <name>parse</name><parameter_list>(<parameter><decl><type><name>FunctionQParser</name></type> <name>fp</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>SyntaxError</name></expr></argument></throws> <block>{<block_content>
         <decl_stmt><decl><type><name>TInfo</name></type> <name>tinfo</name> <init>= <expr><call><name>parseTerm</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
         <return>return <expr><operator>new</operator> <call><name>TermFreqValueSource</name><argument_list>(<argument><expr><name><name>tinfo</name><operator>.</operator><name>field</name></name></expr></argument>, <argument><expr><name><name>tinfo</name><operator>.</operator><name>val</name></name></expr></argument>, <argument><expr><name><name>tinfo</name><operator>.</operator><name>indexedField</name></name></expr></argument>, <argument><expr><name><name>tinfo</name><operator>.</operator><name>indexedBytes</name></name></expr></argument>)</argument_list></call></expr>;</return>
       <expr_stmt/>}</block_content>
@@ -619</block><operator>,</operator>7 +618<operator>,</operator>7 @@ public abstract class ValueSourceParser implements NamedListInitializedPlugin <block>{<block_content>
 
     <expr_stmt><expr><call><name>addParser</name><argument_list>(<argument><expr><literal type="string">"tf"</literal></expr></argument>, <argument><expr><operator>new</operator> <class><super><name>ValueSourceParser</name></super><argument_list>()</argument_list> <block>{
       <function><annotation>@<name>Override</name></annotation>
      <type><specifier>public</specifier> <name>ValueSource</name></type> <name>parse</name><parameter_list>(<parameter><decl><type><name>FunctionQParser</name></type> <name>fp</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>ParseException</name></expr></argument></throws> <block>{<block_content>
      <function><type><specifier>public</specifier> <name>ValueSource</name></type> <name>parse</name><parameter_list>(<parameter><decl><type><name>FunctionQParser</name></type> <name>fp</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>SyntaxError</name></expr></argument></throws> <block>{<block_content>
         <decl_stmt><decl><type><name>TInfo</name></type> <name>tinfo</name> <init>= <expr><call><name>parseTerm</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
         <return>return <expr><operator>new</operator> <call><name>TFValueSource</name><argument_list>(<argument><expr><name><name>tinfo</name><operator>.</operator><name>field</name></name></expr></argument>, <argument><expr><name><name>tinfo</name><operator>.</operator><name>val</name></name></expr></argument>, <argument><expr><name><name>tinfo</name><operator>.</operator><name>indexedField</name></name></expr></argument>, <argument><expr><name><name>tinfo</name><operator>.</operator><name>indexedBytes</name></name></expr></argument>)</argument_list></call></expr>;</return>
       <expr_stmt/>}</block_content>
@@ -627</block><operator>,</operator>7 +626<operator>,</operator>7 @@ public abstract class ValueSourceParser implements NamedListInitializedPlugin <block>{<block_content>
 
     <expr_stmt><expr><call><name>addParser</name><argument_list>(<argument><expr><literal type="string">"norm"</literal></expr></argument>, <argument><expr><operator>new</operator> <class><super><name>ValueSourceParser</name></super><argument_list>()</argument_list> <block>{
       <function><annotation>@<name>Override</name></annotation>
      <type><specifier>public</specifier> <name>ValueSource</name></type> <name>parse</name><parameter_list>(<parameter><decl><type><name>FunctionQParser</name></type> <name>fp</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>ParseException</name></expr></argument></throws> <block>{<block_content>
      <function><type><specifier>public</specifier> <name>ValueSource</name></type> <name>parse</name><parameter_list>(<parameter><decl><type><name>FunctionQParser</name></type> <name>fp</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>SyntaxError</name></expr></argument></throws> <block>{<block_content>
         <decl_stmt><decl><type><name>String</name></type> <name>field</name> <init>= <expr><call><name><name>fp</name><operator>.</operator><name>parseArg</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
         <return>return <expr><operator>new</operator> <call><name>NormValueSource</name><argument_list>(<argument><expr><name>field</name></expr></argument>)</argument_list></call></expr>;</return>
       <expr_stmt/>}</block_content>
@@ -663</block><operator>,</operator>7 +662<operator>,</operator>7 @@ public abstract class ValueSourceParser implements NamedListInitializedPlugin <block>{<block_content>
 
     <expr_stmt><expr><call><name>addParser</name><argument_list>(<argument><expr><literal type="string">"exists"</literal></expr></argument>, <argument><expr><operator>new</operator> <class><super><name>ValueSourceParser</name></super><argument_list>()</argument_list> <block>{
       <function><annotation>@<name>Override</name></annotation>
      <type><specifier>public</specifier> <name>ValueSource</name></type> <name>parse</name><parameter_list>(<parameter><decl><type><name>FunctionQParser</name></type> <name>fp</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>ParseException</name></expr></argument></throws> <block>{<block_content>
      <function><type><specifier>public</specifier> <name>ValueSource</name></type> <name>parse</name><parameter_list>(<parameter><decl><type><name>FunctionQParser</name></type> <name>fp</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>SyntaxError</name></expr></argument></throws> <block>{<block_content>
         <decl_stmt><decl><type><name>ValueSource</name></type> <name>vs</name> <init>= <expr><call><name><name>fp</name><operator>.</operator><name>parseValueSource</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
         <return>return <expr><operator>new</operator> <class><super><name>SimpleBoolFunction</name></super><argument_list>(<argument><expr><name>vs</name></expr></argument>)</argument_list> <block>{
           <annotation>@<name>Override</name></annotation>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">680</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">679</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@ <specifier>public</specifier> <specifier>abstract</specifier> class <name>ValueSourceParser</name> implements <name>NamedListInitializedPlugin</name> <block>{
 
     <expr><call><name>addParser</name><argument_list>(<argument><expr><literal type="string">"not"</literal></expr></argument>, <argument><expr><operator>new</operator> <class><super><name>ValueSourceParser</name></super><argument_list>()</argument_list> <block>{
       <function><annotation>@<name>Override</name></annotation>
      <type><specifier>public</specifier> <name>ValueSource</name></type> <name>parse</name><parameter_list>(<parameter><decl><type><name>FunctionQParser</name></type> <name>fp</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>ParseException</name></expr></argument></throws> <block>{<block_content>
      <function><type><specifier>public</specifier> <name>ValueSource</name></type> <name>parse</name><parameter_list>(<parameter><decl><type><name>FunctionQParser</name></type> <name>fp</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>SyntaxError</name></expr></argument></throws> <block>{<block_content>
         <decl_stmt><decl><type><name>ValueSource</name></type> <name>vs</name> <init>= <expr><call><name><name>fp</name><operator>.</operator><name>parseValueSource</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
         <return>return <expr><operator>new</operator> <class><super><name>SimpleBoolFunction</name></super><argument_list>(<argument><expr><name>vs</name></expr></argument>)</argument_list> <block>{
           <annotation>@<name>Override</name></annotation>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">698</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">697</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@ <specifier>public</specifier> <specifier>abstract</specifier> class <name>ValueSourceParser</name> implements <name>NamedListInitializedPlugin</name> <block>{
 
     <expr><call><name>addParser</name><argument_list>(<argument><expr><literal type="string">"and"</literal></expr></argument>, <argument><expr><operator>new</operator> <class><super><name>ValueSourceParser</name></super><argument_list>()</argument_list> <block>{
       <function><annotation>@<name>Override</name></annotation>
      <type><specifier>public</specifier> <name>ValueSource</name></type> <name>parse</name><parameter_list>(<parameter><decl><type><name>FunctionQParser</name></type> <name>fp</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>ParseException</name></expr></argument></throws> <block>{<block_content>
      <function><type><specifier>public</specifier> <name>ValueSource</name></type> <name>parse</name><parameter_list>(<parameter><decl><type><name>FunctionQParser</name></type> <name>fp</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>SyntaxError</name></expr></argument></throws> <block>{<block_content>
         <decl_stmt><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name>ValueSource</name></argument>&gt;</argument_list></name></type> <name>sources</name> <init>= <expr><call><name><name>fp</name><operator>.</operator><name>parseValueSourceList</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
         <return>return <expr><operator>new</operator> <class><super><name>MultiBoolFunction</name></super><argument_list>(<argument><expr><name>sources</name></expr></argument>)</argument_list> <block>{
           <annotation>@<name>Override</name></annotation>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">717</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">716</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@ <specifier>public</specifier> <specifier>abstract</specifier> class <name>ValueSourceParser</name> implements <name>NamedListInitializedPlugin</name> <block>{
 
     <expr><call><name>addParser</name><argument_list>(<argument><expr><literal type="string">"or"</literal></expr></argument>, <argument><expr><operator>new</operator> <class><super><name>ValueSourceParser</name></super><argument_list>()</argument_list> <block>{
       <function><annotation>@<name>Override</name></annotation>
      <type><specifier>public</specifier> <name>ValueSource</name></type> <name>parse</name><parameter_list>(<parameter><decl><type><name>FunctionQParser</name></type> <name>fp</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>ParseException</name></expr></argument></throws> <block>{<block_content>
      <function><type><specifier>public</specifier> <name>ValueSource</name></type> <name>parse</name><parameter_list>(<parameter><decl><type><name>FunctionQParser</name></type> <name>fp</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>SyntaxError</name></expr></argument></throws> <block>{<block_content>
         <decl_stmt><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name>ValueSource</name></argument>&gt;</argument_list></name></type> <name>sources</name> <init>= <expr><call><name><name>fp</name><operator>.</operator><name>parseValueSourceList</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
         <return>return <expr><operator>new</operator> <class><super><name>MultiBoolFunction</name></super><argument_list>(<argument><expr><name>sources</name></expr></argument>)</argument_list> <block>{
           <annotation>@<name>Override</name></annotation>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">736</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">735</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@ <specifier>public</specifier> <specifier>abstract</specifier> class <name>ValueSourceParser</name> implements <name>NamedListInitializedPlugin</name> <block>{
 
     <expr><call><name>addParser</name><argument_list>(<argument><expr><literal type="string">"xor"</literal></expr></argument>, <argument><expr><operator>new</operator> <class><super><name>ValueSourceParser</name></super><argument_list>()</argument_list> <block>{
       <function><annotation>@<name>Override</name></annotation>
      <type><specifier>public</specifier> <name>ValueSource</name></type> <name>parse</name><parameter_list>(<parameter><decl><type><name>FunctionQParser</name></type> <name>fp</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>ParseException</name></expr></argument></throws> <block>{<block_content>
      <function><type><specifier>public</specifier> <name>ValueSource</name></type> <name>parse</name><parameter_list>(<parameter><decl><type><name>FunctionQParser</name></type> <name>fp</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>SyntaxError</name></expr></argument></throws> <block>{<block_content>
         <decl_stmt><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name>ValueSource</name></argument>&gt;</argument_list></name></type> <name>sources</name> <init>= <expr><call><name><name>fp</name><operator>.</operator><name>parseValueSourceList</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
         <return>return <expr><operator>new</operator> <class><super><name>MultiBoolFunction</name></super><argument_list>(<argument><expr><name>sources</name></expr></argument>)</argument_list> <block>{
           <annotation>@<name>Override</name></annotation>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">758</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">757</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@ <specifier>public</specifier> <specifier>abstract</specifier> class <name>ValueSourceParser</name> implements <name>NamedListInitializedPlugin</name> <block>{
 
     <expr><call><name>addParser</name><argument_list>(<argument><expr><literal type="string">"if"</literal></expr></argument>, <argument><expr><operator>new</operator> <class><super><name>ValueSourceParser</name></super><argument_list>()</argument_list> <block>{
       <function><annotation>@<name>Override</name></annotation>
      <type><specifier>public</specifier> <name>ValueSource</name></type> <name>parse</name><parameter_list>(<parameter><decl><type><name>FunctionQParser</name></type> <name>fp</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>ParseException</name></expr></argument></throws> <block>{<block_content>
      <function><type><specifier>public</specifier> <name>ValueSource</name></type> <name>parse</name><parameter_list>(<parameter><decl><type><name>FunctionQParser</name></type> <name>fp</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>SyntaxError</name></expr></argument></throws> <block>{<block_content>
         <decl_stmt><decl><type><name>ValueSource</name></type> <name>ifValueSource</name> <init>= <expr><call><name><name>fp</name><operator>.</operator><name>parseValueSource</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
         <decl_stmt><decl><type><name>ValueSource</name></type> <name>trueValueSource</name> <init>= <expr><call><name><name>fp</name><operator>.</operator><name>parseValueSource</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
         <decl_stmt><decl><type><name>ValueSource</name></type> <name>falseValueSource</name> <init>= <expr><call><name><name>fp</name><operator>.</operator><name>parseValueSource</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">769</literal></expr><operator>,</operator><expr><literal type="number">14</literal> <operator>+</operator><literal type="number">768</literal></expr><operator>,</operator><expr><literal type="number">14</literal> @@ <specifier>public</specifier> <specifier>abstract</specifier> class <name>ValueSourceParser</name> implements <name>NamedListInitializedPlugin</name> <block>{
 
     <expr><call><name>addParser</name><argument_list>(<argument><expr><literal type="string">"def"</literal></expr></argument>, <argument><expr><operator>new</operator> <class><super><name>ValueSourceParser</name></super><argument_list>()</argument_list> <block>{
       <function><annotation>@<name>Override</name></annotation>
      <type><specifier>public</specifier> <name>ValueSource</name></type> <name>parse</name><parameter_list>(<parameter><decl><type><name>FunctionQParser</name></type> <name>fp</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>ParseException</name></expr></argument></throws> <block>{<block_content>
      <function><type><specifier>public</specifier> <name>ValueSource</name></type> <name>parse</name><parameter_list>(<parameter><decl><type><name>FunctionQParser</name></type> <name>fp</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>SyntaxError</name></expr></argument></throws> <block>{<block_content>
         <return>return <expr><operator>new</operator> <call><name>DefFunction</name><argument_list>(<argument><expr><call><name><name>fp</name><operator>.</operator><name>parseValueSourceList</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
       <expr_stmt/>}</block_content>
     }</block></function>)</block_content></block>;</function>
 
   <expr_stmt/>}</block>
 
  <function><type><specifier>private</specifier> <specifier>static</specifier> <name>TInfo</name></type> <name>parseTerm</name><parameter_list>(<parameter><decl><type><name>FunctionQParser</name></type> <name>fp</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>ParseException</name></expr></argument></throws> <block>{<block_content>
  <function><type><specifier>private</specifier> <specifier>static</specifier> <name>TInfo</name></type> <name>parseTerm</name><parameter_list>(<parameter><decl><type><name>FunctionQParser</name></type> <name>fp</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>SyntaxError</name></expr></argument></throws> <block>{<block_content>
     <decl_stmt><decl><type><name>TInfo</name></type> <name>tinfo</name> <init>= <expr><operator>new</operator> <call><name>TInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
 
     <expr_stmt><expr><name><name>tinfo</name><operator>.</operator><name>indexedField</name></name> <operator>=</operator> <name><name>tinfo</name><operator>.</operator><name>field</name></name> <operator>=</operator> <call><name><name>fp</name><operator>.</operator><name>parseArg</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">888</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">887</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@ class <name>DateValueSourceParser</name> extends <name>ValueSourceParser</name> <block>{
   }</block>
 
   @<name>Override</name>
  <specifier>public</specifier> <name>ValueSource</name> <call><name>parse</name><argument_list>(<argument><expr><name>FunctionQParser</name> <name>fp</name></expr></argument>)</argument_list></call> <throws>throws <argument><expr><name>ParseException</name> <block>{
  <expr><specifier>public</specifier> <name>ValueSource</name> <call><name>parse</name><argument_list>(<argument><expr><name>FunctionQParser</name> <name>fp</name></expr></argument>)</argument_list></call></expr></block></expr></argument></throws> <throws>throws <argument><expr><name>SyntaxError</name> <block>{
     <expr><name>String</name> <name>first</name> <operator>=</operator> <call><name><name>fp</name><operator>.</operator><name>parseArg</name></name><argument_list>()</argument_list></call></expr></block></expr></argument></throws></expr>;</expr_stmt>
     <decl_stmt><decl><type><name>String</name></type> <name>second</name> <init>= <expr><call><name><name>fp</name><operator>.</operator><name>parseArg</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
     <if_stmt><if>if <condition>(<expr><name>first</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>first</name> <operator>=</operator> <literal type="string">"NOW"</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">1079</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">1078</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@ <specifier>abstract</specifier> class <name>DoubleParser</name> extends <name>NamedParser</name> <block>{
   <expr><specifier>public</specifier> <specifier>abstract</specifier> <name>double</name> <call><name>func</name><argument_list>(<argument><expr><name>int</name> <name>doc</name></expr></argument>, <argument><expr><name>FunctionValues</name> <name>vals</name></expr></argument>)</argument_list></call></expr>;
 
   @<name>Override</name>
  <specifier>public</specifier> <name>ValueSource</name> <call><name>parse</name><argument_list>(<argument><expr><name>FunctionQParser</name> <name>fp</name></expr></argument>)</argument_list></call> <throws>throws <argument><expr><name>ParseException</name> <block>{
  <expr><specifier>public</specifier> <name>ValueSource</name> <call><name>parse</name><argument_list>(<argument><expr><name>FunctionQParser</name> <name>fp</name></expr></argument>)</argument_list></call></expr></block></expr></argument></throws> <throws>throws <argument><expr><name>SyntaxError</name> <block>{</block></expr></argument></throws></block></expr></expr_stmt>
     <return>return <expr><operator>new</operator> <call><name>Function</name><argument_list>(<argument><expr><call><name><name>fp</name><operator>.</operator><name>parseValueSource</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
   <expr_stmt/>}</block_content>
 
@@ -1119</block><operator>,</operator>7 +1118<operator>,</operator>7 @@ abstract class Double2Parser extends NamedParser <block>{<block_content>
   <decl_stmt><decl><type><specifier>public</specifier> <specifier>abstract</specifier> <name>double</name></type> <name>func</name><argument_list>(<argument><expr><name>int</name> <name>doc</name></expr></argument>, <argument><expr><name>FunctionValues</name> <name>a</name></expr></argument>, <argument><expr><name>FunctionValues</name> <name>b</name></expr></argument>)</argument_list></decl>;</decl_stmt>
 
   <function><annotation>@<name>Override</name></annotation>
  <type><specifier>public</specifier> <name>ValueSource</name></type> <name>parse</name><parameter_list>(<parameter><decl><type><name>FunctionQParser</name></type> <name>fp</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>ParseException</name></expr></argument></throws> <block>{<block_content>
  <function><type><specifier>public</specifier> <name>ValueSource</name></type> <name>parse</name><parameter_list>(<parameter><decl><type><name>FunctionQParser</name></type> <name>fp</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>SyntaxError</name></expr></argument></throws> <block>{<block_content>
     <return>return <expr><operator>new</operator> <call><name>Function</name><argument_list>(<argument><expr><call><name><name>fp</name><operator>.</operator><name>parseValueSource</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>fp</name><operator>.</operator><name>parseValueSource</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
   <expr_stmt/>}</block_content>
 
diff --git a/solr/core/src/java/org/apache/solr/search/function/distance/HaversineConstFunction.java b/solr/core/src/java/org/apache/solr/search/function/distance/HaversineConstFunction.java
index 0876450f4b1..b9efc028ede 100755
-- a/solr/core/src/java/org/apache/solr/search/function/distance/HaversineConstFunction.java
++ b/solr/core/src/java/org/apache/solr/search/function/distance/HaversineConstFunction.java
@@ -24</block><operator>,</operator>7 +24<operator>,</operator>6 @@ import org.apache.lucene.queries.function.valuesource.ConstNumberSource;</function>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>queries</name><operator>.</operator><name>function</name><operator>.</operator><name>valuesource</name><operator>.</operator><name>DoubleConstValueSource</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>queries</name><operator>.</operator><name>function</name><operator>.</operator><name>valuesource</name><operator>.</operator><name>MultiValueSource</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>queries</name><operator>.</operator><name>function</name><operator>.</operator><name>valuesource</name><operator>.</operator><name>VectorValueSource</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>queryparser</name><operator>.</operator><name>classic</name><operator>.</operator><name>ParseException</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>search</name><operator>.</operator><name>IndexSearcher</name></name>;</import>
 <import>import <name><name>com</name><operator>.</operator><name>spatial4j</name><operator>.</operator><name>core</name><operator>.</operator><name>io</name><operator>.</operator><name>ParseUtils</name></name>;</import>
 <import>import <name><name>com</name><operator>.</operator><name>spatial4j</name><operator>.</operator><name>core</name><operator>.</operator><name>distance</name><operator>.</operator><name>DistanceUtils</name></name>;</import>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">32</literal></expr><operator>,</operator><expr><literal type="number">6</literal> <operator>+</operator><literal type="number">31</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@</expr></expr_stmt> <import>import <name><name>com</name><operator>.</operator><name>spatial4j</name><operator>.</operator><name>core</name><operator>.</operator><name>exception</name><operator>.</operator><name>InvalidShapeException</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>common</name><operator>.</operator><name>params</name><operator>.</operator><name>SpatialParams</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>schema</name><operator>.</operator><name>SchemaField</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>search</name><operator>.</operator><name>FunctionQParser</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>search</name><operator>.</operator><name>SyntaxError</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>search</name><operator>.</operator><name>ValueSourceParser</name></name>;</import>
 
 <import>import <name><name>java</name><operator>.</operator><name>io</name><operator>.</operator><name>IOException</name></name>;</import>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">48</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">48</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@ <specifier>public</specifier> class <name>HaversineConstFunction</name> extends <name>ValueSource</name> <block>{
 
   <expr><specifier>public</specifier> <specifier>static</specifier> <name>ValueSourceParser</name> <name>parser</name> <operator>=</operator> <operator>new</operator> <class><super><name>ValueSourceParser</name></super><argument_list>()</argument_list> <block>{
     <decl_stmt><decl><annotation>@<name>Override</name></annotation>
    <type><specifier>public</specifier> <name>ValueSource</name></type> <name>parse</name><argument_list>(<argument><expr><name>FunctionQParser</name> <name>fp</name></expr></argument>)</argument_list> <throws>throws <argument><expr><name>ParseException</name>
    <specifier>public</specifier> <name>ValueSource</name> <call><name>parse</name><argument_list>(<argument><expr><name>FunctionQParser</name> <name>fp</name></expr></argument>)</argument_list></call></expr></argument></throws> <throws>throws <argument><expr><name>SyntaxError</name>
     <block>{
       <comment type="line">// TODO: dispatch through SpatialQueryable in the future?</comment>
       <expr><name><name>List</name><argument_list type="generic">&lt;<argument><name>ValueSource</name></argument>&gt;</argument_list></name> <name>sources</name> <operator>=</operator> <call><name><name>fp</name><operator>.</operator><name>parseValueSourceList</name></name><argument_list>()</argument_list></call></expr></block></expr></argument></throws></decl>;</decl_stmt>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">65</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">65</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@ <specifier>public</specifier> class <name>HaversineConstFunction</name> extends <name>ValueSource</name> <block>{
       }</block></expr></expr_stmt> <if_stmt><if type="elseif">else if <condition>(<expr><call><name><name>sources</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
         <decl_stmt><decl><type><name>ValueSource</name></type> <name>vs</name> <init>= <expr><call><name><name>sources</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
         <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>vs</name> <operator>instanceof</operator> <name>MultiValueSource</name><operator>)</operator></expr>)</condition> <block>{<block_content>
          <throw>throw <expr><operator>new</operator> <call><name>ParseException</name><argument_list>(<argument><expr><literal type="string">"geodist - invalid parameters:"</literal> <operator>+</operator> <name>sources</name></expr></argument>)</argument_list></call></expr>;</throw>
          <throw>throw <expr><operator>new</operator> <call><name>SyntaxError</name><argument_list>(<argument><expr><literal type="string">"geodist - invalid parameters:"</literal> <operator>+</operator> <name>sources</name></expr></argument>)</argument_list></call></expr>;</throw>
         <expr_stmt/>}</block_content>
         mv1 = (MultiValueSource</block></if></if_stmt>)</block_content>vs</block><empty_stmt>;</empty_stmt></if></if_stmt>
       <expr_stmt/>}</block> <if_stmt><if type="elseif">else if <condition>(<expr><call><name><name>sources</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">88</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">88</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@ <specifier>public</specifier> class <name>HaversineConstFunction</name> extends <name>ValueSource</name> <block>{
           <expr><name>mv1</name> <operator>=</operator> <call><name>makeMV</name><argument_list>(<argument><expr><call><name><name>sources</name><operator>.</operator><name>subList</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>sources</name></expr></argument>)</argument_list></call></expr>;
           <name>vs1</name> <operator>=</operator> <call><name><name>sources</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></block></expr>;</expr_stmt>
           <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>vs1</name> <operator>instanceof</operator> <name>MultiValueSource</name><operator>)</operator></expr>)</condition> <block>{<block_content>
            <throw>throw <expr><operator>new</operator> <call><name>ParseException</name><argument_list>(<argument><expr><literal type="string">"geodist - invalid parameters:"</literal> <operator>+</operator> <name>sources</name></expr></argument>)</argument_list></call></expr>;</throw>
            <throw>throw <expr><operator>new</operator> <call><name>SyntaxError</name><argument_list>(<argument><expr><literal type="string">"geodist - invalid parameters:"</literal> <operator>+</operator> <name>sources</name></expr></argument>)</argument_list></call></expr>;</throw>
           <expr_stmt/>}</block_content>
           mv2 = (MultiValueSource</block></if></if_stmt>)</block_content>vs1</block><empty_stmt>;</empty_stmt></if></if_stmt></class></expr>
         }</block>
@@ <operator>-</operator><literal type="number">96</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">96</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@ <specifier>public</specifier> class <name>HaversineConstFunction</name> extends <name>ValueSource</name> <block>{
         <expr><name>mv1</name> <operator>=</operator> <call><name>makeMV</name><argument_list>(<argument><expr><call><name><name>sources</name><operator>.</operator><name>subList</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>sources</name></expr></argument>)</argument_list></call></expr>;
         <name>mv2</name> <operator>=</operator> <call><name>makeMV</name><argument_list>(<argument><expr><call><name><name>sources</name><operator>.</operator><name>subList</name></name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>,<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>sources</name></expr></argument>)</argument_list></call></block></expr>;</expr_stmt>
       <expr_stmt/>}</block_content> else if (sources.size(</block></function>)</block_content> &gt; 4</block></function>)</block_content> <block>{<block_content>
        <throw>throw <expr><operator>new</operator> <call><name>ParseException</name><argument_list>(<argument><expr><literal type="string">"geodist - invalid parameters:"</literal> <operator>+</operator> <name>sources</name></expr></argument>)</argument_list></call></expr>;</throw>
        <throw>throw <expr><operator>new</operator> <call><name>SyntaxError</name><argument_list>(<argument><expr><literal type="string">"geodist - invalid parameters:"</literal> <operator>+</operator> <name>sources</name></expr></argument>)</argument_list></call></expr>;</throw>
       <expr_stmt/>}</block_content>
 
       if (mv1 == null</block></block></function></class></expr></argument>)</argument_list></call> <block>{
@@ <expr><operator>-</operator><literal type="number">109</literal></expr>,<expr><literal type="number">7</literal> <operator>+</operator><literal type="number">109</literal></expr>,<expr><literal type="number">7</literal> @@ <specifier>public</specifier> class <name>HaversineConstFunction</name> extends <name>ValueSource</name> <block>{
       }</block></expr>
 
       <if_stmt><if>if <condition>(<expr><name>mv1</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <name>mv2</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
        <throw>throw <expr><operator>new</operator> <call><name>ParseException</name><argument_list>(<argument><expr><literal type="string">"geodist - not enough parameters:"</literal> <operator>+</operator> <name>sources</name></expr></argument>)</argument_list></call></expr>;</throw>
        <throw>throw <expr><operator>new</operator> <call><name>SyntaxError</name><argument_list>(<argument><expr><literal type="string">"geodist - not enough parameters:"</literal> <operator>+</operator> <name>sources</name></expr></argument>)</argument_list></call></expr>;</throw>
       <expr_stmt/>}</block_content>
 
       <comment type="line">// We have all the parameters at this point, now check if one of the points is constant</comment>
@@ -130</block><operator>,</operator><expr_stmt><expr><literal type="number">24</literal> <operator>+</operator><literal type="number">130</literal></expr><operator>,</operator><expr><literal type="number">24</literal> @@ <specifier>public</specifier> class <name>HaversineConstFunction</name> extends <name>ValueSource</name> <block>{
   }</block></expr>;</expr_stmt></if></if_stmt>
 
   <comment type="block" format="javadoc">/** make a MultiValueSource from two non MultiValueSources */</comment>
  <specifier>private</specifier> <specifier>static</specifier> <name>VectorValueSource</name> <call><name>makeMV</name><argument_list>(<argument><expr><name><name>List</name><argument_list type="generic">&lt;<argument><name>ValueSource</name></argument>&gt;</argument_list></name> <name>sources</name></expr></argument>, <argument><expr><name><name>List</name><argument_list type="generic">&lt;<argument><name>ValueSource</name></argument>&gt;</argument_list></name> <name>orig</name></expr></argument>)</argument_list></call> <throws>throws <argument><expr><name>ParseException</name> <block>{
  <expr><specifier>private</specifier> <specifier>static</specifier> <name>VectorValueSource</name> <call><name>makeMV</name><argument_list>(<argument><expr><name><name>List</name><argument_list type="generic">&lt;<argument><name>ValueSource</name></argument>&gt;</argument_list></name> <name>sources</name></expr></argument>, <argument><expr><name><name>List</name><argument_list type="generic">&lt;<argument><name>ValueSource</name></argument>&gt;</argument_list></name> <name>orig</name></expr></argument>)</argument_list></call></expr></block></expr></argument></throws> <throws>throws <argument><expr><name>SyntaxError</name> <block>{
     <expr><name>ValueSource</name> <name>vs1</name> <operator>=</operator> <call><name><name>sources</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></block></expr></argument></throws></block></expr>;
     <name>ValueSource</name> <name>vs2</name> <operator>=</operator> <call><name><name>sources</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></block></expr>;</expr_stmt>
 
     <if_stmt><if>if <condition>(<expr><name>vs1</name> <operator>instanceof</operator> <name>MultiValueSource</name> <operator>||</operator> <name>vs2</name> <operator>instanceof</operator> <name>MultiValueSource</name></expr>)</condition> <block>{<block_content>
      <throw>throw <expr><operator>new</operator> <call><name>ParseException</name><argument_list>(<argument><expr><literal type="string">"geodist - invalid parameters:"</literal> <operator>+</operator> <name>orig</name></expr></argument>)</argument_list></call></expr>;</throw>
      <throw>throw <expr><operator>new</operator> <call><name>SyntaxError</name><argument_list>(<argument><expr><literal type="string">"geodist - invalid parameters:"</literal> <operator>+</operator> <name>orig</name></expr></argument>)</argument_list></call></expr>;</throw>
     <expr_stmt/>}</block_content>
     return  new VectorValueSource(sources</block></if></if_stmt>)</block_content></block>;</function>
   <expr_stmt/>}</block_content>
 
  private static MultiValueSource parsePoint(FunctionQParser fp</block></function>)</block> <throws>throws <argument><expr><name>ParseException</name> <block>{
  <expr><specifier>private</specifier> <specifier>static</specifier> <name>MultiValueSource</name> <call><name>parsePoint</name><argument_list>(<argument><expr><name>FunctionQParser</name> <name>fp</name></expr></argument>)</argument_list></call></expr></block></expr></argument></throws> <throws>throws <argument><expr><name>SyntaxError</name> <block>{
     <expr><name>String</name> <name>pt</name> <operator>=</operator> <call><name><name>fp</name><operator>.</operator><name>getParam</name></name><argument_list>(<argument><expr><name><name>SpatialParams</name><operator>.</operator><name>POINT</name></name></expr></argument>)</argument_list></call></expr></block></expr></argument></throws><empty_stmt>;</empty_stmt></class></expr></argument></argument_list></call></expr></block></expr></expr_stmt>
     <if_stmt><if>if <condition>(<expr><name>pt</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="null">null</literal></expr>;</return></block_content></block></if></if_stmt>
     <decl_stmt><decl><type><name><name>double</name><index>[]</index></name></type> <name>point</name> <init>= <expr><literal type="null">null</literal></expr></init></decl>;</decl_stmt>
     <try>try <block>{<block_content>
       <expr_stmt><expr><name>point</name> <operator>=</operator> <call><name><name>ParseUtils</name><operator>.</operator><name>parseLatitudeLongitude</name></name><argument_list>(<argument><expr><name>pt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
     <expr_stmt/>}</block_content> catch (InvalidShapeException e</block></try>)</block> <block>{
      <throw>throw <expr><operator>new</operator> <call><name>ParseException</name><argument_list>(<argument><expr><literal type="string">"Bad spatial pt:"</literal> <operator>+</operator> <name>pt</name></expr></argument>)</argument_list></call></expr>;</throw>
      <throw>throw <expr><operator>new</operator> <call><name>SyntaxError</name><argument_list>(<argument><expr><literal type="string">"Bad spatial pt:"</literal> <operator>+</operator> <name>pt</name></expr></argument>)</argument_list></call></expr>;</throw>
     <expr_stmt/>}</block>
     <return>return <expr><operator>new</operator> <call><name>VectorValueSource</name><argument_list>(<argument><expr><name><name>Arrays</name><operator>.</operator></name>&lt;<name>ValueSource</name><operator>&gt;</operator><call><name>asList</name><argument_list>(<argument><expr><operator>new</operator> <call><name>DoubleConstValueSource</name><argument_list>(<argument><expr><name><name>point</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><operator>new</operator> <call><name>DoubleConstValueSource</name><argument_list>(<argument><expr><name><name>point</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></class></expr></return>
   <expr_stmt/>}</block_content>
@@ -161</block><operator>,</operator>13 +161<operator>,</operator>13 @@ public class HaversineConstFunction extends ValueSource <block>{<block_content>
     <return>return <expr><literal type="null">null</literal></expr>;</return>
   <expr_stmt/>}</block_content>
 
  private static MultiValueSource parseSfield(FunctionQParser fp</block></function>)</block_content> <throws>throws <argument><expr><name>ParseException</name> <block>{
  <expr><specifier>private</specifier> <specifier>static</specifier> <name>MultiValueSource</name> <call><name>parseSfield</name><argument_list>(<argument><expr><name>FunctionQParser</name> <name>fp</name></expr></argument>)</argument_list></call></expr></block></expr></argument></throws> <throws>throws <argument><expr><name>SyntaxError</name> <block>{
     <expr><name>String</name> <name>sfield</name> <operator>=</operator> <call><name><name>fp</name><operator>.</operator><name>getParam</name></name><argument_list>(<argument><expr><name><name>SpatialParams</name><operator>.</operator><name>FIELD</name></name></expr></argument>)</argument_list></call></expr></block></expr></argument></throws></block>;</function>
     <if_stmt><if>if <condition>(<expr><name>sfield</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="null">null</literal></expr>;</return></block_content></block></if></if_stmt>
     <decl_stmt><decl><type><name>SchemaField</name></type> <name>sf</name> <init>= <expr><call><name><name>fp</name><operator>.</operator><name>getReq</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSchema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getField</name><argument_list>(<argument><expr><name>sfield</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
     <decl_stmt><decl><type><name>ValueSource</name></type> <name>vs</name> <init>= <expr><call><name><name>sf</name><operator>.</operator><name>getType</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getValueSource</name><argument_list>(<argument><expr><name>sf</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
     <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>vs</name> <operator>instanceof</operator> <name>MultiValueSource</name><operator>)</operator></expr>)</condition> <block>{<block_content>
      <throw>throw <expr><operator>new</operator> <call><name>ParseException</name><argument_list>(<argument><expr><literal type="string">"Spatial field must implement MultiValueSource:"</literal> <operator>+</operator> <name>sf</name></expr></argument>)</argument_list></call></expr>;</throw>
      <throw>throw <expr><operator>new</operator> <call><name>SyntaxError</name><argument_list>(<argument><expr><literal type="string">"Spatial field must implement MultiValueSource:"</literal> <operator>+</operator> <name>sf</name></expr></argument>)</argument_list></call></expr>;</throw>
     <expr_stmt/>}</block_content>
     return (MultiValueSource</block></if></if_stmt>)</block><expr_stmt><expr><name>vs</name></expr>;</expr_stmt></class></expr></argument></argument_list></call></expr>
   }</block>
<name>diff</name> <operator>--</operator><name>git</name> <name>a</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>search</name><operator>/</operator><name>grouping</name><operator>/</operator><name>distributed</name><operator>/</operator><name>command</name><operator>/</operator><name><name>QueryCommand</name><operator>.</operator><name>java</name></name> <name>b</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>search</name><operator>/</operator><name>grouping</name><operator>/</operator><name>distributed</name><operator>/</operator><name>command</name><operator>/</operator><name><name>QueryCommand</name><operator>.</operator><name>java</name></name>
<name>index</name> <literal type="number">363b8b87ed4</literal><operator>..</operator><literal type="number">3262e7ef6e7</literal> <literal type="number">100644</literal>
<operator>--</operator> <name>a</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>search</name><operator>/</operator><name>grouping</name><operator>/</operator><name>distributed</name><operator>/</operator><name>command</name><operator>/</operator><name><name>QueryCommand</name><operator>.</operator><name>java</name></name>
<operator>++</operator> <name>b</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>search</name><operator>/</operator><name>grouping</name><operator>/</operator><name>distributed</name><operator>/</operator><name>command</name><operator>/</operator><name><name>QueryCommand</name><operator>.</operator><name>java</name></name>
@@ <operator>-</operator><literal type="number">17</literal></expr><operator>,</operator><expr><literal type="number">12</literal> <operator>+</operator><literal type="number">17</literal></expr><operator>,</operator><expr><literal type="number">12</literal> @@</expr></expr_stmt> <package>package <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>search</name><operator>.</operator><name>grouping</name><operator>.</operator><name>distributed</name><operator>.</operator><name>command</name></name>;</package>
  <expr_stmt><expr><operator>*</operator> <name>limitations</name> <name>under</name> <name>the</name> <name><name>License</name><operator>.</operator></name>
  *<operator>/</operator></expr></expr_stmt>
 
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>queryparser</name><operator>.</operator><name>classic</name><operator>.</operator><name>ParseException</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>search</name><operator>.</operator><name>*</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>request</name><operator>.</operator><name>SolrQueryRequest</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>search</name><operator>.</operator><name>DocSet</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>search</name><operator>.</operator><name>QParser</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>search</name><operator>.</operator><name>SolrIndexSearcher</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>search</name><operator>.</operator><name>SyntaxError</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>search</name><operator>.</operator><name>grouping</name><operator>.</operator><name>Command</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>search</name><operator>.</operator><name>grouping</name><operator>.</operator><name>collector</name><operator>.</operator><name>FilterCollector</name></name>;</import>
 
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">61</literal></expr><operator>,</operator><expr><literal type="number">9</literal> <operator>+</operator><literal type="number">61</literal></expr><operator>,</operator><expr><literal type="number">8</literal> @@ <specifier>public</specifier> class <name>QueryCommand</name> implements <name><name>Command</name><argument_list type="generic">&lt;<argument><name>QueryCommandResult</name></argument>&gt;</argument_list></name> <block>{
      <expr><operator>*</operator> @<name>param</name> <name>groupQueryString</name> <name>The</name> <name>group</name> <name>query</name> <name>string</name> <name>to</name> <name>parse</name>
      <operator>*</operator> @<name>param</name> <name>request</name> <name>The</name> <name>current</name> <name>request</name>
      <operator>*</operator> @</expr><return>return <expr><name>this</name>
     <operator>*</operator> @<throws>throws <argument><expr><name>ParseException</name> <name>If</name> <name>parsing</name> <name>the</name> <name>groupQueryString</name> <name>failed</name>
      <operator>*</operator><operator>/</operator>
    <specifier>public</specifier> <name>Builder</name> <call><name>setQuery</name><argument_list>(<argument><expr><name>String</name> <name>groupQueryString</name></expr></argument>, <argument><expr><name>SolrQueryRequest</name> <name>request</name></expr></argument>)</argument_list></call></expr></argument></throws> <throws>throws <argument><expr><name>ParseException</name> <block>{
    <expr><specifier>public</specifier> <name>Builder</name> <call><name>setQuery</name><argument_list>(<argument><expr><name>String</name> <name>groupQueryString</name></expr></argument>, <argument><expr><name>SolrQueryRequest</name> <name>request</name></expr></argument>)</argument_list></call></expr></block></expr></argument></throws> <throws>throws <argument><expr><name>SyntaxError</name> <block>{
       <expr><name>QParser</name> <name>parser</name> <operator>=</operator> <call><name><name>QParser</name><operator>.</operator><name>getParser</name></name><argument_list>(<argument><expr><name>groupQueryString</name></expr></argument>, <argument><expr><literal type="null">null</literal></expr></argument>, <argument><expr><name>request</name></expr></argument>)</argument_list></call></expr></block></expr></argument></throws></expr>;</return>
       <name><name>this</name><operator>.</operator><name>queryString</name></name> <operator>=</operator> <name>groupQueryString</name></block></expr>;</expr_stmt>
       <return>return <expr><call><name>setQuery</name><argument_list>(<argument><expr><call><name><name>parser</name><operator>.</operator><name>getQuery</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
<expr_stmt><expr><name>diff</name> <operator>--</operator><name>git</name> <name>a</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>update</name><operator>/</operator><name><name>DirectUpdateHandler2</name><operator>.</operator><name>java</name></name> <name>b</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>update</name><operator>/</operator><name><name>DirectUpdateHandler2</name><operator>.</operator><name>java</name></name>
<name>index</name> <literal type="number">5589e052b6c</literal><operator>..</operator><literal type="number">98202a99306</literal> <literal type="number">100644</literal>
<operator>--</operator> <name>a</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>update</name><operator>/</operator><name><name>DirectUpdateHandler2</name><operator>.</operator><name>java</name></name>
<operator>++</operator> <name>b</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>update</name><operator>/</operator><name><name>DirectUpdateHandler2</name><operator>.</operator><name>java</name></name>
@@ <operator>-</operator><literal type="number">37</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">37</literal></expr><operator>,</operator><expr><literal type="number">6</literal> @@</expr></expr_stmt> <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>index</name><operator>.</operator><name>IndexReader</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>index</name><operator>.</operator><name>IndexWriter</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>index</name><operator>.</operator><name>Term</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>queries</name><operator>.</operator><name>function</name><operator>.</operator><name>ValueSource</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>queryparser</name><operator>.</operator><name>classic</name><operator>.</operator><name>ParseException</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>search</name><operator>.</operator><name>BooleanClause</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>search</name><operator>.</operator><name>BooleanClause</name><operator>.</operator><name>Occur</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>search</name><operator>.</operator><name>BooleanQuery</name></name>;</import>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">57</literal></expr><operator>,</operator><expr><literal type="number">6</literal> <operator>+</operator><literal type="number">56</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@</expr></expr_stmt> <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>response</name><operator>.</operator><name>SolrQueryResponse</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>schema</name><operator>.</operator><name>SchemaField</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>search</name><operator>.</operator><name>FunctionRangeQuery</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>search</name><operator>.</operator><name>QParser</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>search</name><operator>.</operator><name>SyntaxError</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>search</name><operator>.</operator><name>QueryUtils</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>search</name><operator>.</operator><name>SolrIndexSearcher</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>search</name><operator>.</operator><name>function</name><operator>.</operator><name>ValueSourceRangeFilter</name></name>;</import>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">317</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">317</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@ <specifier>public</specifier> class <name>DirectUpdateHandler2</name> extends <name>UpdateHandler</name> implements <name>SolrCoreState</name></expr></expr_stmt>
 
       <return>return <expr><name>q</name></expr>;</return>
 
    <expr_stmt/>}</block> <catch>catch <parameter_list>(<parameter><decl><type><name>ParseException</name></type> <name>e</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt/>}</block_content> catch (SyntaxError e</block></catch></class></expr></return>)</block_content> <block>{<block_content>
       <throw>throw <expr><operator>new</operator> <call><name>SolrException</name><argument_list>(<argument><expr><name><name>SolrException</name><operator>.</operator><name>ErrorCode</name><operator>.</operator><name>BAD_REQUEST</name></name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</throw>
     <expr_stmt/>}</block_content>
   }
diff --git a/solr/core/src/java/org/apache/solr/util/SolrPluginUtils.java b/solr/core/src/java/org/apache/solr/util/SolrPluginUtils.java
index 96aa5e23118..ad02cf95767 100644
-- a/solr/core/src/java/org/apache/solr/util/SolrPluginUtils.java
++ b/solr/core/src/java/org/apache/solr/util/SolrPluginUtils.java
@@ -17</block></block><operator>,</operator>12 +17<operator>,</operator>8 @@
 
 package org.apache.solr.util;</function>
 
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>document</name><operator>.</operator><name>Document</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>index</name><operator>.</operator><name>IndexableField</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>index</name><operator>.</operator><name>StorableField</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>index</name><operator>.</operator><name>StoredDocument</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>queryparser</name><operator>.</operator><name>classic</name><operator>.</operator><name>ParseException</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>queryparser</name><operator>.</operator><name>classic</name><operator>.</operator><name>QueryParser</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>search</name><operator>.</operator><name>*</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>search</name><operator>.</operator><name>BooleanClause</name><operator>.</operator><name>Occur</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>common</name><operator>.</operator><name>SolrDocument</name></name>;</import>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">30</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">26</literal></expr><operator>,</operator><expr><literal type="number">6</literal> @@</expr></expr_stmt> <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>common</name><operator>.</operator><name>SolrDocumentList</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>common</name><operator>.</operator><name>SolrException</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>common</name><operator>.</operator><name>params</name><operator>.</operator><name>CommonParams</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>common</name><operator>.</operator><name>params</name><operator>.</operator><name>SolrParams</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>common</name><operator>.</operator><name>params</name><operator>.</operator><name>UpdateParams</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>common</name><operator>.</operator><name>util</name><operator>.</operator><name>NamedList</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>common</name><operator>.</operator><name>util</name><operator>.</operator><name>SimpleOrderedMap</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>common</name><operator>.</operator><name>util</name><operator>.</operator><name>StrUtils</name></name>;</import>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">38</literal></expr><operator>,</operator><expr><literal type="number">13</literal> <operator>+</operator><literal type="number">33</literal></expr><operator>,</operator><expr><literal type="number">12</literal> @@</expr></expr_stmt> <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>core</name><operator>.</operator><name>SolrCore</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>handler</name><operator>.</operator><name>component</name><operator>.</operator><name>HighlightComponent</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>handler</name><operator>.</operator><name>component</name><operator>.</operator><name>ResponseBuilder</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>highlight</name><operator>.</operator><name>SolrHighlighter</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>parser</name><operator>.</operator><name>QueryParser</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>request</name><operator>.</operator><name>SolrQueryRequest</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>response</name><operator>.</operator><name>SolrQueryResponse</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>schema</name><operator>.</operator><name>IndexSchema</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>schema</name><operator>.</operator><name>SchemaField</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>search</name><operator>.</operator><name>*</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>update</name><operator>.</operator><name>DocumentBuilder</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>slf4j</name><operator>.</operator><name>Logger</name></name>;</import>
 
 <import>import <name><name>java</name><operator>.</operator><name>io</name><operator>.</operator><name>IOException</name></name>;</import>
 <import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>*</name></name>;</import>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">386</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">380</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@ <specifier>public</specifier> class <name>SolrPluginUtils</name> <block>{
 
     <expr><name>DocList</name> <name>results</name> <operator>=</operator> <call><name><name>req</name><operator>.</operator><name>getSearcher</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getDocList</name><argument_list>(<argument><expr><name>query</name></expr></argument>,<argument><expr><operator>(</operator><name>DocSet</name><operator>)</operator><literal type="null">null</literal></expr></argument>, <argument><expr><name>sort</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>limit</name></expr></argument>)</argument_list></call></expr>;</block></expr></expr_stmt>
     <return>return <expr><name>results</name></expr>;</return>
    <expr_stmt/>}</block_content> catch (ParseException e</block></function>)</block> <block>{
    <expr_stmt/>}</block> <catch>catch <parameter_list>(<parameter><decl><type><name>SyntaxError</name></type> <name>e</name></decl></parameter>)</parameter_list> <block>{<block_content>
       <throw>throw <expr><operator>new</operator> <call><name>SolrException</name><argument_list>(<argument><expr><name><name>SolrException</name><operator>.</operator><name>ErrorCode</name><operator>.</operator><name>BAD_REQUEST</name></name></expr></argument>, <argument><expr><literal type="string">"Error parsing query: "</literal> <operator>+</operator> <name>qs</name></expr></argument>)</argument_list></call></expr>;</throw>
     <expr_stmt/>}</block_content>
 
@@ -604</block><operator>,</operator><expr_stmt><expr><literal type="number">8</literal> <operator>+</operator><literal type="number">598</literal></expr><operator>,</operator><expr><literal type="number">6</literal> @@ <specifier>public</specifier> class <name>SolrPluginUtils</name> <block>{
 
   <comment type="block" format="javadoc">/**
    * Escapes all special characters except '"', '-', and '+'
   *
   * @see QueryParser#escape
    */</comment>
   <expr><specifier>public</specifier> <specifier>static</specifier> <name>CharSequence</name> <call><name>partialEscape</name><argument_list>(<argument><expr><name>CharSequence</name> <name>s</name></expr></argument>)</argument_list></call> <block>{
     <expr><name>StringBuilder</name> <name>sb</name> <operator>=</operator> <operator>new</operator> <call><name>StringBuilder</name><argument_list>()</argument_list></call></expr>;
@@ <operator>-</operator><literal type="number">726</literal><operator>,</operator><literal type="number">7</literal> <operator>+</operator><literal type="number">718</literal><operator>,</operator><literal type="number">7</literal> @@ <specifier>public</specifier> class <name>SolrPluginUtils</name> <block>{
      <expr><operator>*</operator><operator>/</operator>
     @<name>Override</name>
     <specifier>protected</specifier> <name>Query</name> <call><name>getFieldQuery</name><argument_list>(<argument><expr><name>String</name> <name>field</name></expr></argument>, <argument><expr><name>String</name> <name>queryText</name></expr></argument>, <argument><expr><name>boolean</name> <name>quoted</name></expr></argument>)</argument_list></call>
      <throws>throws <argument><expr><name>ParseException</name> <block>{</block></expr></argument></throws>
      <throws>throws <argument><expr><name>SyntaxError</name> <block>{</block></expr></argument></throws></expr>
 
       <if_stmt><if>if <condition>(<expr><call><name><name>aliases</name><operator>.</operator><name>containsKey</name></name><argument_list>(<argument><expr><name>field</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
 
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">798</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">790</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@ <specifier>public</specifier> class <name>SolrPluginUtils</name> <block>{
    <expr><operator>*</operator> @</expr><return>return <expr><literal type="null">null</literal></expr></return> <if_stmt><if>if no queries are generated
    */
   public static List&lt;Query&gt; parseQueryStrings<condition>(<expr><name>SolrQueryRequest</name> <name>req</name></expr><operator>,</operator>
                                              <expr><name><name>String</name><index>[]</index></name> <name>queries</name></expr>)</condition><block type="pseudo"><block_content> <throws>throws <argument><expr><name>ParseException</name> <block>{
                                              <expr><name><name>String</name><index>[]</index></name> <name>queries</name></expr></block></expr></argument></throws><expr_stmt><expr/></expr_stmt></block_content></block></if></if_stmt></block></expr></expr_stmt></block_content></block></if></if_stmt></block></block></expr></block></expr></expr_stmt></catch></class></expr></argument>)</argument_list></call> <throws>throws <argument><expr><name>SyntaxError</name> <block>{</block></expr></argument></throws></expr>
     <if_stmt><if>if <condition>(<expr><literal type="null">null</literal> <operator>==</operator> <name>queries</name> <operator>||</operator> <literal type="number">0</literal> <operator>==</operator> <name><name>queries</name><operator>.</operator><name>length</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="null">null</literal></expr>;</return></block_content></block></if></if_stmt>
     <name><name>List</name><argument_list type="generic">&lt;<argument><name>Query</name></argument>&gt;</argument_list></name> <name>out</name> <operator>=</operator> <operator>new</operator> <call><name><name>ArrayList</name><argument_list type="generic">&lt;<argument><name>Query</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>queries</name><operator>.</operator><name>length</name></name></expr></argument>)</argument_list></call></block></expr>;</expr_stmt>
     <for>for <control>(<init><decl><type><name>String</name></type> <name>q</name> <range>: <expr><name>queries</name></expr></range></decl></init>)</control> <block>{<block_content>
<expr_stmt><expr><name>diff</name> <operator>--</operator><name>git</name> <name>a</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>test</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name><name>DummyValueSourceParser</name><operator>.</operator><name>java</name></name> <name>b</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>test</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name><name>DummyValueSourceParser</name><operator>.</operator><name>java</name></name>
<name>index</name> <literal type="number">4351f0dc674</literal><operator>..</operator><literal type="number">068e045a23d</literal> <literal type="number">100644</literal>
<operator>--</operator> <name>a</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>test</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name><name>DummyValueSourceParser</name><operator>.</operator><name>java</name></name>
<operator>++</operator> <name>b</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>test</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name><name>DummyValueSourceParser</name><operator>.</operator><name>java</name></name>
@@ <operator>-</operator><literal type="number">19</literal></expr><operator>,</operator><expr><literal type="number">9</literal> <operator>+</operator><literal type="number">19</literal></expr><operator>,</operator><expr><literal type="number">9</literal> @@</expr></expr_stmt> <package>package <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>core</name></name>;</package>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>queries</name><operator>.</operator><name>function</name><operator>.</operator><name>FunctionValues</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>queries</name><operator>.</operator><name>function</name><operator>.</operator><name>ValueSource</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>queries</name><operator>.</operator><name>function</name><operator>.</operator><name>valuesource</name><operator>.</operator><name>SimpleFloatFunction</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>queryparser</name><operator>.</operator><name>classic</name><operator>.</operator><name>ParseException</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>common</name><operator>.</operator><name>util</name><operator>.</operator><name>NamedList</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>search</name><operator>.</operator><name>FunctionQParser</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>search</name><operator>.</operator><name>SyntaxError</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>search</name><operator>.</operator><name>ValueSourceParser</name></name>;</import>
 
 
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">38</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">38</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@ <specifier>public</specifier> class <name>DummyValueSourceParser</name> extends <name>ValueSourceParser</name> <block>{
   }</block>
 
   @<name>Override</name>
  <specifier>public</specifier> <name>ValueSource</name> <call><name>parse</name><argument_list>(<argument><expr><name>FunctionQParser</name> <name>fp</name></expr></argument>)</argument_list></call> <throws>throws <argument><expr><name>ParseException</name> <block>{
  <expr><specifier>public</specifier> <name>ValueSource</name> <call><name>parse</name><argument_list>(<argument><expr><name>FunctionQParser</name> <name>fp</name></expr></argument>)</argument_list></call></expr></block></expr></argument></throws> <throws>throws <argument><expr><name>SyntaxError</name> <block>{
     <expr><name>ValueSource</name> <name>source</name> <operator>=</operator> <call><name><name>fp</name><operator>.</operator><name>parseValueSource</name></name><argument_list>()</argument_list></call></expr></block></expr></argument></throws></expr>;</expr_stmt>
     <decl_stmt><decl><type><name>ValueSource</name></type> <name>result</name> <init>= <expr><operator>new</operator> <class><super><name>SimpleFloatFunction</name></super><argument_list>(<argument><expr><name>source</name></expr></argument>)</argument_list> <block>{
       <annotation>@<name>Override</name></annotation>
<expr_stmt><expr><name>diff</name> <operator>--</operator><name>git</name> <name>a</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>test</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name><name>TestArbitraryIndexDir</name><operator>.</operator><name>java</name></name> <name>b</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>test</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name><name>TestArbitraryIndexDir</name><operator>.</operator><name>java</name></name>
<name>index</name> <literal type="number">492130c8dc2</literal><operator>..</operator><literal type="number">086a14316ba</literal> <literal type="number">100644</literal>
<operator>--</operator> <name>a</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>test</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name><name>TestArbitraryIndexDir</name><operator>.</operator><name>java</name></name>
<operator>++</operator> <name>b</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>test</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name><name>TestArbitraryIndexDir</name><operator>.</operator><name>java</name></name>
@@ <operator>-</operator><literal type="number">29</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">29</literal></expr><operator>,</operator><expr><literal type="number">6</literal> @@</expr></expr_stmt> <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>document</name><operator>.</operator><name>Field</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>document</name><operator>.</operator><name>TextField</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>index</name><operator>.</operator><name>IndexWriter</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>index</name><operator>.</operator><name>IndexWriterConfig</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>queryparser</name><operator>.</operator><name>classic</name><operator>.</operator><name>ParseException</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>store</name><operator>.</operator><name>Directory</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>util</name><operator>.</operator><name>Version</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>common</name><operator>.</operator><name>SolrException</name></name>;</import>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">86</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">85</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@ <specifier>public</specifier> class <name>TestArbitraryIndexDir</name> extends <name>AbstractSolrTestCase</name><block>{
   }</block>
 
   @<name>Test</name>
  <specifier>public</specifier> <name>void</name> <call><name>testLoadNewIndexDir</name><argument_list>()</argument_list></call> <throws>throws <argument><expr><name>IOException</name></expr></argument>, <argument><expr><name>ParserConfigurationException</name></expr></argument>, <argument><expr><name>SAXException</name></expr></argument>, <argument><expr><name>ParseException</name> <block>{
  <expr><specifier>public</specifier> <name>void</name> <call><name>testLoadNewIndexDir</name><argument_list>()</argument_list></call></expr></block></expr></argument></throws> <throws>throws <argument><expr><name>IOException</name></expr></argument>, <argument><expr><name>ParserConfigurationException</name></expr></argument>, <argument><expr><name>SAXException</name> <block>{
     <comment type="line">//add a doc in original index dir</comment>
     <expr><call><name>assertU</name><argument_list>(<argument><expr><call><name>adoc</name><argument_list>(<argument><expr><literal type="string">"id"</literal></expr></argument>, <argument><expr><call><name><name>String</name><operator>.</operator><name>valueOf</name></name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>,
         <argument><expr><literal type="string">"name"</literal></expr></argument>, <argument><expr><literal type="string">"name"</literal><operator>+</operator><call><name><name>String</name><operator>.</operator><name>valueOf</name></name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></block></expr></argument></throws></expr>;</expr_stmt>
<expr_stmt><expr><name>diff</name> <operator>--</operator><name>git</name> <name>a</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>test</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>search</name><operator>/</operator><name><name>FooQParserPlugin</name><operator>.</operator><name>java</name></name> <name>b</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>test</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>search</name><operator>/</operator><name><name>FooQParserPlugin</name><operator>.</operator><name>java</name></name>
<name>index</name> <name>bad1156d724</name><operator>..</operator><name>b6168244c86</name> <literal type="number">100755</literal>
<operator>--</operator> <name>a</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>test</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>search</name><operator>/</operator><name><name>FooQParserPlugin</name><operator>.</operator><name>java</name></name>
<operator>++</operator> <name>b</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>test</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>search</name><operator>/</operator><name><name>FooQParserPlugin</name><operator>.</operator><name>java</name></name>
@@ <operator>-</operator><literal type="number">17</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">17</literal></expr><operator>,</operator><expr><literal type="number">6</literal> @@</expr></expr_stmt>
 
 <package>package <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>search</name></name>;</package>
 
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>queryparser</name><operator>.</operator><name>classic</name><operator>.</operator><name>ParseException</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>common</name><operator>.</operator><name>params</name><operator>.</operator><name>SolrParams</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>common</name><operator>.</operator><name>util</name><operator>.</operator><name>NamedList</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>request</name><operator>.</operator><name>SolrQueryRequest</name></name>;</import>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">42</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">41</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@ class <name>FooQParser</name> extends <name>QParser</name> <block>{
   }</block>
 
   @<name>Override</name>
  <specifier>public</specifier> <name>Query</name> <call><name>parse</name><argument_list>()</argument_list></call> <throws>throws <argument><expr><name>ParseException</name> <block>{
  <expr><specifier>public</specifier> <name>Query</name> <call><name>parse</name><argument_list>()</argument_list></call></expr></block></expr></argument></throws> <throws>throws <argument><expr><name>SyntaxError</name> <block>{</block></expr></argument></throws></expr></expr_stmt>
     <return>return <expr><operator>new</operator> <call><name>TermQuery</name><argument_list>(<argument><expr><operator>new</operator> <call><name>Term</name><argument_list>(<argument><expr><call><name><name>localParams</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name><name>QueryParsing</name><operator>.</operator><name>F</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>localParams</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name><name>QueryParsing</name><operator>.</operator><name>V</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
   <expr_stmt/>}</block>
 <expr_stmt/></class></expr>}</init>
<name>diff</name> --<name>git</name> <name>a</name>/<name>solr</name>/<name>core</name>/<name>src</name>/<name>test</name>/<name>org</name>/<name>apache</name>/<name>solr</name>/<name>search</name>/<name><name>TestExtendedDismaxParser</name><operator>.</operator><name>java</name></name> <name>b</name>/<name>solr</name>/<name>core</name>/<name>src</name>/<name>test</name>/<name>org</name>/<name>apache</name>/<name>solr</name>/<name>search</name>/<name><name>TestExtendedDismaxParser</name><operator>.</operator><name>java</name></name>
<name>index</name> 0c97d86d69c..<name>d51d6dc9d70</name> 100755
-- <name>a</name>/<name>solr</name>/<name>core</name>/<name>src</name>/<name>test</name>/<name>org</name>/<name>apache</name>/<name>solr</name>/<name>search</name>/<name><name>TestExtendedDismaxParser</name><operator>.</operator><name>java</name></name>
++ <name>b</name>/<name>solr</name>/<name>core</name>/<name>src</name>/<name>test</name>/<name>org</name>/<name>apache</name>/<name>solr</name>/<name>search</name>/<name><name>TestExtendedDismaxParser</name><operator>.</operator><name>java</name></name>
@@ -772</decl>,7 +772,7 @@ public <decl><type ref="prev"/><name>class</name> <name>TestExtendedDismaxParser</name> extends <name>AbstractSolrTestCase</name> <block>{<block_content>
             <expr_stmt><expr><literal type="string">"defType"</literal></expr><operator>,</operator> <expr><literal type="string">"edismax"</literal></expr></expr_stmt></block_content></block></decl></decl_stmt></block_content></block></for></block></class></expr></return></block_content></block></function></block_content></block></function></block></class></expr></argument>)</argument_list></call></expr>
         , <expr><literal type="string">"*[count(//doc)=1]"</literal></expr></block></expr></expr_stmt></block></class></expr></return></block_content></block></function></block_content></block></function></block></class></expr></argument>)</argument_list></call></expr>;
     
    <comment type="line">// Query string field 'cat_s' for special char / - causes ParseException without patch SOLR-3467</comment>
    <comment type="line">// Query string field 'cat_s' for special char / - causes SyntaxError without patch SOLR-3467</comment>
     <call><name>assertQ</name><argument_list>(<argument><expr><literal type="string">"Escaping string with reserved / character"</literal></expr></argument>,
         <argument><expr><call><name>req</name><argument_list>(<argument><expr><literal type="string">"q"</literal></expr></argument>, <argument><expr><literal type="string">"foo/"</literal></expr></argument>,
             <argument><expr><literal type="string">"qf"</literal></expr></argument>, <argument><expr><literal type="string">"cat_s"</literal></expr></argument>,
<argument><expr><name>diff</name> <operator>--</operator><name>git</name> <name>a</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>test</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>search</name><operator>/</operator><name><name>TestSolrQueryParser</name><operator>.</operator><name>java</name></name> <name>b</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>test</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>search</name><operator>/</operator><name><name>TestSolrQueryParser</name><operator>.</operator><name>java</name></name>
<name>index</name> <name>f65333ae6ed</name><operator>..</operator><name>cef61461783</name> <literal type="number">100644</literal>
<operator>--</operator> <name>a</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>test</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>search</name><operator>/</operator><name><name>TestSolrQueryParser</name><operator>.</operator><name>java</name></name>
<operator>++</operator> <name>b</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>test</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>search</name><operator>/</operator><name><name>TestSolrQueryParser</name><operator>.</operator><name>java</name></name>
@@ <operator>-</operator><literal type="number">35</literal></expr></argument>,<argument><expr><literal type="number">6</literal> <operator>+</operator><literal type="number">35</literal></expr></argument>,<argument><expr><literal type="number">12</literal> @@ <specifier>public</specifier> class <name>TestSolrQueryParser</name> extends <name>SolrTestCaseJ4</name> <block>{
     <expr><call><name>assertU</name><argument_list>(<argument><expr><call><name>adoc</name><argument_list>(<argument><expr><literal type="string">"id"</literal></expr></argument>,<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><literal type="string">"text"</literal></expr></argument>,<argument><expr><name>v</name></expr></argument>,  <argument><expr><literal type="string">"text_np"</literal></expr></argument>,<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
     <name>v</name><operator>=</operator><literal type="string">"now cow"</literal></block></expr></argument>;</argument_list></call></expr></argument></argument_list></call>
     <call><name>assertU</name><argument_list>(<argument><expr><call><name>adoc</name><argument_list>(<argument><expr><literal type="string">"id"</literal></expr></argument>,<argument><expr><literal type="string">"2"</literal></expr></argument>, <argument><expr><literal type="string">"text"</literal></expr></argument>,<argument><expr><name>v</name></expr></argument>,  <argument><expr><literal type="string">"text_np"</literal></expr></argument>,<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></block></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assertU</name><argument_list>(<argument><expr><call><name>adoc</name><argument_list>(<argument><expr><literal type="string">"id"</literal></expr></argument>,<argument><expr><literal type="string">"3"</literal></expr></argument>, <argument><expr><literal type="string">"foo_s"</literal></expr></argument>,<argument><expr><literal type="string">"a ' \" \\ {! ) } ( { z"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="line">// A value filled with special chars</comment>

    <expr_stmt><expr><call><name>assertU</name><argument_list>(<argument><expr><call><name>adoc</name><argument_list>(<argument><expr><literal type="string">"id"</literal></expr></argument>,<argument><expr><literal type="string">"10"</literal></expr></argument>, <argument><expr><literal type="string">"qqq_s"</literal></expr></argument>,<argument><expr><literal type="string">"X"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assertU</name><argument_list>(<argument><expr><call><name>adoc</name><argument_list>(<argument><expr><literal type="string">"id"</literal></expr></argument>,<argument><expr><literal type="string">"11"</literal></expr></argument>, <argument><expr><literal type="string">"www_s"</literal></expr></argument>,<argument><expr><literal type="string">"X"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assertU</name><argument_list>(<argument><expr><call><name>adoc</name><argument_list>(<argument><expr><literal type="string">"id"</literal></expr></argument>,<argument><expr><literal type="string">"12"</literal></expr></argument>, <argument><expr><literal type="string">"eee_s"</literal></expr></argument>,<argument><expr><literal type="string">"X"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

     <expr_stmt><expr><call><name>assertU</name><argument_list>(<argument><expr><call><name>commit</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
   <expr_stmt/>}</block>
 
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">49</literal></expr><operator>,</operator><expr><literal type="number">4</literal> <operator>+</operator><literal type="number">55</literal></expr><operator>,</operator><expr><literal type="number">35</literal> @@ <specifier>public</specifier> class <name>TestSolrQueryParser</name> extends <name>SolrTestCaseJ4</name> <block>{
         ,<expr><literal type="string">"//*[@numFound='2']"</literal></expr></block></expr></expr_stmt></class></expr></return></block_content></block></function></block_content></block></function></block></class></expr></argument>
     )</argument_list></call></expr>;</expr_stmt>
   <expr_stmt/>}</block_content>

  @Test
  public void testLocalParamsInQP(</block></function>)</block_content> <throws>throws <argument><expr><name>Exception</name> <block>{
    <expr><call><name>assertJQ</name><argument_list>(<argument><expr><call><name>req</name><argument_list>(<argument><expr><literal type="string">"q"</literal></expr></argument>,<argument><expr><literal type="string">"qaz {!term f=text v=$qq} wsx"</literal></expr></argument>, <argument><expr><literal type="string">"qq"</literal></expr></argument>,<argument><expr><literal type="string">"now"</literal></expr></argument>)</argument_list></call></expr></argument>
        ,<argument><expr><literal type="string">"/response/numFound==2"</literal></expr></argument>
    )</argument_list></call></expr></block></expr></argument></throws></block>;</function>

    <expr_stmt><expr><call><name>assertJQ</name><argument_list>(<argument><expr><call><name>req</name><argument_list>(<argument><expr><literal type="string">"q"</literal></expr></argument>,<argument><expr><literal type="string">"qaz {!term f=text v=$qq} wsx"</literal></expr></argument>, <argument><expr><literal type="string">"qq"</literal></expr></argument>,<argument><expr><literal type="string">"nomatch"</literal></expr></argument>)</argument_list></call></expr></argument>
        ,<argument><expr><literal type="string">"/response/numFound==0"</literal></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>assertJQ</name><argument_list>(<argument><expr><call><name>req</name><argument_list>(<argument><expr><literal type="string">"q"</literal></expr></argument>,<argument><expr><literal type="string">"qaz {!term f=text}now wsx"</literal></expr></argument>, <argument><expr><literal type="string">"qq"</literal></expr></argument>,<argument><expr><literal type="string">"now"</literal></expr></argument>)</argument_list></call></expr></argument>
        ,<argument><expr><literal type="string">"/response/numFound==2"</literal></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>assertJQ</name><argument_list>(<argument><expr><call><name>req</name><argument_list>(<argument><expr><literal type="string">"q"</literal></expr></argument>,<argument><expr><literal type="string">"qaz {!term f=foo_s v='a \\' \" \\\\ {! ) } ( { z'} wsx"</literal></expr></argument>)</argument_list></call></expr></argument>           <comment type="line">// single quote escaping</comment>
        ,<argument><expr><literal type="string">"/response/numFound==1"</literal></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>assertJQ</name><argument_list>(<argument><expr><call><name>req</name><argument_list>(<argument><expr><literal type="string">"q"</literal></expr></argument>,<argument><expr><literal type="string">"qaz {!term f=foo_s v=\"a ' \\\" \\\\ {! ) } ( { z\"} wsx"</literal></expr></argument>)</argument_list></call></expr></argument>         <comment type="line">// double quote escaping</comment>
        ,<argument><expr><literal type="string">"/response/numFound==1"</literal></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// double-join to test back-to-back local params</comment>
    <expr_stmt><expr><call><name>assertJQ</name><argument_list>(<argument><expr><call><name>req</name><argument_list>(<argument><expr><literal type="string">"q"</literal></expr></argument>,<argument><expr><literal type="string">"qaz {!join from=www_s to=eee_s}{!join from=qqq_s to=www_s}id:10"</literal></expr></argument> )</argument_list></call></expr></argument>
        ,<argument><expr><literal type="string">"/response/docs/[0]/id=='12'"</literal></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>


  <expr_stmt/>}</block>

 <expr_stmt/></class></expr></argument>}</argument_list></call>
<name>diff</name> <operator>--</operator><name>git</name> <name>a</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>test</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>search</name><operator>/</operator><name><name>TestValueSourceCache</name><operator>.</operator><name>java</name></name> <name>b</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>test</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>search</name><operator>/</operator><name><name>TestValueSourceCache</name><operator>.</operator><name>java</name></name>
<name>index</name> <name>d9e35a1fabb</name><operator>..</operator><name>b6da59185c1</name> <literal type="number">100644</literal>
<operator>--</operator> <name>a</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>test</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>search</name><operator>/</operator><name><name>TestValueSourceCache</name><operator>.</operator><name>java</name></name>
<operator>++</operator> <name>b</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>test</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>search</name><operator>/</operator><name><name>TestValueSourceCache</name><operator>.</operator><name>java</name></name>
@@ <operator>-</operator><literal type="number">17</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">17</literal></expr><operator>,</operator><expr><literal type="number">6</literal> @@</expr></expr_stmt> <package>package <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>search</name></name>;</package>
  <expr_stmt><expr><operator>*</operator> <name>limitations</name> <name>under</name> <name>the</name> <name><name>License</name><operator>.</operator></name>
  *<operator>/</operator></expr></expr_stmt>
 
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>queryparser</name><operator>.</operator><name>classic</name><operator>.</operator><name>ParseException</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>search</name><operator>.</operator><name>Query</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>search</name><operator>.</operator><name>QueryUtils</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>SolrTestCaseJ4</name></name>;</import>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">41</literal></expr><operator>,</operator><expr><literal type="number">14</literal> <operator>+</operator><literal type="number">40</literal></expr><operator>,</operator><expr><literal type="number">14</literal> @@ <specifier>public</specifier> class <name>TestValueSourceCache</name> extends <name>SolrTestCaseJ4</name> <block>{
     <expr><name>_func</name> <operator>=</operator> <literal type="null">null</literal></expr>;
   }</block>
 
  <name>Query</name> <call><name>getQuery</name><argument_list>(<argument><expr><name>String</name> <name>query</name></expr></argument>)</argument_list></call> <throws>throws <argument><expr><name>ParseException</name> <block>{
  <expr><name>Query</name> <call><name>getQuery</name><argument_list>(<argument><expr><name>String</name> <name>query</name></expr></argument>)</argument_list></call></expr></block></expr></argument></throws> <throws>throws <argument><expr><name>SyntaxError</name> <block>{
     <expr><call><name><name>_func</name><operator>.</operator><name>setString</name></name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></block></expr></argument></throws></expr>;</expr_stmt>
     <return>return <expr><call><name><name>_func</name><operator>.</operator><name>parse</name></name><argument_list>()</argument_list></call></expr>;</return>
   <expr_stmt/>}</block_content>
 
   <comment type="line">// This is actually also tested by the tests for val_d1 below, but the bug was reported against geodist()...</comment>
   @Test
  public void testGeodistSource(</block></function>)</block_content> <throws>throws <argument><expr><name>ParseException</name> <block>{
  <expr><specifier>public</specifier> <name>void</name> <call><name>testGeodistSource</name><argument_list>()</argument_list></call></expr></block></expr></argument></throws> <throws>throws <argument><expr><name>SyntaxError</name> <block>{
     <expr><name>Query</name> <name>q_home</name> <operator>=</operator> <call><name>getQuery</name><argument_list>(<argument><expr><literal type="string">"geodist(home_ll, 45.0, 43.0)"</literal></expr></argument>)</argument_list></call></expr></block></expr></argument></throws></block>;</function>
     <decl_stmt><decl><type><name>Query</name></type> <name>q_work</name> <init>= <expr><call><name>getQuery</name><argument_list>(<argument><expr><literal type="string">"geodist(work_ll, 45.0, 43.0)"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
     <decl_stmt><decl><type><name>Query</name></type> <name>q_home2</name> <init>= <expr><call><name>getQuery</name><argument_list>(<argument><expr><literal type="string">"geodist(home_ll, 45.0, 43.0)"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">57</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">56</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@ <specifier>public</specifier> class <name>TestValueSourceCache</name> extends <name>SolrTestCaseJ4</name> <block>{
   }</block>
 
   @<name>Test</name>
  <specifier>public</specifier> <name>void</name> <call><name>testNumerics</name><argument_list>()</argument_list></call> <throws>throws <argument><expr><name>ParseException</name> <block>{
  <expr><specifier>public</specifier> <name>void</name> <call><name>testNumerics</name><argument_list>()</argument_list></call></expr></block></expr></argument></throws> <throws>throws <argument><expr><name>SyntaxError</name> <block>{
     <expr><name><name>String</name><index>[]</index></name> <name>templates</name> <operator>=</operator> <operator>new</operator> <name><name>String</name><index>[]</index></name><block>{
         <expr><literal type="string">"sum(#v0, #n0)"</literal></expr>,
         <argument><expr><literal type="string">"product(pow(#v0,#n0),#v1,#n1)"</literal></expr></argument>,
<argument/></block></expr></block></expr></argument>@<argument>@ <expr><operator>-</operator><literal type="number">94</literal></expr></argument>,<argument><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">93</literal></expr></argument>,<argument><expr><literal type="number">7</literal> @@ <specifier>public</specifier> class <name>TestValueSourceCache</name> extends <name>SolrTestCaseJ4</name></expr></argument></throws> <block>{<block_content>
 
   <comment type="line">// This test should will fail because q1 and q3 evaluate as equal unless</comment>
   <comment type="line">// fixes for bug 2829 are in place.</comment>
  <function><type><name>void</name></type> <name>tryQuerySameTypes</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>template</name></decl></parameter>, <parameter><decl><type><name>String</name></type> <name>numbers</name></decl></parameter>, <parameter><decl><type><name>String</name></type> <name>type</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>ParseException</name></expr></argument></throws> <block>{<block_content>
  <function><type><name>void</name></type> <name>tryQuerySameTypes</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>template</name></decl></parameter>, <parameter><decl><type><name>String</name></type> <name>numbers</name></decl></parameter>, <parameter><decl><type><name>String</name></type> <name>type</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>SyntaxError</name></expr></argument></throws> <block>{<block_content>
     <decl_stmt><decl><type><name>String</name></type> <name>s1</name> <init>= <expr><name>template</name></expr></init></decl>;</decl_stmt>
     <decl_stmt><decl><type><name>String</name></type> <name>s2</name> <init>= <expr><name>template</name></expr></init></decl>;</decl_stmt>
     <decl_stmt><decl><type><name>String</name></type> <name>s3</name> <init>= <expr><name>template</name></expr></init></decl>;</decl_stmt>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">120</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">119</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@ <specifier>public</specifier> class <name>TestValueSourceCache</name> extends <name>SolrTestCaseJ4</name> <block>{
 
   <comment type="line">// These should always and forever fail, and would have failed without the fixes for 2829, but why not make</comment>
   <comment type="line">// some more tests just in case???</comment>
  <expr><name>void</name> <call><name>tryQueryDiffTypes</name><argument_list>(<argument><expr><name>String</name> <name>template</name></expr></argument>, <argument><expr><name>String</name> <name>numbers</name></expr></argument>, <argument><expr><name><name>String</name><index>[]</index></name> <name>types</name></expr></argument>)</argument_list></call> <throws>throws <argument><expr><name>ParseException</name> <block>{
  <expr><name>void</name> <call><name>tryQueryDiffTypes</name><argument_list>(<argument><expr><name>String</name> <name>template</name></expr></argument>, <argument><expr><name>String</name> <name>numbers</name></expr></argument>, <argument><expr><name><name>String</name><index>[]</index></name> <name>types</name></expr></argument>)</argument_list></call></expr></block></expr></argument></throws> <throws>throws <argument><expr><name>SyntaxError</name> <block>{
     <expr><name>String</name> <name>s1</name> <operator>=</operator> <name>template</name></expr></block></expr></argument></throws></expr>;
     <name>String</name> <name>s2</name> <operator>=</operator> <name>template</name></block></expr>;</expr_stmt>
 
<expr_stmt><expr><name>diff</name> <operator>--</operator><name>git</name> <name>a</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>test</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>search</name><operator>/</operator><name>function</name><operator>/</operator><name><name>NvlValueSourceParser</name><operator>.</operator><name>java</name></name> <name>b</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>test</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>search</name><operator>/</operator><name>function</name><operator>/</operator><name><name>NvlValueSourceParser</name><operator>.</operator><name>java</name></name>
<name>index</name> <literal type="number">49a240afe88</literal><operator>..</operator><name>f56ad15edec</name> <literal type="number">100755</literal>
<operator>--</operator> <name>a</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>test</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>search</name><operator>/</operator><name>function</name><operator>/</operator><name><name>NvlValueSourceParser</name><operator>.</operator><name>java</name></name>
<operator>++</operator> <name>b</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>test</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>search</name><operator>/</operator><name>function</name><operator>/</operator><name><name>NvlValueSourceParser</name><operator>.</operator><name>java</name></name>
@@ <operator>-</operator><literal type="number">20</literal></expr><operator>,</operator><expr><literal type="number">9</literal> <operator>+</operator><literal type="number">20</literal></expr><operator>,</operator><expr><literal type="number">9</literal> @@</expr></expr_stmt> <package>package <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>search</name><operator>.</operator><name>function</name></name>;</package>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>queries</name><operator>.</operator><name>function</name><operator>.</operator><name>FunctionValues</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>queries</name><operator>.</operator><name>function</name><operator>.</operator><name>ValueSource</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>queries</name><operator>.</operator><name>function</name><operator>.</operator><name>valuesource</name><operator>.</operator><name>SimpleFloatFunction</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>queryparser</name><operator>.</operator><name>classic</name><operator>.</operator><name>ParseException</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>common</name><operator>.</operator><name>util</name><operator>.</operator><name>NamedList</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>search</name><operator>.</operator><name>FunctionQParser</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>search</name><operator>.</operator><name>SyntaxError</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>search</name><operator>.</operator><name>ValueSourceParser</name></name>;</import></block_content></block></function></block_content></block></function></block_content></block></expr></expr_stmt></block></class></expr></argument></argument_list></call></expr></expr_stmt></block_content></block></function></block_content></block></function></block></class></expr></argument></argument_list></call></expr></expr_stmt></block_content></block></function></block_content></block></function></block></class></expr></argument></argument_list></call></expr></expr_stmt></block_content></block></function></block_content></block></function></block></class></expr></argument></argument_list></call></expr></expr_stmt></block_content></block></function></block_content></block></function></block></class></expr></argument></argument_list></call></expr></expr_stmt></block_content></block></function></block_content></block></function></block></class></expr></argument></argument_list></call></expr></block></expr></expr_stmt></block_content></block></function></block_content></block></function></block></class></expr></argument></argument_list></call></expr></block></expr></expr_stmt></block_content></block></function></block_content></block></function></block></class></expr></argument></argument_list></call></expr></expr_stmt></block></class></expr></argument></argument_list></call></expr></expr_stmt></block></class></expr></argument></argument_list></call></expr></expr_stmt></block_content></block></function></block_content></block></function></block></class></expr></argument></argument_list></call></expr></block></expr></expr_stmt></block_content></block></function></block_content></block></function></block></class></expr></argument></argument_list></call></expr></block></expr></expr_stmt></block_content></block></function></block_content></block></function></block></class></expr></argument></argument_list></call></expr></expr_stmt></block></class></expr></argument></argument_list></call></expr></expr_stmt></block_content></block></function></block_content></block></function></block></class></expr></argument></argument_list></call></expr></expr_stmt></block_content></block></function></block_content></block></function></block></class></expr></argument></argument_list></call></block></expr></expr_stmt></block_content></block></function></block_content></block></function></block></class></expr></argument></argument_list></call></expr></expr_stmt></block></class></expr></argument></argument_list></call></expr></expr_stmt></block></class></expr></argument></argument_list></call></expr></expr_stmt></block></class></expr></argument></argument_list></call></expr></expr_stmt></block></class></expr></argument></argument_list></call></expr></expr_stmt></block></class></expr></argument></argument_list></call></expr></block></expr></block></expr></expr_stmt></block_content></block></if></if_stmt></block_content></block></function></block_content></block></function></block_content></block></function></block_content></block></if></if_stmt></block_content></block></function></block_content></block></function></block_content></block></function></block_content></block></function></block_content></block></if></if_stmt></block></expr></expr_stmt></block_content></block></if></if_stmt></block_content></block></for></block_content></block></function></block_content></block></function></block_content></block></if></if_stmt></block_content></block></if></if_stmt></block_content></block></if></if_stmt></block_content></block></if></if_stmt></block_content></block></function></block_content></block></function></block_content></block></function></block_content></block></if></if_stmt>
 
 <comment type="block" format="javadoc">/**
@@ -46,7 +46,7 @@ public class NvlValueSourceParser extends ValueSourceParser {
     private float nvlFloatValue = 0.0f;
 
     @Override
    public ValueSource parse(FunctionQParser fp) throws ParseException {
    public ValueSource parse(FunctionQParser fp) throws SyntaxError {
       ValueSource source = fp.parseValueSource();
       final float nvl = fp.parseFloat();
 
diff --git a/solr/core/src/test/org/apache/solr/util/DateMathParserTest.java b/solr/core/src/test/org/apache/solr/util/DateMathParserTest.java
index 83055810b1d..715055bb600 100644
-- a/solr/core/src/test/org/apache/solr/util/DateMathParserTest.java
++ b/solr/core/src/test/org/apache/solr/util/DateMathParserTest.java
@@ -329,7 +329,7 @@ public class DateMathParserTest extends LuceneTestCase {
     for (String command : badCommands.keySet()) {
       try {
         Date out = p.parseMath(command);
        fail("Didn't generate ParseException for: " + command);
        fail("Didn't generate SyntaxError for: " + command);
       } catch (ParseException e) {
         assertEquals("Wrong pos for: " + command + " =&gt; " + e.getMessage(),
                      badCommands.get(command).intValue(), e.getErrorOffset());
- 
2.19.1.windows.1

</comment></unit>
