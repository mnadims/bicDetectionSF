<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" revision="1.0.0" language="Java" filename="E:/01Courses@USASK/CMPT898-HumanDrivenSoftwareEngineeringForScientificResearch/ProjectProgress/data_files/final_dataset/gen_patch_codes/filtered/lucene/e6231ad585.java"><expr_stmt><expr><name>From</name> <name>e6231ad585c5a1799d881ebf2f25a917546fe795</name> <name>Mon</name> <name>Sep</name> <literal type="number">17</literal> <literal type="number">00</literal><operator>:</operator><literal type="number">00</literal><operator>:</operator><literal type="number">00</literal> <literal type="number">2001</literal>
<name>From</name><operator>:</operator> <name>Adrien</name> <name><name>Grand</name> <argument_list type="generic">&lt;<argument><name>jpountz</name><annotation>@<name><name>apache</name><operator>.</operator><name>org</name></name></annotation></argument>&gt;</argument_list></name>
<name>Date</name><operator>:</operator> <name>Sat</name></expr><operator>,</operator> <expr><literal type="number">23</literal> <name>Feb</name> <literal type="number">2013</literal> <literal type="number">16</literal><operator>:</operator><literal type="number">28</literal><operator>:</operator><literal type="number">13</literal> <operator>+</operator><literal type="number">0000</literal>
<name>Subject</name><operator>:</operator> <index>[<expr><name>PATCH</name></expr>]</index> <name>SOLR</name><operator>-</operator><literal type="number">3855</literal><operator>:</operator> <name>Fix</name> <name>faceting</name> <name>on</name> <name>numeric</name> <name>fields</name> <name>with</name> <name>precisionStep</name>
 <operator>&lt;</operator> <name><name>Integer</name><operator>.</operator><name>MAX_VALUE</name></name></expr><operator>,</operator> <expr><name><name>facet</name><operator>.</operator><name>mincount</name></name><operator>=</operator><literal type="number">0</literal> <name>and</name> <name><name>facet</name><operator>.</operator><name>method</name></name><operator>=</operator><name><name>fcs</name><operator>.</operator>

<name>git</name></name><operator>-</operator><name>svn</name><operator>-</operator><name>id</name><operator>:</operator> <name>https</name><operator>:</operator><comment type="line">//svn.apache.org/repos/asf/lucene/dev/trunk@1449360 13f79535-47bb-0310-9956-ffa450edef68</comment>
<operator>--</operator>
 <operator>...</operator><operator>/</operator><name>handler</name><operator>/</operator><name>component</name><operator>/</operator><name><name>StatsComponent</name><operator>.</operator><name>java</name></name>     <operator>|</operator>   <literal type="number">6</literal> <operator>+</operator><operator>-</operator>
 <operator>...</operator><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>request</name><operator>/</operator><name><name>NumericFacets</name><operator>.</operator><name>java</name></name>    <operator>|</operator>  <literal type="number">50</literal> <operator>++</operator><operator>++</operator><operator>++</operator><operator>++</operator><operator>-</operator>
 <operator>...</operator><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>request</name><operator>/</operator><name><name>SimpleFacets</name><operator>.</operator><name>java</name></name> <operator>|</operator> <literal type="number">103</literal> <operator>++</operator><operator>++</operator><operator>++</operator><operator>++</operator><operator>++</operator><operator>++</operator><operator>--</operator><operator>--</operator><operator>--</operator>
 <operator>...</operator><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>request</name><operator>/</operator><name><name>TestFaceting</name><operator>.</operator><name>java</name></name> <operator>|</operator>  <literal type="number">30</literal> <operator>++</operator><operator>++</operator><operator>+</operator>
 <literal type="number">4</literal> <name>files</name> <name>changed</name></expr><operator>,</operator> <expr><literal type="number">142</literal> <call><name>insertions</name><argument_list>(<argument><expr><operator>+</operator></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><literal type="number">47</literal> <call><name>deletions</name><argument_list>(<argument><expr><operator>-</operator></expr></argument>)</argument_list></call>

<name>diff</name> <operator>--</operator><name>git</name> <name>a</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>handler</name><operator>/</operator><name>component</name><operator>/</operator><name><name>StatsComponent</name><operator>.</operator><name>java</name></name> <name>b</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>handler</name><operator>/</operator><name>component</name><operator>/</operator><name><name>StatsComponent</name><operator>.</operator><name>java</name></name>
<name>index</name> <name>dc433b42783</name><operator>..</operator><literal type="number">377613e0aee</literal> <literal type="number">100644</literal>
<operator>--</operator> <name>a</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>handler</name><operator>/</operator><name>component</name><operator>/</operator><name><name>StatsComponent</name><operator>.</operator><name>java</name></name>
<operator>++</operator> <name>b</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>handler</name><operator>/</operator><name>component</name><operator>/</operator><name><name>StatsComponent</name><operator>.</operator><name>java</name></name>
@@ <operator>-</operator><literal type="number">35</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">35</literal></expr><operator>,</operator><expr><literal type="number">6</literal> @@</expr></expr_stmt> <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>request</name><operator>.</operator><name>SolrQueryRequest</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>request</name><operator>.</operator><name>UnInvertedField</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>schema</name><operator>.</operator><name>FieldType</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>schema</name><operator>.</operator><name>SchemaField</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>schema</name><operator>.</operator><name>TrieField</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>search</name><operator>.</operator><name>DocIterator</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>search</name><operator>.</operator><name>DocSet</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>search</name><operator>.</operator><name>SolrIndexSearcher</name></name>;</import>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">214</literal></expr><operator>,</operator><expr><literal type="number">10</literal> <operator>+</operator><literal type="number">213</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@ <name>class</name> <name>SimpleStats</name> <block>{
         <expr><name>FieldType</name> <name>ft</name> <operator>=</operator> <call><name><name>sf</name><operator>.</operator><name>getType</name></name><argument_list>()</argument_list></call></expr>;
         <expr><name><name>NamedList</name><argument_list type="generic">&lt;<argument><name>?</name></argument>&gt;</argument_list></name> <name>stv</name></expr>;
 
        <comment type="line">// Currently, only UnInvertedField can deal with multi-part trie fields</comment>
        <expr><name>String</name> <name>prefix</name> <operator>=</operator> <call><name><name>TrieField</name><operator>.</operator><name>getMainValuePrefix</name></name><argument_list>(<argument><expr><name>ft</name></expr></argument>)</argument_list></call></expr>;

        <if_stmt><if>if <condition>(<expr><call><name><name>sf</name><operator>.</operator><name>multiValued</name></name><argument_list>()</argument_list></call> <operator>||</operator> <call><name><name>ft</name><operator>.</operator><name>multiValuedFieldCache</name></name><argument_list>()</argument_list></call> <operator>||</operator> <name>prefix</name><operator>!=</operator><literal type="null">null</literal></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name><name>sf</name><operator>.</operator><name>multiValued</name></name><argument_list>()</argument_list></call> <operator>||</operator> <call><name><name>ft</name><operator>.</operator><name>multiValuedFieldCache</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
           <comment type="line">//use UnInvertedField for multivalued fields</comment>
           <decl_stmt><decl><type><name>UnInvertedField</name></type> <name>uif</name> <init>= <expr><call><name><name>UnInvertedField</name><operator>.</operator><name>getUnInvertedField</name></name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>searcher</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
           <expr_stmt><expr><name>stv</name> <operator>=</operator> <call><name><name>uif</name><operator>.</operator><name>getStats</name></name><argument_list>(<argument><expr><name>searcher</name></expr></argument>, <argument><expr><name>docs</name></expr></argument>, <argument><expr><name>facets</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>getStatsValues</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>diff</name> <operator>--</operator><name>git</name> <name>a</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>request</name><operator>/</operator><name><name>NumericFacets</name><operator>.</operator><name>java</name></name> <name>b</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>request</name><operator>/</operator><name><name>NumericFacets</name><operator>.</operator><name>java</name></name>
<name>index</name> <literal type="number">7a6ec4c9861</literal><operator>..</operator><name>a19356bf4c5</name> <literal type="number">100644</literal>
<operator>--</operator> <name>a</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>request</name><operator>/</operator><name><name>NumericFacets</name><operator>.</operator><name>java</name></name>
<operator>++</operator> <name>b</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>request</name><operator>/</operator><name><name>NumericFacets</name><operator>.</operator><name>java</name></name>
@@ <operator>-</operator><literal type="number">40</literal></expr><operator>,</operator><expr><literal type="number">10</literal> <operator>+</operator><literal type="number">40</literal></expr><operator>,</operator><expr><literal type="number">12</literal> @@</expr></expr_stmt> <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>util</name><operator>.</operator><name>Bits</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>util</name><operator>.</operator><name>BytesRef</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>util</name><operator>.</operator><name>CharsRef</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>util</name><operator>.</operator><name>PriorityQueue</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>util</name><operator>.</operator><name>StringHelper</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>common</name><operator>.</operator><name>params</name><operator>.</operator><name>FacetParams</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>common</name><operator>.</operator><name>util</name><operator>.</operator><name>NamedList</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>schema</name><operator>.</operator><name>FieldType</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>schema</name><operator>.</operator><name>SchemaField</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>schema</name><operator>.</operator><name>TrieField</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>search</name><operator>.</operator><name>DocIterator</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>search</name><operator>.</operator><name>DocSet</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>search</name><operator>.</operator><name>SolrIndexSearcher</name></name>;</import>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">266</literal></expr><operator>,</operator><expr><literal type="number">10</literal> <operator>+</operator><literal type="number">268</literal></expr><operator>,</operator><expr><literal type="number">28</literal> @@ <name>final</name> <name>class</name> <name>NumericFacets</name> <block>{
         }</block>
         <name>final</name> <name>Terms</name> <name>terms</name> <operator>=</operator> <call><name><name>searcher</name><operator>.</operator><name>getAtomicReader</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>terms</name><argument_list>(<argument><expr><name>fieldName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
         <if_stmt><if>if <condition>(<expr><name>terms</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
          <decl_stmt><decl><type><specifier>final</specifier> <name>String</name></type> <name>prefixStr</name> <init>= <expr><call><name><name>TrieField</name><operator>.</operator><name>getMainValuePrefix</name></name><argument_list>(<argument><expr><name>ft</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><specifier>final</specifier> <name>BytesRef</name></type> <name>prefix</name></decl>;</decl_stmt>
          <if_stmt><if>if <condition>(<expr><name>prefixStr</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>prefix</name> <operator>=</operator> <operator>new</operator> <call><name>BytesRef</name><argument_list>(<argument><expr><name>prefixStr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt/></block_content></block></if></if_stmt></block_content></block></if></if_stmt></block_content></block></if></if_stmt></block_content></block></if></if_stmt>}</block></expr></expr_stmt> <if_stmt><else>else <block>{<block_content>
            <expr_stmt><expr><name>prefix</name> <operator>=</operator> <operator>new</operator> <call><name>BytesRef</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></else></if_stmt>
           <decl_stmt><decl><type><specifier>final</specifier> <name>TermsEnum</name></type> <name>termsEnum</name> <init>= <expr><call><name><name>terms</name><operator>.</operator><name>iterator</name></name><argument_list>(<argument><expr><literal type="null">null</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>BytesRef</name></type> <name>term</name> <init>= <expr><call><name><name>termsEnum</name><operator>.</operator><name>next</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>BytesRef</name></type> <name>term</name></decl>;</decl_stmt>
          <switch>switch <condition>(<expr><call><name><name>termsEnum</name><operator>.</operator><name>seekCeil</name></name><argument_list>(<argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <case>case <expr><name>FOUND</name></expr>:</case>
            <case>case <expr><name>NOT_FOUND</name></expr>:</case>
              <expr_stmt><expr><name>term</name> <operator>=</operator> <call><name><name>termsEnum</name><operator>.</operator><name>term</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
              <break>break;</break>
            <case>case <expr><name>END</name></expr>:</case>
              <expr_stmt><expr><name>term</name> <operator>=</operator> <literal type="null">null</literal></expr>;</expr_stmt>
              <break>break;</break>
            <default>default:</default>
              <throw>throw <expr><operator>new</operator> <call><name>AssertionError</name><argument_list>()</argument_list></call></expr>;</throw>
          </block_content>}</block></switch>
           <decl_stmt><decl><type><specifier>final</specifier> <name>CharsRef</name></type> <name>spare</name> <init>= <expr><operator>new</operator> <call><name>CharsRef</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
          <for>for <control>(<init><decl><type><name>int</name></type> <name>skipped</name> <init>= <expr><name><name>hashTable</name><operator>.</operator><name>size</name></name></expr></init></decl>;</init> <condition><expr><name>skipped</name> <operator>&lt;</operator> <name>offset</name> <operator>&amp;&amp;</operator> <name>term</name> <operator>!=</operator> <literal type="null">null</literal></expr>;</condition> <incr/>)</control> <block>{<block_content>
          <for>for <control>(<init><decl><type><name>int</name></type> <name>skipped</name> <init>= <expr><name><name>hashTable</name><operator>.</operator><name>size</name></name></expr></init></decl>;</init> <condition><expr><name>skipped</name> <operator>&lt;</operator> <name>offset</name> <operator>&amp;&amp;</operator> <name>term</name> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <call><name><name>StringHelper</name><operator>.</operator><name>startsWith</name></name><argument_list>(<argument><expr><name>term</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>;</condition> <incr/>)</control> <block>{<block_content>
             <expr_stmt><expr><call><name><name>ft</name><operator>.</operator><name>indexedToReadable</name></name><argument_list>(<argument><expr><name>term</name></expr></argument>, <argument><expr><name>spare</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
             <decl_stmt><decl><type><specifier>final</specifier> <name>String</name></type> <name>termStr</name> <init>= <expr><call><name><name>spare</name><operator>.</operator><name>toString</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
             <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>alreadySeen</name><operator>.</operator><name>contains</name></name><argument_list>(<argument><expr><name>termStr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">277</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">297</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@ <name>final</name> <name>class</name> <name>NumericFacets</name> <block>{
             }</block>
             <name>term</name> <operator>=</operator> <call><name><name>termsEnum</name><operator>.</operator><name>next</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
           </block_content>}</block></if></if_stmt>
          <for>for <control>( <init>;</init> <condition><expr><name>term</name> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>limit</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <call><name><name>result</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&lt;</operator> <name>limit</name><operator>)</operator></expr>;</condition> <incr><expr><name>term</name> <operator>=</operator> <call><name><name>termsEnum</name><operator>.</operator><name>next</name></name><argument_list>()</argument_list></call></expr></incr>)</control> <block>{<block_content>
          <for>for <control>( <init>;</init> <condition><expr><name>term</name> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <call><name><name>StringHelper</name><operator>.</operator><name>startsWith</name></name><argument_list>(<argument><expr><name>term</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name>limit</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <call><name><name>result</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&lt;</operator> <name>limit</name><operator>)</operator></expr>;</condition> <incr><expr><name>term</name> <operator>=</operator> <call><name><name>termsEnum</name><operator>.</operator><name>next</name></name><argument_list>()</argument_list></call></expr></incr>)</control> <block>{<block_content>
             <expr_stmt><expr><call><name><name>ft</name><operator>.</operator><name>indexedToReadable</name></name><argument_list>(<argument><expr><name>term</name></expr></argument>, <argument><expr><name>spare</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
             <decl_stmt><decl><type><specifier>final</specifier> <name>String</name></type> <name>termStr</name> <init>= <expr><call><name><name>spare</name><operator>.</operator><name>toString</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
             <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>alreadySeen</name><operator>.</operator><name>contains</name></name><argument_list>(<argument><expr><name>termStr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">301</literal></expr><operator>,</operator><expr><literal type="number">13</literal> <operator>+</operator><literal type="number">321</literal></expr><operator>,</operator><expr><literal type="number">31</literal> @@ <name>final</name> <name>class</name> <name>NumericFacets</name> <block>{
       }</block>
       <name>final</name> <name>Terms</name> <name>terms</name> <operator>=</operator> <call><name><name>searcher</name><operator>.</operator><name>getAtomicReader</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>terms</name><argument_list>(<argument><expr><name>fieldName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
       <if_stmt><if>if <condition>(<expr><name>terms</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><specifier>final</specifier> <name>String</name></type> <name>prefixStr</name> <init>= <expr><call><name><name>TrieField</name><operator>.</operator><name>getMainValuePrefix</name></name><argument_list>(<argument><expr><name>ft</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>BytesRef</name></type> <name>prefix</name></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>prefixStr</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><name>prefix</name> <operator>=</operator> <operator>new</operator> <call><name>BytesRef</name><argument_list>(<argument><expr><name>prefixStr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
          <expr_stmt><expr><name>prefix</name> <operator>=</operator> <operator>new</operator> <call><name>BytesRef</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
         <decl_stmt><decl><type><specifier>final</specifier> <name>TermsEnum</name></type> <name>termsEnum</name> <init>= <expr><call><name><name>terms</name><operator>.</operator><name>iterator</name></name><argument_list>(<argument><expr><literal type="null">null</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>BytesRef</name></type> <name>term</name></decl>;</decl_stmt>
        <switch>switch <condition>(<expr><call><name><name>termsEnum</name><operator>.</operator><name>seekCeil</name></name><argument_list>(<argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
          <case>case <expr><name>FOUND</name></expr>:</case>
          <case>case <expr><name>NOT_FOUND</name></expr>:</case>
            <expr_stmt><expr><name>term</name> <operator>=</operator> <call><name><name>termsEnum</name><operator>.</operator><name>term</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
          <case>case <expr><name>END</name></expr>:</case>
            <expr_stmt><expr><name>term</name> <operator>=</operator> <literal type="null">null</literal></expr>;</expr_stmt>
            <break>break;</break>
          <default>default:</default>
            <throw>throw <expr><operator>new</operator> <call><name>AssertionError</name><argument_list>()</argument_list></call></expr>;</throw>
        </block_content>}</block></switch>
         <decl_stmt><decl><type><specifier>final</specifier> <name>CharsRef</name></type> <name>spare</name> <init>= <expr><operator>new</operator> <call><name>CharsRef</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>BytesRef</name></type> <name>term</name> <init>= <expr><call><name><name>termsEnum</name><operator>.</operator><name>next</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>offset</name> <operator>&amp;&amp;</operator> <name>term</name> <operator>!=</operator> <literal type="null">null</literal></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>offset</name> <operator>&amp;&amp;</operator> <name>term</name> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <call><name><name>StringHelper</name><operator>.</operator><name>startsWith</name></name><argument_list>(<argument><expr><name>term</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
           <expr_stmt><expr><name>term</name> <operator>=</operator> <call><name><name>termsEnum</name><operator>.</operator><name>next</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
         </block_content>}</block></for>
        <for>for <control>( <init>;</init> <condition><expr><name>term</name> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>limit</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <call><name><name>result</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&lt;</operator> <name>limit</name><operator>)</operator></expr>;</condition> <incr><expr><name>term</name> <operator>=</operator> <call><name><name>termsEnum</name><operator>.</operator><name>next</name></name><argument_list>()</argument_list></call></expr></incr>)</control> <block>{<block_content>
        <for>for <control>( <init>;</init> <condition><expr><name>term</name> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <call><name><name>StringHelper</name><operator>.</operator><name>startsWith</name></name><argument_list>(<argument><expr><name>term</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name>limit</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <call><name><name>result</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&lt;</operator> <name>limit</name><operator>)</operator></expr>;</condition> <incr><expr><name>term</name> <operator>=</operator> <call><name><name>termsEnum</name><operator>.</operator><name>next</name></name><argument_list>()</argument_list></call></expr></incr>)</control> <block>{<block_content>
           <expr_stmt><expr><call><name><name>ft</name><operator>.</operator><name>indexedToReadable</name></name><argument_list>(<argument><expr><name>term</name></expr></argument>, <argument><expr><name>spare</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
           <decl_stmt><decl><type><specifier>final</specifier> <name>String</name></type> <name>termStr</name> <init>= <expr><call><name><name>spare</name><operator>.</operator><name>toString</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
           <decl_stmt><decl><type><name>Integer</name></type> <name>count</name> <init>= <expr><call><name><name>counts</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>termStr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>diff</name> <operator>--</operator><name>git</name> <name>a</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>request</name><operator>/</operator><name><name>SimpleFacets</name><operator>.</operator><name>java</name></name> <name>b</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>request</name><operator>/</operator><name><name>SimpleFacets</name><operator>.</operator><name>java</name></name>
<name>index</name> <name>f0f48787b14</name><operator>..</operator><literal type="number">49a6c67d4bb</literal> <literal type="number">100644</literal>
<operator>--</operator> <name>a</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>request</name><operator>/</operator><name><name>SimpleFacets</name><operator>.</operator><name>java</name></name>
<operator>++</operator> <name>b</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>request</name><operator>/</operator><name><name>SimpleFacets</name><operator>.</operator><name>java</name></name>
@@ <operator>-</operator><literal type="number">320</literal></expr><operator>,</operator><expr><literal type="number">6</literal> <operator>+</operator><literal type="number">320</literal></expr><operator>,</operator><expr><literal type="number">10</literal> @@ <specifier>public</specifier> <name>class</name> <name>SimpleFacets</name> <block>{
     <return>return <expr><call><name><name>collector</name><operator>.</operator><name>getGroupCount</name></name><argument_list>()</argument_list></call></expr>;</return>
   }</block></expr></expr_stmt>
 
  <enum>enum <name>FacetMethod</name> <block>{
    <decl><name>ENUM</name></decl>, <decl><name>FC</name></decl>, <decl><name>FCS</name></decl>;
  }</block></enum>

   <function><type><specifier>public</specifier> <name><name>NamedList</name><argument_list type="generic">&lt;<argument><name>Integer</name></argument>&gt;</argument_list></name></type> <name>getTermCounts</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>field</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws> <block>{<block_content>
     <decl_stmt><decl><type><name>int</name></type> <name>offset</name> <init>= <expr><call><name><name>params</name><operator>.</operator><name>getFieldInt</name></name><argument_list>(<argument><expr><name>field</name></expr></argument>, <argument><expr><name><name>FacetParams</name><operator>.</operator><name>FACET_OFFSET</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
     <decl_stmt><decl><type><name>int</name></type> <name>limit</name> <init>= <expr><call><name><name>params</name><operator>.</operator><name>getFieldInt</name></name><argument_list>(<argument><expr><name>field</name></expr></argument>, <argument><expr><name><name>FacetParams</name><operator>.</operator><name>FACET_LIMIT</name></name></expr></argument>, <argument><expr><literal type="number">100</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">342</literal></expr><operator>,</operator><expr><literal type="number">57</literal> <operator>+</operator><literal type="number">346</literal></expr><operator>,</operator><expr><literal type="number">84</literal> @@ <specifier>public</specifier> <name>class</name> <name>SimpleFacets</name> <block>{
     <expr><name>FieldType</name> <name>ft</name> <operator>=</operator> <call><name><name>sf</name><operator>.</operator><name>getType</name></name><argument_list>()</argument_list></call></expr>;
 
     <comment type="line">// determine what type of faceting method to use</comment>
    <name>String</name> <name>method</name> <operator>=</operator> <call><name><name>params</name><operator>.</operator><name>getFieldParam</name></name><argument_list>(<argument><expr><name>field</name></expr></argument>, <argument><expr><name><name>FacetParams</name><operator>.</operator><name>FACET_METHOD</name></name></expr></argument>)</argument_list></call></block></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>boolean</name></type> <name>enumMethod</name> <init>= <expr><call><name><name>FacetParams</name><operator>.</operator><name>FACET_METHOD_enum</name><operator>.</operator><name>equals</name></name><argument_list>(<argument><expr><name>method</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>final</specifier> <name>String</name></type> <name>methodStr</name> <init>= <expr><call><name><name>params</name><operator>.</operator><name>getFieldParam</name></name><argument_list>(<argument><expr><name>field</name></expr></argument>, <argument><expr><name><name>FacetParams</name><operator>.</operator><name>FACET_METHOD</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>FacetMethod</name></type> <name>method</name> <init>= <expr><literal type="null">null</literal></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name><name>FacetParams</name><operator>.</operator><name>FACET_METHOD_enum</name><operator>.</operator><name>equals</name></name><argument_list>(<argument><expr><name>methodStr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>method</name> <operator>=</operator> <name><name>FacetMethod</name><operator>.</operator><name>ENUM</name></name></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name><name>FacetParams</name><operator>.</operator><name>FACET_METHOD_fcs</name><operator>.</operator><name>equals</name></name><argument_list>(<argument><expr><name>methodStr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>method</name> <operator>=</operator> <name><name>FacetMethod</name><operator>.</operator><name>FCS</name></name></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name><name>FacetParams</name><operator>.</operator><name>FACET_METHOD_fc</name><operator>.</operator><name>equals</name></name><argument_list>(<argument><expr><name>methodStr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>method</name> <operator>=</operator> <name><name>FacetMethod</name><operator>.</operator><name>FC</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
 
    <comment type="line">// TODO: default to per-segment or not?</comment>
    <decl_stmt><decl><type><name>boolean</name></type> <name>per_segment</name> <init>= <expr><call><name><name>FacetParams</name><operator>.</operator><name>FACET_METHOD_fcs</name><operator>.</operator><name>equals</name></name><argument_list>(<argument><expr><name>method</name></expr></argument>)</argument_list></call> <comment type="line">// explicit</comment>
        <operator>||</operator> <operator>(</operator><call><name><name>ft</name><operator>.</operator><name>getNumericType</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <call><name><name>sf</name><operator>.</operator><name>hasDocValues</name></name><argument_list>()</argument_list></call><operator>)</operator></expr></init></decl>;</decl_stmt> <comment type="line">// numeric doc values are per-segment by default</comment>
    <if_stmt><if>if <condition>(<expr><name>method</name> <operator>==</operator> <name><name>FacetMethod</name><operator>.</operator><name>ENUM</name></name> <operator>&amp;&amp;</operator> <call><name><name>TrieField</name><operator>.</operator><name>getMainValuePrefix</name></name><argument_list>(<argument><expr><name>ft</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
      <comment type="line">// enum can't deal with trie fields that index several terms per value</comment>
      <expr_stmt><expr><name>method</name> <operator>=</operator> <ternary><condition><expr><call><name><name>sf</name><operator>.</operator><name>multiValued</name></name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><name><name>FacetMethod</name><operator>.</operator><name>FC</name></name></expr> </then><else>: <expr><name><name>FacetMethod</name><operator>.</operator><name>FCS</name></name></expr></else></ternary></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
 
     <if_stmt><if>if <condition>(<expr><name>method</name> <operator>==</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <name>ft</name> <operator>instanceof</operator> <name>BoolField</name></expr>)</condition> <block>{<block_content>
       <comment type="line">// Always use filters for booleans... we know the number of values is very small.</comment>
      <expr_stmt><expr><name>enumMethod</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>method</name> <operator>=</operator> <name><name>FacetMethod</name><operator>.</operator><name>ENUM</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <decl_stmt><decl><type><specifier>final</specifier> <name>boolean</name></type> <name>multiToken</name> <init>= <expr><call><name><name>sf</name><operator>.</operator><name>multiValued</name></name><argument_list>()</argument_list></call> <operator>||</operator> <call><name><name>ft</name><operator>.</operator><name>multiValuedFieldCache</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    
    <if_stmt><if>if <condition>(<expr><name>method</name> <operator>==</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <call><name><name>ft</name><operator>.</operator><name>getNumericType</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name><name>sf</name><operator>.</operator><name>multiValued</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
      <comment type="line">// the per-segment approach is optimal for numeric field types since there</comment>
      <comment type="line">// are no global ords to merge and no need to create an expensive</comment>
      <comment type="line">// top-level reader</comment>
      <expr_stmt><expr><name>method</name> <operator>=</operator> <name><name>FacetMethod</name><operator>.</operator><name>FCS</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name><name>ft</name><operator>.</operator><name>getNumericType</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <call><name><name>sf</name><operator>.</operator><name>hasDocValues</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
      <comment type="line">// only fcs is able to leverage the numeric field caches</comment>
      <expr_stmt><expr><name>method</name> <operator>=</operator> <name><name>FacetMethod</name><operator>.</operator><name>FCS</name></name></expr>;</expr_stmt>
     </block_content>}</block></if></if_stmt>
    <decl_stmt><decl><type><name>boolean</name></type> <name>multiToken</name> <init>= <expr><call><name><name>sf</name><operator>.</operator><name>multiValued</name></name><argument_list>()</argument_list></call> <operator>||</operator> <call><name><name>ft</name><operator>.</operator><name>multiValuedFieldCache</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
 
    <if_stmt><if>if <condition>(<expr><call><name><name>TrieField</name><operator>.</operator><name>getMainValuePrefix</name></name><argument_list>(<argument><expr><name>ft</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
      <comment type="line">// A TrieField with multiple parts indexed per value... currently only</comment>
      <comment type="line">// UnInvertedField can handle this case, so force it's use.</comment>
      <expr_stmt><expr><name>enumMethod</name> <operator>=</operator> <literal type="boolean">false</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>multiToken</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>method</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
      <comment type="line">// TODO: default to per-segment or not?</comment>
      <expr_stmt><expr><name>method</name> <operator>=</operator> <name><name>FacetMethod</name><operator>.</operator><name>FC</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>method</name> <operator>==</operator> <name><name>FacetMethod</name><operator>.</operator><name>FCS</name></name> <operator>&amp;&amp;</operator> <name>multiToken</name></expr>)</condition> <block>{<block_content>
      <comment type="line">// only fc knows how to deal with multi-token fields</comment>
      <expr_stmt><expr><name>method</name> <operator>=</operator> <name><name>FacetMethod</name><operator>.</operator><name>FC</name></name></expr>;</expr_stmt>
     </block_content>}</block></if></if_stmt>
 
     <if_stmt><if>if <condition>(<expr><call><name><name>params</name><operator>.</operator><name>getFieldBool</name></name><argument_list>(<argument><expr><name>field</name></expr></argument>, <argument><expr><name><name>GroupParams</name><operator>.</operator><name>GROUP_FACET</name></name></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
       <expr_stmt><expr><name>counts</name> <operator>=</operator> <call><name>getGroupedCounts</name><argument_list>(<argument><expr><name>searcher</name></expr></argument>, <argument><expr><name>docs</name></expr></argument>, <argument><expr><name>field</name></expr></argument>, <argument><expr><name>multiToken</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>,<argument><expr><name>limit</name></expr></argument>, <argument><expr><name>mincount</name></expr></argument>, <argument><expr><name>missing</name></expr></argument>, <argument><expr><name>sort</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
     </block_content>}</block></if> <else>else <block>{<block_content>
      <comment type="line">// unless the enum method is explicitly specified, use a counting method.</comment>
      <if_stmt><if>if <condition>(<expr><name>enumMethod</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>counts</name> <operator>=</operator> <call><name>getFacetTermEnumCounts</name><argument_list>(<argument><expr><name>searcher</name></expr></argument>, <argument><expr><name>docs</name></expr></argument>, <argument><expr><name>field</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>limit</name></expr></argument>, <argument><expr><name>mincount</name></expr></argument>,<argument><expr><name>missing</name></expr></argument>,<argument><expr><name>sort</name></expr></argument>,<argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if> <else>else <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>multiToken</name></expr>)</condition> <block>{<block_content>
          <decl_stmt><decl><type><name>UnInvertedField</name></type> <name>uif</name> <init>= <expr><call><name><name>UnInvertedField</name><operator>.</operator><name>getUnInvertedField</name></name><argument_list>(<argument><expr><name>field</name></expr></argument>, <argument><expr><name>searcher</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><name>counts</name> <operator>=</operator> <call><name><name>uif</name><operator>.</operator><name>getCounts</name></name><argument_list>(<argument><expr><name>searcher</name></expr></argument>, <argument><expr><name>docs</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>limit</name></expr></argument>, <argument><expr><name>mincount</name></expr></argument>,<argument><expr><name>missing</name></expr></argument>,<argument><expr><name>sort</name></expr></argument>,<argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
          <comment type="line">// TODO: future logic could use filters instead of the fieldcache if</comment>
          <comment type="line">// the number of terms in the field is small enough.</comment>
          <if_stmt><if>if <condition>(<expr><name>per_segment</name></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name><name>ft</name><operator>.</operator><name>getNumericType</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name><name>sf</name><operator>.</operator><name>multiValued</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
              <comment type="line">// force numeric faceting</comment>
              <if_stmt><if>if <condition>(<expr><name>prefix</name> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name><name>prefix</name><operator>.</operator><name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
                <throw>throw <expr><operator>new</operator> <call><name>SolrException</name><argument_list>(<argument><expr><name><name>ErrorCode</name><operator>.</operator><name>BAD_REQUEST</name></name></expr></argument>, <argument><expr><name><name>FacetParams</name><operator>.</operator><name>FACET_PREFIX</name></name> <operator>+</operator> <literal type="string">" is not supported on numeric types"</literal></expr></argument>)</argument_list></call></expr>;</throw>
              </block_content>}</block></if></if_stmt>
              <expr_stmt><expr><name>counts</name> <operator>=</operator> <call><name><name>NumericFacets</name><operator>.</operator><name>getCounts</name></name><argument_list>(<argument><expr><name>searcher</name></expr></argument>, <argument><expr><name>docs</name></expr></argument>, <argument><expr><name>field</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>limit</name></expr></argument>, <argument><expr><name>mincount</name></expr></argument>, <argument><expr><name>missing</name></expr></argument>, <argument><expr><name>sort</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
              <decl_stmt><decl><type><name>PerSegmentSingleValuedFaceting</name></type> <name>ps</name> <init>= <expr><operator>new</operator> <call><name>PerSegmentSingleValuedFaceting</name><argument_list>(<argument><expr><name>searcher</name></expr></argument>, <argument><expr><name>docs</name></expr></argument>, <argument><expr><name>field</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>,<argument><expr><name>limit</name></expr></argument>, <argument><expr><name>mincount</name></expr></argument>, <argument><expr><name>missing</name></expr></argument>, <argument><expr><name>sort</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
              <decl_stmt><decl><type><name>Executor</name></type> <name>executor</name> <init>= <expr><ternary><condition><expr><name>threads</name> <operator>==</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>directExecutor</name></expr> </then><else>: <expr><name>facetExecutor</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
              <expr_stmt><expr><call><name><name>ps</name><operator>.</operator><name>setNumThreads</name></name><argument_list>(<argument><expr><name>threads</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><name>counts</name> <operator>=</operator> <call><name><name>ps</name><operator>.</operator><name>getFacetCounts</name></name><argument_list>(<argument><expr><name>executor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <assert>assert <expr><name>method</name> <operator>!=</operator> <literal type="null">null</literal></expr>;</assert>
      <switch>switch <condition>(<expr><name>method</name></expr>)</condition> <block>{<block_content>
        <case>case <expr><name>ENUM</name></expr>:</case>
          <assert>assert <expr><call><name><name>TrieField</name><operator>.</operator><name>getMainValuePrefix</name></name><argument_list>(<argument><expr><name>ft</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="null">null</literal></expr>;</assert>
          <expr_stmt><expr><name>counts</name> <operator>=</operator> <call><name>getFacetTermEnumCounts</name><argument_list>(<argument><expr><name>searcher</name></expr></argument>, <argument><expr><name>docs</name></expr></argument>, <argument><expr><name>field</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>limit</name></expr></argument>, <argument><expr><name>mincount</name></expr></argument>,<argument><expr><name>missing</name></expr></argument>,<argument><expr><name>sort</name></expr></argument>,<argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <break>break;</break>
        <case>case <expr><name>FCS</name></expr>:</case>
          <assert>assert <expr><operator>!</operator><name>multiToken</name></expr>;</assert>
          <if_stmt><if>if <condition>(<expr><call><name><name>ft</name><operator>.</operator><name>getNumericType</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name><name>sf</name><operator>.</operator><name>multiValued</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
            <comment type="line">// force numeric faceting</comment>
            <if_stmt><if>if <condition>(<expr><name>prefix</name> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name><name>prefix</name><operator>.</operator><name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
              <throw>throw <expr><operator>new</operator> <call><name>SolrException</name><argument_list>(<argument><expr><name><name>ErrorCode</name><operator>.</operator><name>BAD_REQUEST</name></name></expr></argument>, <argument><expr><name><name>FacetParams</name><operator>.</operator><name>FACET_PREFIX</name></name> <operator>+</operator> <literal type="string">" is not supported on numeric types"</literal></expr></argument>)</argument_list></call></expr>;</throw>
             </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>counts</name> <operator>=</operator> <call><name><name>NumericFacets</name><operator>.</operator><name>getCounts</name></name><argument_list>(<argument><expr><name>searcher</name></expr></argument>, <argument><expr><name>docs</name></expr></argument>, <argument><expr><name>field</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>limit</name></expr></argument>, <argument><expr><name>mincount</name></expr></argument>, <argument><expr><name>missing</name></expr></argument>, <argument><expr><name>sort</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if> <else>else <block>{<block_content>
            <decl_stmt><decl><type><name>PerSegmentSingleValuedFaceting</name></type> <name>ps</name> <init>= <expr><operator>new</operator> <call><name>PerSegmentSingleValuedFaceting</name><argument_list>(<argument><expr><name>searcher</name></expr></argument>, <argument><expr><name>docs</name></expr></argument>, <argument><expr><name>field</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>,<argument><expr><name>limit</name></expr></argument>, <argument><expr><name>mincount</name></expr></argument>, <argument><expr><name>missing</name></expr></argument>, <argument><expr><name>sort</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Executor</name></type> <name>executor</name> <init>= <expr><ternary><condition><expr><name>threads</name> <operator>==</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>directExecutor</name></expr> </then><else>: <expr><name>facetExecutor</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>ps</name><operator>.</operator><name>setNumThreads</name></name><argument_list>(<argument><expr><name>threads</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>counts</name> <operator>=</operator> <call><name><name>ps</name><operator>.</operator><name>getFacetCounts</name></name><argument_list>(<argument><expr><name>executor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></else></if_stmt>
          <break>break;</break>
        <case>case <expr><name>FC</name></expr>:</case>
          <if_stmt><if>if <condition>(<expr><name>multiToken</name> <operator>||</operator> <call><name><name>TrieField</name><operator>.</operator><name>getMainValuePrefix</name></name><argument_list>(<argument><expr><name>ft</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>UnInvertedField</name></type> <name>uif</name> <init>= <expr><call><name><name>UnInvertedField</name><operator>.</operator><name>getUnInvertedField</name></name><argument_list>(<argument><expr><name>field</name></expr></argument>, <argument><expr><name>searcher</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>counts</name> <operator>=</operator> <call><name><name>uif</name><operator>.</operator><name>getCounts</name></name><argument_list>(<argument><expr><name>searcher</name></expr></argument>, <argument><expr><name>docs</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>limit</name></expr></argument>, <argument><expr><name>mincount</name></expr></argument>,<argument><expr><name>missing</name></expr></argument>,<argument><expr><name>sort</name></expr></argument>,<argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
           </block_content>}</block></if> <else>else <block>{<block_content>
             <expr_stmt><expr><name>counts</name> <operator>=</operator> <call><name>getFieldCacheCounts</name><argument_list>(<argument><expr><name>searcher</name></expr></argument>, <argument><expr><name>docs</name></expr></argument>, <argument><expr><name>field</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>,<argument><expr><name>limit</name></expr></argument>, <argument><expr><name>mincount</name></expr></argument>, <argument><expr><name>missing</name></expr></argument>, <argument><expr><name>sort</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
           </block_content>}</block></else></if_stmt>

        </block_content>}</block></switch>
          <break>break;</break>
        <default>default:</default>
          <throw>throw <expr><operator>new</operator> <call><name>AssertionError</name><argument_list>()</argument_list></call></expr>;</throw>
       </block_content>}</block></else></if_stmt>
     </block_content>}</block></if></if_stmt>
 
<expr_stmt><expr><name>diff</name> <operator>--</operator><name>git</name> <name>a</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>test</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>request</name><operator>/</operator><name><name>TestFaceting</name><operator>.</operator><name>java</name></name> <name>b</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>test</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>request</name><operator>/</operator><name><name>TestFaceting</name><operator>.</operator><name>java</name></name>
<name>index</name> <literal type="number">6c3f9b3f9d6</literal><operator>..</operator><literal type="number">9cd0486b0aa</literal> <literal type="number">100755</literal>
<operator>--</operator> <name>a</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>test</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>request</name><operator>/</operator><name><name>TestFaceting</name><operator>.</operator><name>java</name></name>
<operator>++</operator> <name>b</name><operator>/</operator><name>solr</name><operator>/</operator><name>core</name><operator>/</operator><name>src</name><operator>/</operator><name>test</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>solr</name><operator>/</operator><name>request</name><operator>/</operator><name><name>TestFaceting</name><operator>.</operator><name>java</name></name>
@@ <operator>-</operator><literal type="number">17</literal></expr><operator>,</operator><expr><literal type="number">6</literal> <operator>+</operator><literal type="number">17</literal></expr><operator>,</operator><expr><literal type="number">8</literal> @@</expr></expr_stmt>
 
 <package>package <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>request</name></name>;</package>
 
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>ArrayList</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>List</name></name>;</import>
 <import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>Locale</name></name>;</import>
 <import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>Random</name></name>;</import>
 
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">25</literal></expr><operator>,</operator><expr><literal type="number">6</literal> <operator>+</operator><literal type="number">27</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@</expr></expr_stmt> <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>index</name><operator>.</operator><name>Term</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>index</name><operator>.</operator><name>TermsEnum</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>lucene</name><operator>.</operator><name>util</name><operator>.</operator><name>BytesRef</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>SolrTestCaseJ4</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>solr</name><operator>.</operator><name>common</name><operator>.</operator><name>params</name><operator>.</operator><name>FacetParams</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>junit</name><operator>.</operator><name>After</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>junit</name><operator>.</operator><name>BeforeClass</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>junit</name><operator>.</operator><name>Test</name></name>;</import>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">263</literal></expr><operator>,</operator><expr><literal type="number">5</literal> <operator>+</operator><literal type="number">266</literal></expr><operator>,</operator><expr><literal type="number">32</literal> @@ <specifier>public</specifier> <name>class</name> <name>TestFaceting</name> extends <name>SolrTestCaseJ4</name> <block>{
             )</block></expr>;</expr_stmt>
   </block_content>}</block></else></if_stmt>
 
  <function><annotation>@<name>Test</name></annotation>
  <type><specifier>public</specifier> <name>void</name></type> <name>testTrieFields</name><parameter_list>()</parameter_list> <block>{<block_content>
    <comment type="line">// make sure that terms are correctly filtered even for trie fields that index several</comment>
    <comment type="line">// terms for a single value</comment>
    <decl_stmt><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>fields</name> <init>= <expr><operator>new</operator> <call><name><name>ArrayList</name><argument_list type="generic">&lt;<argument><name>String</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>fields</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><literal type="string">"id"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>fields</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><literal type="string">"7"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><specifier>final</specifier> <name><name>String</name><index>[]</index></name></type> <name>suffixes</name> <init>= <expr><operator>new</operator> <name><name>String</name><index>[]</index></name> <block>{<expr><literal type="string">"ti"</literal></expr>, <expr><literal type="string">"tis"</literal></expr>, <expr><literal type="string">"tf"</literal></expr>, <expr><literal type="string">"tfs"</literal></expr>, <expr><literal type="string">"tl"</literal></expr>, <expr><literal type="string">"tls"</literal></expr>, <expr><literal type="string">"td"</literal></expr>, <expr><literal type="string">"tds"</literal></expr>}</block></expr></init></decl>;</decl_stmt>
    <for>for <control>(<init><decl><type><name>String</name></type> <name>suffix</name> <range>: <expr><name>suffixes</name></expr></range></decl></init>)</control> <block>{<block_content>
      <expr_stmt><expr><call><name><name>fields</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><literal type="string">"f_"</literal> <operator>+</operator> <name>suffix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>fields</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><literal type="string">"42"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>assertU</name><argument_list>(<argument><expr><call><name>adoc</name><argument_list>(<argument><expr><call><name><name>fields</name><operator>.</operator><name>toArray</name></name><argument_list>(<argument><expr><operator>new</operator> <name><name>String</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assertU</name><argument_list>(<argument><expr><call><name>commit</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><decl><type><name>String</name></type> <name>suffix</name> <range>: <expr><name>suffixes</name></expr></range></decl></init>)</control> <block>{<block_content>
      <for>for <control>(<init><decl><type><name>String</name></type> <name>facetMethod</name> <range>: <expr><operator>new</operator> <name><name>String</name><index>[]</index></name> <block>{<expr><name><name>FacetParams</name><operator>.</operator><name>FACET_METHOD_enum</name></name></expr>, <expr><name><name>FacetParams</name><operator>.</operator><name>FACET_METHOD_fc</name></name></expr>, <expr><name><name>FacetParams</name><operator>.</operator><name>FACET_METHOD_fcs</name></name></expr>}</block></expr></range></decl></init>)</control> <block>{<block_content>
        <for>for <control>(<init><decl><type><name>String</name></type> <name>facetSort</name> <range>: <expr><operator>new</operator> <name><name>String</name><index>[]</index></name> <block>{<expr><name><name>FacetParams</name><operator>.</operator><name>FACET_SORT_COUNT</name></name></expr>, <expr><name><name>FacetParams</name><operator>.</operator><name>FACET_SORT_INDEX</name></name></expr>}</block></expr></range></decl></init>)</control> <block>{<block_content>
          <for>for <control>(<init><decl><type><name>String</name></type> <name>value</name> <range>: <expr><operator>new</operator> <name><name>String</name><index>[]</index></name> <block>{<expr><literal type="string">"42"</literal></expr>, <expr><literal type="string">"43"</literal></expr>}</block></expr></range></decl></init>)</control> <block>{<block_content> <comment type="line">// match or not</comment>
            <decl_stmt><decl><type><specifier>final</specifier> <name>String</name></type> <name>field</name> <init>= <expr><literal type="string">"f_"</literal> <operator>+</operator> <name>suffix</name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>assertQ</name><argument_list>(<argument><expr><literal type="string">"field="</literal> <operator>+</operator> <name>field</name> <operator>+</operator> <literal type="string">",method="</literal> <operator>+</operator> <name>facetMethod</name> <operator>+</operator> <literal type="string">",sort="</literal> <operator>+</operator> <name>facetSort</name></expr></argument>,
                <argument><expr><call><name>req</name><argument_list>(<argument><expr><literal type="string">"q"</literal></expr></argument>, <argument><expr><name>field</name> <operator>+</operator> <literal type="string">":"</literal> <operator>+</operator> <name>value</name></expr></argument>, <argument><expr><name><name>FacetParams</name><operator>.</operator><name>FACET</name></name></expr></argument>, <argument><expr><literal type="string">"true"</literal></expr></argument>, <argument><expr><name><name>FacetParams</name><operator>.</operator><name>FACET_FIELD</name></name></expr></argument>, <argument><expr><name>field</name></expr></argument>, <argument><expr><name><name>FacetParams</name><operator>.</operator><name>FACET_MINCOUNT</name></name></expr></argument>, <argument><expr><literal type="string">"0"</literal></expr></argument>, <argument><expr><name><name>FacetParams</name><operator>.</operator><name>FACET_SORT</name></name></expr></argument>, <argument><expr><name>facetSort</name></expr></argument>, <argument><expr><name><name>FacetParams</name><operator>.</operator><name>FACET_METHOD</name></name></expr></argument>, <argument><expr><name>facetMethod</name></expr></argument>)</argument_list></call></expr></argument>,
                <argument><expr><literal type="string">"*[count(//lst[@name='"</literal> <operator>+</operator> <name>field</name> <operator>+</operator> <literal type="string">"']/int)=1]"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// exactly 1 facet count</comment>
          </block_content>}</block></for>
        </block_content>}</block></for>
      </block_content>}</block></for>
    </block_content>}</block></for>
  </block_content>}</block></function>
 
 </block_content>}</block></else></if_stmt>
<expr_stmt><expr><operator>\</operator> <name>No</name> <name>newline</name> <name>at</name> <name>end</name> <name>of</name> <name>file</name>
<operator>-</operator> 
<literal type="number">2.19.1.windows</literal><literal type="number">.1</literal></expr></expr_stmt></block_content></block></else></if_stmt></block_content></block></if></if_stmt></block_content></block></function></block_content></block></for></block_content></block></for></block_content></block></for></block_content></block></if></if_stmt></block_content></block></if></if_stmt></block_content></block></for></block_content></block></for></block_content></block></for></block_content></block></for>

</unit>
