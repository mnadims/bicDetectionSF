<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" revision="1.0.0" language="Java" filename="E:/01Courses@USASK/CMPT898-HumanDrivenSoftwareEngineeringForScientificResearch/ProjectProgress/data_files/final_dataset/gen_patch_codes/filtered/hadoop/95f9a515aac.java"><expr_stmt><expr><name>From</name> <literal type="number">95f9a515aac3c19e14a39539f490203f5867dcc5</literal> <name>Mon</name> <name>Sep</name> <literal type="number">17</literal> <literal type="number">00</literal><operator>:</operator><literal type="number">00</literal><operator>:</operator><literal type="number">00</literal> <literal type="number">2001</literal>
<name>From</name><operator>:</operator> <name>Andrew</name> <name><name>Wang</name> <argument_list type="generic">&lt;<argument><name>wang</name><annotation>@<name><name>apache</name><operator>.</operator><name>org</name></name></annotation></argument>&gt;</argument_list></name>
<name>Date</name><operator>:</operator> <name>Mon</name></expr><operator>,</operator> <expr><literal type="number">5</literal> <name>Aug</name> <literal type="number">2013</literal> <literal type="number">23</literal><operator>:</operator><literal type="number">28</literal><operator>:</operator><literal type="number">14</literal> <operator>+</operator><literal type="number">0000</literal>
<name>Subject</name><operator>:</operator> <index>[<expr><name>PATCH</name></expr>]</index> <name>HADOOP</name><operator>-</operator><literal type="number">9817.</literal> <name>FileSystem</name><operator>#</operator><name>globStatus</name> <name>and</name> <name>FileContext</name><operator>#</operator><name>globStatus</name>
 <name>need</name> <name>to</name> <name>work</name> <name>with</name> <name><name>symlinks</name><operator>.</operator></name> (<name>Colin</name> <name>Patrick</name> <name>McCabe</name> <name>via</name> <name>Andrew</name> <name>Wang</name></expr></expr_stmt>)

<expr_stmt><expr><name>git</name><operator>-</operator><name>svn</name><operator>-</operator><name>id</name><operator>:</operator> <name>https</name><operator>:</operator><comment type="line">//svn.apache.org/repos/asf/hadoop/common/trunk@1510807 13f79535-47bb-0310-9956-ffa450edef68</comment>
<operator>--</operator>
 <operator>...</operator><operator>/</operator><name>hadoop</name><operator>-</operator><name>common</name><operator>/</operator><name><name>CHANGES</name><operator>.</operator><name>txt</name></name>                 <operator>|</operator>   <literal type="number">3</literal> <operator>+</operator>
 <operator>...</operator><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>hadoop</name><operator>/</operator><name>fs</name><operator>/</operator><name><name>FileContext</name><operator>.</operator><name>java</name></name>     <operator>|</operator> <literal type="number">153</literal> <operator>+</operator><operator>--</operator><operator>--</operator><operator>--</operator><operator>--</operator><operator>-</operator>
 <operator>...</operator><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>hadoop</name><operator>/</operator><name>fs</name><operator>/</operator><name><name>FileSystem</name><operator>.</operator><name>java</name></name> <operator>|</operator> <literal type="number">123</literal> <operator>+</operator><operator>--</operator><operator>--</operator><operator>--</operator><operator>-</operator>
 <operator>...</operator><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>hadoop</name><operator>/</operator><name>fs</name><operator>/</operator><name><name>Globber</name><operator>.</operator><name>java</name></name>    <operator>|</operator> <literal type="number">215</literal> <operator>++</operator><operator>++</operator><operator>++</operator><operator>++</operator><operator>++</operator><operator>++</operator><operator>++</operator>
 <operator>...</operator><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>hadoop</name><operator>/</operator><name>fs</name><operator>/</operator><name><name>FSWrapper</name><operator>.</operator><name>java</name></name>  <operator>|</operator>   <literal type="number">3</literal> <operator>+</operator>
 <operator>...</operator><operator>/</operator><name>hadoop</name><operator>/</operator><name>fs</name><operator>/</operator><name><name>FileContextTestWrapper</name><operator>.</operator><name>java</name></name>     <operator>|</operator>   <literal type="number">6</literal> <operator>+</operator>
 <operator>...</operator><operator>/</operator><name>hadoop</name><operator>/</operator><name>fs</name><operator>/</operator><name><name>FileSystemTestWrapper</name><operator>.</operator><name>java</name></name>      <operator>|</operator>   <literal type="number">6</literal> <operator>+</operator>
 <operator>...</operator><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>hadoop</name><operator>/</operator><name>fs</name><operator>/</operator><name><name>TestFileUtil</name><operator>.</operator><name>java</name></name>    <operator>|</operator>   <literal type="number">2</literal> <operator>+</operator>
 <operator>...</operator><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>hadoop</name><operator>/</operator><name>fs</name><operator>/</operator><name><name>TestPath</name><operator>.</operator><name>java</name></name>   <operator>|</operator>  <literal type="number">42</literal> <operator>++</operator><operator>-</operator>
 <operator>...</operator><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>hadoop</name><operator>/</operator><name>fs</name><operator>/</operator><name><name>TestGlobPaths</name><operator>.</operator><name>java</name></name>   <operator>|</operator> <literal type="number">265</literal> <operator>++</operator><operator>++</operator><operator>++</operator><operator>++</operator><operator>++</operator><operator>++</operator><operator>++</operator><operator>++</operator><operator>++</operator>
 <literal type="number">10</literal> <name>files</name> <name>changed</name></expr><operator>,</operator> <expr><literal type="number">539</literal> <call><name>insertions</name><argument_list>(<argument><expr><operator>+</operator></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><literal type="number">279</literal> <call><name>deletions</name><argument_list>(<argument><expr><operator>-</operator></expr></argument>)</argument_list></call>
 <name>create</name> <name>mode</name> <literal type="number">100644</literal> <name>hadoop</name><operator>-</operator><name>common</name><operator>-</operator><name>project</name><operator>/</operator><name>hadoop</name><operator>-</operator><name>common</name><operator>/</operator><name>src</name><operator>/</operator><name>main</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>hadoop</name><operator>/</operator><name>fs</name><operator>/</operator><name><name>Globber</name><operator>.</operator><name>java</name></name>

<name>diff</name> <operator>--</operator><name>git</name> <name>a</name><operator>/</operator><name>hadoop</name><operator>-</operator><name>common</name><operator>-</operator><name>project</name><operator>/</operator><name>hadoop</name><operator>-</operator><name>common</name><operator>/</operator><name><name>CHANGES</name><operator>.</operator><name>txt</name></name> <name>b</name><operator>/</operator><name>hadoop</name><operator>-</operator><name>common</name><operator>-</operator><name>project</name><operator>/</operator><name>hadoop</name><operator>-</operator><name>common</name><operator>/</operator><name><name>CHANGES</name><operator>.</operator><name>txt</name></name>
<name>index</name> <literal type="number">7864c35f5c0</literal><operator>..</operator><name>bafef60534b</name> <literal type="number">100644</literal>
<operator>--</operator> <name>a</name><operator>/</operator><name>hadoop</name><operator>-</operator><name>common</name><operator>-</operator><name>project</name><operator>/</operator><name>hadoop</name><operator>-</operator><name>common</name><operator>/</operator><name><name>CHANGES</name><operator>.</operator><name>txt</name></name>
<operator>++</operator> <name>b</name><operator>/</operator><name>hadoop</name><operator>-</operator><name>common</name><operator>-</operator><name>project</name><operator>/</operator><name>hadoop</name><operator>-</operator><name>common</name><operator>/</operator><name><name>CHANGES</name><operator>.</operator><name>txt</name></name>
@@ <operator>-</operator><literal type="number">314</literal></expr><operator>,</operator><expr><literal type="number">6</literal> <operator>+</operator><literal type="number">314</literal></expr><operator>,</operator><expr><literal type="number">9</literal> @@ <name>Release</name> <literal type="number">2.3.0</literal> <operator>-</operator> <name>UNRELEASED</name>
     <name>HADOOP</name><operator>-</operator><literal type="number">9761.</literal>  <name>ViewFileSystem</name><operator>#</operator><name>rename</name> <name>fails</name> <name>when</name> <name>using</name> <name><name>DistributedFileSystem</name><operator>.</operator></name>
     (<name>Andrew</name> <name>Wang</name> <name>via</name> <name>Colin</name> <name>Patrick</name> <name>McCabe</name></expr></expr_stmt>)
 
    <expr_stmt><expr><name>HADOOP</name><operator>-</operator><literal type="number">9817.</literal> <name>FileSystem</name><operator>#</operator><name>globStatus</name> <name>and</name> <name>FileContext</name><operator>#</operator><name>globStatus</name> <name>need</name> <name>to</name> <name>work</name>
    <name>with</name> <name><name>symlinks</name><operator>.</operator></name> (<name>Colin</name> <name>Patrick</name> <name>McCabe</name> <name>via</name> <name>Andrew</name> <name>Wang</name></expr></expr_stmt>)

 <expr_stmt><expr><name>Release</name> <literal type="number">2.1.1</literal><operator>-</operator><name>beta</name> <operator>-</operator> <name>UNRELEASED</name>
 
   <name>INCOMPATIBLE</name> <name>CHANGES</name>
<name>diff</name> <operator>--</operator><name>git</name> <name>a</name><operator>/</operator><name>hadoop</name><operator>-</operator><name>common</name><operator>-</operator><name>project</name><operator>/</operator><name>hadoop</name><operator>-</operator><name>common</name><operator>/</operator><name>src</name><operator>/</operator><name>main</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>hadoop</name><operator>/</operator><name>fs</name><operator>/</operator><name><name>FileContext</name><operator>.</operator><name>java</name></name> <name>b</name><operator>/</operator><name>hadoop</name><operator>-</operator><name>common</name><operator>-</operator><name>project</name><operator>/</operator><name>hadoop</name><operator>-</operator><name>common</name><operator>/</operator><name>src</name><operator>/</operator><name>main</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>hadoop</name><operator>/</operator><name>fs</name><operator>/</operator><name><name>FileContext</name><operator>.</operator><name>java</name></name>
<name>index</name> <literal type="number">7564e581839</literal><operator>..</operator><literal type="number">83a0004f498</literal> <literal type="number">100644</literal>
<operator>--</operator> <name>a</name><operator>/</operator><name>hadoop</name><operator>-</operator><name>common</name><operator>-</operator><name>project</name><operator>/</operator><name>hadoop</name><operator>-</operator><name>common</name><operator>/</operator><name>src</name><operator>/</operator><name>main</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>hadoop</name><operator>/</operator><name>fs</name><operator>/</operator><name><name>FileContext</name><operator>.</operator><name>java</name></name>
<operator>++</operator> <name>b</name><operator>/</operator><name>hadoop</name><operator>-</operator><name>common</name><operator>-</operator><name>project</name><operator>/</operator><name>hadoop</name><operator>-</operator><name>common</name><operator>/</operator><name>src</name><operator>/</operator><name>main</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>hadoop</name><operator>/</operator><name>fs</name><operator>/</operator><name><name>FileContext</name><operator>.</operator><name>java</name></name>
@@ <operator>-</operator><literal type="number">258</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">258</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@ <specifier>private</specifier> <call><name>FileContext</name><argument_list>(<argument><expr><name>final</name> <name>AbstractFileSystem</name> <name>defFs</name></expr></argument>,
    <argument><expr><operator>*</operator> <name>Hence</name> <name>this</name> <name>method</name> <name>is</name> <name>not</name> <name>called</name> <call><name>makeAbsolute</name><argument_list>()</argument_list></call> <name>and</name> 
    <operator>*</operator> <name>has</name> <name>been</name> <name>deliberately</name> <name>declared</name> <specifier>private</specifier><operator>.</operator>
    <operator>*</operator><operator>/</operator>
  <specifier>private</specifier> <name>Path</name> <call><name>fixRelativePart</name><argument_list>(<argument><expr><name>Path</name> <name>p</name></expr></argument>)</argument_list></call> <block>{
  <expr><name>Path</name> <call><name>fixRelativePart</name><argument_list>(<argument><expr><name>Path</name> <name>p</name></expr></argument>)</argument_list></call> <block>{
     <if_stmt><if>if <condition>(<expr><call><name><name>p</name><operator>.</operator><name>isUriPathAbsolute</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
       <return>return <expr><name>p</name></expr>;</return>
     <expr_stmt/>}</block_content> else <block>{<block_content>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">1905</literal></expr><operator>,</operator><expr><literal type="number">7</literal> <operator>+</operator><literal type="number">1905</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@ <specifier>public</specifier> <name>LocatedFileStatus</name> <call><name>next</name><argument_list>()</argument_list></call> <throws>throws <argument><expr><name>IOException</name> <block>{
     <expr><specifier>public</specifier> <name><name>FileStatus</name><index>[]</index></name> <call><name>globStatus</name><argument_list>(<argument><expr><name>Path</name> <name>pathPattern</name></expr></argument>)</argument_list></call></expr></block></expr></argument></throws>
         <throws>throws <argument><expr><name>AccessControlException</name></expr></argument>, <argument><expr><name>UnsupportedFileSystemException</name></expr></argument>,
         <argument><expr><name>IOException</name> <block>{</block></expr></argument></throws></expr></expr_stmt>
      <return>return <expr><call><name>globStatus</name><argument_list>(<argument><expr><name>pathPattern</name></expr></argument>, <argument><expr><name>DEFAULT_FILTER</name></expr></argument>)</argument_list></call></expr>;</return>
      <return>return <expr><operator>new</operator> <call><name>Globber</name><argument_list>(<argument><expr><name><name>FileContext</name><operator>.</operator><name>this</name></name></expr></argument>, <argument><expr><name>pathPattern</name></expr></argument>, <argument><expr><name>DEFAULT_FILTER</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>glob</name><argument_list>()</argument_list></call></expr>;</return>
     <expr_stmt/>}</block_content>
     
     <comment type="block" format="javadoc">/**
@@ -1934,154 +1934,7 @@ public LocatedFileStatus next() throws IOException {
     public FileStatus[] globStatus(final Path pathPattern,
         final PathFilter filter) throws AccessControlException,
         UnsupportedFileSystemException, IOException {
      URI uri = getFSofPath(fixRelativePart(pathPattern)).getUri();

      String filename = pathPattern.toUri().getPath();

      List&lt;String&gt; filePatterns = GlobExpander.expand(filename);
      if (filePatterns.size() == 1) {
        Path absPathPattern = fixRelativePart(pathPattern);
        return globStatusInternal(uri, new Path(absPathPattern.toUri()
            .getPath()), filter);
      } else {
        List&lt;FileStatus&gt; results = new ArrayList&lt;FileStatus&gt;();
        for (String iFilePattern : filePatterns) {
          Path iAbsFilePattern = fixRelativePart(new Path(iFilePattern));
          FileStatus[] files = globStatusInternal(uri, iAbsFilePattern, filter);
          for (FileStatus file : files) {
            results.add(file);
          }
        }
        return results.toArray(new FileStatus[results.size()]);
      }
    }

    /**
     * 
     * @param uri for all the inPathPattern
     * @param inPathPattern - without the scheme &amp; authority (take from uri)
     * @param filter
     *
     * @return an array of FileStatus objects
     *
     * @throws AccessControlException If access is denied
     * @throws IOException If an I/O error occurred
     */</comment>
    private FileStatus[] globStatusInternal(final URI uri</block></block><operator>,</operator>
        <decl_stmt><decl><type><specifier>final</specifier> <name>Path</name></type> <name>inPathPattern</name></decl>, <decl><type ref="prev"/><name>final</name> <name>PathFilter</name> <name>filter</name></decl>)
        <throws>throws <argument><expr><name>AccessControlException</name></expr></argument>, <argument><expr><name>IOException</name>
      <block>{
      <expr><name><name>Path</name><index>[]</index></name> <name>parents</name> <operator>=</operator> <operator>new</operator> <name><name>Path</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></block></expr></argument></throws>;</decl_stmt></if></if_stmt>
      <name>int</name> <name>level</name> <operator>=</operator> <literal type="number">0</literal></block></expr>;
      
      <assert>assert<expr><operator>(</operator><call><name><name>inPathPattern</name><operator>.</operator><name>toUri</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getScheme</name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator>
          <call><name><name>inPathPattern</name><operator>.</operator><name>toUri</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getAuthority</name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> 
          <call><name><name>inPathPattern</name><operator>.</operator><name>isUriPathAbsolute</name></name><argument_list>()</argument_list></call><operator>)</operator></expr>;</assert>

      
      <name>String</name> <name>filename</name> <operator>=</operator> <call><name><name>inPathPattern</name><operator>.</operator><name>toUri</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getPath</name><argument_list>()</argument_list></call></block></expr></argument>;
      
      <comment type="line">// path has only zero component</comment>
      if <argument><expr><operator>(</operator><call><name><name>filename</name><operator>.</operator><name>isEmpty</name></name><argument_list>()</argument_list></call> <operator>||</operator> <call><name><name>Path</name><operator>.</operator><name>SEPARATOR</name><operator>.</operator><name>equals</name></name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call><operator>)</operator> <block>{
        <expr><name>Path</name> <name>p</name> <operator>=</operator> <call><name><name>inPathPattern</name><operator>.</operator><name>makeQualified</name></name><argument_list>(<argument><expr><name>uri</name></expr></argument>, <argument><expr><literal type="null">null</literal></expr></argument>)</argument_list></call></expr>;
        <return>return <expr><call><name>getFileStatus</name><argument_list>(<argument><expr><operator>new</operator> <name><name>Path</name><index>[]</index></name><block>{<expr><name>p</name></expr>}</block></expr></argument>)</argument_list></call></expr>;</return>
      }</block></expr></argument></argument_list></call></expr></expr_stmt>

      <comment type="line">// path has at least one component</comment>
      <decl_stmt><decl><type><name><name>String</name><index>[]</index></name></type> <name>components</name> <init>= <expr><call><name><name>filename</name><operator>.</operator><name>split</name></name><argument_list>(<argument><expr><name><name>Path</name><operator>.</operator><name>SEPARATOR</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      
      <comment type="line">// Path is absolute, first component is "/" hence first component</comment>
      <comment type="line">// is the uri root</comment>
      <expr_stmt><expr><name><name>parents</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>new</operator> <call><name>Path</name><argument_list>(<argument><expr><operator>new</operator> <call><name>Path</name><argument_list>(<argument><expr><name>uri</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>new</operator> <call><name>Path</name><argument_list>(<argument><expr><literal type="string">"/"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>level</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

      <comment type="line">// glob the paths that match the parent path, ie. [0, components.length-1]</comment>
      <decl_stmt><decl><type><name><name>boolean</name><index>[]</index></name></type> <name>hasGlob</name> <init>= <expr><operator>new</operator> <name><name>boolean</name><index>[]</index></name><block>{<expr><literal type="boolean">false</literal></expr>}</block></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name><name>Path</name><index>[]</index></name></type> <name>relParentPaths</name> <init>= 
        <expr><call><name>globPathsLevel</name><argument_list>(<argument><expr><name>parents</name></expr></argument>, <argument><expr><name>components</name></expr></argument>, <argument><expr><name>level</name></expr></argument>, <argument><expr><name>hasGlob</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name><name>FileStatus</name><index>[]</index></name></type> <name>results</name></decl>;</decl_stmt>
      
      <if_stmt><if>if <condition>(<expr><name>relParentPaths</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <name><name>relParentPaths</name><operator>.</operator><name>length</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>results</name> <operator>=</operator> <literal type="null">null</literal></expr>;</expr_stmt>
      </block_content>}</block></if> <else>else <block>{<block_content>
        <comment type="line">// fix the pathes to be abs</comment>
        <decl_stmt><decl><type><name><name>Path</name><index>[]</index></name></type> <name>parentPaths</name> <init>= <expr><operator>new</operator> <name><name>Path</name> <index>[<expr><name><name>relParentPaths</name><operator>.</operator><name>length</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt> 
        <for>for<control>(<init><decl><type><name>int</name></type> <name>i</name><init>=<expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>relParentPaths</name><operator>.</operator><name>length</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
          <expr_stmt><expr><name><name>parentPaths</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>relParentPaths</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><call><name>makeQualified</name><argument_list>(<argument><expr><name>uri</name></expr></argument>, <argument><expr><literal type="null">null</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
        
        <comment type="line">// Now work on the last component of the path</comment>
        <decl_stmt><decl><type><name>GlobFilter</name></type> <name>fp</name> <init>= 
                    <expr><operator>new</operator> <call><name>GlobFilter</name><argument_list>(<argument><expr><name><name>components</name><index>[<expr><name><name>components</name><operator>.</operator><name>length</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>filter</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><call><name><name>fp</name><operator>.</operator><name>hasPattern</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content> <comment type="line">// last component has a pattern</comment>
          <comment type="line">// list parent directories and then glob the results</comment>
          <try>try <block>{<block_content>
            <expr_stmt><expr><name>results</name> <operator>=</operator> <call><name>listStatus</name><argument_list>(<argument><expr><name>parentPaths</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block> <catch>catch <parameter_list>(<parameter><decl><type><name>FileNotFoundException</name></type> <name>e</name></decl></parameter>)</parameter_list> <block>{<block_content>
            <expr_stmt><expr><name>results</name> <operator>=</operator> <literal type="null">null</literal></expr>;</expr_stmt>
          </block_content>}</block></catch></try>
          <expr_stmt><expr><name><name>hasGlob</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content> <comment type="line">// last component does not have a pattern</comment>
          <comment type="line">// get all the path names</comment>
          <decl_stmt><decl><type><name><name>ArrayList</name><argument_list type="generic">&lt;<argument><name>Path</name></argument>&gt;</argument_list></name></type> <name>filteredPaths</name> <init>= 
                                      <expr><operator>new</operator> <call><name><name>ArrayList</name><argument_list type="generic">&lt;<argument><name>Path</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>parentPaths</name><operator>.</operator><name>length</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>parentPaths</name><operator>.</operator><name>length</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <expr_stmt><expr><name><name>parentPaths</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>new</operator> <call><name>Path</name><argument_list>(<argument><expr><name><name>parentPaths</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
              <argument><expr><name><name>components</name><index>[<expr><name><name>components</name><operator>.</operator><name>length</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><call><name><name>fp</name><operator>.</operator><name>accept</name></name><argument_list>(<argument><expr><name><name>parentPaths</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
              <expr_stmt><expr><call><name><name>filteredPaths</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name><name>parentPaths</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
          </block_content>}</block></for>
          <comment type="line">// get all their statuses</comment>
          <expr_stmt><expr><name>results</name> <operator>=</operator> <call><name>getFileStatus</name><argument_list>(
              <argument><expr><call><name><name>filteredPaths</name><operator>.</operator><name>toArray</name></name><argument_list>(<argument><expr><operator>new</operator> <name><name>Path</name><index>[<expr><call><name><name>filteredPaths</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></else></if_stmt>

      <comment type="line">// Decide if the pathPattern contains a glob or not</comment>
      <if_stmt><if>if <condition>(<expr><name>results</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>hasGlob</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><name>results</name> <operator>=</operator> <operator>new</operator> <name><name>FileStatus</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if> <else>else <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>results</name><operator>.</operator><name>length</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>hasGlob</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>results</name> <operator>=</operator> <literal type="null">null</literal></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
          <expr_stmt><expr><call><name><name>Arrays</name><operator>.</operator><name>sort</name></name><argument_list>(<argument><expr><name>results</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></else></if_stmt>
      <return>return <expr><name>results</name></expr>;</return>
    }

    <comment type="block">/*
     * For a path of N components, return a list of paths that match the
     * components [&lt;code&gt;level&lt;/code&gt;, &lt;code&gt;N-1&lt;/code&gt;].
     */</comment>
    private <function><type><name><name>Path</name><index>[]</index></name></type> <name>globPathsLevel</name><parameter_list>(<parameter><decl><type><name><name>Path</name><index>[]</index></name></type> <name>parents</name></decl></parameter>, <parameter><decl><type><name><name>String</name><index>[]</index></name></type> <name>filePattern</name></decl></parameter>,
        <parameter><decl><type><name>int</name></type> <name>level</name></decl></parameter>, <parameter><decl><type><name><name>boolean</name><index>[]</index></name></type> <name>hasGlob</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>AccessControlException</name></expr></argument>,
        <argument><expr><name>FileNotFoundException</name></expr></argument>, <argument><expr><name>IOException</name></expr></argument></throws> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>level</name> <operator>==</operator> <name><name>filePattern</name><operator>.</operator><name>length</name></name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <return>return <expr><name>parents</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><name>parents</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <name><name>parents</name><operator>.</operator><name>length</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <return>return <expr><literal type="null">null</literal></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <decl_stmt><decl><type><name>GlobFilter</name></type> <name>fp</name> <init>= <expr><operator>new</operator> <call><name>GlobFilter</name><argument_list>(<argument><expr><name><name>filePattern</name><index>[<expr><name>level</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><call><name><name>fp</name><operator>.</operator><name>hasPattern</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
        <try>try <block>{<block_content>
          <expr_stmt><expr><name>parents</name> <operator>=</operator> <call><name><name>FileUtil</name><operator>.</operator><name>stat2Paths</name></name><argument_list>(<argument><expr><call><name>listStatus</name><argument_list>(<argument><expr><name>parents</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block> <catch>catch <parameter_list>(<parameter><decl><type><name>FileNotFoundException</name></type> <name>e</name></decl></parameter>)</parameter_list> <block>{<block_content>
          <expr_stmt><expr><name>parents</name> <operator>=</operator> <literal type="null">null</literal></expr>;</expr_stmt>
        </block_content>}</block></catch></try>
        <expr_stmt><expr><name><name>hasGlob</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
      </block_content>}</block></if> <else>else <block>{<block_content>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>parents</name><operator>.</operator><name>length</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
          <expr_stmt><expr><name><name>parents</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>new</operator> <call><name>Path</name><argument_list>(<argument><expr><name><name>parents</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>filePattern</name><index>[<expr><name>level</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
      </block_content>}</block></else></if_stmt>
      <return>return <expr><call><name>globPathsLevel</name><argument_list>(<argument><expr><name>parents</name></expr></argument>, <argument><expr><name>filePattern</name></expr></argument>, <argument><expr><name>level</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>hasGlob</name></expr></argument>)</argument_list></call></expr>;</return>
      <return>return <expr><operator>new</operator> <call><name>Globber</name><argument_list>(<argument><expr><name><name>FileContext</name><operator>.</operator><name>this</name></name></expr></argument>, <argument><expr><name>pathPattern</name></expr></argument>, <argument><expr><name>filter</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>glob</name><argument_list>()</argument_list></call></expr>;</return>
     </block_content>}</block></function>
 
     <comment type="block" format="javadoc">/**
diff --git a/hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/FileSystem.java b/hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/FileSystem.java
index 8f8bc8752fb..7d9e931b34f 100644
-- a/hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/FileSystem.java
++ b/hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/FileSystem.java
@@ -1619,7 +1619,7 @@ private void listStatus(ArrayList&lt;FileStatus&gt; results, Path f,
    * @throws IOException
    */</comment>
   <function><type><specifier>public</specifier> <name><name>FileStatus</name><index>[]</index></name></type> <name>globStatus</name><parameter_list>(<parameter><decl><type><name>Path</name></type> <name>pathPattern</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws> <block>{<block_content>
    <return>return <expr><call><name>globStatus</name><argument_list>(<argument><expr><name>pathPattern</name></expr></argument>, <argument><expr><name>DEFAULT_FILTER</name></expr></argument>)</argument_list></call></expr>;</return>
    <return>return <expr><operator>new</operator> <call><name>Globber</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>pathPattern</name></expr></argument>, <argument><expr><name>DEFAULT_FILTER</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>glob</name><argument_list>()</argument_list></call></expr>;</return>
   </block_content>}</block></function>
   
   <comment type="block" format="javadoc">/**
@@ -1637,126 +1637,7 @@ private void listStatus(ArrayList&lt;FileStatus&gt; results, Path f,
    */</comment>
   <function><type><specifier>public</specifier> <name><name>FileStatus</name><index>[]</index></name></type> <name>globStatus</name><parameter_list>(<parameter><decl><type><name>Path</name></type> <name>pathPattern</name></decl></parameter>, <parameter><decl><type><name>PathFilter</name></type> <name>filter</name></decl></parameter>)</parameter_list>
       <throws>throws <argument><expr><name>IOException</name></expr></argument></throws> <block>{<block_content>
    <decl_stmt><decl><type><name>String</name></type> <name>filename</name> <init>= <expr><call><name><name>pathPattern</name><operator>.</operator><name>toUri</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getPath</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name>FileStatus</name></argument>&gt;</argument_list></name></type> <name>allMatches</name> <init>= <expr><literal type="null">null</literal></expr></init></decl>;</decl_stmt>
    
    <decl_stmt><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>filePatterns</name> <init>= <expr><call><name><name>GlobExpander</name><operator>.</operator><name>expand</name></name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <for>for <control>(<init><decl><type><name>String</name></type> <name>filePattern</name> <range>: <expr><name>filePatterns</name></expr></range></decl></init>)</control> <block>{<block_content>
      <decl_stmt><decl><type><name>Path</name></type> <name>path</name> <init>= <expr><operator>new</operator> <call><name>Path</name><argument_list>(<argument><expr><ternary><condition><expr><call><name><name>filePattern</name><operator>.</operator><name>isEmpty</name></name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><name><name>Path</name><operator>.</operator><name>CUR_DIR</name></name></expr> </then><else>: <expr><name>filePattern</name></expr></else></ternary></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name>FileStatus</name></argument>&gt;</argument_list></name></type> <name>matches</name> <init>= <expr><call><name>globStatusInternal</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>filter</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><name>matches</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>allMatches</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><name>allMatches</name> <operator>=</operator> <name>matches</name></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
          <expr_stmt><expr><call><name><name>allMatches</name><operator>.</operator><name>addAll</name></name><argument_list>(<argument><expr><name>matches</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    
    <decl_stmt><decl><type><name><name>FileStatus</name><index>[]</index></name></type> <name>results</name> <init>= <expr><literal type="null">null</literal></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>allMatches</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>results</name> <operator>=</operator> <call><name><name>allMatches</name><operator>.</operator><name>toArray</name></name><argument_list>(<argument><expr><operator>new</operator> <name><name>FileStatus</name><index>[<expr><call><name><name>allMatches</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name><name>filePatterns</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
      <comment type="line">// no matches with multiple expansions is a non-matching glob </comment>
      <expr_stmt><expr><name>results</name> <operator>=</operator> <operator>new</operator> <name><name>FileStatus</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>results</name></expr>;</return>
  </block_content>}</block></function>

  <comment type="line">// sort gripes because FileStatus Comparable isn't parameterized...</comment>
  <function><annotation>@<name>SuppressWarnings</name><argument_list>(<argument><expr><literal type="string">"unchecked"</literal></expr></argument>)</argument_list></annotation> 
  <type><specifier>private</specifier> <name><name>List</name><argument_list type="generic">&lt;<argument><name>FileStatus</name></argument>&gt;</argument_list></name></type> <name>globStatusInternal</name><parameter_list>(<parameter><decl><type><name>Path</name></type> <name>pathPattern</name></decl></parameter>,
      <parameter><decl><type><name>PathFilter</name></type> <name>filter</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws> <block>{<block_content>
    <decl_stmt><decl><type><name>boolean</name></type> <name>patternHasGlob</name> <init>= <expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt>       <comment type="line">// pathPattern has any globs</comment>
    <decl_stmt><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name>FileStatus</name></argument>&gt;</argument_list></name></type> <name>matches</name> <init>= <expr><operator>new</operator> <call><name><name>ArrayList</name><argument_list type="generic">&lt;<argument><name>FileStatus</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="line">// determine starting point</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>level</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>String</name></type> <name>baseDir</name> <init>= <expr><name><name>Path</name><operator>.</operator><name>CUR_DIR</name></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name><name>pathPattern</name><operator>.</operator><name>isAbsolute</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>level</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt> <comment type="line">// need to skip empty item at beginning of split list</comment>
      <expr_stmt><expr><name>baseDir</name> <operator>=</operator> <name><name>Path</name><operator>.</operator><name>SEPARATOR</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    
    <comment type="line">// parse components and determine if it's a glob</comment>
    <decl_stmt><decl><type><name><name>String</name><index>[]</index></name></type> <name>components</name> <init>= <expr><literal type="null">null</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>GlobFilter</name><index>[]</index></name></type> <name>filters</name> <init>= <expr><literal type="null">null</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>String</name></type> <name>filename</name> <init>= <expr><call><name><name>pathPattern</name><operator>.</operator><name>toUri</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getPath</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>filename</name><operator>.</operator><name>isEmpty</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name><name>Path</name><operator>.</operator><name>SEPARATOR</name><operator>.</operator><name>equals</name></name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>components</name> <operator>=</operator> <call><name><name>filename</name><operator>.</operator><name>split</name></name><argument_list>(<argument><expr><name><name>Path</name><operator>.</operator><name>SEPARATOR</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>filters</name> <operator>=</operator> <operator>new</operator> <name><name>GlobFilter</name><index>[<expr><name><name>components</name><operator>.</operator><name>length</name></name></expr>]</index></name></expr>;</expr_stmt>
      <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name><init>=<expr><name>level</name></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>components</name><operator>.</operator><name>length</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <expr_stmt><expr><name><name>filters</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>new</operator> <call><name>GlobFilter</name><argument_list>(<argument><expr><name><name>components</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>patternHasGlob</name> <operator>|=</operator> <name><name>filters</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><call><name>hasPattern</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><name>patternHasGlob</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>baseDir</name> <operator>=</operator> <call><name>unquotePathComponent</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>components</name> <operator>=</operator> <literal type="null">null</literal></expr>;</expr_stmt> <comment type="line">// short through to filter check</comment>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    
    <comment type="line">// seed the parent directory path, return if it doesn't exist</comment>
    <try>try <block>{<block_content>
      <expr_stmt><expr><call><name><name>matches</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><call><name>getFileStatus</name><argument_list>(<argument><expr><operator>new</operator> <call><name>Path</name><argument_list>(<argument><expr><name>baseDir</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block> <catch>catch <parameter_list>(<parameter><decl><type><name>FileNotFoundException</name></type> <name>e</name></decl></parameter>)</parameter_list> <block>{<block_content>
      <return>return <expr><ternary><condition><expr><name>patternHasGlob</name></expr> ?</condition><then> <expr><name>matches</name></expr> </then><else>: <expr><literal type="null">null</literal></expr></else></ternary></expr>;</return>
    </block_content>}</block></catch></try>
    
    <comment type="line">// skip if there are no components other than the basedir</comment>
    <if_stmt><if>if <condition>(<expr><name>components</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
      <comment type="line">// iterate through each path component</comment>
      <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name><init>=<expr><name>level</name></expr></init></decl>;</init> <condition><expr><operator>(</operator><name>i</name> <operator>&lt;</operator> <name><name>components</name><operator>.</operator><name>length</name></name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>!</operator><call><name><name>matches</name><operator>.</operator><name>isEmpty</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name>FileStatus</name></argument>&gt;</argument_list></name></type> <name>children</name> <init>= <expr><operator>new</operator> <call><name><name>ArrayList</name><argument_list type="generic">&lt;<argument><name>FileStatus</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>FileStatus</name></type> <name>match</name> <range>: <expr><name>matches</name></expr></range></decl></init>)</control> <block>{<block_content>
          <comment type="line">// don't look for children in a file matched by a glob</comment>
          <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>match</name><operator>.</operator><name>isDirectory</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
            <continue>continue;</continue>
          </block_content>}</block></if></if_stmt>
          <try>try <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>filters</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><call><name>hasPattern</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
              <comment type="line">// get all children matching the filter</comment>
              <decl_stmt><decl><type><name><name>FileStatus</name><index>[]</index></name></type> <name>statuses</name> <init>= <expr><call><name>listStatus</name><argument_list>(<argument><expr><call><name><name>match</name><operator>.</operator><name>getPath</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>filters</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
              <expr_stmt><expr><call><name><name>children</name><operator>.</operator><name>addAll</name></name><argument_list>(<argument><expr><call><name><name>Arrays</name><operator>.</operator><name>asList</name></name><argument_list>(<argument><expr><name>statuses</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
              <comment type="line">// the component does not have a pattern</comment>
              <decl_stmt><decl><type><name>String</name></type> <name>component</name> <init>= <expr><call><name>unquotePathComponent</name><argument_list>(<argument><expr><name><name>components</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
              <decl_stmt><decl><type><name>Path</name></type> <name>child</name> <init>= <expr><operator>new</operator> <call><name>Path</name><argument_list>(<argument><expr><call><name><name>match</name><operator>.</operator><name>getPath</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>component</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
              <expr_stmt><expr><call><name><name>children</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><call><name>getFileStatus</name><argument_list>(<argument><expr><name>child</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
          </block_content>}</block> <catch>catch <parameter_list>(<parameter><decl><type><name>FileNotFoundException</name></type> <name>e</name></decl></parameter>)</parameter_list> <block>{<block_content>
            <comment type="line">// don't care</comment>
          </block_content>}</block></catch></try>
        </block_content>}</block></for>
        <expr_stmt><expr><name>matches</name> <operator>=</operator> <name>children</name></expr>;</expr_stmt>
      </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>
    <comment type="line">// remove anything that didn't match the filter</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>matches</name><operator>.</operator><name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name><name>Iterator</name><argument_list type="generic">&lt;<argument><name>FileStatus</name></argument>&gt;</argument_list></name></type> <name>iter</name> <init>= <expr><call><name><name>matches</name><operator>.</operator><name>iterator</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
      <while>while <condition>(<expr><call><name><name>iter</name><operator>.</operator><name>hasNext</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>filter</name><operator>.</operator><name>accept</name></name><argument_list>(<argument><expr><call><name><name>iter</name><operator>.</operator><name>next</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getPath</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><call><name><name>iter</name><operator>.</operator><name>remove</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></while>
    </block_content>}</block></if></if_stmt>
    <comment type="line">// no final paths, if there were any globs return empty list</comment>
    <if_stmt><if>if <condition>(<expr><call><name><name>matches</name><operator>.</operator><name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
      <return>return <expr><ternary><condition><expr><name>patternHasGlob</name></expr> ?</condition><then> <expr><name>matches</name></expr> </then><else>: <expr><literal type="null">null</literal></expr></else></ternary></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name><name>Collections</name><operator>.</operator><name>sort</name></name><argument_list>(<argument><expr><name>matches</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>matches</name></expr>;</return>
  </block_content>}</block></function>

  <comment type="block" format="javadoc">/**
   * The glob filter builds a regexp per path component.  If the component
   * does not contain a shell metachar, then it falls back to appending the
   * raw string to the list of built up paths.  This raw path needs to have
   * the quoting removed.  Ie. convert all occurances of "\X" to "X"
   * @param name of the path component
   * @return the unquoted path component
   */</comment>
  <function><type><specifier>private</specifier> <name>String</name></type> <name>unquotePathComponent</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>name</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <return>return <expr><call><name><name>name</name><operator>.</operator><name>replaceAll</name></name><argument_list>(<argument><expr><literal type="string">"\\\\(.)"</literal></expr></argument>, <argument><expr><literal type="string">"$1"</literal></expr></argument>)</argument_list></call></expr>;</return>
    <return>return <expr><operator>new</operator> <call><name>Globber</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>pathPattern</name></expr></argument>, <argument><expr><name>filter</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>glob</name><argument_list>()</argument_list></call></expr>;</return>
   </block_content>}</block></function>
   
   <comment type="block" format="javadoc">/**
diff --git a/hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/Globber.java b/hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/Globber.java
new file mode 100644
index 00000000000..ad28478aeb8
-- /dev/null
++ b/hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/Globber.java
@@ -0,0 +1,215 @@
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</comment>
<package>package <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>hadoop</name><operator>.</operator><name>fs</name></name>;</package>

<import>import <name><name>java</name><operator>.</operator><name>io</name><operator>.</operator><name>IOException</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>ArrayList</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>List</name></name>;</import>

<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>commons</name><operator>.</operator><name>logging</name><operator>.</operator><name>LogFactory</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>commons</name><operator>.</operator><name>logging</name><operator>.</operator><name>Log</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>hadoop</name><operator>.</operator><name>classification</name><operator>.</operator><name>InterfaceAudience</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>hadoop</name><operator>.</operator><name>classification</name><operator>.</operator><name>InterfaceStability</name></name>;</import>

<class><annotation>@<name><name>InterfaceAudience</name><operator>.</operator><name>Private</name></name></annotation>
<annotation>@<name><name>InterfaceStability</name><operator>.</operator><name>Unstable</name></name></annotation>
class <name>Globber</name> <block>{
  <decl_stmt><decl><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>Log</name></type> <name>LOG</name> <init>= <expr><call><name><name>LogFactory</name><operator>.</operator><name>getLog</name></name><argument_list>(<argument><expr><call><name><name>Globber</name><operator>.</operator><name><name>class</name><operator>.</operator><name>getName</name></name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>FileSystem</name></type> <name>fs</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>FileContext</name></type> <name>fc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>Path</name></type> <name>pathPattern</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>PathFilter</name></type> <name>filter</name></decl>;</decl_stmt>
  
  <constructor><specifier>public</specifier> <name>Globber</name><parameter_list>(<parameter><decl><type><name>FileSystem</name></type> <name>fs</name></decl></parameter>, <parameter><decl><type><name>Path</name></type> <name>pathPattern</name></decl></parameter>, <parameter><decl><type><name>PathFilter</name></type> <name>filter</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><name><name>this</name><operator>.</operator><name>fs</name></name> <operator>=</operator> <name>fs</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>this</name><operator>.</operator><name>fc</name></name> <operator>=</operator> <literal type="null">null</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>this</name><operator>.</operator><name>pathPattern</name></name> <operator>=</operator> <name>pathPattern</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>this</name><operator>.</operator><name>filter</name></name> <operator>=</operator> <name>filter</name></expr>;</expr_stmt>
  </block_content>}</block></constructor>

  <constructor><specifier>public</specifier> <name>Globber</name><parameter_list>(<parameter><decl><type><name>FileContext</name></type> <name>fc</name></decl></parameter>, <parameter><decl><type><name>Path</name></type> <name>pathPattern</name></decl></parameter>, <parameter><decl><type><name>PathFilter</name></type> <name>filter</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><name><name>this</name><operator>.</operator><name>fs</name></name> <operator>=</operator> <literal type="null">null</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>this</name><operator>.</operator><name>fc</name></name> <operator>=</operator> <name>fc</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>this</name><operator>.</operator><name>pathPattern</name></name> <operator>=</operator> <name>pathPattern</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>this</name><operator>.</operator><name>filter</name></name> <operator>=</operator> <name>filter</name></expr>;</expr_stmt>
  </block_content>}</block></constructor>

  <function><type><specifier>private</specifier> <name>FileStatus</name></type> <name>getFileStatus</name><parameter_list>(<parameter><decl><type><name>Path</name></type> <name>path</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <try>try <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>fs</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
        <return>return <expr><call><name><name>fs</name><operator>.</operator><name>getFileStatus</name></name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</return>
      </block_content>}</block></if> <else>else <block>{<block_content>
        <return>return <expr><call><name><name>fc</name><operator>.</operator><name>getFileStatus</name></name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</return>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block> <catch>catch <parameter_list>(<parameter><decl><type><name>IOException</name></type> <name>e</name></decl></parameter>)</parameter_list> <block>{<block_content>
      <return>return <expr><literal type="null">null</literal></expr>;</return>
    </block_content>}</block></catch></try>
  </block_content>}</block></function>

  <function><type><specifier>private</specifier> <name><name>FileStatus</name><index>[]</index></name></type> <name>listStatus</name><parameter_list>(<parameter><decl><type><name>Path</name></type> <name>path</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <try>try <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>fs</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
        <return>return <expr><call><name><name>fs</name><operator>.</operator><name>listStatus</name></name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</return>
      </block_content>}</block></if> <else>else <block>{<block_content>
        <return>return <expr><call><name><name>fc</name><operator>.</operator><name>util</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>listStatus</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</return>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block> <catch>catch <parameter_list>(<parameter><decl><type><name>IOException</name></type> <name>e</name></decl></parameter>)</parameter_list> <block>{<block_content>
      <return>return <expr><operator>new</operator> <name><name>FileStatus</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</return>
    </block_content>}</block></catch></try>
  </block_content>}</block></function>

  <function><type><specifier>private</specifier> <name>Path</name></type> <name>fixRelativePart</name><parameter_list>(<parameter><decl><type><name>Path</name></type> <name>path</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>fs</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
      <return>return <expr><call><name><name>fs</name><operator>.</operator><name>fixRelativePart</name></name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <return>return <expr><call><name><name>fc</name><operator>.</operator><name>fixRelativePart</name></name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></function>

  <comment type="block" format="javadoc">/**
   * Translate an absolute path into a list of path components.
   * We merge double slashes into a single slash here.
   * The first path component (i.e. root) does not get an entry in the list.
   */</comment>
  <function><type><specifier>private</specifier> <specifier>static</specifier> <name><name>List</name><argument_list type="generic">&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>getPathComponents</name><parameter_list>(<parameter><decl><type><name>String</name></type> <name>path</name></decl></parameter>)</parameter_list>
      <throws>throws <argument><expr><name>IOException</name></expr></argument></throws> <block>{<block_content>
    <decl_stmt><decl><type><name><name>ArrayList</name><argument_list type="generic">&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>ret</name> <init>= <expr><operator>new</operator> <call><name><name>ArrayList</name><argument_list type="generic">&lt;<argument><name>String</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <for>for <control>(<init><decl><type><name>String</name></type> <name>component</name> <range>: <expr><call><name><name>path</name><operator>.</operator><name>split</name></name><argument_list>(<argument><expr><name><name>Path</name><operator>.</operator><name>SEPARATOR</name></name></expr></argument>)</argument_list></call></expr></range></decl></init>)</control> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>component</name><operator>.</operator><name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name><name>ret</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name>component</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <return>return <expr><name>ret</name></expr>;</return>
  </block_content>}</block></function>

  <function><type><specifier>private</specifier> <name>String</name></type> <name>schemeFromPath</name><parameter_list>(<parameter><decl><type><name>Path</name></type> <name>path</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws> <block>{<block_content>
    <decl_stmt><decl><type><name>String</name></type> <name>scheme</name> <init>= <expr><call><name><name>pathPattern</name><operator>.</operator><name>toUri</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getScheme</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>scheme</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>fs</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>scheme</name> <operator>=</operator> <call><name><name>fs</name><operator>.</operator><name>getUri</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getScheme</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><name>scheme</name> <operator>=</operator> <call><name><name>fc</name><operator>.</operator><name>getFSofPath</name></name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>getUri</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getScheme</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>scheme</name></expr>;</return>
  </block_content>}</block></function>

  <function><type><specifier>private</specifier> <name>String</name></type> <name>authorityFromPath</name><parameter_list>(<parameter><decl><type><name>Path</name></type> <name>path</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws> <block>{<block_content>
    <decl_stmt><decl><type><name>String</name></type> <name>authority</name> <init>= <expr><call><name><name>pathPattern</name><operator>.</operator><name>toUri</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getAuthority</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>authority</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>fs</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>authority</name> <operator>=</operator> <call><name><name>fs</name><operator>.</operator><name>getUri</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getAuthority</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><name>authority</name> <operator>=</operator> <call><name><name>fc</name><operator>.</operator><name>getFSofPath</name></name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>getUri</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getAuthority</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>authority</name></expr> ;</return>
  </block_content>}</block></function>

  <function><type><specifier>public</specifier> <name><name>FileStatus</name><index>[]</index></name></type> <name>glob</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws> <block>{<block_content>
    <comment type="line">// First we get the scheme and authority of the pattern that was passed</comment>
    <comment type="line">// in.</comment>
    <decl_stmt><decl><type><name>String</name></type> <name>scheme</name> <init>= <expr><call><name>schemeFromPath</name><argument_list>(<argument><expr><name>pathPattern</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>String</name></type> <name>authority</name> <init>= <expr><call><name>authorityFromPath</name><argument_list>(<argument><expr><name>pathPattern</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="line">// Next we strip off everything except the pathname itself, and expand all</comment>
    <comment type="line">// globs.  Expansion is a process which turns "grouping" clauses,</comment>
    <comment type="line">// expressed as brackets, into separate path patterns.</comment>
    <decl_stmt><decl><type><name>String</name></type> <name>pathPatternString</name> <init>= <expr><call><name><name>pathPattern</name><operator>.</operator><name>toUri</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getPath</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>flattenedPatterns</name> <init>= <expr><call><name><name>GlobExpander</name><operator>.</operator><name>expand</name></name><argument_list>(<argument><expr><name>pathPatternString</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="line">// Now loop over all flattened patterns.  In every case, we'll be trying to</comment>
    <comment type="line">// match them to entries in the filesystem.</comment>
    <decl_stmt><decl><type><name><name>ArrayList</name><argument_list type="generic">&lt;<argument><name>FileStatus</name></argument>&gt;</argument_list></name></type> <name>results</name> <init>= 
        <expr><operator>new</operator> <call><name><name>ArrayList</name><argument_list type="generic">&lt;<argument><name>FileStatus</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>flattenedPatterns</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>boolean</name></type> <name>sawWildcard</name> <init>= <expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt>
    <for>for <control>(<init><decl><type><name>String</name></type> <name>flatPattern</name> <range>: <expr><name>flattenedPatterns</name></expr></range></decl></init>)</control> <block>{<block_content>
      <comment type="line">// Get the absolute path for this flattened pattern.  We couldn't do </comment>
      <comment type="line">// this prior to flattening because of patterns like {/,a}, where which</comment>
      <comment type="line">// path you go down influences how the path must be made absolute.</comment>
      <decl_stmt><decl><type><name>Path</name></type> <name>absPattern</name> <init>=
          <expr><call><name>fixRelativePart</name><argument_list>(<argument><expr><operator>new</operator> <call><name>Path</name><argument_list>(<argument><expr><ternary><condition><expr><call><name><name>flatPattern</name> <operator>.</operator><name>isEmpty</name></name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><literal type="string">"."</literal></expr> </then><else>: <expr><name>flatPattern</name></expr></else></ternary></expr></argument> )</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <comment type="line">// Now we break the flattened, absolute pattern into path components.</comment>
      <comment type="line">// For example, /a/*/c would be broken into the list [a, *, c]</comment>
      <decl_stmt><decl><type><name><name>List</name><argument_list type="generic">&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>components</name> <init>=
          <expr><call><name>getPathComponents</name><argument_list>(<argument><expr><call><name><name>absPattern</name><operator>.</operator><name>toUri</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getPath</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <comment type="line">// Starting out at the root of the filesystem, we try to match</comment>
      <comment type="line">// filesystem entries against pattern components.</comment>
      <decl_stmt><decl><type><name><name>ArrayList</name><argument_list type="generic">&lt;<argument><name>FileStatus</name></argument>&gt;</argument_list></name></type> <name>candidates</name> <init>= <expr><operator>new</operator> <call><name><name>ArrayList</name><argument_list type="generic">&lt;<argument><name>FileStatus</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name><name>candidates</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><operator>new</operator> <call><name>FileStatus</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
          <argument><expr><operator>new</operator> <call><name>Path</name><argument_list>(<argument><expr><name>scheme</name></expr></argument>, <argument><expr><name>authority</name></expr></argument>, <argument><expr><literal type="string">"/"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <for>for <control>(<init><decl><type><name>String</name></type> <name>component</name> <range>: <expr><name>components</name></expr></range></decl></init>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name><name>ArrayList</name><argument_list type="generic">&lt;<argument><name>FileStatus</name></argument>&gt;</argument_list></name></type> <name>newCandidates</name> <init>=
            <expr><operator>new</operator> <call><name><name>ArrayList</name><argument_list type="generic">&lt;<argument><name>FileStatus</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>candidates</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>GlobFilter</name></type> <name>globFilter</name> <init>= <expr><operator>new</operator> <call><name>GlobFilter</name><argument_list>(<argument><expr><name>component</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><call><name><name>globFilter</name><operator>.</operator><name>hasPattern</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><name>sawWildcard</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><call><name><name>candidates</name><operator>.</operator><name>isEmpty</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <name>sawWildcard</name></expr>)</condition> <block>{<block_content>
          <break>break;</break>
        </block_content>}</block></if></if_stmt>
        <for>for <control>(<init><decl><type><name>FileStatus</name></type> <name>candidate</name> <range>: <expr><name>candidates</name></expr></range></decl></init>)</control> <block>{<block_content>
          <decl_stmt><decl><type><name>FileStatus</name></type> <name>resolvedCandidate</name> <init>= <expr><name>candidate</name></expr></init></decl>;</decl_stmt>
          <if_stmt><if>if <condition>(<expr><call><name><name>candidate</name><operator>.</operator><name>isSymlink</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
            <comment type="line">// We have to resolve symlinks, because otherwise we don't know</comment>
            <comment type="line">// whether they are directories.</comment>
            <expr_stmt><expr><name>resolvedCandidate</name> <operator>=</operator> <call><name>getFileStatus</name><argument_list>(<argument><expr><call><name><name>candidate</name><operator>.</operator><name>getPath</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
          <if_stmt><if>if <condition>(<expr><name>resolvedCandidate</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator>
              <call><name><name>resolvedCandidate</name><operator>.</operator><name>isDirectory</name></name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="boolean">false</literal></expr>)</condition> <block>{<block_content>
            <continue>continue;</continue>
          </block_content>}</block></if></if_stmt>
          <decl_stmt><decl><type><name><name>FileStatus</name><index>[]</index></name></type> <name>children</name> <init>= <expr><call><name>listStatus</name><argument_list>(<argument><expr><call><name><name>candidate</name><operator>.</operator><name>getPath</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <for>for <control>(<init><decl><type><name>FileStatus</name></type> <name>child</name> <range>: <expr><name>children</name></expr></range></decl></init>)</control> <block>{<block_content>
            <comment type="line">// Set the child path based on the parent path.</comment>
            <comment type="line">// This keeps the symlinks in our path.</comment>
            <expr_stmt><expr><call><name><name>child</name><operator>.</operator><name>setPath</name></name><argument_list>(<argument><expr><operator>new</operator> <call><name>Path</name><argument_list>(<argument><expr><call><name><name>candidate</name><operator>.</operator><name>getPath</name></name><argument_list>()</argument_list></call></expr></argument>,
                    <argument><expr><call><name><name>child</name><operator>.</operator><name>getPath</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getName</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><call><name><name>globFilter</name><operator>.</operator><name>accept</name></name><argument_list>(<argument><expr><call><name><name>child</name><operator>.</operator><name>getPath</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
              <expr_stmt><expr><call><name><name>newCandidates</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name>child</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
          </block_content>}</block></for>
        </block_content>}</block></for>
        <expr_stmt><expr><name>candidates</name> <operator>=</operator> <name>newCandidates</name></expr>;</expr_stmt>
      </block_content>}</block></for>
      <for>for <control>(<init><decl><type><name>FileStatus</name></type> <name>status</name> <range>: <expr><name>candidates</name></expr></range></decl></init>)</control> <block>{<block_content>
        <comment type="line">// HADOOP-3497 semantics: the user-defined filter is applied at the</comment>
        <comment type="line">// end, once the full path is built up.</comment>
        <if_stmt><if>if <condition>(<expr><call><name><name>filter</name><operator>.</operator><name>accept</name></name><argument_list>(<argument><expr><call><name><name>status</name><operator>.</operator><name>getPath</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><call><name><name>results</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></for>
    </block_content>}</block></for>
    <comment type="block">/*
     * When the input pattern "looks" like just a simple filename, and we
     * can't find it, we return null rather than an empty array.
     * This is a special case which the shell relies on.
     *
     * To be more precise: if there were no results, AND there were no
     * groupings (aka brackets), and no wildcards in the input (aka stars),
     * we return null.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>!</operator><name>sawWildcard</name><operator>)</operator> <operator>&amp;&amp;</operator> <call><name><name>results</name><operator>.</operator><name>isEmpty</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
        <operator>(</operator><call><name><name>flattenedPatterns</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&lt;=</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
      <return>return <expr><literal type="null">null</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><call><name><name>results</name><operator>.</operator><name>toArray</name></name><argument_list>(<argument><expr><operator>new</operator> <name><name>FileStatus</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></function>
}</block></class>
<expr_stmt><expr><name>diff</name> <operator>--</operator><name>git</name> <name>a</name><operator>/</operator><name>hadoop</name><operator>-</operator><name>common</name><operator>-</operator><name>project</name><operator>/</operator><name>hadoop</name><operator>-</operator><name>common</name><operator>/</operator><name>src</name><operator>/</operator><name>test</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>hadoop</name><operator>/</operator><name>fs</name><operator>/</operator><name><name>FSWrapper</name><operator>.</operator><name>java</name></name> <name>b</name><operator>/</operator><name>hadoop</name><operator>-</operator><name>common</name><operator>-</operator><name>project</name><operator>/</operator><name>hadoop</name><operator>-</operator><name>common</name><operator>/</operator><name>src</name><operator>/</operator><name>test</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>hadoop</name><operator>/</operator><name>fs</name><operator>/</operator><name><name>FSWrapper</name><operator>.</operator><name>java</name></name>
<name>index</name> <name>e8875bf08da</name><operator>..</operator><name>ae4ad059b68</name> <literal type="number">100644</literal>
<operator>--</operator> <name>a</name><operator>/</operator><name>hadoop</name><operator>-</operator><name>common</name><operator>-</operator><name>project</name><operator>/</operator><name>hadoop</name><operator>-</operator><name>common</name><operator>/</operator><name>src</name><operator>/</operator><name>test</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>hadoop</name><operator>/</operator><name>fs</name><operator>/</operator><name><name>FSWrapper</name><operator>.</operator><name>java</name></name>
<operator>++</operator> <name>b</name><operator>/</operator><name>hadoop</name><operator>-</operator><name>common</name><operator>-</operator><name>project</name><operator>/</operator><name>hadoop</name><operator>-</operator><name>common</name><operator>/</operator><name>src</name><operator>/</operator><name>test</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>hadoop</name><operator>/</operator><name>fs</name><operator>/</operator><name><name>FSWrapper</name><operator>.</operator><name>java</name></name>
@@ <operator>-</operator><literal type="number">109</literal></expr><operator>,</operator><expr><literal type="number">4</literal> <operator>+</operator><literal type="number">109</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@ <specifier>abstract</specifier> <specifier>public</specifier> <name>void</name> <call><name>createSymlink</name><argument_list>(<argument><expr><name>final</name> <name>Path</name> <name>target</name></expr></argument>, <argument><expr><name>final</name> <name>Path</name> <name>link</name></expr></argument>,
   <argument><expr><specifier>abstract</specifier> <specifier>public</specifier> <name><name>FileStatus</name><index>[]</index></name> <call><name>listStatus</name><argument_list>(<argument><expr><name>final</name> <name>Path</name> <name>f</name></expr></argument>)</argument_list></call>
       <throws>throws <argument><expr><name>AccessControlException</name></expr></argument>, <argument><expr><name>FileNotFoundException</name></expr></argument>,
       <argument><expr><name>UnsupportedFileSystemException</name></expr></argument>, <argument><expr><name>IOException</name></expr></argument></throws></expr></argument>;
  
  <argument><expr><specifier>abstract</specifier> <specifier>public</specifier> <name><name>FileStatus</name><index>[]</index></name> <call><name>globStatus</name><argument_list>(<argument><expr><name>Path</name> <name>pathPattern</name></expr></argument>, <argument><expr><name>PathFilter</name> <name>filter</name></expr></argument>)</argument_list></call>
      <throws>throws <argument><expr><name>IOException</name></expr></argument></throws></expr></argument>;</argument_list></call></expr></expr_stmt>
 }
diff <expr_stmt><expr><operator>--</operator><name>git</name> <name>a</name><operator>/</operator><name>hadoop</name><operator>-</operator><name>common</name><operator>-</operator><name>project</name><operator>/</operator><name>hadoop</name><operator>-</operator><name>common</name><operator>/</operator><name>src</name><operator>/</operator><name>test</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>hadoop</name><operator>/</operator><name>fs</name><operator>/</operator><name><name>FileContextTestWrapper</name><operator>.</operator><name>java</name></name> <name>b</name><operator>/</operator><name>hadoop</name><operator>-</operator><name>common</name><operator>-</operator><name>project</name><operator>/</operator><name>hadoop</name><operator>-</operator><name>common</name><operator>/</operator><name>src</name><operator>/</operator><name>test</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>hadoop</name><operator>/</operator><name>fs</name><operator>/</operator><name><name>FileContextTestWrapper</name><operator>.</operator><name>java</name></name>
<name>index</name> <literal type="number">56736da90e0</literal><operator>..</operator><name>e10b22edb7c</name> <literal type="number">100644</literal>
<operator>--</operator> <name>a</name><operator>/</operator><name>hadoop</name><operator>-</operator><name>common</name><operator>-</operator><name>project</name><operator>/</operator><name>hadoop</name><operator>-</operator><name>common</name><operator>/</operator><name>src</name><operator>/</operator><name>test</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>hadoop</name><operator>/</operator><name>fs</name><operator>/</operator><name><name>FileContextTestWrapper</name><operator>.</operator><name>java</name></name>
<operator>++</operator> <name>b</name><operator>/</operator><name>hadoop</name><operator>-</operator><name>common</name><operator>-</operator><name>project</name><operator>/</operator><name>hadoop</name><operator>-</operator><name>common</name><operator>/</operator><name>src</name><operator>/</operator><name>test</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>hadoop</name><operator>/</operator><name>fs</name><operator>/</operator><name><name>FileContextTestWrapper</name><operator>.</operator><name>java</name></name>
@@ <operator>-</operator><literal type="number">332</literal></expr><operator>,</operator><expr><literal type="number">4</literal> <operator>+</operator><literal type="number">332</literal></expr><operator>,</operator><expr><literal type="number">10</literal> @@ <specifier>public</specifier> <name>void</name> <call><name>setTimes</name><argument_list>(<argument><expr><name>Path</name> <name>f</name></expr></argument>, <argument><expr><name>long</name> <name>mtime</name></expr></argument>, <argument><expr><name>long</name> <name>atime</name></expr></argument>)</argument_list></call>
       <name>FileNotFoundException</name></expr><operator>,</operator> <expr><name>UnsupportedFileSystemException</name></expr><operator>,</operator> <expr><name>IOException</name> <block>{
     <return>return <expr><call><name><name>fc</name><operator>.</operator><name>util</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>listStatus</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</return>
   }</block></expr></expr_stmt>

  <function><annotation>@<name>Override</name></annotation>
  <type><specifier>public</specifier> <name><name>FileStatus</name><index>[]</index></name></type> <name>globStatus</name><parameter_list>(<parameter><decl><type><name>Path</name></type> <name>pathPattern</name></decl></parameter>, <parameter><decl><type><name>PathFilter</name></type> <name>filter</name></decl></parameter>)</parameter_list>
      <throws>throws <argument><expr><name>IOException</name></expr></argument></throws> <block>{<block_content>
    <return>return <expr><call><name><name>fc</name><operator>.</operator><name>util</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>globStatus</name><argument_list>(<argument><expr><name>pathPattern</name></expr></argument>, <argument><expr><name>filter</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></function>
 }
diff <expr_stmt><expr><operator>--</operator><name>git</name> <name>a</name><operator>/</operator><name>hadoop</name><operator>-</operator><name>common</name><operator>-</operator><name>project</name><operator>/</operator><name>hadoop</name><operator>-</operator><name>common</name><operator>/</operator><name>src</name><operator>/</operator><name>test</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>hadoop</name><operator>/</operator><name>fs</name><operator>/</operator><name><name>FileSystemTestWrapper</name><operator>.</operator><name>java</name></name> <name>b</name><operator>/</operator><name>hadoop</name><operator>-</operator><name>common</name><operator>-</operator><name>project</name><operator>/</operator><name>hadoop</name><operator>-</operator><name>common</name><operator>/</operator><name>src</name><operator>/</operator><name>test</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>hadoop</name><operator>/</operator><name>fs</name><operator>/</operator><name><name>FileSystemTestWrapper</name><operator>.</operator><name>java</name></name>
<name>index</name> <literal type="number">28656288c17</literal><operator>..</operator><name>eb5df084b97</name> <literal type="number">100644</literal>
<operator>--</operator> <name>a</name><operator>/</operator><name>hadoop</name><operator>-</operator><name>common</name><operator>-</operator><name>project</name><operator>/</operator><name>hadoop</name><operator>-</operator><name>common</name><operator>/</operator><name>src</name><operator>/</operator><name>test</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>hadoop</name><operator>/</operator><name>fs</name><operator>/</operator><name><name>FileSystemTestWrapper</name><operator>.</operator><name>java</name></name>
<operator>++</operator> <name>b</name><operator>/</operator><name>hadoop</name><operator>-</operator><name>common</name><operator>-</operator><name>project</name><operator>/</operator><name>hadoop</name><operator>-</operator><name>common</name><operator>/</operator><name>src</name><operator>/</operator><name>test</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>hadoop</name><operator>/</operator><name>fs</name><operator>/</operator><name><name>FileSystemTestWrapper</name><operator>.</operator><name>java</name></name>
@@ <operator>-</operator><literal type="number">397</literal></expr><operator>,</operator><expr><literal type="number">4</literal> <operator>+</operator><literal type="number">397</literal></expr><operator>,</operator><expr><literal type="number">10</literal> @@ <specifier>public</specifier> <name>void</name> <call><name>setTimes</name><argument_list>(<argument><expr><name>Path</name> <name>f</name></expr></argument>, <argument><expr><name>long</name> <name>mtime</name></expr></argument>, <argument><expr><name>long</name> <name>atime</name></expr></argument>)</argument_list></call>
       <name>FileNotFoundException</name></expr><operator>,</operator> <expr><name>UnsupportedFileSystemException</name></expr><operator>,</operator> <expr><name>IOException</name> <block>{
     <return>return <expr><call><name><name>fs</name><operator>.</operator><name>listStatus</name></name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</return>
   }</block></expr></expr_stmt>

  <function><annotation>@<name>Override</name></annotation>
  <type><specifier>public</specifier> <name><name>FileStatus</name><index>[]</index></name></type> <name>globStatus</name><parameter_list>(<parameter><decl><type><name>Path</name></type> <name>pathPattern</name></decl></parameter>, <parameter><decl><type><name>PathFilter</name></type> <name>filter</name></decl></parameter>)</parameter_list>
      <throws>throws <argument><expr><name>IOException</name></expr></argument></throws> <block>{<block_content>
    <return>return <expr><call><name><name>fs</name><operator>.</operator><name>globStatus</name></name><argument_list>(<argument><expr><name>pathPattern</name></expr></argument>, <argument><expr><name>filter</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></function>
 }
diff <expr_stmt><expr><operator>--</operator><name>git</name> <name>a</name><operator>/</operator><name>hadoop</name><operator>-</operator><name>common</name><operator>-</operator><name>project</name><operator>/</operator><name>hadoop</name><operator>-</operator><name>common</name><operator>/</operator><name>src</name><operator>/</operator><name>test</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>hadoop</name><operator>/</operator><name>fs</name><operator>/</operator><name><name>TestFileUtil</name><operator>.</operator><name>java</name></name> <name>b</name><operator>/</operator><name>hadoop</name><operator>-</operator><name>common</name><operator>-</operator><name>project</name><operator>/</operator><name>hadoop</name><operator>-</operator><name>common</name><operator>/</operator><name>src</name><operator>/</operator><name>test</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>hadoop</name><operator>/</operator><name>fs</name><operator>/</operator><name><name>TestFileUtil</name><operator>.</operator><name>java</name></name>
<name>index</name> <literal type="number">5672508127a</literal><operator>..</operator><name>a9646d33b39</name> <literal type="number">100644</literal>
<operator>--</operator> <name>a</name><operator>/</operator><name>hadoop</name><operator>-</operator><name>common</name><operator>-</operator><name>project</name><operator>/</operator><name>hadoop</name><operator>-</operator><name>common</name><operator>/</operator><name>src</name><operator>/</operator><name>test</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>hadoop</name><operator>/</operator><name>fs</name><operator>/</operator><name><name>TestFileUtil</name><operator>.</operator><name>java</name></name>
<operator>++</operator> <name>b</name><operator>/</operator><name>hadoop</name><operator>-</operator><name>common</name><operator>-</operator><name>project</name><operator>/</operator><name>hadoop</name><operator>-</operator><name>common</name><operator>/</operator><name>src</name><operator>/</operator><name>test</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>hadoop</name><operator>/</operator><name>fs</name><operator>/</operator><name><name>TestFileUtil</name><operator>.</operator><name>java</name></name>
@@ <operator>-</operator><literal type="number">793</literal></expr><operator>,</operator><expr><literal type="number">6</literal> <operator>+</operator><literal type="number">793</literal></expr><operator>,</operator><expr><literal type="number">8</literal> @@ <specifier>public</specifier> <name>void</name> <call><name>testCreateJarWithClassPath</name><argument_list>()</argument_list></call> <throws>throws <argument><expr><name>Exception</name> <block>{
         }</block></expr></argument>
       }
       <argument><expr><name><name>List</name><argument_list type="generic">&lt;<argument><name>String</name></argument>&gt;</argument_list></name> <name>actualClassPaths</name> <operator>=</operator> <call><name><name>Arrays</name><operator>.</operator><name>asList</name></name><argument_list>(<argument><expr><call><name><name>classPathAttr</name><operator>.</operator><name>split</name></name><argument_list>(<argument><expr><literal type="string">" "</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument></throws></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>Collections</name><operator>.</operator><name>sort</name></name><argument_list>(<argument><expr><name>expectedClassPaths</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>Collections</name><operator>.</operator><name>sort</name></name><argument_list>(<argument><expr><name>actualClassPaths</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
       <expr_stmt><expr><call><name><name>Assert</name><operator>.</operator><name>assertEquals</name></name><argument_list>(<argument><expr><name>expectedClassPaths</name></expr></argument>, <argument><expr><name>actualClassPaths</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
     } finally <block>{<block_content>
       <if_stmt><if>if <condition>(<expr><name>jarFile</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>diff</name> <operator>--</operator><name>git</name> <name>a</name><operator>/</operator><name>hadoop</name><operator>-</operator><name>common</name><operator>-</operator><name>project</name><operator>/</operator><name>hadoop</name><operator>-</operator><name>common</name><operator>/</operator><name>src</name><operator>/</operator><name>test</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>hadoop</name><operator>/</operator><name>fs</name><operator>/</operator><name><name>TestPath</name><operator>.</operator><name>java</name></name> <name>b</name><operator>/</operator><name>hadoop</name><operator>-</operator><name>common</name><operator>-</operator><name>project</name><operator>/</operator><name>hadoop</name><operator>-</operator><name>common</name><operator>/</operator><name>src</name><operator>/</operator><name>test</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>hadoop</name><operator>/</operator><name>fs</name><operator>/</operator><name><name>TestPath</name><operator>.</operator><name>java</name></name>
<name>index</name> <literal type="number">7a5843a8a75</literal><operator>..</operator><literal type="number">0f6bf71bded</literal> <literal type="number">100644</literal>
<operator>--</operator> <name>a</name><operator>/</operator><name>hadoop</name><operator>-</operator><name>common</name><operator>-</operator><name>project</name><operator>/</operator><name>hadoop</name><operator>-</operator><name>common</name><operator>/</operator><name>src</name><operator>/</operator><name>test</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>hadoop</name><operator>/</operator><name>fs</name><operator>/</operator><name><name>TestPath</name><operator>.</operator><name>java</name></name>
<operator>++</operator> <name>b</name><operator>/</operator><name>hadoop</name><operator>-</operator><name>common</name><operator>-</operator><name>project</name><operator>/</operator><name>hadoop</name><operator>-</operator><name>common</name><operator>/</operator><name>src</name><operator>/</operator><name>test</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>hadoop</name><operator>/</operator><name>fs</name><operator>/</operator><name><name>TestPath</name><operator>.</operator><name>java</name></name>
@@ <operator>-</operator><literal type="number">28</literal></expr><operator>,</operator><expr><literal type="number">11</literal> <operator>+</operator><literal type="number">28</literal></expr><operator>,</operator><expr><literal type="number">38</literal> @@</expr></expr_stmt>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>hadoop</name><operator>.</operator><name>io</name><operator>.</operator><name>AvroTestUtil</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>hadoop</name><operator>.</operator><name>util</name><operator>.</operator><name>Shell</name></name>;</import>
 
<import>import <name><name>junit</name><operator>.</operator><name>framework</name><operator>.</operator><name>TestCase</name></name>;</import>
<import>import <name><name>com</name><operator>.</operator><name>google</name><operator>.</operator><name>common</name><operator>.</operator><name>base</name><operator>.</operator><name>Joiner</name></name>;</import>
 
<import>import static <name><name>org</name><operator>.</operator><name>junit</name><operator>.</operator><name>Assert</name><operator>.</operator><name>fail</name></name>;</import>
<import>import <name><name>junit</name><operator>.</operator><name>framework</name><operator>.</operator><name>TestCase</name></name>;</import>
 
 <class><specifier>public</specifier> class <name>TestPath</name> <super_list><extends>extends <super><name>TestCase</name></super></extends></super_list> <block>{
  <comment type="block" format="javadoc">/**
   * Merge a bunch of Path objects into a sorted semicolon-separated
   * path string.
   */</comment>
  <function><type><specifier>public</specifier> <specifier>static</specifier> <name>String</name></type> <name>mergeStatuses</name><parameter_list>(<parameter><decl><type><name>Path</name></type> <name><name>paths</name><index>[]</index></name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>String</name></type> <name><name>pathStrings</name><index>[]</index></name> <init>= <expr><operator>new</operator> <name><name>String</name><index>[<expr><name><name>paths</name><operator>.</operator><name>length</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <for>for <control>(<init><decl><type><name>Path</name></type> <name>path</name> <range>: <expr><name>paths</name></expr></range></decl></init>)</control> <block>{<block_content>
      <expr_stmt><expr><name><name>pathStrings</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name><name>path</name><operator>.</operator><name>toUri</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getPath</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name><name>Arrays</name><operator>.</operator><name>sort</name></name><argument_list>(<argument><expr><name>pathStrings</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name><name>Joiner</name><operator>.</operator><name>on</name></name><argument_list>(<argument><expr><literal type="string">";"</literal></expr></argument>)</argument_list></call><operator>.</operator><call><name>join</name><argument_list>(<argument><expr><name>pathStrings</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></function>

  <comment type="block" format="javadoc">/**
   * Merge a bunch of FileStatus objects into a sorted semicolon-separated
   * path string.
   */</comment>
  <function><type><specifier>public</specifier> <specifier>static</specifier> <name>String</name></type> <name>mergeStatuses</name><parameter_list>(<parameter><decl><type><name>FileStatus</name></type> <name><name>statuses</name><index>[]</index></name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>Path</name></type> <name><name>paths</name><index>[]</index></name> <init>= <expr><operator>new</operator> <name><name>Path</name><index>[<expr><name><name>statuses</name><operator>.</operator><name>length</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <for>for <control>(<init><decl><type><name>FileStatus</name></type> <name>status</name> <range>: <expr><name>statuses</name></expr></range></decl></init>)</control> <block>{<block_content>
      <expr_stmt><expr><name><name>paths</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name><name>status</name><operator>.</operator><name>getPath</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <return>return <expr><call><name>mergeStatuses</name><argument_list>(<argument><expr><name>paths</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></function>

   <function><annotation>@<name>Test</name> <argument_list>(<argument><expr><name>timeout</name> <operator>=</operator> <literal type="number">30000</literal></expr></argument>)</argument_list></annotation>
   <type><specifier>public</specifier> <name>void</name></type> <name>testToString</name><parameter_list>()</parameter_list> <block>{<block_content>
     <expr_stmt><expr><call><name>toStringTest</name><argument_list>(<argument><expr><literal type="string">"/"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">352</literal></expr><operator>,</operator><expr><literal type="number">10</literal> <operator>+</operator><literal type="number">379</literal></expr><operator>,</operator><expr><literal type="number">11</literal> @@ <specifier>public</specifier> <name>void</name> <call><name>testGlobEscapeStatus</name><argument_list>()</argument_list></call> <throws>throws <argument><expr><name>Exception</name> <block>{
     <comment type="line">// ensure globStatus with "*" finds all dir contents</comment>
     <expr><name>stats</name> <operator>=</operator> <call><name><name>lfs</name><operator>.</operator><name>globStatus</name></name><argument_list>(<argument><expr><operator>new</operator> <call><name>Path</name><argument_list>(<argument><expr><name>testRoot</name></expr></argument>, <argument><expr><literal type="string">"*"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></block></expr></argument></throws></expr>;</expr_stmt>
     <expr_stmt><expr><call><name><name>Arrays</name><operator>.</operator><name>sort</name></name><argument_list>(<argument><expr><name>stats</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><name><name>paths</name><operator>.</operator><name>length</name></name></expr></argument>, <argument><expr><name><name>stats</name><operator>.</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name><init>=<expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>paths</name><operator>.</operator><name>length</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
      <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><name><name>paths</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><call><name>getParent</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>stats</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><call><name>getPath</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>Path</name></type> <name><name>parentPaths</name><index>[]</index></name> <init>= <expr><operator>new</operator> <name><name>Path</name><index>[<expr><name><name>paths</name><operator>.</operator><name>length</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>paths</name><operator>.</operator><name>length</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
      <expr_stmt><expr><name><name>parentPaths</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>paths</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><call><name>getParent</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
     </block_content>}</block></for>
    <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><call><name>mergeStatuses</name><argument_list>(<argument><expr><name>parentPaths</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>mergeStatuses</name><argument_list>(<argument><expr><name>stats</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
 
     <comment type="line">// ensure that globStatus with an escaped "\*" only finds "*"</comment>
     <expr_stmt><expr><name>stats</name> <operator>=</operator> <call><name><name>lfs</name><operator>.</operator><name>globStatus</name></name><argument_list>(<argument><expr><operator>new</operator> <call><name>Path</name><argument_list>(<argument><expr><name>testRoot</name></expr></argument>, <argument><expr><literal type="string">"\\*"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">365</literal></expr><operator>,</operator><expr><literal type="number">9</literal> <operator>+</operator><literal type="number">393</literal></expr><operator>,</operator><expr><literal type="number">7</literal> @@ <specifier>public</specifier> <name>void</name> <call><name>testGlobEscapeStatus</name><argument_list>()</argument_list></call> <throws>throws <argument><expr><name>Exception</name> <block>{
     <comment type="line">// try to glob the inner file for all dirs</comment>
     <expr><name>stats</name> <operator>=</operator> <call><name><name>lfs</name><operator>.</operator><name>globStatus</name></name><argument_list>(<argument><expr><operator>new</operator> <call><name>Path</name><argument_list>(<argument><expr><name>testRoot</name></expr></argument>, <argument><expr><literal type="string">"*/f"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></block></expr></argument></throws></expr>;</expr_stmt>
     <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><name><name>paths</name><operator>.</operator><name>length</name></name></expr></argument>, <argument><expr><name><name>stats</name><operator>.</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name><init>=<expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>paths</name><operator>.</operator><name>length</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
      <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><name><name>paths</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>stats</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><call><name>getPath</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>assertEquals</name><argument_list>(<argument><expr><call><name>mergeStatuses</name><argument_list>(<argument><expr><name>paths</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>mergeStatuses</name><argument_list>(<argument><expr><name>stats</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
 
     <comment type="line">// try to get the inner file for only the "*" dir</comment>
     <expr_stmt><expr><name>stats</name> <operator>=</operator> <call><name><name>lfs</name><operator>.</operator><name>globStatus</name></name><argument_list>(<argument><expr><operator>new</operator> <call><name>Path</name><argument_list>(<argument><expr><name>testRoot</name></expr></argument>, <argument><expr><literal type="string">"\\*/f"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>diff</name> <operator>--</operator><name>git</name> <name>a</name><operator>/</operator><name>hadoop</name><operator>-</operator><name>hdfs</name><operator>-</operator><name>project</name><operator>/</operator><name>hadoop</name><operator>-</operator><name>hdfs</name><operator>/</operator><name>src</name><operator>/</operator><name>test</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>hadoop</name><operator>/</operator><name>fs</name><operator>/</operator><name><name>TestGlobPaths</name><operator>.</operator><name>java</name></name> <name>b</name><operator>/</operator><name>hadoop</name><operator>-</operator><name>hdfs</name><operator>-</operator><name>project</name><operator>/</operator><name>hadoop</name><operator>-</operator><name>hdfs</name><operator>/</operator><name>src</name><operator>/</operator><name>test</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>hadoop</name><operator>/</operator><name>fs</name><operator>/</operator><name><name>TestGlobPaths</name><operator>.</operator><name>java</name></name>
<name>index</name> <literal type="number">3b69b04205c</literal><operator>..</operator><literal type="number">76f668f6fee</literal> <literal type="number">100644</literal>
<operator>--</operator> <name>a</name><operator>/</operator><name>hadoop</name><operator>-</operator><name>hdfs</name><operator>-</operator><name>project</name><operator>/</operator><name>hadoop</name><operator>-</operator><name>hdfs</name><operator>/</operator><name>src</name><operator>/</operator><name>test</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>hadoop</name><operator>/</operator><name>fs</name><operator>/</operator><name><name>TestGlobPaths</name><operator>.</operator><name>java</name></name>
<operator>++</operator> <name>b</name><operator>/</operator><name>hadoop</name><operator>-</operator><name>hdfs</name><operator>-</operator><name>project</name><operator>/</operator><name>hadoop</name><operator>-</operator><name>hdfs</name><operator>/</operator><name>src</name><operator>/</operator><name>test</name><operator>/</operator><name>java</name><operator>/</operator><name>org</name><operator>/</operator><name>apache</name><operator>/</operator><name>hadoop</name><operator>/</operator><name>fs</name><operator>/</operator><name><name>TestGlobPaths</name><operator>.</operator><name>java</name></name>
@@ <operator>-</operator><literal type="number">20</literal></expr><operator>,</operator><expr><literal type="number">14</literal> <operator>+</operator><literal type="number">20</literal></expr><operator>,</operator><expr><literal type="number">18</literal> @@</expr></expr_stmt>
 <import>import static <name><name>org</name><operator>.</operator><name>junit</name><operator>.</operator><name>Assert</name><operator>.</operator><name>*</name></name>;</import>
 
 <import>import <name><name>java</name><operator>.</operator><name>io</name><operator>.</operator><name>IOException</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>Arrays</name></name>;</import>
 <import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>regex</name><operator>.</operator><name>Pattern</name></name>;</import>
 
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>commons</name><operator>.</operator><name>lang</name><operator>.</operator><name>StringUtils</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>hadoop</name><operator>.</operator><name>conf</name><operator>.</operator><name>Configuration</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>hadoop</name><operator>.</operator><name>fs</name><operator>.</operator><name>permission</name><operator>.</operator><name>FsPermission</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>hadoop</name><operator>.</operator><name>hdfs</name><operator>.</operator><name>HdfsConfiguration</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>hadoop</name><operator>.</operator><name>hdfs</name><operator>.</operator><name>MiniDFSCluster</name></name>;</import>
 <import>import <name><name>org</name><operator>.</operator><name>junit</name><operator>.</operator><name>*</name></name>;</import>
 
<import>import <name><name>com</name><operator>.</operator><name>google</name><operator>.</operator><name>common</name><operator>.</operator><name>base</name><operator>.</operator><name>Joiner</name></name>;</import>

 <class><specifier>public</specifier> class <name>TestGlobPaths</name> <block>{
 
   <class><specifier>static</specifier> class <name>RegexPathFilter</name> <super_list><implements>implements <super><name>PathFilter</name></super></implements></super_list> <block>{
<annotation>@</annotation>@ <expr_stmt><expr><operator>-</operator><literal type="number">784</literal></expr><operator>,</operator><expr><literal type="number">4</literal> <operator>+</operator><literal type="number">788</literal></expr><operator>,</operator><expr><literal type="number">265</literal> @@ <specifier>public</specifier> <name>void</name> <call><name>cleanupDFS</name><argument_list>()</argument_list></call> <throws>throws <argument><expr><name>IOException</name> <block>{
     <expr><call><name><name>fs</name><operator>.</operator><name>delete</name></name><argument_list>(<argument><expr><operator>new</operator> <call><name>Path</name><argument_list>(<argument><expr><name>USER_DIR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr></block></expr></argument></throws></expr>;</expr_stmt>
   }</block></class>
   
  <comment type="block" format="javadoc">/**
   * A glob test that can be run on either FileContext or FileSystem.
   */</comment>
  <interface><specifier>private</specifier> <specifier>static</specifier> interface <name>FSTestWrapperGlobTest</name> <block>{
    <decl_stmt><decl><type><name>void</name></type> <name>run</name><argument_list>(<argument><expr><name>FSTestWrapper</name> <name>wrap</name></expr></argument>, <argument><expr><name>FileSystem</name> <name>fs</name></expr></argument>, <argument><expr><name>FileContext</name> <name>fc</name></expr></argument>)</argument_list>
        <throws>throws <argument><expr><name>Exception</name></expr></argument></throws></decl>;</decl_stmt>
  }</block></interface>

  <comment type="block" format="javadoc">/**
   * Run a glob test on FileSystem.
   */</comment>
  <function><type><specifier>private</specifier> <specifier>static</specifier> <name>void</name></type> <name>testOnFileSystem</name><parameter_list>(<parameter><decl><type><name>FSTestWrapperGlobTest</name></type> <name>test</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>Exception</name></expr></argument></throws> <block>{<block_content>
    <decl_stmt><decl><type><name>Configuration</name></type> <name>conf</name> <init>= <expr><operator>new</operator> <call><name>HdfsConfiguration</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MiniDFSCluster</name></type> <name>cluster</name> <init>= <expr><operator>new</operator> <call><name><name>MiniDFSCluster</name><operator>.</operator><name>Builder</name></name><argument_list>(<argument><expr><name>conf</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>build</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <try>try <block>{<block_content>
      <decl_stmt><decl><type><name>FileSystem</name></type> <name>fs</name> <init>= <expr><call><name><name>FileSystem</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>conf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name><name>test</name><operator>.</operator><name>run</name></name><argument_list>(<argument><expr><operator>new</operator> <call><name>FileSystemTestWrapper</name><argument_list>(<argument><expr><name>fs</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><literal type="null">null</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block> <finally>finally <block>{<block_content>
      <expr_stmt><expr><call><name><name>cluster</name><operator>.</operator><name>shutdown</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></finally></try>
  </block_content>}</block></function>

  <comment type="block" format="javadoc">/**
   * Run a glob test on FileContext.
   */</comment>
  <function><type><specifier>private</specifier> <specifier>static</specifier> <name>void</name></type> <name>testOnFileContext</name><parameter_list>(<parameter><decl><type><name>FSTestWrapperGlobTest</name></type> <name>test</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>Exception</name></expr></argument></throws> <block>{<block_content>
    <decl_stmt><decl><type><name>Configuration</name></type> <name>conf</name> <init>= <expr><operator>new</operator> <call><name>HdfsConfiguration</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MiniDFSCluster</name></type> <name>cluster</name> <init>= <expr><operator>new</operator> <call><name><name>MiniDFSCluster</name><operator>.</operator><name>Builder</name></name><argument_list>(<argument><expr><name>conf</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>build</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <try>try <block>{<block_content>
      <decl_stmt><decl><type><name>FileContext</name></type> <name>fc</name> <init>= <expr><call><name><name>FileContext</name><operator>.</operator><name>getFileContext</name></name><argument_list>(<argument><expr><name>conf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name><name>test</name><operator>.</operator><name>run</name></name><argument_list>(<argument><expr><operator>new</operator> <call><name>FileContextTestWrapper</name><argument_list>(<argument><expr><name>fc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="null">null</literal></expr></argument>, <argument><expr><name>fc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block> <finally>finally <block>{<block_content>
      <expr_stmt><expr><call><name><name>cluster</name><operator>.</operator><name>shutdown</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></finally></try>
  </block_content>}</block></function>
  
  <comment type="block" format="javadoc">/**
   * Accept all paths.
   */</comment>
  <class><specifier>private</specifier> <specifier>static</specifier> class <name>AcceptAllPathFilter</name> <super_list><implements>implements <super><name>PathFilter</name></super></implements></super_list> <block>{
    <function><annotation>@<name>Override</name></annotation>
    <type><specifier>public</specifier> <name>boolean</name></type> <name>accept</name><parameter_list>(<parameter><decl><type><name>Path</name></type> <name>path</name></decl></parameter>)</parameter_list> <block>{<block_content>
      <return>return <expr><literal type="boolean">true</literal></expr>;</return>
    </block_content>}</block></function>
  }</block></class>

  <comment type="block" format="javadoc">/**
   * Accept only paths ending in Z.
   */</comment>
  <class><specifier>private</specifier> <specifier>static</specifier> class <name>AcceptPathsEndingInZ</name> <super_list><implements>implements <super><name>PathFilter</name></super></implements></super_list> <block>{
    <function><annotation>@<name>Override</name></annotation>
    <type><specifier>public</specifier> <name>boolean</name></type> <name>accept</name><parameter_list>(<parameter><decl><type><name>Path</name></type> <name>path</name></decl></parameter>)</parameter_list> <block>{<block_content>
      <decl_stmt><decl><type><name>String</name></type> <name>stringPath</name> <init>= <expr><call><name><name>path</name><operator>.</operator><name>toUri</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getPath</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
      <return>return <expr><call><name><name>stringPath</name><operator>.</operator><name>endsWith</name></name><argument_list>(<argument><expr><literal type="string">"z"</literal></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>
  }</block></class>

  <comment type="block" format="javadoc">/**
   * Test globbing through symlinks.
   */</comment>
  <class><specifier>private</specifier> <specifier>static</specifier> class <name>TestGlobWithSymlinks</name> <super_list><implements>implements <super><name>FSTestWrapperGlobTest</name></super></implements></super_list> <block>{
    <function><type><specifier>public</specifier> <name>void</name></type> <name>run</name><parameter_list>(<parameter><decl><type><name>FSTestWrapper</name></type> <name>wrap</name></decl></parameter>, <parameter><decl><type><name>FileSystem</name></type> <name>fs</name></decl></parameter>, <parameter><decl><type><name>FileContext</name></type> <name>fc</name></decl></parameter>)</parameter_list>
        <throws>throws <argument><expr><name>Exception</name></expr></argument></throws> <block>{<block_content>
      <comment type="line">// Test that globbing through a symlink to a directory yields a path</comment>
      <comment type="line">// containing that symlink.</comment>
      <expr_stmt><expr><call><name><name>wrap</name><operator>.</operator><name>mkdir</name></name><argument_list>(<argument><expr><operator>new</operator> <call><name>Path</name><argument_list>(<argument><expr><literal type="string">"/alpha"</literal></expr></argument>)</argument_list></call></expr></argument>,
          <argument><expr><call><name><name>FsPermission</name><operator>.</operator><name>getDirDefault</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>wrap</name><operator>.</operator><name>createSymlink</name></name><argument_list>(<argument><expr><operator>new</operator> <call><name>Path</name><argument_list>(<argument><expr><literal type="string">"/alpha"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>new</operator> <call><name>Path</name><argument_list>(<argument><expr><literal type="string">"/alphaLink"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>wrap</name><operator>.</operator><name>mkdir</name></name><argument_list>(<argument><expr><operator>new</operator> <call><name>Path</name><argument_list>(<argument><expr><literal type="string">"/alphaLink/beta"</literal></expr></argument>)</argument_list></call></expr></argument>,
          <argument><expr><call><name><name>FsPermission</name><operator>.</operator><name>getDirDefault</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <comment type="line">// Test simple glob</comment>
      <decl_stmt><decl><type><name><name>FileStatus</name><index>[]</index></name></type> <name>statuses</name> <init>=
          <expr><call><name><name>wrap</name><operator>.</operator><name>globStatus</name></name><argument_list>(<argument><expr><operator>new</operator> <call><name>Path</name><argument_list>(<argument><expr><literal type="string">"/alpha/*"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>new</operator> <call><name>AcceptAllPathFilter</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name><name>Assert</name><operator>.</operator><name>assertEquals</name></name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>statuses</name><operator>.</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>Assert</name><operator>.</operator><name>assertEquals</name></name><argument_list>(<argument><expr><literal type="string">"/alpha/beta"</literal></expr></argument>,
          <argument><expr><name><name>statuses</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><call><name>getPath</name><argument_list>()</argument_list></call><operator>.</operator><call><name>toUri</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getPath</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <comment type="line">// Test glob through symlink</comment>
      <expr_stmt><expr><name>statuses</name> <operator>=</operator>
          <call><name><name>wrap</name><operator>.</operator><name>globStatus</name></name><argument_list>(<argument><expr><operator>new</operator> <call><name>Path</name><argument_list>(<argument><expr><literal type="string">"/alphaLink/*"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>new</operator> <call><name>AcceptAllPathFilter</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>Assert</name><operator>.</operator><name>assertEquals</name></name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>statuses</name><operator>.</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>Assert</name><operator>.</operator><name>assertEquals</name></name><argument_list>(<argument><expr><literal type="string">"/alphaLink/beta"</literal></expr></argument>,
          <argument><expr><name><name>statuses</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><call><name>getPath</name><argument_list>()</argument_list></call><operator>.</operator><call><name>toUri</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getPath</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <comment type="line">// If the terminal path component in a globbed path is a symlink,</comment>
      <comment type="line">// we don't dereference that link.</comment>
      <expr_stmt><expr><call><name><name>wrap</name><operator>.</operator><name>createSymlink</name></name><argument_list>(<argument><expr><operator>new</operator> <call><name>Path</name><argument_list>(<argument><expr><literal type="string">"beta"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>new</operator> <call><name>Path</name><argument_list>(<argument><expr><literal type="string">"/alphaLink/betaLink"</literal></expr></argument>)</argument_list></call></expr></argument>,
          <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>statuses</name> <operator>=</operator> <call><name><name>wrap</name><operator>.</operator><name>globStatus</name></name><argument_list>(<argument><expr><operator>new</operator> <call><name>Path</name><argument_list>(<argument><expr><literal type="string">"/alpha/betaLi*"</literal></expr></argument>)</argument_list></call></expr></argument>,
          <argument><expr><operator>new</operator> <call><name>AcceptAllPathFilter</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>Assert</name><operator>.</operator><name>assertEquals</name></name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>statuses</name><operator>.</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>Assert</name><operator>.</operator><name>assertEquals</name></name><argument_list>(<argument><expr><literal type="string">"/alpha/betaLink"</literal></expr></argument>,
          <argument><expr><name><name>statuses</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><call><name>getPath</name><argument_list>()</argument_list></call><operator>.</operator><call><name>toUri</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getPath</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <comment type="line">// todo: test symlink-to-symlink-to-dir, etc.</comment>
    </block_content>}</block></function>
  }</block></class>

  <function><annotation>@<name>Test</name></annotation>
  <type><specifier>public</specifier> <name>void</name></type> <name>testGlobWithSymlinksOnFS</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>Exception</name></expr></argument></throws> <block>{<block_content>
    <expr_stmt><expr><call><name>testOnFileSystem</name><argument_list>(<argument><expr><operator>new</operator> <call><name>TestGlobWithSymlinks</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></function>

  <function><annotation>@<name>Test</name></annotation>
  <type><specifier>public</specifier> <name>void</name></type> <name>testGlobWithSymlinksOnFC</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>Exception</name></expr></argument></throws> <block>{<block_content>
    <expr_stmt><expr><call><name>testOnFileContext</name><argument_list>(<argument><expr><operator>new</operator> <call><name>TestGlobWithSymlinks</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></function>

  <comment type="block" format="javadoc">/**
   * Test globbing symlinks to symlinks.
   *
   * Also test globbing dangling symlinks.  It should NOT throw any exceptions!
   */</comment>
  <class><specifier>private</specifier> <specifier>static</specifier> class <name>TestGlobWithSymlinksToSymlinks</name>
      <super_list><implements>implements <super><name>FSTestWrapperGlobTest</name></super></implements></super_list> <block>{
    <function><type><specifier>public</specifier> <name>void</name></type> <name>run</name><parameter_list>(<parameter><decl><type><name>FSTestWrapper</name></type> <name>wrap</name></decl></parameter>, <parameter><decl><type><name>FileSystem</name></type> <name>fs</name></decl></parameter>, <parameter><decl><type><name>FileContext</name></type> <name>fc</name></decl></parameter>)</parameter_list>
        <throws>throws <argument><expr><name>Exception</name></expr></argument></throws> <block>{<block_content>
      <comment type="line">// Test that globbing through a symlink to a symlink to a directory</comment>
      <comment type="line">// fully resolves</comment>
      <expr_stmt><expr><call><name><name>wrap</name><operator>.</operator><name>mkdir</name></name><argument_list>(<argument><expr><operator>new</operator> <call><name>Path</name><argument_list>(<argument><expr><literal type="string">"/alpha"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>FsPermission</name><operator>.</operator><name>getDirDefault</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>wrap</name><operator>.</operator><name>createSymlink</name></name><argument_list>(<argument><expr><operator>new</operator> <call><name>Path</name><argument_list>(<argument><expr><literal type="string">"/alpha"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>new</operator> <call><name>Path</name><argument_list>(<argument><expr><literal type="string">"/alphaLink"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>wrap</name><operator>.</operator><name>createSymlink</name></name><argument_list>(<argument><expr><operator>new</operator> <call><name>Path</name><argument_list>(<argument><expr><literal type="string">"/alphaLink"</literal></expr></argument>)</argument_list></call></expr></argument>,
          <argument><expr><operator>new</operator> <call><name>Path</name><argument_list>(<argument><expr><literal type="string">"/alphaLinkLink"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>wrap</name><operator>.</operator><name>mkdir</name></name><argument_list>(<argument><expr><operator>new</operator> <call><name>Path</name><argument_list>(<argument><expr><literal type="string">"/alpha/beta"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>FsPermission</name><operator>.</operator><name>getDirDefault</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <comment type="line">// Test glob through symlink to a symlink to a directory</comment>
      <decl_stmt><decl><type><name>FileStatus</name></type> <name><name>statuses</name><index>[]</index></name> <init>=
          <expr><call><name><name>wrap</name><operator>.</operator><name>globStatus</name></name><argument_list>(<argument><expr><operator>new</operator> <call><name>Path</name><argument_list>(<argument><expr><literal type="string">"/alphaLinkLink"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>new</operator> <call><name>AcceptAllPathFilter</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name><name>Assert</name><operator>.</operator><name>assertEquals</name></name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>statuses</name><operator>.</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>Assert</name><operator>.</operator><name>assertEquals</name></name><argument_list>(<argument><expr><literal type="string">"/alphaLinkLink"</literal></expr></argument>,
          <argument><expr><name><name>statuses</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><call><name>getPath</name><argument_list>()</argument_list></call><operator>.</operator><call><name>toUri</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getPath</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>statuses</name> <operator>=</operator>
          <call><name><name>wrap</name><operator>.</operator><name>globStatus</name></name><argument_list>(<argument><expr><operator>new</operator> <call><name>Path</name><argument_list>(<argument><expr><literal type="string">"/alphaLinkLink/*"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>new</operator> <call><name>AcceptAllPathFilter</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>Assert</name><operator>.</operator><name>assertEquals</name></name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>statuses</name><operator>.</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>Assert</name><operator>.</operator><name>assertEquals</name></name><argument_list>(<argument><expr><literal type="string">"/alphaLinkLink/beta"</literal></expr></argument>,
          <argument><expr><name><name>statuses</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><call><name>getPath</name><argument_list>()</argument_list></call><operator>.</operator><call><name>toUri</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getPath</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <comment type="line">// Test glob of dangling symlink (theta does not actually exist)</comment>
      <expr_stmt><expr><call><name><name>wrap</name><operator>.</operator><name>createSymlink</name></name><argument_list>(<argument><expr><operator>new</operator> <call><name>Path</name><argument_list>(<argument><expr><literal type="string">"theta"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>new</operator> <call><name>Path</name><argument_list>(<argument><expr><literal type="string">"/alpha/kappa"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>statuses</name> <operator>=</operator> <call><name><name>wrap</name><operator>.</operator><name>globStatus</name></name><argument_list>(<argument><expr><operator>new</operator> <call><name>Path</name><argument_list>(<argument><expr><literal type="string">"/alpha/kappa/kappa"</literal></expr></argument>)</argument_list></call></expr></argument>,
              <argument><expr><operator>new</operator> <call><name>AcceptAllPathFilter</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>Assert</name><operator>.</operator><name>assertNull</name></name><argument_list>(<argument><expr><name>statuses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <comment type="line">// Test glob of symlinks</comment>
      <expr_stmt><expr><call><name><name>wrap</name><operator>.</operator><name>createFile</name></name><argument_list>(<argument><expr><literal type="string">"/alpha/beta/gamma"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>wrap</name><operator>.</operator><name>createSymlink</name></name><argument_list>(<argument><expr><operator>new</operator> <call><name>Path</name><argument_list>(<argument><expr><literal type="string">"gamma"</literal></expr></argument>)</argument_list></call></expr></argument>,
          <argument><expr><operator>new</operator> <call><name>Path</name><argument_list>(<argument><expr><literal type="string">"/alpha/beta/gammaLink"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>wrap</name><operator>.</operator><name>createSymlink</name></name><argument_list>(<argument><expr><operator>new</operator> <call><name>Path</name><argument_list>(<argument><expr><literal type="string">"gammaLink"</literal></expr></argument>)</argument_list></call></expr></argument>,
          <argument><expr><operator>new</operator> <call><name>Path</name><argument_list>(<argument><expr><literal type="string">"/alpha/beta/gammaLinkLink"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>wrap</name><operator>.</operator><name>createSymlink</name></name><argument_list>(<argument><expr><operator>new</operator> <call><name>Path</name><argument_list>(<argument><expr><literal type="string">"gammaLinkLink"</literal></expr></argument>)</argument_list></call></expr></argument>,
          <argument><expr><operator>new</operator> <call><name>Path</name><argument_list>(<argument><expr><literal type="string">"/alpha/beta/gammaLinkLinkLink"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>statuses</name> <operator>=</operator> <call><name><name>wrap</name><operator>.</operator><name>globStatus</name></name><argument_list>(<argument><expr><operator>new</operator> <call><name>Path</name><argument_list>(<argument><expr><literal type="string">"/alpha/*/gammaLinkLinkLink"</literal></expr></argument>)</argument_list></call></expr></argument>,
              <argument><expr><operator>new</operator> <call><name>AcceptAllPathFilter</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>Assert</name><operator>.</operator><name>assertEquals</name></name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>statuses</name><operator>.</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>Assert</name><operator>.</operator><name>assertEquals</name></name><argument_list>(<argument><expr><literal type="string">"/alpha/beta/gammaLinkLinkLink"</literal></expr></argument>,
          <argument><expr><name><name>statuses</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><call><name>getPath</name><argument_list>()</argument_list></call><operator>.</operator><call><name>toUri</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getPath</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>statuses</name> <operator>=</operator> <call><name><name>wrap</name><operator>.</operator><name>globStatus</name></name><argument_list>(<argument><expr><operator>new</operator> <call><name>Path</name><argument_list>(<argument><expr><literal type="string">"/alpha/beta/*"</literal></expr></argument>)</argument_list></call></expr></argument>,
              <argument><expr><operator>new</operator> <call><name>AcceptAllPathFilter</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>Assert</name><operator>.</operator><name>assertEquals</name></name><argument_list>(<argument><expr><literal type="string">"/alpha/beta/gamma;/alpha/beta/gammaLink;"</literal> <operator>+</operator>
          <literal type="string">"/alpha/beta/gammaLinkLink;/alpha/beta/gammaLinkLinkLink"</literal></expr></argument>,
          <argument><expr><call><name><name>TestPath</name><operator>.</operator><name>mergeStatuses</name></name><argument_list>(<argument><expr><name>statuses</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <comment type="line">// Let's create two symlinks that point to each other, and glob on them.</comment>
      <expr_stmt><expr><call><name><name>wrap</name><operator>.</operator><name>createSymlink</name></name><argument_list>(<argument><expr><operator>new</operator> <call><name>Path</name><argument_list>(<argument><expr><literal type="string">"tweedledee"</literal></expr></argument>)</argument_list></call></expr></argument>,
          <argument><expr><operator>new</operator> <call><name>Path</name><argument_list>(<argument><expr><literal type="string">"/tweedledum"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>wrap</name><operator>.</operator><name>createSymlink</name></name><argument_list>(<argument><expr><operator>new</operator> <call><name>Path</name><argument_list>(<argument><expr><literal type="string">"tweedledum"</literal></expr></argument>)</argument_list></call></expr></argument>,
          <argument><expr><operator>new</operator> <call><name>Path</name><argument_list>(<argument><expr><literal type="string">"/tweedledee"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>statuses</name> <operator>=</operator> <call><name><name>wrap</name><operator>.</operator><name>globStatus</name></name><argument_list>(<argument><expr><operator>new</operator> <call><name>Path</name><argument_list>(<argument><expr><literal type="string">"/tweedledee/unobtainium"</literal></expr></argument>)</argument_list></call></expr></argument>,
              <argument><expr><operator>new</operator> <call><name>AcceptAllPathFilter</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>Assert</name><operator>.</operator><name>assertNull</name></name><argument_list>(<argument><expr><name>statuses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>
  }</block></class>

  <function><annotation>@<name>Test</name></annotation>
  <type><specifier>public</specifier> <name>void</name></type> <name>testGlobWithSymlinksToSymlinksOnFS</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>Exception</name></expr></argument></throws> <block>{<block_content>
    <expr_stmt><expr><call><name>testOnFileSystem</name><argument_list>(<argument><expr><operator>new</operator> <call><name>TestGlobWithSymlinksToSymlinks</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></function>

  <function><annotation>@<name>Test</name></annotation>
  <type><specifier>public</specifier> <name>void</name></type> <name>testGlobWithSymlinksToSymlinksOnFC</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>Exception</name></expr></argument></throws> <block>{<block_content>
    <expr_stmt><expr><call><name>testOnFileContext</name><argument_list>(<argument><expr><operator>new</operator> <call><name>TestGlobWithSymlinksToSymlinks</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></function>

  <comment type="block" format="javadoc">/**
   * Test globbing symlinks with a custom PathFilter
   */</comment>
  <class><specifier>private</specifier> <specifier>static</specifier> class <name>TestGlobSymlinksWithCustomPathFilter</name>
      <super_list><implements>implements <super><name>FSTestWrapperGlobTest</name></super></implements></super_list> <block>{
    <function><type><specifier>public</specifier> <name>void</name></type> <name>run</name><parameter_list>(<parameter><decl><type><name>FSTestWrapper</name></type> <name>wrap</name></decl></parameter>, <parameter><decl><type><name>FileSystem</name></type> <name>fs</name></decl></parameter>, <parameter><decl><type><name>FileContext</name></type> <name>fc</name></decl></parameter>)</parameter_list>
        <throws>throws <argument><expr><name>Exception</name></expr></argument></throws> <block>{<block_content>
      <comment type="line">// Test that globbing through a symlink to a symlink to a directory</comment>
      <comment type="line">// fully resolves</comment>
      <expr_stmt><expr><call><name><name>wrap</name><operator>.</operator><name>mkdir</name></name><argument_list>(<argument><expr><operator>new</operator> <call><name>Path</name><argument_list>(<argument><expr><literal type="string">"/alpha"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>FsPermission</name><operator>.</operator><name>getDirDefault</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>wrap</name><operator>.</operator><name>createSymlink</name></name><argument_list>(<argument><expr><operator>new</operator> <call><name>Path</name><argument_list>(<argument><expr><literal type="string">"/alpha"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>new</operator> <call><name>Path</name><argument_list>(<argument><expr><literal type="string">"/alphaLinkz"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>wrap</name><operator>.</operator><name>mkdir</name></name><argument_list>(<argument><expr><operator>new</operator> <call><name>Path</name><argument_list>(<argument><expr><literal type="string">"/alpha/beta"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>FsPermission</name><operator>.</operator><name>getDirDefault</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>wrap</name><operator>.</operator><name>mkdir</name></name><argument_list>(<argument><expr><operator>new</operator> <call><name>Path</name><argument_list>(<argument><expr><literal type="string">"/alpha/betaz"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>FsPermission</name><operator>.</operator><name>getDirDefault</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <comment type="line">// Test glob through symlink to a symlink to a directory, with a PathFilter</comment>
      <decl_stmt><decl><type><name>FileStatus</name></type> <name><name>statuses</name><index>[]</index></name> <init>=
          <expr><call><name><name>wrap</name><operator>.</operator><name>globStatus</name></name><argument_list>(<argument><expr><operator>new</operator> <call><name>Path</name><argument_list>(<argument><expr><literal type="string">"/alpha/beta"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>new</operator> <call><name>AcceptPathsEndingInZ</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name><name>Assert</name><operator>.</operator><name>assertNull</name></name><argument_list>(<argument><expr><name>statuses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>statuses</name> <operator>=</operator>
          <call><name><name>wrap</name><operator>.</operator><name>globStatus</name></name><argument_list>(<argument><expr><operator>new</operator> <call><name>Path</name><argument_list>(<argument><expr><literal type="string">"/alphaLinkz/betaz"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>new</operator> <call><name>AcceptPathsEndingInZ</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>Assert</name><operator>.</operator><name>assertEquals</name></name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>statuses</name><operator>.</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>Assert</name><operator>.</operator><name>assertEquals</name></name><argument_list>(<argument><expr><literal type="string">"/alphaLinkz/betaz"</literal></expr></argument>,
          <argument><expr><name><name>statuses</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><call><name>getPath</name><argument_list>()</argument_list></call><operator>.</operator><call><name>toUri</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getPath</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>statuses</name> <operator>=</operator>
          <call><name><name>wrap</name><operator>.</operator><name>globStatus</name></name><argument_list>(<argument><expr><operator>new</operator> <call><name>Path</name><argument_list>(<argument><expr><literal type="string">"/*/*"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>new</operator> <call><name>AcceptPathsEndingInZ</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>Assert</name><operator>.</operator><name>assertEquals</name></name><argument_list>(<argument><expr><literal type="string">"/alpha/betaz;/alphaLinkz/betaz"</literal></expr></argument>,
          <argument><expr><call><name><name>TestPath</name><operator>.</operator><name>mergeStatuses</name></name><argument_list>(<argument><expr><name>statuses</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>statuses</name> <operator>=</operator>
          <call><name><name>wrap</name><operator>.</operator><name>globStatus</name></name><argument_list>(<argument><expr><operator>new</operator> <call><name>Path</name><argument_list>(<argument><expr><literal type="string">"/*/*"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>new</operator> <call><name>AcceptAllPathFilter</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>Assert</name><operator>.</operator><name>assertEquals</name></name><argument_list>(<argument><expr><literal type="string">"/alpha/beta;/alpha/betaz;"</literal> <operator>+</operator>
          <literal type="string">"/alphaLinkz/beta;/alphaLinkz/betaz"</literal></expr></argument>,
          <argument><expr><call><name><name>TestPath</name><operator>.</operator><name>mergeStatuses</name></name><argument_list>(<argument><expr><name>statuses</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>
  }</block></class>

  <function><annotation>@<name>Test</name></annotation>
  <type><specifier>public</specifier> <name>void</name></type> <name>testGlobSymlinksWithCustomPathFilterOnFS</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>Exception</name></expr></argument></throws> <block>{<block_content>
    <expr_stmt><expr><call><name>testOnFileSystem</name><argument_list>(<argument><expr><operator>new</operator> <call><name>TestGlobSymlinksWithCustomPathFilter</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></function>

  <function><annotation>@<name>Test</name></annotation>
  <type><specifier>public</specifier> <name>void</name></type> <name>testGlobSymlinksWithCustomPathFilterOnFC</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>Exception</name></expr></argument></throws> <block>{<block_content>
    <expr_stmt><expr><call><name>testOnFileContext</name><argument_list>(<argument><expr><operator>new</operator> <call><name>TestGlobSymlinksWithCustomPathFilter</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></function>

  <comment type="block" format="javadoc">/**
   * Test that globStatus fills in the scheme even when it is not provided.
   */</comment>
  <class><specifier>private</specifier> <specifier>static</specifier> class <name>TestGlobFillsInScheme</name>
      <super_list><implements>implements <super><name>FSTestWrapperGlobTest</name></super></implements></super_list> <block>{
    <function><type><specifier>public</specifier> <name>void</name></type> <name>run</name><parameter_list>(<parameter><decl><type><name>FSTestWrapper</name></type> <name>wrap</name></decl></parameter>, <parameter><decl><type><name>FileSystem</name></type> <name>fs</name></decl></parameter>, <parameter><decl><type><name>FileContext</name></type> <name>fc</name></decl></parameter>)</parameter_list> 
        <throws>throws <argument><expr><name>Exception</name></expr></argument></throws> <block>{<block_content>
      <comment type="line">// Verify that the default scheme is hdfs, when we don't supply one.</comment>
      <expr_stmt><expr><call><name><name>wrap</name><operator>.</operator><name>mkdir</name></name><argument_list>(<argument><expr><operator>new</operator> <call><name>Path</name><argument_list>(<argument><expr><literal type="string">"/alpha"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>FsPermission</name><operator>.</operator><name>getDirDefault</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>wrap</name><operator>.</operator><name>createSymlink</name></name><argument_list>(<argument><expr><operator>new</operator> <call><name>Path</name><argument_list>(<argument><expr><literal type="string">"/alpha"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>new</operator> <call><name>Path</name><argument_list>(<argument><expr><literal type="string">"/alphaLink"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <decl_stmt><decl><type><name>FileStatus</name></type> <name><name>statuses</name><index>[]</index></name> <init>=
          <expr><call><name><name>wrap</name><operator>.</operator><name>globStatus</name></name><argument_list>(<argument><expr><operator>new</operator> <call><name>Path</name><argument_list>(<argument><expr><literal type="string">"/alphaLink"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>new</operator> <call><name>AcceptAllPathFilter</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name><name>Assert</name><operator>.</operator><name>assertEquals</name></name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>statuses</name><operator>.</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <decl_stmt><decl><type><name>Path</name></type> <name>path</name> <init>= <expr><name><name>statuses</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><call><name>getPath</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name><name>Assert</name><operator>.</operator><name>assertEquals</name></name><argument_list>(<argument><expr><literal type="string">"/alphaLink"</literal></expr></argument>, <argument><expr><call><name><name>path</name><operator>.</operator><name>toUri</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getPath</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>Assert</name><operator>.</operator><name>assertEquals</name></name><argument_list>(<argument><expr><literal type="string">"hdfs"</literal></expr></argument>, <argument><expr><call><name><name>path</name><operator>.</operator><name>toUri</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getScheme</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>fc</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
        <comment type="line">// If we're using FileContext, then we can list a file:/// URI.</comment>
        <comment type="line">// Since everyone should have the root directory, we list that.</comment>
        <expr_stmt><expr><name>statuses</name> <operator>=</operator>
            <call><name><name>wrap</name><operator>.</operator><name>globStatus</name></name><argument_list>(<argument><expr><operator>new</operator> <call><name>Path</name><argument_list>(<argument><expr><literal type="string">"file:///"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>new</operator> <call><name>AcceptAllPathFilter</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>Assert</name><operator>.</operator><name>assertEquals</name></name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>statuses</name><operator>.</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>Path</name></type> <name>filePath</name> <init>= <expr><name><name>statuses</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><call><name>getPath</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>Assert</name><operator>.</operator><name>assertEquals</name></name><argument_list>(<argument><expr><literal type="string">"file"</literal></expr></argument>, <argument><expr><call><name><name>filePath</name><operator>.</operator><name>toUri</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getScheme</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>Assert</name><operator>.</operator><name>assertEquals</name></name><argument_list>(<argument><expr><literal type="string">"/"</literal></expr></argument>, <argument><expr><call><name><name>filePath</name><operator>.</operator><name>toUri</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getPath</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if> <else>else <block>{<block_content>
        <comment type="line">// The FileSystem we passed in should have scheme 'hdfs'</comment>
        <expr_stmt><expr><call><name><name>Assert</name><operator>.</operator><name>assertEquals</name></name><argument_list>(<argument><expr><literal type="string">"hdfs"</literal></expr></argument>, <argument><expr><call><name><name>fs</name><operator>.</operator><name>getScheme</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></function>
  }</block></class>

  <function><annotation>@<name>Test</name></annotation>
  <type><specifier>public</specifier> <name>void</name></type> <name>testGlobFillsInSchemeOnFS</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>Exception</name></expr></argument></throws> <block>{<block_content>
    <expr_stmt><expr><call><name>testOnFileSystem</name><argument_list>(<argument><expr><operator>new</operator> <call><name>TestGlobFillsInScheme</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></function>

  <function><annotation>@<name>Test</name></annotation>
  <type><specifier>public</specifier> <name>void</name></type> <name>testGlobFillsInSchemeOnFC</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>Exception</name></expr></argument></throws> <block>{<block_content>
    <expr_stmt><expr><call><name>testOnFileContext</name><argument_list>(<argument><expr><operator>new</operator> <call><name>TestGlobFillsInScheme</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></function>
 }</block></class>
<expr_stmt><expr><operator>-</operator> 
<literal type="number">2.19.1.windows</literal><literal type="number">.1</literal></expr></expr_stmt></block_content></block></for></block_content></block></function></block></class></block_content></block></if></if_stmt></block_content></block>

</unit>
